This is guix.zh_CN.info, produced by makeinfo version 6.7 from
guix.zh_CN.texi.

Copyright © 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020 Ludovic
Courtès
Copyright © 2013, 2014, 2016 Andreas Enge
Copyright © 2013 Nikita Karetnikov
Copyright © 2014, 2015, 2016 Alex Kost
Copyright © 2015, 2016 Mathieu Lirzin
Copyright © 2014 Pierre-Antoine Rault
Copyright © 2015 Taylan Ulrich Bayırlı/Kammer
Copyright © 2015, 2016, 2017, 2019, 2020 Leo Famulari
Copyright © 2015, 2016, 2017, 2018, 2019, 2020 Ricardo Wurmus
Copyright © 2016 Ben Woodcroft
Copyright © 2016, 2017, 2018 Chris Marusich
Copyright © 2016, 2017, 2018, 2019, 2020 Efraim Flashner
Copyright © 2016 John Darrington
Copyright © 2016, 2017 Nikita Gillmann
Copyright © 2016, 2017, 2018, 2019, 2020 Jan Nieuwenhuizen
Copyright © 2016, 2017, 2018, 2019, 2020 Julien Lepiller
Copyright © 2016 Alex ter Weele
Copyright © 2016, 2017, 2018, 2019 Christopher Baines
Copyright © 2017, 2018, 2019 Clément Lassieur
Copyright © 2017, 2018 Mathieu Othacehe
Copyright © 2017 Federico Beffa
Copyright © 2017, 2018 Carlo Zancanaro
Copyright © 2017 Thomas Danckaert
Copyright © 2017 humanitiesNerd
Copyright © 2017 Christopher Allan Webber
Copyright © 2017, 2018, 2019, 2020 Marius Bakke
Copyright © 2017, 2019, 2020 Hartmut Goebel
Copyright © 2017, 2019, 2020 Maxim Cournoyer
Copyright © 2017, 2018, 2019, 2020 Tobias Geerinckx-Rice
Copyright © 2017 George Clemmer
Copyright © 2017 Andy Wingo
Copyright © 2017, 2018, 2019 Arun Isaac
Copyright © 2017 nee
Copyright © 2018 Rutger Helling
Copyright © 2018 Oleg Pykhalov
Copyright © 2018 Mike Gerwitz
Copyright © 2018 Pierre-Antoine Rouby
Copyright © 2018, 2019 Gábor Boskovits
Copyright © 2018, 2019 Florian Pelz
Copyright © 2018 Laura Lazzati
Copyright © 2018 Alex Vong
Copyright © 2019 Josh Holland
Copyright © 2019, 2020 Diego Nicola Barbato
Copyright © 2019 Ivan Petkov
Copyright © 2019 Jakob L. Kreuze
Copyright © 2019 Kyle Andrews
Copyright © 2019 Alex Griffin
Copyright © 2019 Guillaume Le Vaillant
Copyright © 2020 Leo Prikler
Copyright © 2019, 2020 Simon Tournier
Copyright © 2020 Wiktor Żelazny
Copyright © 2020 Damien Cassou
Copyright © 2020 Jakub Kądziołka
Copyright © 2020 Jack Hill
Copyright © 2020 Naga Malleswari
Copyright © 2020 Brice Waegeneire
Copyright © 2020 R Veera Kumar
Copyright © 2020 Pierre Langlois
Copyright © 2020 pinoaffe

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled “GNU Free
Documentation License”.
INFO-DIR-SECTION 系统管理
START-INFO-DIR-ENTRY
* Guix：（guix）.         管理安装的软件和系统配置。
* guix package：调用guix package.  安装、删除和升级软件包。
* guix gc：调用guix gc.   回收不使用的硬盘空间。
* guix pull：调用guix pull.  更新可用的软件包列表。
* guix system：调用guix system.  管理操作系统配置。
* guix deploy: (guix)Invoking guix deploy.  Manage operating system
                                              configurations for remote hosts.
END-INFO-DIR-ENTRY

INFO-DIR-SECTION 软件开发
START-INFO-DIR-ENTRY
* guix environment：调用guix environment.  用Guix构建开发环境。
* guix build：（guix）调用guix build.  构建软件包。
* guix pack：（guix）调用guix pack.  创建二进制bundle。
END-INFO-DIR-ENTRY


File: guix.zh_CN.info,  Node: Top,  Next: 介绍,  Up: (dir)

GNU Guix
********

这份文档介绍GNU Guix版本1.0.1.17089-7e269，一个为GNU系统编写的函数式包管
理器。

   This manual is also available in Simplified Chinese (*note
(guix.zh_CN)Top::), French (*note (guix.fr)Top::), German (*note
(guix.de)Top::), Spanish (*note (guix.es)Top::), and Russian (*note
(guix.ru)Top::).  If you would like to translate it in your native
language, consider joining the Translation Project
(https://translationproject.org/domain/guix-manual.html).

* Menu:

* 介绍::                   Guix是关于什么的？
* 安装::                   安装Guix。
* 系统安装::             安装整个操作系统。
* 软件包管理::          软件包安装，升级，等
* 开发::                   Guix辅助的软件开发。
* 编程接口::             在Scheme里使用Guix。
* 工具::                   软件包管理命令。
* 系统配置::             配置操作系统。
* 文档::                   浏览软件用户手册。
* 安装调试文件::       为调试工具提供输入。
* 安全更新::             快速部署安全补丁。
* 引导::                   从头开始构建GNU/Linux。
* 移植::                   以别的平台或内核为目标。
* 贡献::                   你需要帮助！

* 致谢::                   感谢！
* GNU自由文档许可证::  这个用户手册的许可证。
* 概念索引::             概念。
* 编程索引::             数据类型、函数和变量。

 －－－详细的章节列表－－－



介绍



* 以Guix的方式管理软件::  特殊的地方。
* GNU发行版::             软件包和工具。

安装



* 二进制文件安装::    立刻运行Guix！
* 需求::                   构建和运行Guix需要的软件。
* 运行测试套件::       测试Guix。
* 设置后台进程::       准备“构建后台进程”的环境。
* 调用guix-daemon::        运行“构建后台进程”
* 设置应用程序::       应用程序相关的设置。

设置后台进程



* 设置构建环境::       准备隔离的构建环境。
* 下发工作给后台进程的设置::  下发构建工作给远程的机器。
* SELinux的支持::         为后台进程使用SELinux规则。

系统安装



* 限制::                   你可以期待什么。
* 硬件的考虑::          支持的硬件。
* U盘和DVD安装::         准备安装介质。
* 准备安装::             网络、分区、等
* 指导的图形安装::    简单的图形安装
* 手动安装::             适合巫师的手动安装。
* 系统安装之后::       当安装成功后。
* 在虚拟机里安装Guix。::  Guix系统游乐场。
* 构建安装镜像::       这是怎样实现的。

手动安装



* 键盘布局、网络和分区::  初始设置。
* 继续安装步骤。::    安装。

软件包管理



* 功能::                   Guix怎样让你的生活更美好。
* 调用guix package::       软件包安装，删除，等
* Substitutes::              下载构建好的二进制文件。
* 有多个输出的软件包::  单个输入多个输出的软件包。
* 调用guix gc::            运行垃圾回收器。
* 调用guix pull::          获取最新的Guix和发行版。
* 通道::                   定制软件包集合。
* Invoking guix time-machine::  Running an older revision of Guix.
* Inferiors::                和其它版本的Guix交互。
* 调用guix describe::      显示你的Guix版本信息。
* 调用guix archive::       导出和导入仓库文件。

Substitutes



* 官方的substitute服务器::  substitute的一个特殊来源。
* 授权substitute服务器。::  怎么开启或关闭substitute。
* 验证substitute::         Guix怎样验证substitute。
* 代理设置::             怎样通过代理获取substitute。
* substitute失败::         当substitute失败时会发生什么。
* 关于信任二进制文件::  你怎么信任二进制块。

开发



* 调用guix environment::   设置开发环境。
* 调用guix pack::          创建软件bundle。
* The GCC toolchain::        Working with languages supported by GCC.

编程接口



* 软件包模块::          从程序员的角度看软件包。
* 定义软件包::          定义新软件包。
* 构建系统::             指定如何构建软件包。
* 仓库::                   操纵软件包仓库。
* Derivations::              软件包derivation的底层接口。
* 仓库monad::              仓库的纯函数式接口。
* G-表达式::              操纵构建表达式。
* 调用guix repl::          交互式地操作Guix。

定义软件包



* 软件包引用::          软件包数据类型。
* origin参考手册::       origin数据类型。

工具



* 调用guix build::         用命令行构建软件包。
* 调用guix edit。::       编辑软件包定义。
* 调用guix download::      下载一个文件并打印它的hash。
* 调用guix hash::          计算一个文件的密码学hash。
* 调用guix import::        导入软件包定义。
* 调用guix refresh::       更新软件包定义。
* 调用guix lint::          从软件包定义里寻找错误。
* 调用guix size::          分析硬盘使用情况。
* 调用guix graph::         展示软件包的关系图。
* 调用guix publish::       分享substitute。
* 调用guix challenge::     挑战subtitute服务器。
* 调用guix copy::          复制到远程的仓库，或从远程的仓库复制。
* 调用guix container::     进程隔离。
* 调用guix weather::       评估substitute的可用性。
* 调用guix processes::     列出客户端进程。

调用‘guix build’



* 普通的构建选项::    大部分命令的构建选项。
* 软件包变换选项。::  创建软件包的变体。
* 额外的构建选项::    只属于’guix build’的选项。
* 调试构建错误::       真实的打包经验。

系统配置



* 使用配置系统::       定制你的GNU系统。
* 操作系统参考::       操作系统声明详情。
* 文件系统::             设置文件系统挂载。
* 映射的设备::          块设备额外的处理。
* 用户帐号::             指定用户帐号。
* 键盘布局::             系统怎样理解按键。
* 区域::                   语言和文化惯例设置。
* 服务::                   指定系统服务。
* setuid程序::             以root权限运行的程序。
* X.509证书::              认证HTTPS服务器。
* Name Service Switch::      设置libc的name service switch。
* 初始的内存虚拟硬盘::  Linux-Libre引导。
* 引导设置::             设置引导程序。
* 调用guix system::        实例化一个系统配置。
* Invoking guix deploy::     Deploying a system configuration to a remote
                               host.
* 在虚拟机里运行Guix::  怎样在虚拟机里运行Guix。
* 定义服务::             添加新的服务定义。

服务



* 基础服务::             必要的系统服务。
* 执行计划任务::       mcron服务。
* 日志轮替::             rottlog服务。
* 网络服务::             网络设置，SSH后台进程，等
* X窗口::                  图形显示器。
* 打印服务::             本地和远程打印机的支持。
* 桌面服务::             D-Bus和桌面服务。
* 声音服务::             ALSA和Pulseaudio服务。
* 数据库服务::          SQL数据库，键值仓库，等
* 邮件服务::             IMAP，POP3，SMTP，等
* 消息服务::             消息服务。
* 电话服务::             电话服务。
* 监控服务::             监控服务。
* Kerberos服务::           Kerberos服务。
* Web服务::                Web服务。
* 证书服务::             Let’s Encrypt TLS证书。
* DNS服务::                DNS后台进程。
* VPN服务::                VPN后台进程。
* 网络文件系统::       网络文件系统相关的服务。
* 持续集成::             Cuirass服务。
* 电源管理服务::       延长电池寿命。
* 音频服务::             MPD。
* 虚拟化服务::          虚拟化服务。
* 版本控制服务::       远程访问Git仓库。
* 游戏服务::             游戏服务器。
* PAM Mount Service::        Service to mount volumes when logging in.
* Guix Services::            Services relating specifically to Guix.
* Linux Services::           Services tied to the Linux kernel.
* Hurd Services::            Services specific to a Hurd System.
* 其它各种服务::       其它服务。

定义服务



* 合成服务::             服务合成的模型。
* 服务类型和服务::    类型和服务。
* 服务参考::             API参考。
* Shepherd服务::           一种特别的服务。



File: guix.zh_CN.info,  Node: 介绍,  Next: 安装,  Prev: Top,  Up: Top

1 介绍
******

GNU Guix(1)是GNU系统的包管理器和发行版。Guix让无特权的用户可以轻松地安装
，升级，或删除软件包，回滚到前一个软件包集合，从源代码构建软件包，及辅助
软件环境的创建和维护。

   你可以在现有的GNU/Linux发行版上安装GNU Guix（*note 安装::），Guix可以
补充已有的工具，并且不会和它们产生冲突。或者你可以把它当作独立的操作系统
发行版（“Guix 系统”(2)）。*Note GNU发行版::.

* Menu:

* 以Guix的方式管理软件::  特殊的地方。
* GNU发行版::             软件包和工具。

   ---------- Footnotes ----------

   (1) “Guix”读做“geeks”，或“ɡiːks”（国际音标）

   (2) 我们以前把Guix系统称为“Guix系统发行版”或“GuixSD”。我们现在觉得把
一切都统一在“Guix”的旗帜下更合理，因为，毕竟即使在别的发行版上你也可以随
时通过‘guix system’命令获得Guix系统


File: guix.zh_CN.info,  Node: 以Guix的方式管理软件,  Next: GNU发行版,  Up: 介绍

1.1 以Guix的方式管理软件
========================

Guix提供了命令行软件包管理接口（*note 软件包管理::），辅助软件开发的工具
（*note 开发::），高级用法的命令行接口（*note 工具::），以及Scheme编程语
言接口（*note 编程接口::）。 “构建后台进程”为用户构建软件包（*note
设置后台进程::），及从授权的源（*note Substitutes::）下载预构建的二进制
文件。

   Guix包含很多GNU和非GNU的软件包定义，所有的这些软件包都尊重用户的自由
(https://www.gnu.org/philosophy/free-sw.html)。它是_可扩展的_：用户可以
编写自己的软件包定义（*note 定义软件包::），并且把它们作为独立的软件包模
块*note 软件包模块::。它也是_可定制的_：用户可以从现有的软件包定义衍生出
特殊的软件包，包括从命令行（*note 软件包变换选项。::）。

   在底层，Guix实现了由Nix（*note 致谢::）开创的“函数式包管理器”。在
Guix里，软件包构建和安装过程被视为数学意义上的_函数_。函数获取输入，如构
建脚本、编译器和库，并且返回一个安装好的软件包。作为一个纯函数，它的结果
只取决于它的输入－－例如，它不能引用没有作为显式输入传入的软件和脚本。当
传入特定的输入时，一个构建函数总是得到相同的结果。它不能以任何方式修改运
行系统的环境，例如，它不能创建，修改，或删除构建和安装环境之外的文件夹。
这是通过在隔离的环境（“容器”）里运行构建进程实现的，在这个环境里只能访问
到显式的输入。

   软件包构建函数的结果被“缓存”在文件系统里的一个叫做“仓库”（*note
仓库::）的特殊文件夹内。每个软件包都被安装在仓库（默认在‘/gnu/store’）里
的一个独立的文件夹内。这个文件夹的名字含有用于构建这个软件包的所有输入的
hash，所以，修改输入会得到一个不同的文件夹名。

   这种手段是实现Guix的突出功能的基础：对事务型软件包升级和回滚的支持，
每个用户独立的安装，软件包垃圾回收*note 功能::。


File: guix.zh_CN.info,  Node: GNU发行版,  Prev: 以Guix的方式管理软件,  Up: 介绍

1.2 GNU发行版
=============

Guix提供了一个GNU系统发行版，这个发新版只包含自由软件(1)。这个发行版可以
独立安装（*note 系统安装::），但是把Guix安装为一个已经安装好的
GNU/Linux系统的包管理器也是可行的（*note 安装::）。当我们需要区分这两者
时，我们把独立的发行版称为“Guix系统”。

   这个发行版提供了GNU核心软件包，如libc、gcc和Binutils，以及很多GNU和非
GNU应用程序。可用的软件包的完整列表可以在on-line
(https://www.gnu.org/software/guix/packages)浏览，或者通过运行‘guix
package’（*note 调用guix package::）获得：

     guix package --list-available

   我们的目标是提供一个基于Linux和其它GNU变体的可用的100%自由的软件发行
版，我们的重点是推广和紧密集成GNU组件，以及强调帮助用户行使那些自由的程
序和工具。

   目前这些平台提供软件包：

‘x86_64-linux’
     Intel/AMD ‘x86_64’架构，Linux-Libre内核；

‘i686-linux’
     Intel 32位架构（IA32)，Linux-Libre内核；

‘armhf-linux’
     ARMv7-A架构，带硬件浮点数、Thumb-2和NEON扩展，EABI硬件浮点数应用二
     进制接口（ABI），和Linux-Libre内核。

‘aarch64-linux’
     little-endian 64-bit ARMv8-A processors, Linux-Libre kernel.

‘mips64el-linux (deprecated)’
     little-endian 64-bit MIPS processors, specifically the Loongson
     series, n32 ABI, and Linux-Libre kernel.  This configuration is no
     longer fully supported; in particular, there is no ongoing work to
     ensure that this architecture still works.  Should someone decide
     they wish to revive this architecture then the code is still
     available.

   在Guix系统里，你_声明_操作系统所有方面的配置，然后Guix以事务型的，可
重复的，和无状态的方式解决实例化配置的问题（*note 系统配置::）。Guix系统
使用Linux-Libre内核，Shepherd初始化系统*note (shepherd)介绍::，知名的
GNU工具和工具链，以及你可选的图形界面环境和系统服务。

   Guix系统在上面所有的平台上都可用，除了‘mips64el-linux’。

关于移植到其它架构或内核的信息，*note 移植::。

   构建这个发行版需要努力合作，欢迎你加入！关于你可以怎样提供帮助的信息
，*Note 贡献::。

   ---------- Footnotes ----------

   (1) 这里的“自由”指的是软件提供给用户的自由
(https://www.gnu.org/philosophy/free-sw.html)。


File: guix.zh_CN.info,  Node: 安装,  Next: 系统安装,  Prev: 介绍,  Up: Top

2 安装
******

     注: 我们推荐使用shell安装脚本
     (https://git.savannah.gnu.org/cgit/guix.git/plain/etc/guix-install.sh)在
     已有的GNU/Linux系统（即“foreign distro”）上安装Guix。(1)这个脚本自
     动下载、安装并且初始化Guix，它需要以root用户身份运行。

   在foreign distro上安装时，GNU Guix可以在不引起冲突的前提下补充现有的
工具。它的数据只存放在两个文件夹里，通常是‘/gnu/store’和‘/var/guix’；系
统上的其它文件，如‘/etc’，不会被修改。

   一旦安装好了，可以通过运行‘guix pull’升级Guix（*note 调用guix pull::）
。

   如果你希望手动执行安装步骤，或者想改变安装步骤，接下来这些小节会很有
用。它们介绍Guix的软件依赖，以及如何手动安装和使用Guix。

* Menu:

* 二进制文件安装::    立刻运行Guix！
* 需求::                   构建和运行Guix需要的软件。
* 运行测试套件::       测试Guix。
* 设置后台进程::       准备“构建后台进程”的环境。
* 调用guix-daemon::        运行“构建后台进程”
* 设置应用程序::       应用程序相关的设置。
* Upgrading Guix::           Upgrading Guix and its build daemon.

   ---------- Footnotes ----------

   (1) 这个小节是关于安装包管理器的，可以在GNU/Linux系统上完成。如果你想
安装完整的GNU操作系统，*note 系统安装::。


File: guix.zh_CN.info,  Node: 二进制文件安装,  Next: 需求,  Up: 安装

2.1 二进制文件安装
==================

这个小节介绍如何在任意的系统上用独立的Guix二进制文件包安装Guix和它的依赖
。这通常比从源代码安装更快，下一小节会介绍如何从源代码安装。唯一的需求是
有GNU tar和Xz。

     注: We recommend the use of this shell installer script
     (https://git.savannah.gnu.org/cgit/guix.git/plain/etc/guix-install.sh).
     The script automates the download, installation, and initial
     configuration steps described below.  It should be run as the root
     user.  As root, you can thus run this:

          cd /tmp
          wget https://git.savannah.gnu.org/cgit/guix.git/plain/etc/guix-install.sh
          chmod +x guix-install.sh
          ./guix-install.sh

   安装步骤如下：

  1. Download the binary tarball from
     ‘https://ftp.gnu.org/gnu/guix/guix-binary-1.0.1.17089-7e269.x86_64-linux.tar.xz’,
     where ‘x86_64-linux’ can be replaced with ‘i686-linux’ for an
     ‘i686’ (32-bits) machine already running the kernel Linux, and so
     on (*note GNU发行版::).

     请确保下载相关的‘.sig’文件，并且用它验证文件包的可靠性，方法如下：

          $ wget https://ftp.gnu.org/gnu/guix/guix-binary-1.0.1.17089-7e269.x86_64-linux.tar.xz.sig
          $ gpg --verify guix-binary-1.0.1.17089-7e269.x86_64-linux.tar.xz.sig

     如果那个命令因为缺少所需的公钥而失败了，那么用这个命令导入它：

          $ wget https://sv.gnu.org/people/viewgpg.php?user_id=15145 \
                -qO - | gpg --import -

     再次运行‘gpg --verify’命令。

     Take note that a warning like “This key is not certified with a
     trusted signature!” is normal.

  2. 现在你需要成为‘root’用户。基于你的发行版，你可能需要执行‘su -’或
     ‘sudo -i’。以‘root’用户身份，执行：

          # cd /tmp
          # tar --warning=no-timestamp -xf \
               /path/to/guix-binary-1.0.1.17089-7e269.x86_64-linux.tar.xz
          # mv var/guix /var/ && mv gnu /

     This creates ‘/gnu/store’ (*note 仓库::) and ‘/var/guix’.  The
     latter contains a ready-to-use profile for ‘root’ (see next step).

     _不要_在一个正常的Guix系统上解压这个文件包，因为那会把现有的重要的
     文件覆盖。

     The ‘--warning=no-timestamp’ option makes sure GNU tar does not
     emit warnings about “implausibly old time stamps” (such warnings
     were triggered by GNU tar 1.26 and older; recent versions are
     fine).  They stem from the fact that all the files in the archive
     have their modification time set to zero (which means January 1st,
     1970).  This is done on purpose to make sure the archive content is
     independent of its creation time, thus making it reproducible.

  3. 使profile出现在‘~root/.config/guix/current’，这是‘guix pull’安装更
     新的位置（*note 调用guix pull::）：

          # mkdir -p ~root/.config/guix
          # ln -sf /var/guix/profiles/per-user/root/current-guix \
                   ~root/.config/guix/current

     Source ‘etc/profile’ to augment ‘PATH’ and other relevant
     environment variables:

          # GUIX_PROFILE="`echo ~root`/.config/guix/current" ; \
            source $GUIX_PROFILE/etc/profile

  4. 像下面解释的那样为“构建用户”创建用户组和用户（*note 设置构建环境::）
     。

  5. 运行后台进程，并设置为开机自启动。

     如果你的主机的发行版使用systemd init系统，可以用这些命令：

          # cp ~root/.config/guix/current/lib/systemd/system/gnu-store.mount \
               ~root/.config/guix/current/lib/systemd/system/guix-daemon.service \
               /etc/systemd/system/
          # systemctl enable --now gnu-store.mount guix-daemon

     如果你的主机的发行版使用Upstart init系统：

          # initctl reload-configuration
          # cp ~root/.config/guix/current/lib/upstart/system/guix-daemon.conf \
               /etc/init/
          # start guix-daemon

     此外，你可以手动启动后台进程：

          # ~root/.config/guix/current/bin/guix-daemon \
                 --build-users-group=guixbuild

  6. 使机器上的其他用户也可以使用‘guix’命令：

          # mkdir -p /usr/local/bin
          # cd /usr/local/bin
          # ln -s /var/guix/profiles/per-user/root/current-guix/bin/guix

     最好让这个用户手册的Info版也可以被访问：

          # mkdir -p /usr/local/share/info
          # cd /usr/local/share/info
          # for i in /var/guix/profiles/per-user/root/current-guix/share/info/* ;
            do ln -s $i ; done

     That way, assuming ‘/usr/local/share/info’ is in the search path,
     running ‘info guix’ will open this manual (*note (texinfo)Other
     Info Directories::, for more details on changing the Info search
     path).

  7. 为了使用‘ci.guix.gnu.org’或其镜像的substitute（*note Substitutes::）
     ，对其授权：

          # guix archive --authorize < \
               ~root/.config/guix/current/share/guix/ci.guix.gnu.org.pub

  8. 每个用户可能需要执行一些额外的步骤以使各自的Guix环境可用，*note
     设置应用程序::。

   瞧，安装完成了！

   你可以通过给root profile安装一个软件包来确认Guix可以正常工作。

     # guix install hello

   二进制安装包可以通过在Guix源代码树里运行下面这些命令来重现和验证：

     make guix-binary.系统.tar.xz

... 这个命令会执行：

     guix pack -s 系统 --localstatedir \
       --profile-name=current-guix guix

   *Note 调用guix pack::，了解这个方便的工具。


File: guix.zh_CN.info,  Node: 需求,  Next: 运行测试套件,  Prev: 二进制文件安装,  Up: 安装

2.2 需求
========

这个小节列举了从源代码构建Guix的需求。构建Guix的步骤和其它GNU软件相同，
这里不介绍。请阅读Guix源代码树里的‘README’和‘INSTALL’文件以了解更多的信
息。

   GNU Guix可以从它的网站下载<https://www.gnu.org/software/guix/>。

   GNU Guix依赖这些软件包：

   • GNU Guile (https://gnu.org/software/guile/), version 3.0.x or
     2.2.x;
   • Guile-Gcrypt (https://notabug.org/cwebber/guile-gcrypt)，版本
     0.1.0或更新；
   • GnuTLS (https://gnutls.org/)，特别是它的Guile接口（*note
     怎样为Guile安装GnuTLS接口: (gnutls-guile)Guile Preparations.）；
   • Guile-SQLite3 (https://notabug.org/guile-sqlite3/guile-sqlite3)，版
     本0.1.0或更新；
   • Guile-Git (https://gitlab.com/guile-git/guile-git)，2017年8月及之后
     的版本；
   • Guile-JSON (https://savannah.nongnu.org/projects/guile-json/) 3.x;
   • zlib (https://zlib.net)；
   • GNU Make (https://www.gnu.org/software/make/)。

   这些依赖是可选的：

   • Support for build offloading (*note 下发工作给后台进程的设置::) and
     ‘guix copy’ (*note 调用guix copy::) depends on Guile-SSH
     (https://github.com/artyom-poptsov/guile-ssh), version 0.12.0 or
     later.

   • When lzlib (https://www.nongnu.org/lzip/lzlib.html) is available,
     lzlib substitutes can be used and ‘guix publish’ can compress
     substitutes with lzlib.

   • 当libbz2 (http://www.bzip.org)存在时，‘guix-daemon’可以用它压缩构建
     日志。

   Unless ‘--disable-daemon’ was passed to ‘configure’, the following
packages are also needed:

   • GNU libgcrypt (https://gnupg.org/)；
   • SQLite 3 (https://sqlite.org)；
   • GCC’s g++ (https://gcc.gnu.org)，支持 C++11标准。

   When configuring Guix on a system that already has a Guix
installation, be sure to specify the same state directory as the
existing installation using the ‘--localstatedir’ option of the
‘configure’ script (*note ‘localstatedir’: (standards)Directory
Variables.).  Usually, this LOCALSTATEDIR option is set to the value
‘/var’.  The ‘configure’ script protects against unintended
misconfiguration of LOCALSTATEDIR so you do not inadvertently corrupt
your store (*note 仓库::).


File: guix.zh_CN.info,  Node: 运行测试套件,  Next: 设置后台进程,  Prev: 需求,  Up: 安装

2.3 运行测试套件
================

成功执行‘configure’和‘make’之后，最好运行测试套件。它可以帮助查找设置和
环境的错误，或者是Guix自身的bug－－并且，报告测试错误是帮助改进软件的好
方法。输入下面的命令以执行测试套件。

     make check

   测试用例可以并行运行：你可以用GNU make的‘-j’参数来加速运行。才一台较
新的机器上第一次运行可能会花几分钟，后续的运行会更快，因为为测试创建的仓
库已经包含了各种缓存。

   你还可以通过定义makefile的‘TESTS’变量只运行测试的一个子集：

     make check TESTS="tests/store.scm tests/cpio.scm"

   默认情况下，测试结果只展示到文件层级。为了看每个独立的测试用例的详情
，可以像这样定义‘SCM_LOG_DRIVER_FLAGS’ makefile变量：

     make check TESTS="tests/base64.scm" SCM_LOG_DRIVER_FLAGS="--brief=no"

   遇到错误时，请给<bug-guix@gnu.org>发邮件，并附带‘test-suite.log’文件
。请在消息里说明使用的Guix的版本信息和依赖（*note 需求::）的版本信息。

   Guix还附带了一个可以测试整个Guix系统实例的全系统测试套件。它只能在已
经安装Guix的系统上运行：

     make check-system

或者，同样的，通过定义‘TESTS’只运行测试的一个子集：

     make check-system TESTS="basic mcron"

   这些系统测试是在‘(gnu tests ...)’模块里定义的。它们在虚拟机（VM）里运
行轻量的指令。它们的计算量可能很多也可能很少，这取决于它们依赖的
substitute（*note Substitutes::）是否已经存在。它们之中有些需要很多存储
空间以保存虚拟机硬盘。

   再重复一遍，如果遇到测试错误，请给<bug-guix@gnu.org>发邮件，并附带详
细的说明。


File: guix.zh_CN.info,  Node: 设置后台进程,  Next: 调用guix-daemon,  Prev: 运行测试套件,  Up: 安装

2.4 设置后台进程
================

构建软件包或运行垃圾回收器之类的操作都是由一个特殊的进程代替客户执行的，
即“构建后台进程”。只有这个进程可以访问仓库和相关的数据库。因此，所有修改
仓库的操作都通过这个后台进程执行。例如，‘guix package’和‘guix build’之类
的命令行工具通过和这个后台进程通信（通过远程过程调用）来指示它该做什么。

   接下来的几个小节介绍如何准备“构建后台进程”的环境。参考*note
Substitutes::，了解怎样允许这个后台进程下载预构建好的二进制文件。

* Menu:

* 设置构建环境::       准备隔离的构建环境。
* 下发工作给后台进程的设置::  下发构建工作给远程的机器。
* SELinux的支持::         为后台进程使用SELinux规则。


File: guix.zh_CN.info,  Node: 设置构建环境,  Next: 下发工作给后台进程的设置,  Up: 设置后台进程

2.4.1 设置构建环境
------------------

在一个标准的多用户设置里，Guix和它的后台进程–‘guix-daemon’程序–是由
‘root’用户安装的，并且‘guix-daemon’以‘root’用户身份运行。无特权的用户可
以用Guix的工具构建软件包或访问仓库，这个后台进程会代替用户进行这些操作，
以确保仓库保持一致的状态，并且允许构建好的软件包可以在不同用户间共享。

   当‘guix-daemon’以‘root’用户身份运行时，由于安全方面的考虑，你可能不希
望软件包构建进程也以‘root’用户身份运行。为了避免那样，我们需要创建一个
“构建用户”池，以供后台进程启动的构建进程使用。这些构建用户不需要拥有
shell和家目录：他们只会在后台进程为构建进程剥夺‘root’特权时使用。拥有多
个这类用户使后台进程可以以不同的UID启动不同的构建进程，这保证它们不会互
相干扰–这是一个重要的功能，因为构建被视为纯函数（*note 介绍::）。

   在一个GNU/Linux系统上，可以这样创建一个构建用户池（用bash语法和
‘shadow’命令）：

     # groupadd --system guixbuild
     # for i in `seq -w 1 10`;
       do
         useradd -g guixbuild -G guixbuild           \
                 -d /var/empty -s `which nologin`    \
                 -c "Guix build user $i" --system    \
                 guixbuilder$i;
       done

构建用户的数量决定了有多少个构建任务可以并行执行，即‘--max-jobs’参数
(*note ‘--max-jobs’: 调用guix-daemon.)。为了使用‘guix system vm’和相关的
命令，你需要把构建用户添加到‘kvm’用户组，以使它们访问‘/dev/kvm’。为此，
把‘-G guixbuild’替换成‘-G guixbuild,kvm’（*note 调用guix system::）。

   之后以‘root’身份用下面的命令运行‘guix-daemon’程序command(1)：

     # guix-daemon --build-users-group=guixbuild

这样，后台进程在一个chroot环境里，以一个‘guixbuilder’用户组成员的身份启
动构建进程。在GNU/Linux上，默认的，这个chroot环境仅包含这些东西：

   • 一个和主机‘/dev’独立的(2)，最小的‘/dev’文件夹；

   • ‘/proc’文件夹；它只含有当前容器的进程，因为用了一个独立的进程PID命
     名空间；

   • ‘/etc/passwd’，仅包含当前用户和‘nobody’；

   • ‘/etc/group’，包含用户的组；

   • ‘/etc/hosts’，包含‘localhost’映射到‘127.0.0.1’的条目；

   • 一个可写的‘/tmp’文件夹。

   You can influence the directory where the daemon stores build trees
via the ‘TMPDIR’ environment variable.  However, the build tree within
the chroot is always called ‘/tmp/guix-build-NAME.drv-0’, where NAME is
the derivation name—e.g., ‘coreutils-8.24’.  This way, the value of
‘TMPDIR’ does not leak inside build environments, which avoids
discrepancies in cases where build processes capture the name of their
build tree.

   The daemon also honors the ‘http_proxy’ and ‘https_proxy’ environment
variables for HTTP and HTTPS downloads it performs, be it for
fixed-output derivations (*note Derivations::) or for substitutes (*note
Substitutes::).

   If you are installing Guix as an unprivileged user, it is still
possible to run ‘guix-daemon’ provided you pass ‘--disable-chroot’.
However, build processes will not be isolated from one another, and not
from the rest of the system.  Thus, build processes may interfere with
each other, and may access programs, libraries, and other files
available on the system—making it much harder to view them as _pure_
functions.

   ---------- Footnotes ----------

   (1) 如果你的机器使用systemd init系统，把
‘PREFIX/lib/systemd/system/guix-daemon.service’文件复制到
‘/etc/systemd/system’文件夹里可以使‘guix-daemon’自启动。类似的，如果你的
机器使用Upstart init系统，把
‘PREFIX/lib/upstart/system/guix-daemon.conf’文件复制到‘/etc/init’文件夹
里

   (2) 大致这样，因为虽然chroot环境里的‘/dev’包含的文件是固定的，大部分
这些文件只有在主机有对应的文件时才能创建。


File: guix.zh_CN.info,  Node: 下发工作给后台进程的设置,  Next: SELinux的支持,  Prev: 设置构建环境,  Up: 设置后台进程

2.4.2 使用任务下发设施
----------------------

当需要时，构建后台进程可以把构建derivation的任务“下发”给其它运行Guix的机
器，这通过‘下发’ “构建钩子”实现(1)。当那个功能被启用时，会从
‘/etc/guix/machines.scm’读取一列用户指定的机器；每次发送构建请求时，如执
行‘guix build’，后台进程尝试把它下发到某一台满足derivation的约束（特别是
系统类型–如‘x86_64-linux’）的机器上。缺少的必备构建依赖通过SSH复制到目标
机器，然后继续构建；成功后，构建输出的结果被复制回初始的机器上。

   ‘/etc/guix/machines.scm’文件通常是这样的：

     (list (build-machine
             (name "eightysix.example.org")
             (system "x86_64-linux")
             (host-key "ssh-ed25519 AAAAC3Nza...")
             (user "bob")
             (speed 2.))     ;非常快！

           (build-machine
             (name "armeight.example.org")
             (system "aarch64-linux")
             (host-key "ssh-rsa AAAAB3Nza...")
             (user "alice")
             (private-key
              (string-append (getenv "HOME")
                             "/.ssh/identity-for-guix"))))

In the example above we specify a list of two build machines, one for
the ‘x86_64’ architecture and one for the ‘aarch64’ architecture.

   事实上，这个文件–并不意外地–是一个Scheme文件，当‘下发’钩子被启动时执
行。它的返回值必须是一个包含‘build-machine’对象的列表。虽然这个例子展示
的是一个固定的列表，你可以想象，使用DNS-SD来返回一个包含从局域网内发现的
构建机器的列表，*note Guile-Avahi: (guile-avahi)介绍.。‘build-machine’数
据类型的详细信息如下。

 -- 数据类型: build-machine
     这个数据类型表示后台进程可以下发构建任务的构建机器。重要的项有：

     ‘名字’
          远程机器的主机名。

     ‘系统’
          远程机器的系统类型–如，‘"x86_64-linux"’。

     ‘用户’
          通过SSH连接远程机器时使用的用户帐号。注意，SSH密钥_不_能被密码
          保护，以支持无交互的登录。

     ‘主机公钥’
          这必须是机器的OpenSSH格式的SSH“公钥”。这是用来在连接机器时认证
          身份的。它是一个像这样的长字符串：

               ssh-ed25519 AAAAC3NzaC...mde+UhL hint@example.org

          如果这个机器正在运行OpenSSH后台进程，‘sshd’，那么主机公钥可以
          在‘/etc/ssh/ssh_host_ed25519_key.pub’找到。

          如果这个机器正在运行GNU lsh，‘lshd’，那么主机公钥可以在
          ‘/etc/lsh/host-key.pub’或类似的位置找到。它可以通过
          ‘lsh-export-key’命令转换成OpenSSH格式（*note (lsh)Converting
          keys::）：

               $ lsh-export-key --openssh < /etc/lsh/host-key.pub
               ssh-rsa AAAAB3NzaC1yc2EAAAAEOp8FoQAAAQEAs1eB46LV...

     一些可选的项：

     ‘port’（默认值：‘22’）
          机器上的SSH服务器的端口号。

     ‘private-key’（默认值：‘~root/.ssh/id_rsa’）
          连接机器时使用的SSH私钥，OpenSSH格式。这个私钥不能被密码保护。

          注意，默认值是_root帐号_的私钥。使用默认值时请确保它存在。

     ‘compression’（默认值：‘"zlib@openssh.com,zlib"’）
     ‘compression-level’（默认值：‘3’）
          SSH压缩算法和压缩级别。

          下发任务依赖SSH压缩来减少传输文件到构建机器时使用的带宽。

     ‘daemon-socket’（默认值：‘"/var/guix/daemon-socket/socket"’）
          那台机器上的‘guix-daemon’监听的Unix套接字文件名。

     ‘parallel-builds’（默认值：‘1’）
          那台机器上可以并行运行的构建任务数量。

     ‘speed’（默认值：‘1.0’）
          一个相对的速度值。下发调度器会偏好速度更快的机器。

     ‘features’ （‘'()’）
          一个表示机器支持的功能的字符串列表。例如，‘"kvm"’表示机器有KVM
          Linux模块和相关的硬件支持。Derivation可以通过名字请求需要的功
          能，然后被分发到匹配的机器的任务队列里。

   ‘guix’命令必须在构建机器的搜素路径里。你可以通过这个命令检查：

     ssh build-machine guix repl --version

   ‘machines.scm’到位后，还有一件要做的事。如上所述，下发任务时会在机器
的仓库之间传输文件。为此，你需要在每台机器上生成一个密钥对，以使后台进程
可以从仓库导出签名后的文件包（*note 调用guix archive::）：

     # guix archive --generate-key

每台构建机器都必须认证主机器的公钥，从而接收从主机器接收的仓库文件：

     # guix archive --authorize < master-public-key.txt

类似的，主机器必须认证每台构建机器的公钥：

   所有这些有关公钥的繁琐事宜都是为了表达主服务器和构建服务器之间成对的
互相信任关系。具体地，当主机器从构建机器接收文件时（反之亦然），它的构建
后台进程可以确保文件是原样的，没有被篡改，并且被认证的公钥签名过。

   为了测试你的设置是否能正常工作，在主节点上运行这个命令：

     # guix offload test

   这会尝试连接每台在‘/etc/guix/machines.scm’里指定的构建机器，确保
Guile和Guix模块在每台机器上都可用，尝试导出到这些机器和从这些机器导入，
并且报告这个过程中遇到的任何错误。

   如果你希望用别的文件测试，只需要在命令行指定它：

     # guix offload test machines-qualif.scm

   最后，你可以像这样只测试机器列表里名字匹配某个正则表达式的子集：

     # guix offload test machines.scm '\.gnu\.org$'

   若想展示所有构建主机的当前负载，在主节点上运行这个命令：

     # guix offload status

   ---------- Footnotes ----------

   (1) 这个功能只有当Guile-SSH
(https://github.com/artyom-poptsov/guile-ssh)存在时才可用。


File: guix.zh_CN.info,  Node: SELinux的支持,  Prev: 下发工作给后台进程的设置,  Up: 设置后台进程

2.4.3 SELinux的支持
-------------------

Guix附带一个SELinux策略文件，位置在‘etc/guix-daemon.cil’，它可以在启用
SELinux的系统上安装，为Guix的文件添加标签及指定后台进程的期望行为。由于
Guix系统不提供SELinux基础策略，这个后台进程策略不能在Guix系统上使用。

2.4.3.1 安装SELinux策略
.......................

用root用户执行这个命令以安装策略：

     semodule -i etc/guix-daemon.cil

   用‘restorecon’或者你的系统提供的其它机制重新给文件系统打标签。

   一旦安装好策略，为文件系统重新打好标签，并且重启了后台进程，它应该在
‘guix_daemon_t’环境里运行。你可以用下面这个命令确认：

     ps -Zax | grep guix-daemon

   运行‘guix build hello’之类的命令并监控SELinux日志以说服你自己
SELinux允许所有的操作。

2.4.3.2 限制
............

这个策略不是完美的。这里有一个关于限制和缺陷的列表，当为Guix后台进程部署
提供的SELinux策略时该认真考虑。

  1. ‘guix_daemon_socket_t’没有被实际使用。所有的套接字操作都和
     ‘guix_daemon_socket_t’没有任何关系。存在这个没被使用的标签并不碍事
     ，但是为这个标签定义套接字规则是更好的选择。

  2. ‘guix gc’不可以任意访问指向profile的链接。由于设计的原因，符号链接
     的目标的文件标签和符号链接本身的文件标签是不同的。尽管
     $localstatedir里的所有profile都被打上了标签，指向这些profile的符号
     链接继承它们所在的文件夹的标签。对于普通用户的家目录里的链接，标签
     是‘user_home_t’。但是对于root用户的家目录，或‘/tmp’，或HTTP服务器的
     工作目录等文件夹里的链接不是这样。‘guix gc’会被阻止读取和跟随这些链
     接。

  3. 后台进程监听TCP连接的功能不再可用。这可能需要额外的规则，因为
     SELinux区别对待网络套接字和文件。

  4. 目前，所有匹配正则表达式
     ‘/gnu/store/.+-(guix-.+|profile)/bin/guix-daemon’的文件都被赋予
     ‘guix_daemon_exec_t’标签；这意味着_任何_profile里的任何有这样名字的
     的文件都会被允许在‘guix_daemon_t’域里执行。这不够理想。一个攻击者可
     以构建提供这个可执行程序的软件包，并说服一个用户安装、运行它，以此
     进入‘guix_daemon_t’域。那时，SELinux无法阻止它访问所在域的进程可以
     访问的文件。

     我们可以在安装时生成一个更严格的策略，仅当前安装的‘guix-daemon’的
     _精确的_的文件名会被打上‘guix_daemon_exec_t’标签，而不是用一个宽泛
     的正则表达式。这样的缺点是root必须在每次安装提供‘guix-daemon’的
     Guix软件包时安装或升级策略。


File: guix.zh_CN.info,  Node: 调用guix-daemon,  Next: 设置应用程序,  Prev: 设置后台进程,  Up: 安装

2.5 调用‘guix-daemon’
=====================

‘guix-daemon’程序实现了所有访问仓库的功能。包括启动构建进程，运行垃圾回
收器，查询构建结果，等。它通常以‘root’身份运行：

     # guix-daemon --build-users-group=guixbuild

关于如何设置它，*note 设置后台进程::。

   By default, ‘guix-daemon’ launches build processes under different
UIDs, taken from the build group specified with ‘--build-users-group’.
In addition, each build process is run in a chroot environment that only
contains the subset of the store that the build process depends on, as
specified by its derivation (*note derivation: 编程接口.), plus a set of
specific system directories.  By default, the latter contains ‘/dev’ and
‘/dev/pts’.  Furthermore, on GNU/Linux, the build environment is a
“container”: in addition to having its own file system tree, it has a
separate mount name space, its own PID name space, network name space,
etc.  This helps achieve reproducible builds (*note 功能::).

   When the daemon performs a build on behalf of the user, it creates a
build directory under ‘/tmp’ or under the directory specified by its
‘TMPDIR’ environment variable.  This directory is shared with the
container for the duration of the build, though within the container,
the build tree is always called ‘/tmp/guix-build-NAME.drv-0’.

   结束时构建文件夹就被自动删除了，除非构建失败并且客户端指定了
‘--keep-failed’参数（*note ‘--keep-failed’: 调用guix build.）。

   The daemon listens for connections and spawns one sub-process for
each session started by a client (one of the ‘guix’ sub-commands).  The
‘guix processes’ command allows you to get an overview of the activity
on your system by viewing each of the active sessions and clients.
*Note 调用guix processes::, for more information.

   下面这些命令行选项受支持：

‘--build-users-group=用户组’
     这会从用户组里选取用户，以运行构建进程（*note 构建用户:
     设置后台进程.）。

‘--no-substitutes’
     不要为构建商品使用substitute。即，总是在本地构建，而不是下载预构建
     的二进制文件（*note Substitutes::）。

     When the daemon runs with ‘--no-substitutes’, clients can still
     explicitly enable substitution via the ‘set-build-options’ remote
     procedure call (*note 仓库::).

‘--substitute-urls=URLS’
     URLS是用空格分隔的substitute源URL列表。当这个选项被省略时，默认使用
     ‘https://ci.guix.gnu.org’。

     这意味着可以从URLS下载substitute，只要它们的签名可信（*note
     Substitutes::）。

‘--no-offload’
     Do not use offload builds to other machines (*note
     下发工作给后台进程的设置::).  That is, always build things locally
     instead of offloading builds to remote machines.

‘--cache-failures’
     缓存失败的构建。默认地，只缓存成功的构建。

     当这个选项被使用时，可以用‘guix gc --list-failures’查询被标记为失败
     的仓库文件；‘guix gc --clear-failures’从仓库里删除失败的缓存。*Note
     调用guix gc::。

‘--cores=N’
‘-c N’
     用N个CPU核来构建每个derivation；‘0’表示有多少就用多少。

     The default value is ‘0’, but it may be overridden by clients, such
     as the ‘--cores’ option of ‘guix build’ (*note 调用guix build::).

     The effect is to define the ‘NIX_BUILD_CORES’ environment variable
     in the build process, which can then use it to exploit internal
     parallelism—for instance, by running ‘make -j$NIX_BUILD_CORES’.

‘--max-jobs=N’
‘-M N’
     最多允许N个并行的构建任务。默认值是‘1’。设置为‘0’表示不在本地执行构
     建；而是下发构建任务（*note 下发工作给后台进程的设置::），或者直接
     失败。

‘--max-silent-time=SECONDS’
     当构建或substitution进程超过SECONDS秒仍然保持静默，就把它结束掉并报
     告构建失败。

     默认值是‘0’，表示关闭超时。

     The value specified here can be overridden by clients (*note
     ‘--max-silent-time’: 普通的构建选项.).

‘--timeout=SECONDS’
     类似地，当构建或substitution进程执行超过SECONDS秒，就把它结束掉并报
     告构建失败。

     默认值是‘0’，表示关闭超时。

     The value specified here can be overridden by clients (*note
     ‘--timeout’: 普通的构建选项.).

‘--rounds=N’
     为每个derivation构建N次，如果连续的构建结果不是每个比特都相同就报告
     错误。这个设置可以被‘guix build’之类的客户端覆盖（*note 调用guix
     build::）。

     当和‘--keep-failed’一起使用时，不同的输出保存在
     ‘/gnu/store/...-check’。这让检查两个结果的区别更容易。

‘--debug’
     生成调试输出。

     This is useful to debug daemon start-up issues, but then it may be
     overridden by clients, for example the ‘--verbosity’ option of
     ‘guix build’ (*note 调用guix build::).

‘--chroot-directory=DIR’
     把DIR添加到构建的chroot。

     这么做可能会改变构建进程的结果–例如，如果它们使用了在DIR里发现的可
     选依赖。因此，建议不要这么做，而是确保每个derivation声明所需的全部
     输入。

‘--disable-chroot’
     关闭chroot构建。

     不建议使用这个选项，因为它会允许构建进程访问到没被声明的依赖。但是
     ，当‘guix-daemon’以没有特权的用户身份运行时，这个选项是必须的。

‘--log-compression=TYPE’
     以TYPE方式压缩构建日志，可选的值：‘gzip’，‘bzip2’，‘none’。

     Unless ‘--lose-logs’ is used, all the build logs are kept in the
     LOCALSTATEDIR.  To save space, the daemon automatically compresses
     them with Bzip2 by default.

‘--disable-deduplication’
     关闭自动对仓库文件“去重”。

     默认地，添加到仓库的文件会被自动“去重”：如果新添加的文件和仓库里找
     到的某个文件完全相同，后台进程把这个新文件变成另一个文件的硬链接。
     这可以明显地减少硬盘使用，代价是构建结束后轻微地增加输入／输出负载
     。这个选项关闭这个优化。

‘--gc-keep-outputs[=yes|no]’
     垃圾收集器（GC）是否必须保留存活的derivation的输出。

     When set to ‘yes’, the GC will keep the outputs of any live
     derivation available in the store—the ‘.drv’ files.  The default is
     ‘no’, meaning that derivation outputs are kept only if they are
     reachable from a GC root.  *Note 调用guix gc::, for more on GC
     roots.

‘--gc-keep-derivations[=yes|no]’
     垃圾收集器（GC）是否必须保留和存活的输出相关的derivation。

     When set to ‘yes’, as is the case by default, the GC keeps
     derivations—i.e., ‘.drv’ files—as long as at least one of their
     outputs is live.  This allows users to keep track of the origins of
     items in their store.  Setting it to ‘no’ saves a bit of disk
     space.

     In this way, setting ‘--gc-keep-derivations’ to ‘yes’ causes
     liveness to flow from outputs to derivations, and setting
     ‘--gc-keep-outputs’ to ‘yes’ causes liveness to flow from
     derivations to outputs.  When both are set to ‘yes’, the effect is
     to keep all the build prerequisites (the sources, compiler,
     libraries, and other build-time tools) of live objects in the
     store, regardless of whether these prerequisites are reachable from
     a GC root.  This is convenient for developers since it saves
     rebuilds or downloads.

‘--impersonate-linux-2.6’
     On Linux-based systems, impersonate Linux 2.6.  This means that the
     kernel’s ‘uname’ system call will report 2.6 as the release number.

     这可能会有助于构建那些（通常是错误地）依赖内核版本号的程序。

‘--lose-logs’
     Do not keep build logs.  By default they are kept under
     ‘LOCALSTATEDIR/guix/log’.

‘--system=SYSTEM’
     假设SYSTEM是当前的系统类型。默认值是configure时发现的架构／内核元组
     ，如‘x86_64-linux’。

‘--listen=ENDPOINT’
     Listen for connections on ENDPOINT.  ENDPOINT is interpreted as the
     file name of a Unix-domain socket if it starts with ‘/’ (slash
     sign).  Otherwise, ENDPOINT is interpreted as a host name or host
     name and port to listen to.  Here are a few examples:

     ‘--listen=/gnu/var/daemon’
          Listen for connections on the ‘/gnu/var/daemon’ Unix-domain
          socket, creating it if needed.

     ‘--listen=localhost’
          Listen for TCP connections on the network interface
          corresponding to ‘localhost’, on port 44146.

     ‘--listen=128.0.0.42:1234’
          Listen for TCP connections on the network interface
          corresponding to ‘128.0.0.42’, on port 1234.

     This option can be repeated multiple times, in which case
     ‘guix-daemon’ accepts connections on all the specified endpoints.
     Users can tell client commands what endpoint to connect to by
     setting the ‘GUIX_DAEMON_SOCKET’ environment variable (*note
     ‘GUIX_DAEMON_SOCKET’: 仓库.).

          注: The daemon protocol is _unauthenticated and unencrypted_.
          Using ‘--listen=HOST’ is suitable on local networks, such as
          clusters, where only trusted nodes may connect to the build
          daemon.  In other cases where remote access to the daemon is
          needed, we recommend using Unix-domain sockets along with SSH.

     When ‘--listen’ is omitted, ‘guix-daemon’ listens for connections
     on the Unix-domain socket located at
     ‘LOCALSTATEDIR/guix/daemon-socket/socket’.


File: guix.zh_CN.info,  Node: 设置应用程序,  Next: Upgrading Guix,  Prev: 调用guix-daemon,  Up: 安装

2.6 设置应用程序
================

When using Guix on top of GNU/Linux distribution other than Guix
System—a so-called “foreign distro”—a few additional steps are needed to
get everything in place.  Here are some of them.

2.6.1 区域
----------

Packages installed via Guix will not use the locale data of the host
system.  Instead, you must first install one of the locale packages
available with Guix and then define the ‘GUIX_LOCPATH’ environment
variable:

     $ guix install glibc-locales
     $ export GUIX_LOCPATH=$HOME/.guix-profile/lib/locale

   Note that the ‘glibc-locales’ package contains data for all the
locales supported by the GNU libc and weighs in at around 917 MiB.
Alternatively, the ‘glibc-utf8-locales’ is smaller but limited to a few
UTF-8 locales.

   The ‘GUIX_LOCPATH’ variable plays a role similar to ‘LOCPATH’ (*note
‘LOCPATH’: (libc)Locale Names.).  There are two important differences
though:

  1. ‘GUIX_LOCPATH’ is honored only by the libc in Guix, and not by the
     libc provided by foreign distros.  Thus, using ‘GUIX_LOCPATH’
     allows you to make sure the programs of the foreign distro will not
     end up loading incompatible locale data.

  2. libc suffixes each entry of ‘GUIX_LOCPATH’ with ‘/X.Y’, where ‘X.Y’
     is the libc version—e.g., ‘2.22’.  This means that, should your
     Guix profile contain a mixture of programs linked against different
     libc version, each libc version will only try to load locale data
     in the right format.

   This is important because the locale data format used by different
libc versions may be incompatible.

2.6.2 Name Service Switch
-------------------------

When using Guix on a foreign distro, we _strongly recommend_ that the
system run the GNU C library’s “name service cache daemon”, ‘nscd’,
which should be listening on the ‘/var/run/nscd/socket’ socket.  Failing
to do that, applications installed with Guix may fail to look up host
names or user accounts, or may even crash.  The next paragraphs explain
why.

   The GNU C library implements a “name service switch” (NSS), which is
an extensible mechanism for “name lookups” in general: host name
resolution, user accounts, and more (*note (libc)Name Service Switch::).

   Being extensible, the NSS supports “plugins”, which provide new name
lookup implementations: for example, the ‘nss-mdns’ plugin allow
resolution of ‘.local’ host names, the ‘nis’ plugin allows user account
lookup using the Network information service (NIS), and so on.  These
extra “lookup services” are configured system-wide in
‘/etc/nsswitch.conf’, and all the programs running on the system honor
those settings (*note (libc)NSS Configuration File::).

   When they perform a name lookup—for instance by calling the
‘getaddrinfo’ function in C—applications first try to connect to the
nscd; on success, nscd performs name lookups on their behalf.  If the
nscd is not running, then they perform the name lookup by themselves, by
loading the name lookup services into their own address space and
running it.  These name lookup services—the ‘libnss_*.so’ files—are
‘dlopen’’d, but they may come from the host system’s C library, rather
than from the C library the application is linked against (the C library
coming from Guix).

   And this is where the problem is: if your application is linked
against Guix’s C library (say, glibc 2.24) and tries to load NSS plugins
from another C library (say, ‘libnss_mdns.so’ for glibc 2.22), it will
likely crash or have its name lookups fail unexpectedly.

   Running ‘nscd’ on the system, among other advantages, eliminates this
binary incompatibility problem because those ‘libnss_*.so’ files are
loaded in the ‘nscd’ process, not in applications themselves.

2.6.3 X11 Fonts
---------------

The majority of graphical applications use Fontconfig to locate and load
fonts and perform X11-client-side rendering.  The ‘fontconfig’ package
in Guix looks for fonts in ‘$HOME/.guix-profile’ by default.  Thus, to
allow graphical applications installed with Guix to display fonts, you
have to install fonts with Guix as well.  Essential font packages
include ‘gs-fonts’, ‘font-dejavu’, and ‘font-gnu-freefont’.

   Once you have installed or removed fonts, or when you notice an
application that does not find fonts, you may need to install Fontconfig
and to force an update of its font cache by running:

     guix install fontconfig
     fc-cache -rv

   To display text written in Chinese languages, Japanese, or Korean in
graphical applications, consider installing ‘font-adobe-source-han-sans’
or ‘font-wqy-zenhei’.  The former has multiple outputs, one per language
family (*note 有多个输出的软件包::).  For instance, the following
command installs fonts for Chinese languages:

     guix install font-adobe-source-han-sans:cn

   Older programs such as ‘xterm’ do not use Fontconfig and instead rely
on server-side font rendering.  Such programs require to specify a full
name of a font using XLFD (X Logical Font Description), like this:

     -*-dejavu sans-medium-r-normal-*-*-100-*-*-*-*-*-1

   To be able to use such full names for the TrueType fonts installed in
your Guix profile, you need to extend the font path of the X server:

     xset +fp $(dirname $(readlink -f ~/.guix-profile/share/fonts/truetype/fonts.dir))

   After that, you can run ‘xlsfonts’ (from ‘xlsfonts’ package) to make
sure your TrueType fonts are listed there.

2.6.4 X.509证书
---------------

The ‘nss-certs’ package provides X.509 certificates, which allow
programs to authenticate Web servers accessed over HTTPS.

   When using Guix on a foreign distro, you can install this package and
define the relevant environment variables so that packages know where to
look for certificates.  *Note X.509证书::, for detailed information.

2.6.5 Emacs Packages
--------------------

When you install Emacs packages with Guix, the Elisp files are placed
under the ‘share/emacs/site-lisp/’ directory of the profile in which
they are installed.  The Elisp libraries are made available to Emacs
through the ‘EMACSLOADPATH’ environment variable, which is set when
installing Emacs itself.

   Additionally, autoload definitions are automatically evaluated at the
initialization of Emacs, by the Guix-specific
‘guix-emacs-autoload-packages’ procedure.  If, for some reason, you want
to avoid auto-loading the Emacs packages installed with Guix, you can do
so by running Emacs with the ‘--no-site-file’ option (*note (emacs)Init
File::).


File: guix.zh_CN.info,  Node: Upgrading Guix,  Prev: 设置应用程序,  Up: 安装

2.7 Upgrading Guix
==================

To upgrade Guix, run:

     guix pull

   *Note 调用guix pull::, for more information.

   On a foreign distro, you can upgrade the build daemon by running:

     sudo -i guix pull

followed by (assuming your distro uses the systemd service management
tool):

     systemctl restart guix-daemon.service

   On Guix System, upgrading the daemon is achieved by reconfiguring the
system (*note ‘guix system reconfigure’: 调用guix system.).


File: guix.zh_CN.info,  Node: 系统安装,  Next: 软件包管理,  Prev: 安装,  Up: Top

3 系统安装
**********

This section explains how to install Guix System on a machine.  Guix, as
a package manager, can also be installed on top of a running GNU/Linux
system, *note 安装::.

     注: You are reading this documentation with an Info reader.  For
     details on how to use it, hit the <RET> key (“return” or “enter”)
     on the link that follows: *note Info reader: (info-stnd)Top.  Hit
     ‘l’ afterwards to come back here.

     Alternatively, run ‘info info’ in another tty to keep the manual
     available.

* Menu:

* 限制::                   你可以期待什么。
* 硬件的考虑::          支持的硬件。
* U盘和DVD安装::         准备安装介质。
* 准备安装::             网络、分区、等
* 指导的图形安装::    简单的图形安装
* 手动安装::             适合巫师的手动安装。
* 系统安装之后::       当安装成功后。
* 在虚拟机里安装Guix。::  Guix系统游乐场。
* 构建安装镜像::       这是怎样实现的。


File: guix.zh_CN.info,  Node: 限制,  Next: 硬件的考虑,  Up: 系统安装

3.1 限制
========

We consider Guix System to be ready for a wide range of “desktop” and
server use cases.  The reliability guarantees it provides—transactional
upgrades and rollbacks, reproducibility—make it a solid foundation.

   Nevertheless, before you proceed with the installation, be aware of
the following noteworthy limitations applicable to version
1.0.1.17089-7e269:

   • Support for the Logical Volume Manager (LVM) is missing.

   • More and more system services are provided (*note 服务::), but some
     may be missing.

   • GNOME, Xfce, LXDE, and Enlightenment are available (*note
     桌面服务::), as well as a number of X11 window managers.  However,
     KDE is currently missing.

   More than a disclaimer, this is an invitation to report issues (and
success stories!), and to join us in improving it.  *Note 贡献::, for
more info.


File: guix.zh_CN.info,  Node: 硬件的考虑,  Next: U盘和DVD安装,  Prev: 限制,  Up: 系统安装

3.2 硬件的考虑
==============

GNU Guix focuses on respecting the user’s computing freedom.  It builds
around the kernel Linux-libre, which means that only hardware for which
free software drivers and firmware exist is supported.  Nowadays, a wide
range of off-the-shelf hardware is supported on GNU/Linux-libre—from
keyboards to graphics cards to scanners and Ethernet controllers.
Unfortunately, there are still areas where hardware vendors deny users
control over their own computing, and such hardware is not supported on
Guix System.

   One of the main areas where free drivers or firmware are lacking is
WiFi devices.  WiFi devices known to work include those using Atheros
chips (AR9271 and AR7010), which corresponds to the ‘ath9k’ Linux-libre
driver, and those using Broadcom/AirForce chips (BCM43xx with
Wireless-Core Revision 5), which corresponds to the ‘b43-open’
Linux-libre driver.  Free firmware exists for both and is available
out-of-the-box on Guix System, as part of ‘%base-firmware’ (*note
‘firmware’: 操作系统参考.).

   The Free Software Foundation (https://www.fsf.org/) runs “Respects
Your Freedom” (https://www.fsf.org/ryf) (RYF), a certification program
for hardware products that respect your freedom and your privacy and
ensure that you have control over your device.  We encourage you to
check the list of RYF-certified devices.

   Another useful resource is the H-Node (https://www.h-node.org/) web
site.  It contains a catalog of hardware devices with information about
their support in GNU/Linux.


File: guix.zh_CN.info,  Node: U盘和DVD安装,  Next: 准备安装,  Prev: 硬件的考虑,  Up: 系统安装

3.3 U盘和DVD安装
================

An ISO-9660 installation image that can be written to a USB stick or
burnt to a DVD can be downloaded from
‘https://ftp.gnu.org/gnu/guix/guix-system-install-1.0.1.17089-7e269.x86_64-linux.iso.xz’,
where you can replace ‘x86_64-linux’ with one of:

‘x86_64-linux’
     for a GNU/Linux system on Intel/AMD-compatible 64-bit CPUs;

‘i686-linux’
     for a 32-bit GNU/Linux system on Intel-compatible CPUs.

   Make sure to download the associated ‘.sig’ file and to verify the
authenticity of the image against it, along these lines:

     $ wget https://ftp.gnu.org/gnu/guix/guix-system-install-1.0.1.17089-7e269.x86_64-linux.iso.xz.sig
     $ gpg --verify guix-system-install-1.0.1.17089-7e269.x86_64-linux.iso.xz.sig

   如果那个命令因为缺少所需的公钥而失败了，那么用这个命令导入它：

     $ wget https://sv.gnu.org/people/viewgpg.php?user_id=15145 \
           -qO - | gpg --import -

再次运行‘gpg --verify’命令。

   Take note that a warning like “This key is not certified with a
trusted signature!” is normal.

   This image contains the tools necessary for an installation.  It is
meant to be copied _as is_ to a large-enough USB stick or DVD.

Copying to a USB Stick
----------------------

To copy the image to a USB stick, follow these steps:

  1. Decompress the image using the ‘xz’ command:

          xz -d guix-system-install-1.0.1.17089-7e269.x86_64-linux.iso.xz

  2. Insert a USB stick of 1 GiB or more into your machine, and
     determine its device name.  Assuming that the USB stick is known as
     ‘/dev/sdX’, copy the image with:

          dd if=guix-system-install-1.0.1.17089-7e269.x86_64-linux.iso of=/dev/sdX
          sync

     Access to ‘/dev/sdX’ usually requires root privileges.

Burning on a DVD
----------------

To copy the image to a DVD, follow these steps:

  1. Decompress the image using the ‘xz’ command:

          xz -d guix-system-install-1.0.1.17089-7e269.x86_64-linux.iso.xz

  2. Insert a blank DVD into your machine, and determine its device
     name.  Assuming that the DVD drive is known as ‘/dev/srX’, copy the
     image with:

          growisofs -dvd-compat -Z /dev/srX=guix-system-install-1.0.1.17089-7e269.x86_64-linux.iso

     Access to ‘/dev/srX’ usually requires root privileges.

Booting
-------

Once this is done, you should be able to reboot the system and boot from
the USB stick or DVD. The latter usually requires you to get in the BIOS
or UEFI boot menu, where you can choose to boot from the USB stick.  In
order to boot from Libreboot, switch to the command mode by pressing the
‘c’ key and type ‘search_grub usb’.

   *Note 在虚拟机里安装Guix。::, if, instead, you would like to install
Guix System in a virtual machine (VM).


File: guix.zh_CN.info,  Node: 准备安装,  Next: 指导的图形安装,  Prev: U盘和DVD安装,  Up: 系统安装

3.4 准备安装
============

Once you have booted, you can use the guided graphical installer, which
makes it easy to get started (*note 指导的图形安装::).  Alternatively,
if you are already familiar with GNU/Linux and if you want more control
than what the graphical installer provides, you can choose the “manual”
installation process (*note 手动安装::).

   The graphical installer is available on TTY1.  You can obtain root
shells on TTYs 3 to 6 by hitting ‘ctrl-alt-f3’, ‘ctrl-alt-f4’, etc.
TTY2 shows this documentation and you can reach it with ‘ctrl-alt-f2’.
Documentation is browsable using the Info reader commands (*note
(info-stnd)Top::).  The installation system runs the GPM mouse daemon,
which allows you to select text with the left mouse button and to paste
it with the middle button.

     注: Installation requires access to the Internet so that any
     missing dependencies of your system configuration can be
     downloaded.  See the “Networking” section below.


File: guix.zh_CN.info,  Node: 指导的图形安装,  Next: 手动安装,  Prev: 准备安装,  Up: 系统安装

3.5 指导的图形安装
==================

The graphical installer is a text-based user interface.  It will guide
you, with dialog boxes, through the steps needed to install GNU Guix
System.

   The first dialog boxes allow you to set up the system as you use it
during the installation: you can choose the language, keyboard layout,
and set up networking, which will be used during the installation.  The
image below shows the networking dialog.

 [image src="images/installer-network.png" alt="networking setup with the graphical
installer" ]

   Later steps allow you to partition your hard disk, as shown in the
image below, to choose whether or not to use encrypted file systems, to
enter the host name and root password, and to create an additional
account, among other things.

 [image src="images/installer-partitions.png" alt="partitioning with the graphical
installer" ]

   Note that, at any time, the installer allows you to exit the current
installation step and resume at a previous step, as show in the image
below.

 [image src="images/installer-resume.png" alt="resuming the installation process" ]

   Once you’re done, the installer produces an operating system
configuration and displays it (*note 使用配置系统::).  At that point you
can hit “OK” and installation will proceed.  On success, you can reboot
into the new system and enjoy.  *Note 系统安装之后::, for what’s next!


File: guix.zh_CN.info,  Node: 手动安装,  Next: 系统安装之后,  Prev: 指导的图形安装,  Up: 系统安装

3.6 手动安装
============

This section describes how you would “manually” install GNU Guix System
on your machine.  This option requires familiarity with GNU/Linux, with
the shell, and with common administration tools.  If you think this is
not for you, consider using the guided graphical installer (*note
指导的图形安装::).

   The installation system provides root shells on TTYs 3 to 6; press
‘ctrl-alt-f3’, ‘ctrl-alt-f4’, and so on to reach them.  It includes many
common tools needed to install the system.  But it is also a full-blown
Guix System, which means that you can install additional packages,
should you need it, using ‘guix package’ (*note 调用guix package::).

* Menu:

* 键盘布局、网络和分区::  初始设置。
* 继续安装步骤。::    安装。


File: guix.zh_CN.info,  Node: 键盘布局、网络和分区,  Next: 继续安装步骤。,  Up: 手动安装

3.6.1 Keyboard Layout, Networking, and Partitioning
---------------------------------------------------

Before you can install the system, you may want to adjust the keyboard
layout, set up networking, and partition your target hard disk.  This
section will guide you through this.

3.6.1.1 键盘布局
................

The installation image uses the US qwerty keyboard layout.  If you want
to change it, you can use the ‘loadkeys’ command.  For example, the
following command selects the Dvorak keyboard layout:

     loadkeys dvorak

   See the files under ‘/run/current-system/profile/share/keymaps’ for a
list of available keyboard layouts.  Run ‘man loadkeys’ for more
information.

3.6.1.2 Networking
..................

Run the following command to see what your network interfaces are
called:

     ifconfig -a

... or, using the GNU/Linux-specific ‘ip’ command:

     ip address

   Wired interfaces have a name starting with ‘e’; for example, the
interface corresponding to the first on-board Ethernet controller is
called ‘eno1’.  Wireless interfaces have a name starting with ‘w’, like
‘w1p2s0’.

Wired connection
     To configure a wired network run the following command,
     substituting INTERFACE with the name of the wired interface you
     want to use.

          ifconfig INTERFACE up

     ... or, using the GNU/Linux-specific ‘ip’ command:

          ip link set INTERFACE up

Wireless connection
     To configure wireless networking, you can create a configuration
     file for the ‘wpa_supplicant’ configuration tool (its location is
     not important) using one of the available text editors such as
     ‘nano’:

          nano wpa_supplicant.conf

     As an example, the following stanza can go to this file and will
     work for many wireless networks, provided you give the actual SSID
     and passphrase for the network you are connecting to:

          network={
            ssid="MY-SSID"
            key_mgmt=WPA-PSK
            psk="the network's secret passphrase"
          }

     Start the wireless service and run it in the background with the
     following command (substitute INTERFACE with the name of the
     network interface you want to use):

          wpa_supplicant -c wpa_supplicant.conf -i INTERFACE -B

     Run ‘man wpa_supplicant’ for more information.

   At this point, you need to acquire an IP address.  On a network where
IP addresses are automatically assigned via DHCP, you can run:

     dhclient -v INTERFACE

   Try to ping a server to see if networking is up and running:

     ping -c 3 gnu.org

   Setting up network access is almost always a requirement because the
image does not contain all the software and tools that may be needed.

   If you need HTTP and HTTPS access to go through a proxy, run the
following command:

     herd set-http-proxy guix-daemon URL

where URL is the proxy URL, for example ‘http://example.org:8118’.

   If you want to, you can continue the installation remotely by
starting an SSH server:

     herd start ssh-daemon

   Make sure to either set a password with ‘passwd’, or configure
OpenSSH public key authentication before logging in.

3.6.1.3 Disk Partitioning
.........................

Unless this has already been done, the next step is to partition, and
then format the target partition(s).

   The installation image includes several partitioning tools, including
Parted (*note (parted)Overview::), ‘fdisk’, and ‘cfdisk’.  Run it and
set up your disk with the partition layout you want:

     cfdisk

   If your disk uses the GUID Partition Table (GPT) format and you plan
to install BIOS-based GRUB (which is the default), make sure a BIOS Boot
Partition is available (*note (grub)BIOS installation::).

   If you instead wish to use EFI-based GRUB, a FAT32 “EFI System
Partition” (ESP) is required.  This partition can be mounted at
‘/boot/efi’ for instance and must have the ‘esp’ flag set.  E.g., for
‘parted’:

     parted /dev/sda set 1 esp on

     注: Unsure whether to use EFI- or BIOS-based GRUB? If the directory
     ‘/sys/firmware/efi’ exists in the installation image, then you
     should probably perform an EFI installation, using
     ‘grub-efi-bootloader’.  Otherwise you should use the BIOS-based
     GRUB, known as ‘grub-bootloader’.  *Note 引导设置::, for more info
     on bootloaders.

   Once you are done partitioning the target hard disk drive, you have
to create a file system on the relevant partition(s)(1).  For the ESP,
if you have one and assuming it is ‘/dev/sda1’, run:

     mkfs.fat -F32 /dev/sda1

   Preferably, assign file systems a label so that you can easily and
reliably refer to them in ‘file-system’ declarations (*note 文件系统::).
This is typically done using the ‘-L’ option of ‘mkfs.ext4’ and related
commands.  So, assuming the target root partition lives at ‘/dev/sda2’,
a file system with the label ‘my-root’ can be created with:

     mkfs.ext4 -L my-root /dev/sda2

   If you are instead planning to encrypt the root partition, you can
use the Cryptsetup/LUKS utilities to do that (see ‘man cryptsetup’ for
more information).  Assuming you want to store the root partition on
‘/dev/sda2’, the command sequence would be along these lines:

     cryptsetup luksFormat /dev/sda2
     cryptsetup open --type luks /dev/sda2 my-partition
     mkfs.ext4 -L my-root /dev/mapper/my-partition

   Once that is done, mount the target file system under ‘/mnt’ with a
command like (again, assuming ‘my-root’ is the label of the root file
system):

     mount LABEL=my-root /mnt

   Also mount any other file systems you would like to use on the target
system relative to this path.  If you have opted for ‘/boot/efi’ as an
EFI mount point for example, mount it at ‘/mnt/boot/efi’ now so it is
found by ‘guix system init’ afterwards.

   Finally, if you plan to use one or more swap partitions (*note swap
space: (libc)Memory Concepts.), make sure to initialize them with
‘mkswap’.  Assuming you have one swap partition on ‘/dev/sda3’, you
would run:

     mkswap /dev/sda3
     swapon /dev/sda3

   Alternatively, you may use a swap file.  For example, assuming that
in the new system you want to use the file ‘/swapfile’ as a swap file,
you would run(2):

     # This is 10 GiB of swap space.  Adjust "count" to change the size.
     dd if=/dev/zero of=/mnt/swapfile bs=1MiB count=10240
     # For security, make the file readable and writable only by root.
     chmod 600 /mnt/swapfile
     mkswap /mnt/swapfile
     swapon /mnt/swapfile

   Note that if you have encrypted the root partition and created a swap
file in its file system as described above, then the encryption also
protects the swap file, just like any other file in that file system.

   ---------- Footnotes ----------

   (1) Currently Guix System only supports ext4, btrfs, and JFS file
systems.  In particular, code that reads file system UUIDs and labels
only works for these file system types.

   (2) This example will work for many types of file systems (e.g.,
ext4).  However, for copy-on-write file systems (e.g., btrfs), the
required steps may be different.  For details, see the manual pages for
‘mkswap’ and ‘swapon’.


File: guix.zh_CN.info,  Node: 继续安装步骤。,  Prev: 键盘布局、网络和分区,  Up: 手动安装

3.6.2 继续安装步骤。
--------------------

With the target partitions ready and the target root mounted on ‘/mnt’,
we’re ready to go.  First, run:

     herd start cow-store /mnt

   This makes ‘/gnu/store’ copy-on-write, such that packages added to it
during the installation phase are written to the target disk on ‘/mnt’
rather than kept in memory.  This is necessary because the first phase
of the ‘guix system init’ command (see below) entails downloads or
builds to ‘/gnu/store’ which, initially, is an in-memory file system.

   Next, you have to edit a file and provide the declaration of the
operating system to be installed.  To that end, the installation system
comes with three text editors.  We recommend GNU nano (*note
(nano)Top::), which supports syntax highlighting and parentheses
matching; other editors include GNU Zile (an Emacs clone), and nvi (a
clone of the original BSD ‘vi’ editor).  We strongly recommend storing
that file on the target root file system, say, as ‘/mnt/etc/config.scm’.
Failing to do that, you will have lost your configuration file once you
have rebooted into the newly-installed system.

   *Note 使用配置系统::, for an overview of the configuration file.  The
example configurations discussed in that section are available under
‘/etc/configuration’ in the installation image.  Thus, to get started
with a system configuration providing a graphical display server (a
“desktop” system), you can run something along these lines:

     # mkdir /mnt/etc
     # cp /etc/configuration/desktop.scm /mnt/etc/config.scm
     # nano /mnt/etc/config.scm

   You should pay attention to what your configuration file contains,
and in particular:

   • Make sure the ‘bootloader-configuration’ form refers to the target
     you want to install GRUB on.  It should mention ‘grub-bootloader’
     if you are installing GRUB in the legacy way, or
     ‘grub-efi-bootloader’ for newer UEFI systems.  For legacy systems,
     the ‘target’ field names a device, like ‘/dev/sda’; for UEFI
     systems it names a path to a mounted EFI partition, like
     ‘/boot/efi’; do make sure the path is currently mounted and a
     ‘file-system’ entry is specified in your configuration.

   • Be sure that your file system labels match the value of their
     respective ‘device’ fields in your ‘file-system’ configuration,
     assuming your ‘file-system’ configuration uses the
     ‘file-system-label’ procedure in its ‘device’ field.

   • If there are encrypted or RAID partitions, make sure to add a
     ‘mapped-devices’ field to describe them (*note 映射的设备::).

   Once you are done preparing the configuration file, the new system
must be initialized (remember that the target root file system is
mounted under ‘/mnt’):

     guix system init /mnt/etc/config.scm /mnt

This copies all the necessary files and installs GRUB on ‘/dev/sdX’,
unless you pass the ‘--no-bootloader’ option.  For more information,
*note 调用guix system::.  This command may trigger downloads or builds
of missing packages, which can take some time.

   Once that command has completed—and hopefully succeeded!—you can run
‘reboot’ and boot into the new system.  The ‘root’ password in the new
system is initially empty; other users’ passwords need to be initialized
by running the ‘passwd’ command as ‘root’, unless your configuration
specifies otherwise (*note user account passwords:
user-account-password.).  *Note 系统安装之后::, for what’s next!


File: guix.zh_CN.info,  Node: 系统安装之后,  Next: 在虚拟机里安装Guix。,  Prev: 手动安装,  Up: 系统安装

3.7 系统安装之后
================

Success, you’ve now booted into Guix System!  From then on, you can
update the system whenever you want by running, say:

     guix pull
     sudo guix system reconfigure /etc/config.scm

This builds a new system generation with the latest packages and
services (*note 调用guix system::).  We recommend doing that regularly
so that your system includes the latest security updates (*note
安全更新::).

     注: Note that ‘sudo guix’ runs your user’s ‘guix’ command and _not_
     root’s, because ‘sudo’ leaves ‘PATH’ unchanged.  To explicitly run
     root’s ‘guix’, type ‘sudo -i guix ...’.

     The difference matters here, because ‘guix pull’ updates the ‘guix’
     command and package definitions only for the user it is ran as.
     This means that if you choose to use ‘guix system reconfigure’ in
     root’s login shell, you’ll need to ‘guix pull’ separately.

   Join us on ‘#guix’ on the Freenode IRC network or on
<guix-devel@gnu.org> to share your experience!


File: guix.zh_CN.info,  Node: 在虚拟机里安装Guix。,  Next: 构建安装镜像,  Prev: 系统安装之后,  Up: 系统安装

3.8 Installing Guix in a Virtual Machine
========================================

If you’d like to install Guix System in a virtual machine (VM) or on a
virtual private server (VPS) rather than on your beloved machine, this
section is for you.

   To boot a QEMU (https://qemu.org/) VM for installing Guix System in a
disk image, follow these steps:

  1. First, retrieve and decompress the Guix system installation image
     as described previously (*note U盘和DVD安装::).

  2. Create a disk image that will hold the installed system.  To make a
     qcow2-formatted disk image, use the ‘qemu-img’ command:

          qemu-img create -f qcow2 guix-system.img 50G

     The resulting file will be much smaller than 50 GB (typically less
     than 1 MB), but it will grow as the virtualized storage device is
     filled up.

  3. Boot the USB installation image in an VM:

          qemu-system-x86_64 -m 1024 -smp 1 -enable-kvm \
            -nic user,model=virtio-net-pci -boot menu=on,order=d \
            -drive file=guix-system.img \
            -drive media=cdrom,file=guix-system-install-1.0.1.17089-7e269.SYSTEM.iso

     ‘-enable-kvm’ is optional, but significantly improves performance,
     *note 在虚拟机里运行Guix::.

  4. You’re now root in the VM, proceed with the installation process.
     *Note 准备安装::, and follow the instructions.

   Once installation is complete, you can boot the system that’s on your
‘guix-system.img’ image.  *Note 在虚拟机里运行Guix::, for how to do
that.


File: guix.zh_CN.info,  Node: 构建安装镜像,  Prev: 在虚拟机里安装Guix。,  Up: 系统安装

3.9 构建安装镜像
================

The installation image described above was built using the ‘guix system’
command, specifically:

     guix system disk-image --file-system-type=iso9660 \
       gnu/system/install.scm

   Have a look at ‘gnu/system/install.scm’ in the source tree, and see
also *note 调用guix system:: for more information about the installation
image.

3.10 Building the Installation Image for ARM Boards
===================================================

Many ARM boards require a specific variant of the U-Boot
(https://www.denx.de/wiki/U-Boot/) bootloader.

   If you build a disk image and the bootloader is not available
otherwise (on another boot drive etc), it’s advisable to build an image
that includes the bootloader, specifically:

     guix system disk-image --system=armhf-linux -e '((@ (gnu system install) os-with-u-boot) (@ (gnu system install) installation-os) "A20-OLinuXino-Lime2")'

   ‘A20-OLinuXino-Lime2’ is the name of the board.  If you specify an
invalid board, a list of possible boards will be printed.


File: guix.zh_CN.info,  Node: 软件包管理,  Next: 开发,  Prev: 系统安装,  Up: Top

4 软件包管理
************

The purpose of GNU Guix is to allow users to easily install, upgrade,
and remove software packages, without having to know about their build
procedures or dependencies.  Guix also goes beyond this obvious set of
features.

   This chapter describes the main features of Guix, as well as the
package management tools it provides.  Along with the command-line
interface described below (*note ‘guix package’: 调用guix package.), you
may also use the Emacs-Guix interface (*note (emacs-guix)Top::), after
installing ‘emacs-guix’ package (run ‘M-x guix-help’ command to start
with it):

     guix install emacs-guix

* Menu:

* 功能::                   Guix怎样让你的生活更美好。
* 调用guix package::       软件包安装，删除，等
* Substitutes::              下载构建好的二进制文件。
* 有多个输出的软件包::  单个输入多个输出的软件包。
* 调用guix gc::            运行垃圾回收器。
* 调用guix pull::          获取最新的Guix和发行版。
* 通道::                   定制软件包集合。
* Invoking guix time-machine::  Running an older revision of Guix.
* Inferiors::                和其它版本的Guix交互。
* 调用guix describe::      显示你的Guix版本信息。
* 调用guix archive::       导出和导入仓库文件。


File: guix.zh_CN.info,  Node: 功能,  Next: 调用guix package,  Up: 软件包管理

4.1 功能
========

When using Guix, each package ends up in the “package store”, in its own
directory—something that resembles ‘/gnu/store/xxx-package-1.2’, where
‘xxx’ is a base32 string.

   Instead of referring to these directories, users have their own
“profile”, which points to the packages that they actually want to use.
These profiles are stored within each user’s home directory, at
‘$HOME/.guix-profile’.

   For example, ‘alice’ installs GCC 4.7.2.  As a result,
‘/home/alice/.guix-profile/bin/gcc’ points to
‘/gnu/store/...-gcc-4.7.2/bin/gcc’.  Now, on the same machine, ‘bob’ had
already installed GCC 4.8.0.  The profile of ‘bob’ simply continues to
point to ‘/gnu/store/...-gcc-4.8.0/bin/gcc’—i.e., both versions of GCC
coexist on the same system without any interference.

   The ‘guix package’ command is the central tool to manage packages
(*note 调用guix package::).  It operates on the per-user profiles, and
can be used _with normal user privileges_.

   The command provides the obvious install, remove, and upgrade
operations.  Each invocation is actually a _transaction_: either the
specified operation succeeds, or nothing happens.  Thus, if the ‘guix
package’ process is terminated during the transaction, or if a power
outage occurs during the transaction, then the user’s profile remains in
its previous state, and remains usable.

   In addition, any package transaction may be _rolled back_.  So, if,
for example, an upgrade installs a new version of a package that turns
out to have a serious bug, users may roll back to the previous instance
of their profile, which was known to work well.  Similarly, the global
system configuration on Guix is subject to transactional upgrades and
roll-back (*note 使用配置系统::).

   All packages in the package store may be _garbage-collected_.  Guix
can determine which packages are still referenced by user profiles, and
remove those that are provably no longer referenced (*note 调用guix
gc::).  Users may also explicitly remove old generations of their
profile so that the packages they refer to can be collected.

   Guix takes a “purely functional” approach to package management, as
described in the introduction (*note 介绍::).  Each ‘/gnu/store’ package
directory name contains a hash of all the inputs that were used to build
that package—compiler, libraries, build scripts, etc.  This direct
correspondence allows users to make sure a given package installation
matches the current state of their distribution.  It also helps maximize
“build reproducibility”: thanks to the isolated build environments that
are used, a given build is likely to yield bit-identical files when
performed on different machines (*note container: 调用guix-daemon.).

   This foundation allows Guix to support “transparent binary/source
deployment”.  When a pre-built binary for a ‘/gnu/store’ item is
available from an external source—a “substitute”, Guix just downloads it
and unpacks it; otherwise, it builds the package from source, locally
(*note Substitutes::).  Because build results are usually bit-for-bit
reproducible, users do not have to trust servers that provide
substitutes: they can force a local build and _challenge_ providers
(*note 调用guix challenge::).

   Control over the build environment is a feature that is also useful
for developers.  The ‘guix environment’ command allows developers of a
package to quickly set up the right development environment for their
package, without having to manually install the dependencies of the
package into their profile (*note 调用guix environment::).

   All of Guix and its package definitions is version-controlled, and
‘guix pull’ allows you to “travel in time” on the history of Guix itself
(*note 调用guix pull::).  This makes it possible to replicate a Guix
instance on a different machine or at a later point in time, which in
turn allows you to _replicate complete software environments_, while
retaining precise “provenance tracking” of the software.


File: guix.zh_CN.info,  Node: 调用guix package,  Next: Substitutes,  Prev: 功能,  Up: 软件包管理

4.2 Invoking ‘guix package’
===========================

The ‘guix package’ command is the tool that allows users to install,
upgrade, and remove packages, as well as rolling back to previous
configurations.  It operates only on the user’s own profile, and works
with normal user privileges (*note 功能::).  Its syntax is:

     guix package OPTIONS

   Primarily, OPTIONS specifies the operations to be performed during
the transaction.  Upon completion, a new profile is created, but
previous “generations” of the profile remain available, should the user
want to roll back.

   For example, to remove ‘lua’ and install ‘guile’ and ‘guile-cairo’ in
a single transaction:

     guix package -r lua -i guile guile-cairo

   For your convenience, we also provide the following aliases:

   • ‘guix search’ is an alias for ‘guix package -s’,
   • ‘guix install’ is an alias for ‘guix package -i’,
   • ‘guix remove’ is an alias for ‘guix package -r’,
   • ‘guix upgrade’ is an alias for ‘guix package -u’,
   • and ‘guix show’ is an alias for ‘guix package --show=’.

   These aliases are less expressive than ‘guix package’ and provide
fewer options, so in some cases you’ll probably want to use ‘guix
package’ directly.

   ‘guix package’ also supports a “declarative approach” whereby the
user specifies the exact set of packages to be available and passes it
via the ‘--manifest’ option (*note ‘--manifest’: profile-manifest.).

   For each user, a symlink to the user’s default profile is
automatically created in ‘$HOME/.guix-profile’.  This symlink always
points to the current generation of the user’s default profile.  Thus,
users can add ‘$HOME/.guix-profile/bin’ to their ‘PATH’ environment
variable, and so on.  If you are not using Guix System, consider adding
the following lines to your ‘~/.bash_profile’ (*note (bash)Bash Startup
Files::) so that newly-spawned shells get all the right environment
variable definitions:

     GUIX_PROFILE="$HOME/.guix-profile" ; \
     source "$HOME/.guix-profile/etc/profile"

   In a multi-user setup, user profiles are stored in a place registered
as a “garbage-collector root”, which ‘$HOME/.guix-profile’ points to
(*note 调用guix gc::).  That directory is normally
‘LOCALSTATEDIR/guix/profiles/per-user/USER’, where LOCALSTATEDIR is the
value passed to ‘configure’ as ‘--localstatedir’, and USER is the user
name.  The ‘per-user’ directory is created when ‘guix-daemon’ is
started, and the USER sub-directory is created by ‘guix package’.

   The OPTIONS can be among the following:

‘--install=PACKAGE ...’
‘-i PACKAGE ...’
     Install the specified PACKAGEs.

     Each PACKAGE may specify either a simple package name, such as
     ‘guile’, or a package name followed by an at-sign and version
     number, such as ‘guile@1.8.8’ or simply ‘guile@1.8’ (in the latter
     case, the newest version prefixed by ‘1.8’ is selected).

     If no version number is specified, the newest available version
     will be selected.  In addition, PACKAGE may contain a colon,
     followed by the name of one of the outputs of the package, as in
     ‘gcc:doc’ or ‘binutils@2.22:lib’ (*note 有多个输出的软件包::).
     Packages with a corresponding name (and optionally version) are
     searched for among the GNU distribution modules (*note
     软件包模块::).

     Sometimes packages have “propagated inputs”: these are dependencies
     that automatically get installed along with the required package
     (*note ‘propagated-inputs’ in ‘package’ objects:
     package-propagated-inputs, for information about propagated inputs
     in package definitions).

     An example is the GNU MPC library: its C header files refer to
     those of the GNU MPFR library, which in turn refer to those of the
     GMP library.  Thus, when installing MPC, the MPFR and GMP libraries
     also get installed in the profile; removing MPC also removes MPFR
     and GMP—unless they had also been explicitly installed by the user.

     Besides, packages sometimes rely on the definition of environment
     variables for their search paths (see explanation of
     ‘--search-paths’ below).  Any missing or possibly incorrect
     environment variable definitions are reported here.

‘--install-from-expression=EXP’
‘-e EXP’
     Install the package EXP evaluates to.

     EXP must be a Scheme expression that evaluates to a ‘<package>’
     object.  This option is notably useful to disambiguate between
     same-named variants of a package, with expressions such as ‘(@ (gnu
     packages base) guile-final)’.

     Note that this option installs the first output of the specified
     package, which may be insufficient when needing a specific output
     of a multiple-output package.

‘--install-from-file=FILE’
‘-f FILE’
     Install the package that the code within FILE evaluates to.

     As an example, FILE might contain a definition like this (*note
     定义软件包::):

          (use-modules (guix)
                       (guix build-system gnu)
                       (guix licenses))

          (package
            (name "hello")
            (version "2.10")
            (source (origin
                      (method url-fetch)
                      (uri (string-append "mirror://gnu/hello/hello-" version
                                          ".tar.gz"))
                      (sha256
                       (base32
                        "0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i"))))
            (build-system gnu-build-system)
            (synopsis "Hello, GNU world: An example GNU package")
            (description "Guess what GNU Hello prints!")
            (home-page "http://www.gnu.org/software/hello/")
            (license gpl3+))

     Developers may find it useful to include such a ‘guix.scm’ file in
     the root of their project source tree that can be used to test
     development snapshots and create reproducible development
     environments (*note 调用guix environment::).

     The FILE may also contain a JSON representation of one or more
     package definitions.  Running ‘guix package -f’ on ‘hello.json’
     with the following contents would result in installing the package
     ‘greeter’ after building ‘myhello’:

          [
            {
              "name": "myhello",
              "version": "2.10",
              "source": "mirror://gnu/hello/hello-2.10.tar.gz",
              "build-system": "gnu",
              "arguments": {
                "tests?": false
              }
              "home-page": "https://www.gnu.org/software/hello/",
              "synopsis": "Hello, GNU world: An example GNU package",
              "description": "GNU Hello prints a greeting.",
              "license": "GPL-3.0+",
              "native-inputs": ["gettext"]
            },
            {
              "name": "greeter",
              "version": "1.0",
              "source": "https://example.com/greeter-1.0.tar.gz",
              "build-system": "gnu",
              "arguments": {
                "test-target": "foo",
                "parallel-build?": false,
              },
              "home-page": "https://example.com/",
              "synopsis": "Greeter using GNU Hello",
              "description": "This is a wrapper around GNU Hello.",
              "license": "GPL-3.0+",
              "inputs": ["myhello", "hello"]
            }
          ]

‘--remove=PACKAGE ...’
‘-r PACKAGE ...’
     Remove the specified PACKAGEs.

     As for ‘--install’, each PACKAGE may specify a version number
     and/or output name in addition to the package name.  For instance,
     ‘-r glibc:debug’ would remove the ‘debug’ output of ‘glibc’.

‘--upgrade[=REGEXP ...]’
‘-u [REGEXP ...]’
     Upgrade all the installed packages.  If one or more REGEXPs are
     specified, upgrade only installed packages whose name matches a
     REGEXP.  Also see the ‘--do-not-upgrade’ option below.

     Note that this upgrades package to the latest version of packages
     found in the distribution currently installed.  To update your
     distribution, you should regularly run ‘guix pull’ (*note 调用guix
     pull::).

‘--do-not-upgrade[=REGEXP ...]’
     When used together with the ‘--upgrade’ option, do _not_ upgrade
     any packages whose name matches a REGEXP.  For example, to upgrade
     all packages in the current profile except those containing the
     substring “emacs”:

          $ guix package --upgrade . --do-not-upgrade emacs

‘--manifest=FILE’
‘-m FILE’
     Create a new generation of the profile from the manifest object
     returned by the Scheme code in FILE.  This option can be repeated
     several times, in which case the manifests are concatenated.

     This allows you to _declare_ the profile’s contents rather than
     constructing it through a sequence of ‘--install’ and similar
     commands.  The advantage is that FILE can be put under version
     control, copied to different machines to reproduce the same
     profile, and so on.

     FILE must return a “manifest” object, which is roughly a list of
     packages:

          (use-package-modules guile emacs)

          (packages->manifest
           (list emacs
                 guile-2.0
                 ;; Use a specific package output.
                 (list guile-2.0 "debug")))

     In this example we have to know which modules define the ‘emacs’
     and ‘guile-2.0’ variables to provide the right
     ‘use-package-modules’ line, which can be cumbersome.  We can
     instead provide regular package specifications and let
     ‘specifications->manifest’ look up the corresponding package
     objects, like this:

          (specifications->manifest
           '("emacs" "guile@2.2" "guile@2.2:debug"))

‘--roll-back’
     Roll back to the previous “generation” of the profile—i.e., undo
     the last transaction.

     When combined with options such as ‘--install’, roll back occurs
     before any other actions.

     When rolling back from the first generation that actually contains
     installed packages, the profile is made to point to the “zeroth
     generation”, which contains no files apart from its own metadata.

     After having rolled back, installing, removing, or upgrading
     packages overwrites previous future generations.  Thus, the history
     of the generations in a profile is always linear.

‘--switch-generation=PATTERN’
‘-S PATTERN’
     Switch to a particular generation defined by PATTERN.

     PATTERN may be either a generation number or a number prefixed with
     “+” or “-”.  The latter means: move forward/backward by a specified
     number of generations.  For example, if you want to return to the
     latest generation after ‘--roll-back’, use
     ‘--switch-generation=+1’.

     The difference between ‘--roll-back’ and ‘--switch-generation=-1’
     is that ‘--switch-generation’ will not make a zeroth generation, so
     if a specified generation does not exist, the current generation
     will not be changed.

‘--search-paths[=KIND]’
     Report environment variable definitions, in Bash syntax, that may
     be needed in order to use the set of installed packages.  These
     environment variables are used to specify “search paths” for files
     used by some of the installed packages.

     For example, GCC needs the ‘CPATH’ and ‘LIBRARY_PATH’ environment
     variables to be defined so it can look for headers and libraries in
     the user’s profile (*note (gcc)Environment Variables::).  If GCC
     and, say, the C library are installed in the profile, then
     ‘--search-paths’ will suggest setting these variables to
     ‘PROFILE/include’ and ‘PROFILE/lib’, respectively.

     The typical use case is to define these environment variables in
     the shell:

          $ eval `guix package --search-paths`

     KIND may be one of ‘exact’, ‘prefix’, or ‘suffix’, meaning that the
     returned environment variable definitions will either be exact
     settings, or prefixes or suffixes of the current value of these
     variables.  When omitted, KIND defaults to ‘exact’.

     This option can also be used to compute the _combined_ search paths
     of several profiles.  Consider this example:

          $ guix package -p foo -i guile
          $ guix package -p bar -i guile-json
          $ guix package -p foo -p bar --search-paths

     The last command above reports about the ‘GUILE_LOAD_PATH’
     variable, even though, taken individually, neither ‘foo’ nor ‘bar’
     would lead to that recommendation.

‘--profile=PROFILE’
‘-p PROFILE’
     Use PROFILE instead of the user’s default profile.

     PROFILE must be the name of a file that will be created upon
     completion.  Concretely, PROFILE will be a mere symbolic link
     (“symlink”) pointing to the actual profile where packages are
     installed:

          $ guix install hello -p ~/code/my-profile
          ...
          $ ~/code/my-profile/bin/hello
          Hello, world!

     All it takes to get rid of the profile is to remove this symlink
     and its siblings that point to specific generations:

          $ rm ~/code/my-profile ~/code/my-profile-*-link

‘--list-profiles’
     List all the user’s profiles:

          $ guix package --list-profiles
          /home/charlie/.guix-profile
          /home/charlie/code/my-profile
          /home/charlie/code/devel-profile
          /home/charlie/tmp/test

     When running as root, list all the profiles of all the users.

‘--allow-collisions’
     Allow colliding packages in the new profile.  Use at your own risk!

     By default, ‘guix package’ reports as an error “collisions” in the
     profile.  Collisions happen when two or more different versions or
     variants of a given package end up in the profile.

‘--bootstrap’
     Use the bootstrap Guile to build the profile.  This option is only
     useful to distribution developers.

   In addition to these actions, ‘guix package’ supports the following
options to query the current state of a profile, or the availability of
packages:

‘--search=REGEXP’
‘-s REGEXP’
     List the available packages whose name, synopsis, or description
     matches REGEXP (in a case-insensitive fashion), sorted by
     relevance.  Print all the metadata of matching packages in
     ‘recutils’ format (*note GNU recutils databases: (recutils)Top.).

     This allows specific fields to be extracted using the ‘recsel’
     command, for instance:

          $ guix package -s malloc | recsel -p name,version,relevance
          name: jemalloc
          version: 4.5.0
          relevance: 6

          name: glibc
          version: 2.25
          relevance: 1

          name: libgc
          version: 7.6.0
          relevance: 1

     Similarly, to show the name of all the packages available under the
     terms of the GNU LGPL version 3:

          $ guix package -s "" | recsel -p name -e 'license ~ "LGPL 3"'
          name: elfutils

          name: gmp
          ...

     It is also possible to refine search results using several ‘-s’
     flags to ‘guix package’, or several arguments to ‘guix search’.
     For example, the following command returns a list of board games
     (this time using the ‘guix search’ alias):

          $ guix search '\<board\>' game | recsel -p name
          name: gnubg
          ...

     If we were to omit ‘-s game’, we would also get software packages
     that deal with printed circuit boards; removing the angle brackets
     around ‘board’ would further add packages that have to do with
     keyboards.

     And now for a more elaborate example.  The following command
     searches for cryptographic libraries, filters out Haskell, Perl,
     Python, and Ruby libraries, and prints the name and synopsis of the
     matching packages:

          $ guix search crypto library | \
              recsel -e '! (name ~ "^(ghc|perl|python|ruby)")' -p name,synopsis

     *Note (recutils)Selection Expressions::, for more information on
     “selection expressions” for ‘recsel -e’.

‘--show=PACKAGE’
     Show details about PACKAGE, taken from the list of available
     packages, in ‘recutils’ format (*note GNU recutils databases:
     (recutils)Top.).

          $ guix package --show=python | recsel -p name,version
          name: python
          version: 2.7.6

          name: python
          version: 3.3.5

     You may also specify the full name of a package to only get details
     about a specific version of it (this time using the ‘guix show’
     alias):
          $ guix show python@3.4 | recsel -p name,version
          name: python
          version: 3.4.3

‘--list-installed[=REGEXP]’
‘-I [REGEXP]’
     List the currently installed packages in the specified profile,
     with the most recently installed packages shown last.  When REGEXP
     is specified, list only installed packages whose name matches
     REGEXP.

     For each installed package, print the following items, separated by
     tabs: the package name, its version string, the part of the package
     that is installed (for instance, ‘out’ for the default output,
     ‘include’ for its headers, etc.), and the path of this package in
     the store.

‘--list-available[=REGEXP]’
‘-A [REGEXP]’
     List packages currently available in the distribution for this
     system (*note GNU发行版::).  When REGEXP is specified, list only
     available packages whose name matches REGEXP.

     For each package, print the following items separated by tabs: its
     name, its version string, the parts of the package (*note
     有多个输出的软件包::), and the source location of its definition.

‘--list-generations[=PATTERN]’
‘-l [PATTERN]’
     Return a list of generations along with their creation dates; for
     each generation, show the installed packages, with the most
     recently installed packages shown last.  Note that the zeroth
     generation is never shown.

     For each installed package, print the following items, separated by
     tabs: the name of a package, its version string, the part of the
     package that is installed (*note 有多个输出的软件包::), and the
     location of this package in the store.

     When PATTERN is used, the command returns only matching
     generations.  Valid patterns include:

        • _Integers and comma-separated integers_.  Both patterns denote
          generation numbers.  For instance, ‘--list-generations=1’
          returns the first one.

          And ‘--list-generations=1,8,2’ outputs three generations in
          the specified order.  Neither spaces nor trailing commas are
          allowed.

        • _Ranges_.  ‘--list-generations=2..9’ prints the specified
          generations and everything in between.  Note that the start of
          a range must be smaller than its end.

          It is also possible to omit the endpoint.  For example,
          ‘--list-generations=2..’, returns all generations starting
          from the second one.

        • _Durations_.  You can also get the last _N_ days, weeks, or
          months by passing an integer along with the first letter of
          the duration.  For example, ‘--list-generations=20d’ lists
          generations that are up to 20 days old.

‘--delete-generations[=PATTERN]’
‘-d [PATTERN]’
     When PATTERN is omitted, delete all generations except the current
     one.

     This command accepts the same patterns as ‘--list-generations’.
     When PATTERN is specified, delete the matching generations.  When
     PATTERN specifies a duration, generations _older_ than the
     specified duration match.  For instance, ‘--delete-generations=1m’
     deletes generations that are more than one month old.

     If the current generation matches, it is _not_ deleted.  Also, the
     zeroth generation is never deleted.

     Note that deleting generations prevents rolling back to them.
     Consequently, this command must be used with care.

   Finally, since ‘guix package’ may actually start build processes, it
supports all the common build options (*note 普通的构建选项::).  It also
supports package transformation options, such as ‘--with-source’ (*note
软件包变换选项。::).  However, note that package transformations are
lost when upgrading; to preserve transformations across upgrades, you
should define your own package variant in a Guile module and add it to
‘GUIX_PACKAGE_PATH’ (*note 定义软件包::).


File: guix.zh_CN.info,  Node: Substitutes,  Next: 有多个输出的软件包,  Prev: 调用guix package,  Up: 软件包管理

4.3 Substitutes
===============

Guix supports transparent source/binary deployment, which means that it
can either build things locally, or download pre-built items from a
server, or both.  We call these pre-built items “substitutes”—they are
substitutes for local build results.  In many cases, downloading a
substitute is much faster than building things locally.

   Substitutes can be anything resulting from a derivation build (*note
Derivations::).  Of course, in the common case, they are pre-built
package binaries, but source tarballs, for instance, which also result
from derivation builds, can be available as substitutes.

* Menu:

* 官方的substitute服务器::  substitute的一个特殊来源。
* 授权substitute服务器。::  怎么开启或关闭substitute。
* 验证substitute::         Guix怎样验证substitute。
* 代理设置::             怎样通过代理获取substitute。
* substitute失败::         当substitute失败时会发生什么。
* 关于信任二进制文件::  你怎么信任二进制块。


File: guix.zh_CN.info,  Node: 官方的substitute服务器,  Next: 授权substitute服务器。,  Up: Substitutes

4.3.1 官方的substitute服务器
----------------------------

The ‘ci.guix.gnu.org’ server is a front-end to an official build farm
that builds packages from Guix continuously for some architectures, and
makes them available as substitutes.  This is the default source of
substitutes; it can be overridden by passing the ‘--substitute-urls’
option either to ‘guix-daemon’ (*note ‘guix-daemon --substitute-urls’:
daemon-substitute-urls.) or to client tools such as ‘guix package’
(*note client ‘--substitute-urls’ option: client-substitute-urls.).

   Substitute URLs can be either HTTP or HTTPS. HTTPS is recommended
because communications are encrypted; conversely, using HTTP makes all
communications visible to an eavesdropper, who could use the information
gathered to determine, for instance, whether your system has unpatched
security vulnerabilities.

   Substitutes from the official build farm are enabled by default when
using Guix System (*note GNU发行版::).  However, they are disabled by
default when using Guix on a foreign distribution, unless you have
explicitly enabled them via one of the recommended installation steps
(*note 安装::).  The following paragraphs describe how to enable or
disable substitutes for the official build farm; the same procedure can
also be used to enable substitutes for any other substitute server.


File: guix.zh_CN.info,  Node: 授权substitute服务器。,  Next: 验证substitute,  Prev: 官方的substitute服务器,  Up: Substitutes

4.3.2 授权substitute服务器。
----------------------------

To allow Guix to download substitutes from ‘ci.guix.gnu.org’ or a mirror
thereof, you must add its public key to the access control list (ACL) of
archive imports, using the ‘guix archive’ command (*note 调用guix
archive::).  Doing so implies that you trust ‘ci.guix.gnu.org’ to not be
compromised and to serve genuine substitutes.

   The public key for ‘ci.guix.gnu.org’ is installed along with Guix, in
‘PREFIX/share/guix/ci.guix.gnu.org.pub’, where PREFIX is the
installation prefix of Guix.  If you installed Guix from source, make
sure you checked the GPG signature of ‘guix-1.0.1.17089-7e269.tar.gz’,
which contains this public key file.  Then, you can run something like
this:

     # guix archive --authorize < PREFIX/share/guix/ci.guix.gnu.org.pub

   Once this is in place, the output of a command like ‘guix build’
should change from something like:

     $ guix build emacs --dry-run
     The following derivations would be built:
        /gnu/store/yr7bnx8xwcayd6j95r2clmkdl1qh688w-emacs-24.3.drv
        /gnu/store/x8qsh1hlhgjx6cwsjyvybnfv2i37z23w-dbus-1.6.4.tar.gz.drv
        /gnu/store/1ixwp12fl950d15h2cj11c73733jay0z-alsa-lib-1.0.27.1.tar.bz2.drv
        /gnu/store/nlma1pw0p603fpfiqy7kn4zm105r5dmw-util-linux-2.21.drv
     ...

to something like:

     $ guix build emacs --dry-run
     112.3 MB would be downloaded:
        /gnu/store/pk3n22lbq6ydamyymqkkz7i69wiwjiwi-emacs-24.3
        /gnu/store/2ygn4ncnhrpr61rssa6z0d9x22si0va3-libjpeg-8d
        /gnu/store/71yz6lgx4dazma9dwn2mcjxaah9w77jq-cairo-1.12.16
        /gnu/store/7zdhgp0n1518lvfn8mb96sxqfmvqrl7v-libxrender-0.9.7
     ...

The text changed from “The following derivations would be built” to
“112.3 MB would be downloaded”.  This indicates that substitutes from
‘ci.guix.gnu.org’ are usable and will be downloaded, when possible, for
future builds.

   The substitute mechanism can be disabled globally by running
‘guix-daemon’ with ‘--no-substitutes’ (*note 调用guix-daemon::).  It can
also be disabled temporarily by passing the ‘--no-substitutes’ option to
‘guix package’, ‘guix build’, and other command-line tools.


File: guix.zh_CN.info,  Node: 验证substitute,  Next: 代理设置,  Prev: 授权substitute服务器。,  Up: Substitutes

4.3.3 验证substitute
--------------------

Guix detects and raises an error when attempting to use a substitute
that has been tampered with.  Likewise, it ignores substitutes that are
not signed, or that are not signed by one of the keys listed in the ACL.

   There is one exception though: if an unauthorized server provides
substitutes that are _bit-for-bit identical_ to those provided by an
authorized server, then the unauthorized server becomes eligible for
downloads.  For example, assume we have chosen two substitute servers
with this option:

     --substitute-urls="https://a.example.org https://b.example.org"

If the ACL contains only the key for ‘b.example.org’, and if
‘a.example.org’ happens to serve the _exact same_ substitutes, then Guix
will download substitutes from ‘a.example.org’ because it comes first in
the list and can be considered a mirror of ‘b.example.org’.  In
practice, independent build machines usually produce the same binaries,
thanks to bit-reproducible builds (see below).

   When using HTTPS, the server’s X.509 certificate is _not_ validated
(in other words, the server is not authenticated), contrary to what
HTTPS clients such as Web browsers usually do.  This is because Guix
authenticates substitute information itself, as explained above, which
is what we care about (whereas X.509 certificates are about
authenticating bindings between domain names and public keys).


File: guix.zh_CN.info,  Node: 代理设置,  Next: substitute失败,  Prev: 验证substitute,  Up: Substitutes

4.3.4 代理设置
--------------

Substitutes are downloaded over HTTP or HTTPS. The ‘http_proxy’ and
‘https_proxy’ environment variables can be set in the environment of
‘guix-daemon’ and are honored for downloads of substitutes.  Note that
the value of those environment variables in the environment where ‘guix
build’, ‘guix package’, and other client commands are run has
_absolutely no effect_.


File: guix.zh_CN.info,  Node: substitute失败,  Next: 关于信任二进制文件,  Prev: 代理设置,  Up: Substitutes

4.3.5 substitute失败
--------------------

Even when a substitute for a derivation is available, sometimes the
substitution attempt will fail.  This can happen for a variety of
reasons: the substitute server might be offline, the substitute may
recently have been deleted, the connection might have been interrupted,
etc.

   When substitutes are enabled and a substitute for a derivation is
available, but the substitution attempt fails, Guix will attempt to
build the derivation locally depending on whether or not ‘--fallback’
was given (*note common build option ‘--fallback’: fallback-option.).
Specifically, if ‘--fallback’ was omitted, then no local build will be
performed, and the derivation is considered to have failed.  However, if
‘--fallback’ was given, then Guix will attempt to build the derivation
locally, and the success or failure of the derivation depends on the
success or failure of the local build.  Note that when substitutes are
disabled or no substitute is available for the derivation in question, a
local build will _always_ be performed, regardless of whether or not
‘--fallback’ was given.

   To get an idea of how many substitutes are available right now, you
can try running the ‘guix weather’ command (*note 调用guix weather::).
This command provides statistics on the substitutes provided by a
server.


File: guix.zh_CN.info,  Node: 关于信任二进制文件,  Prev: substitute失败,  Up: Substitutes

4.3.6 关于信任二进制文件
------------------------

Today, each individual’s control over their own computing is at the
mercy of institutions, corporations, and groups with enough power and
determination to subvert the computing infrastructure and exploit its
weaknesses.  While using ‘ci.guix.gnu.org’ substitutes can be
convenient, we encourage users to also build on their own, or even run
their own build farm, such that ‘ci.guix.gnu.org’ is less of an
interesting target.  One way to help is by publishing the software you
build using ‘guix publish’ so that others have one more choice of server
to download substitutes from (*note 调用guix publish::).

   Guix has the foundations to maximize build reproducibility (*note
功能::).  In most cases, independent builds of a given package or
derivation should yield bit-identical results.  Thus, through a diverse
set of independent package builds, we can strengthen the integrity of
our systems.  The ‘guix challenge’ command aims to help users assess
substitute servers, and to assist developers in finding out about
non-deterministic package builds (*note 调用guix challenge::).
Similarly, the ‘--check’ option of ‘guix build’ allows users to check
whether previously-installed substitutes are genuine by rebuilding them
locally (*note ‘guix build --check’: build-check.).

   In the future, we want Guix to have support to publish and retrieve
binaries to/from other users, in a peer-to-peer fashion.  If you would
like to discuss this project, join us on <guix-devel@gnu.org>.


File: guix.zh_CN.info,  Node: 有多个输出的软件包,  Next: 调用guix gc,  Prev: Substitutes,  Up: 软件包管理

4.4 有多个输出的软件包
======================

Often, packages defined in Guix have a single “output”—i.e., the source
package leads to exactly one directory in the store.  When running ‘guix
install glibc’, one installs the default output of the GNU libc package;
the default output is called ‘out’, but its name can be omitted as shown
in this command.  In this particular case, the default output of ‘glibc’
contains all the C header files, shared libraries, static libraries,
Info documentation, and other supporting files.

   Sometimes it is more appropriate to separate the various types of
files produced from a single source package into separate outputs.  For
instance, the GLib C library (used by GTK+ and related packages)
installs more than 20 MiB of reference documentation as HTML pages.  To
save space for users who do not need it, the documentation goes to a
separate output, called ‘doc’.  To install the main GLib output, which
contains everything but the documentation, one would run:

     guix install glib

   The command to install its documentation is:

     guix install glib:doc

   Some packages install programs with different “dependency
footprints”.  For instance, the WordNet package installs both
command-line tools and graphical user interfaces (GUIs).  The former
depend solely on the C library, whereas the latter depend on Tcl/Tk and
the underlying X libraries.  In this case, we leave the command-line
tools in the default output, whereas the GUIs are in a separate output.
This allows users who do not need the GUIs to save space.  The ‘guix
size’ command can help find out about such situations (*note 调用guix
size::).  ‘guix graph’ can also be helpful (*note 调用guix graph::).

   There are several such multiple-output packages in the GNU
distribution.  Other conventional output names include ‘lib’ for
libraries and possibly header files, ‘bin’ for stand-alone programs, and
‘debug’ for debugging information (*note 安装调试文件::).  The outputs
of a packages are listed in the third column of the output of ‘guix
package --list-available’ (*note 调用guix package::).


File: guix.zh_CN.info,  Node: 调用guix gc,  Next: 调用guix pull,  Prev: 有多个输出的软件包,  Up: 软件包管理

4.5 Invoking ‘guix gc’
======================

Packages that are installed, but not used, may be “garbage-collected”.
The ‘guix gc’ command allows users to explicitly run the garbage
collector to reclaim space from the ‘/gnu/store’ directory.  It is the
_only_ way to remove files from ‘/gnu/store’—removing files or
directories manually may break it beyond repair!

   The garbage collector has a set of known “roots”: any file under
‘/gnu/store’ reachable from a root is considered “live” and cannot be
deleted; any other file is considered “dead” and may be deleted.  The
set of garbage collector roots (“GC roots” for short) includes default
user profiles; by default, the symlinks under ‘/var/guix/gcroots’
represent these GC roots.  New GC roots can be added with ‘guix build
--root’, for example (*note 调用guix build::).  The ‘guix gc
--list-roots’ command lists them.

   Prior to running ‘guix gc --collect-garbage’ to make space, it is
often useful to remove old generations from user profiles; that way, old
package builds referenced by those generations can be reclaimed.  This
is achieved by running ‘guix package --delete-generations’ (*note
调用guix package::).

   Our recommendation is to run a garbage collection periodically, or
when you are short on disk space.  For instance, to guarantee that at
least 5 GB are available on your disk, simply run:

     guix gc -F 5G

   It is perfectly safe to run as a non-interactive periodic job (*note
执行计划任务::, for how to set up such a job).  Running ‘guix gc’ with
no arguments will collect as much garbage as it can, but that is often
inconvenient: you may find yourself having to rebuild or re-download
software that is “dead” from the GC viewpoint but that is necessary to
build other pieces of software—e.g., the compiler tool chain.

   The ‘guix gc’ command has three modes of operation: it can be used to
garbage-collect any dead files (the default), to delete specific files
(the ‘--delete’ option), to print garbage-collector information, or for
more advanced queries.  The garbage collection options are as follows:

‘--collect-garbage[=MIN]’
‘-C [MIN]’
     Collect garbage—i.e., unreachable ‘/gnu/store’ files and
     sub-directories.  This is the default operation when no option is
     specified.

     When MIN is given, stop once MIN bytes have been collected.  MIN
     may be a number of bytes, or it may include a unit as a suffix,
     such as ‘MiB’ for mebibytes and ‘GB’ for gigabytes (*note size
     specifications: (coreutils)Block size.).

     When MIN is omitted, collect all the garbage.

‘--free-space=FREE’
‘-F FREE’
     Collect garbage until FREE space is available under ‘/gnu/store’,
     if possible; FREE denotes storage space, such as ‘500MiB’, as
     described above.

     When FREE or more is already available in ‘/gnu/store’, do nothing
     and exit immediately.

‘--delete-generations[=DURATION]’
‘-d [DURATION]’
     Before starting the garbage collection process, delete all the
     generations older than DURATION, for all the user profiles; when
     run as root, this applies to all the profiles _of all the users_.

     For example, this command deletes all the generations of all your
     profiles that are older than 2 months (except generations that are
     current), and then proceeds to free space until at least 10 GiB are
     available:

          guix gc -d 2m -F 10G

‘--delete’
‘-D’
     Attempt to delete all the store files and directories specified as
     arguments.  This fails if some of the files are not in the store,
     or if they are still live.

‘--list-failures’
     List store items corresponding to cached build failures.

     This prints nothing unless the daemon was started with
     ‘--cache-failures’ (*note ‘--cache-failures’: 调用guix-daemon.).

‘--list-roots’
     List the GC roots owned by the user; when run as root, list _all_
     the GC roots.

‘--list-busy’
     List store items in use by currently running processes.  These
     store items are effectively considered GC roots: they cannot be
     deleted.

‘--clear-failures’
     Remove the specified store items from the failed-build cache.

     Again, this option only makes sense when the daemon is started with
     ‘--cache-failures’.  Otherwise, it does nothing.

‘--list-dead’
     Show the list of dead files and directories still present in the
     store—i.e., files and directories no longer reachable from any
     root.

‘--list-live’
     Show the list of live store files and directories.

   In addition, the references among existing store files can be
queried:

‘--references’
‘--referrers’
     List the references (respectively, the referrers) of store files
     given as arguments.

‘--requisites’
‘-R’
     List the requisites of the store files passed as arguments.
     Requisites include the store files themselves, their references,
     and the references of these, recursively.  In other words, the
     returned list is the “transitive closure” of the store files.

     *Note 调用guix size::, for a tool to profile the size of the
     closure of an element.  *Note 调用guix graph::, for a tool to
     visualize the graph of references.

‘--derivers’
     Return the derivation(s) leading to the given store items (*note
     Derivations::).

     For example, this command:

          guix gc --derivers `guix package -I ^emacs$ | cut -f4`

     returns the ‘.drv’ file(s) leading to the ‘emacs’ package installed
     in your profile.

     Note that there may be zero matching ‘.drv’ files, for instance
     because these files have been garbage-collected.  There can also be
     more than one matching ‘.drv’ due to fixed-output derivations.

   Lastly, the following options allow you to check the integrity of the
store and to control disk usage.

‘--verify[=OPTIONS]’
     Verify the integrity of the store.

     By default, make sure that all the store items marked as valid in
     the database of the daemon actually exist in ‘/gnu/store’.

     When provided, OPTIONS must be a comma-separated list containing
     one or more of ‘contents’ and ‘repair’.

     When passing ‘--verify=contents’, the daemon computes the content
     hash of each store item and compares it against its hash in the
     database.  Hash mismatches are reported as data corruptions.
     Because it traverses _all the files in the store_, this command can
     take a long time, especially on systems with a slow disk drive.

     Using ‘--verify=repair’ or ‘--verify=contents,repair’ causes the
     daemon to try to repair corrupt store items by fetching substitutes
     for them (*note Substitutes::).  Because repairing is not atomic,
     and thus potentially dangerous, it is available only to the system
     administrator.  A lightweight alternative, when you know exactly
     which items in the store are corrupt, is ‘guix build --repair’
     (*note 调用guix build::).

‘--optimize’
     Optimize the store by hard-linking identical files—this is
     “deduplication”.

     The daemon performs deduplication after each successful build or
     archive import, unless it was started with
     ‘--disable-deduplication’ (*note ‘--disable-deduplication’:
     调用guix-daemon.).  Thus, this option is primarily useful when the
     daemon was running with ‘--disable-deduplication’.


File: guix.zh_CN.info,  Node: 调用guix pull,  Next: 通道,  Prev: 调用guix gc,  Up: 软件包管理

4.6 Invoking ‘guix pull’
========================

Packages are installed or upgraded to the latest version available in
the distribution currently available on your local machine.  To update
that distribution, along with the Guix tools, you must run ‘guix pull’:
the command downloads the latest Guix source code and package
descriptions, and deploys it.  Source code is downloaded from a Git
(https://git-scm.com) repository, by default the official GNU Guix
repository, though this can be customized.

   Specifically, ‘guix pull’ downloads code from the “channels” (*note
通道::) specified by one of the followings, in this order:

  1. the ‘--channels’ option;
  2. the user’s ‘~/.config/guix/channels.scm’ file;
  3. the system-wide ‘/etc/guix/channels.scm’ file;
  4. the built-in default channels specified in the ‘%default-channels’
     variable.

   On completion, ‘guix package’ will use packages and package versions
from this just-retrieved copy of Guix.  Not only that, but all the Guix
commands and Scheme modules will also be taken from that latest version.
New ‘guix’ sub-commands added by the update also become available.

   Any user can update their Guix copy using ‘guix pull’, and the effect
is limited to the user who ran ‘guix pull’.  For instance, when user
‘root’ runs ‘guix pull’, this has no effect on the version of Guix that
user ‘alice’ sees, and vice versa.

   The result of running ‘guix pull’ is a “profile” available under
‘~/.config/guix/current’ containing the latest Guix.  Thus, make sure to
add it to the beginning of your search path so that you use the latest
version, and similarly for the Info manual (*note 文档::):

     export PATH="$HOME/.config/guix/current/bin:$PATH"
     export INFOPATH="$HOME/.config/guix/current/share/info:$INFOPATH"

   The ‘--list-generations’ or ‘-l’ option lists past generations
produced by ‘guix pull’, along with details about their provenance:

     $ guix pull -l
     Generation 1	Jun 10 2018 00:18:18
       guix 65956ad
         repository URL: https://git.savannah.gnu.org/git/guix.git
         branch: origin/master
         commit: 65956ad3526ba09e1f7a40722c96c6ef7c0936fe

     Generation 2	Jun 11 2018 11:02:49
       guix e0cc7f6
         repository URL: https://git.savannah.gnu.org/git/guix.git
         branch: origin/master
         commit: e0cc7f669bec22c37481dd03a7941c7d11a64f1d
       2 new packages: keepalived, libnfnetlink
       6 packages upgraded: emacs-nix-mode@2.0.4,
         guile2.0-guix@0.14.0-12.77a1aac, guix@0.14.0-12.77a1aac,
         heimdal@7.5.0, milkytracker@1.02.00, nix@2.0.4

     Generation 3	Jun 13 2018 23:31:07	(current)
       guix 844cc1c
         repository URL: https://git.savannah.gnu.org/git/guix.git
         branch: origin/master
         commit: 844cc1c8f394f03b404c5bb3aee086922373490c
       28 new packages: emacs-helm-ls-git, emacs-helm-mu, ...
       69 packages upgraded: borg@1.1.6, cheese@3.28.0, ...

   *Note ‘guix describe’: 调用guix describe, for other ways to describe
the current status of Guix.

   This ‘~/.config/guix/current’ profile works exactly like the profiles
created by ‘guix package’ (*note 调用guix package::).  That is, you can
list generations, roll back to the previous generation—i.e., the
previous Guix—and so on:

     $ guix pull --roll-back
     switched from generation 3 to 2
     $ guix pull --delete-generations=1
     deleting /var/guix/profiles/per-user/charlie/current-guix-1-link

   You can also use ‘guix package’ (*note 调用guix package::) to manage
the profile by naming it explicitly:
     $ guix package -p ~/.config/guix/current --roll-back
     switched from generation 3 to 2
     $ guix package -p ~/.config/guix/current --delete-generations=1
     deleting /var/guix/profiles/per-user/charlie/current-guix-1-link

   The ‘guix pull’ command is usually invoked with no arguments, but it
supports the following options:

‘--url=URL’
‘--commit=COMMIT’
‘--branch=BRANCH’
     Download code for the ‘guix’ channel from the specified URL, at the
     given COMMIT (a valid Git commit ID represented as a hexadecimal
     string), or BRANCH.

     These options are provided for convenience, but you can also
     specify your configuration in the ‘~/.config/guix/channels.scm’
     file or using the ‘--channels’ option (see below).

‘--channels=FILE’
‘-C FILE’
     Read the list of channels from FILE instead of
     ‘~/.config/guix/channels.scm’ or ‘/etc/guix/channels.scm’.  FILE
     must contain Scheme code that evaluates to a list of channel
     objects.  *Note 通道::, for more information.

‘--news’
‘-N’
     Display the list of packages added or upgraded since the previous
     generation, as well as, occasionally, news written by channel
     authors for their users (*note Writing Channel News: 通道.).

     The package information is the same as displayed upon ‘guix pull’
     completion, but without ellipses; it is also similar to the output
     of ‘guix pull -l’ for the last generation (see below).

‘--list-generations[=PATTERN]’
‘-l [PATTERN]’
     List all the generations of ‘~/.config/guix/current’ or, if PATTERN
     is provided, the subset of generations that match PATTERN.  The
     syntax of PATTERN is the same as with ‘guix package
     --list-generations’ (*note 调用guix package::).

‘--roll-back’
     Roll back to the previous “generation” of
     ‘~/.config/guix/current’—i.e., undo the last transaction.

‘--switch-generation=PATTERN’
‘-S PATTERN’
     Switch to a particular generation defined by PATTERN.

     PATTERN may be either a generation number or a number prefixed with
     “+” or “-”.  The latter means: move forward/backward by a specified
     number of generations.  For example, if you want to return to the
     latest generation after ‘--roll-back’, use
     ‘--switch-generation=+1’.

‘--delete-generations[=PATTERN]’
‘-d [PATTERN]’
     When PATTERN is omitted, delete all generations except the current
     one.

     This command accepts the same patterns as ‘--list-generations’.
     When PATTERN is specified, delete the matching generations.  When
     PATTERN specifies a duration, generations _older_ than the
     specified duration match.  For instance, ‘--delete-generations=1m’
     deletes generations that are more than one month old.

     If the current generation matches, it is _not_ deleted.

     Note that deleting generations prevents rolling back to them.
     Consequently, this command must be used with care.

     *Note 调用guix describe::, for a way to display information about
     the current generation only.

‘--profile=PROFILE’
‘-p PROFILE’
     Use PROFILE instead of ‘~/.config/guix/current’.

‘--dry-run’
‘-n’
     Show which channel commit(s) would be used and what would be built
     or substituted but do not actually do it.

‘--allow-downgrades’
     Allow pulling older or unrelated revisions of channels than those
     currently in use.

     By default, ‘guix pull’ protects against so-called “downgrade
     attacks” whereby the Git repository of a channel would be reset to
     an earlier or unrelated revision of itself, potentially leading you
     to install older, known-vulnerable versions of software packages.

          注: Make sure you understand its security implications before
          using ‘--allow-downgrades’.

‘--system=SYSTEM’
‘-s SYSTEM’
     Attempt to build for SYSTEM—e.g., ‘i686-linux’—instead of the
     system type of the build host.

‘--verbose’
     Produce verbose output, writing build logs to the standard error
     output.

‘--bootstrap’
     Use the bootstrap Guile to build the latest Guix.  This option is
     only useful to Guix developers.

   The “channel” mechanism allows you to instruct ‘guix pull’ which
repository and branch to pull from, as well as _additional_ repositories
containing package modules that should be deployed.  *Note 通道::, for
more information.

   In addition, ‘guix pull’ supports all the common build options (*note
普通的构建选项::).


File: guix.zh_CN.info,  Node: 通道,  Next: Invoking guix time-machine,  Prev: 调用guix pull,  Up: 软件包管理

4.7 通道
========

Guix and its package collection are updated by running ‘guix pull’
(*note 调用guix pull::).  By default ‘guix pull’ downloads and deploys
Guix itself from the official GNU Guix repository.  This can be
customized by defining “channels” in the ‘~/.config/guix/channels.scm’
file.  A channel specifies a URL and branch of a Git repository to be
deployed, and ‘guix pull’ can be instructed to pull from one or more
channels.  In other words, channels can be used to _customize_ and to
_extend_ Guix, as we will see below.

4.7.1 Using a Custom Guix Channel
---------------------------------

The channel called ‘guix’ specifies where Guix itself—its command-line
tools as well as its package collection—should be downloaded.  For
instance, suppose you want to update from your own copy of the Guix
repository at ‘example.org’, and specifically the ‘super-hacks’ branch,
you can write in ‘~/.config/guix/channels.scm’ this specification:

     ;; Tell 'guix pull' to use my own repo.
     (list (channel
             (name 'guix)
             (url "https://example.org/my-guix.git")
             (branch "super-hacks")))

From there on, ‘guix pull’ will fetch code from the ‘super-hacks’ branch
of the repository at ‘example.org’.

4.7.2 Specifying Additional Channels
------------------------------------

You can also specify _additional channels_ to pull from.  Let’s say you
have a bunch of custom package variants or personal packages that you
think would make little sense to contribute to the Guix project, but
would like to have these packages transparently available to you at the
command line.  You would first write modules containing those package
definitions (*note 软件包模块::), maintain them in a Git repository, and
then you and anyone else can use it as an additional channel to get
packages from.  Neat, no?

     Warning: Before you, dear user, shout—“woow this is _soooo
     coool_!”—and publish your personal channel to the world, we would
     like to share a few words of caution:

        • Before publishing a channel, please consider contributing your
          package definitions to Guix proper (*note 贡献::).  Guix as a
          project is open to free software of all sorts, and packages in
          Guix proper are readily available to all Guix users and
          benefit from the project’s quality assurance process.

        • When you maintain package definitions outside Guix, we, Guix
          developers, consider that _the compatibility burden is on
          you_.  Remember that package modules and package definitions
          are just Scheme code that uses various programming interfaces
          (APIs).  We want to remain free to change these APIs to keep
          improving Guix, possibly in ways that break your channel.  We
          never change APIs gratuitously, but we will _not_ commit to
          freezing APIs either.

        • Corollary: if you’re using an external channel and that
          channel breaks, please _report the issue to the channel
          authors_, not to the Guix project.

     You’ve been warned!  Having said this, we believe external channels
     are a practical way to exert your freedom to augment Guix’ package
     collection and to share your improvements, which are basic tenets
     of free software (https://www.gnu.org/philosophy/free-sw.html).
     Please email us at <guix-devel@gnu.org> if you’d like to discuss
     this.

   To use a channel, write ‘~/.config/guix/channels.scm’ to instruct
‘guix pull’ to pull from it _in addition_ to the default Guix
channel(s):

     ;; Add my personal packages to those Guix provides.
     (cons (channel
             (name 'my-personal-packages)
             (url "https://example.org/personal-packages.git"))
           %default-channels)

Note that the snippet above is (as always!) Scheme code; we use ‘cons’
to add a channel the list of channels that the variable
‘%default-channels’ is bound to (*note ‘cons’ and lists: (guile)Pairs.).
With this file in place, ‘guix pull’ builds not only Guix but also the
package modules from your own repository.  The result in
‘~/.config/guix/current’ is the union of Guix with your own package
modules:

     $ guix pull --list-generations
     ...
     Generation 19	Aug 27 2018 16:20:48
       guix d894ab8
         repository URL: https://git.savannah.gnu.org/git/guix.git
         branch: master
         commit: d894ab8e9bfabcefa6c49d9ba2e834dd5a73a300
       my-personal-packages dd3df5e
         repository URL: https://example.org/personal-packages.git
         branch: master
         commit: dd3df5e2c8818760a8fc0bd699e55d3b69fef2bb
       11 new packages: my-gimp, my-emacs-with-cool-features, ...
       4 packages upgraded: emacs-racket-mode@0.0.2-2.1b78827, ...

The output of ‘guix pull’ above shows that Generation 19 includes both
Guix and packages from the ‘my-personal-packages’ channel.  Among the
new and upgraded packages that are listed, some like ‘my-gimp’ and
‘my-emacs-with-cool-features’ might come from ‘my-personal-packages’,
while others come from the Guix default channel.

   To create a channel, create a Git repository containing your own
package modules and make it available.  The repository can contain
anything, but a useful channel will contain Guile modules that export
packages.  Once you start using a channel, Guix will behave as if the
root directory of that channel’s Git repository has been added to the
Guile load path (*note (guile)Load Paths::).  For example, if your
channel contains a file at ‘my-packages/my-tools.scm’ that defines a
Guile module, then the module will be available under the name
‘(my-packages my-tools)’, and you will be able to use it like any other
module (*note (guile)模块::).

4.7.3 Declaring Channel Dependencies
------------------------------------

Channel authors may decide to augment a package collection provided by
other channels.  They can declare their channel to be dependent on other
channels in a meta-data file ‘.guix-channel’, which is to be placed in
the root of the channel repository.

   The meta-data file should contain a simple S-expression like this:

     (channel
      (version 0)
      (dependencies
       (channel
        (name some-collection)
        (url "https://example.org/first-collection.git"))
       (channel
        (name some-other-collection)
        (url "https://example.org/second-collection.git")
        (branch "testing"))))

   In the above example this channel is declared to depend on two other
channels, which will both be fetched automatically.  The modules
provided by the channel will be compiled in an environment where the
modules of all these declared channels are available.

   For the sake of reliability and maintainability, you should avoid
dependencies on channels that you don’t control, and you should aim to
keep the number of dependencies to a minimum.

4.7.4 Package Modules in a Sub-directory
----------------------------------------

As a channel author, you may want to keep your channel modules in a
sub-directory.  If your modules are in the sub-directory ‘guix’, you
must add a meta-data file ‘.guix-channel’ that contains:

     (channel
       (version 0)
       (directory "guix"))

4.7.5 Writing Channel News
--------------------------

Channel authors may occasionally want to communicate to their users
information about important changes in the channel.  You’d send them all
an email, but that’s not convenient.

   Instead, channels can provide a “news file”; when the channel users
run ‘guix pull’, that news file is automatically read and ‘guix pull
--news’ can display the announcements that correspond to the new commits
that have been pulled, if any.

   To do that, channel authors must first declare the name of the news
file in their ‘.guix-channel’ file:

     (channel
       (version 0)
       (news-file "etc/news.txt"))

   The news file itself, ‘etc/news.txt’ in this example, must look
something like this:

     (channel-news
       (version 0)
       (entry (tag "the-bug-fix")
              (title (en "Fixed terrible bug")
                     (fr "Oh la la"))
              (body (en "@emph{Good news}!  It's fixed!")
                    (eo "Certe ĝi pli bone funkcias nun!")))
       (entry (commit "bdcabe815cd28144a2d2b4bc3c5057b051fa9906")
              (title (en "Added a great package")
                     (ca "Què vol dir guix?"))
              (body (en "Don't miss the @code{hello} package!"))))

   The file consists of a list of “news entries”.  Each entry is
associated with a commit or tag: it describes changes made in this
commit, possibly in preceding commits as well.  Users see entries only
the first time they obtain the commit the entry refers to.

   The ‘title’ field should be a one-line summary while ‘body’ can be
arbitrarily long, and both can contain Texinfo markup (*note
(texinfo)Overview::).  Both the title and body are a list of language
tag/message tuples, which allows ‘guix pull’ to display news in the
language that corresponds to the user’s locale.

   If you want to translate news using a gettext-based workflow, you can
extract translatable strings with ‘xgettext’ (*note (gettext)xgettext
Invocation::).  For example, assuming you write news entries in English
first, the command below creates a PO file containing the strings to
translate:

     xgettext -o news.po -l scheme -ken etc/news.scm

   To sum up, yes, you could use your channel as a blog.  But beware,
this is _not quite_ what your users might expect.

4.7.6 Replicating Guix
----------------------

The ‘guix pull --list-generations’ output above shows precisely which
commits were used to build this instance of Guix.  We can thus replicate
it, say, on another machine, by providing a channel specification in
‘~/.config/guix/channels.scm’ that is “pinned” to these commits:

     ;; Deploy specific commits of my channels of interest.
     (list (channel
            (name 'guix)
            (url "https://git.savannah.gnu.org/git/guix.git")
            (commit "d894ab8e9bfabcefa6c49d9ba2e834dd5a73a300"))
           (channel
            (name 'my-personal-packages)
            (url "https://example.org/personal-packages.git")
            (commit "dd3df5e2c8818760a8fc0bd699e55d3b69fef2bb")))

   The ‘guix describe --format=channels’ command can even generate this
list of channels directly (*note 调用guix describe::).  The resulting
file can be used with the -C options of ‘guix pull’ (*note 调用guix
pull::) or ‘guix time-machine’ (*note Invoking guix time-machine::).

   At this point the two machines run the _exact same Guix_, with access
to the _exact same packages_.  The output of ‘guix build gimp’ on one
machine will be exactly the same, bit for bit, as the output of the same
command on the other machine.  It also means both machines have access
to all the source code of Guix and, transitively, to all the source code
of every package it defines.

   This gives you super powers, allowing you to track the provenance of
binary artifacts with very fine grain, and to reproduce software
environments at will—some sort of “meta reproducibility” capabilities,
if you will.  *Note Inferiors::, for another way to take advantage of
these super powers.


File: guix.zh_CN.info,  Node: Invoking guix time-machine,  Next: Inferiors,  Prev: 通道,  Up: 软件包管理

4.8 Invoking ‘guix time-machine’
================================

The ‘guix time-machine’ command provides access to other revisions of
Guix, for example to install older versions of packages, or to reproduce
a computation in an identical environment.  The revision of Guix to be
used is defined by a commit or by a channel description file created by
‘guix describe’ (*note 调用guix describe::).

   The general syntax is:

     guix time-machine OPTIONS... -- COMMAND ARG...

   where COMMAND and ARG... are passed unmodified to the ‘guix’ command
of the specified revision.  The OPTIONS that define this revision are
the same as for ‘guix pull’ (*note 调用guix pull::):

‘--url=URL’
‘--commit=COMMIT’
‘--branch=BRANCH’
     Use the ‘guix’ channel from the specified URL, at the given COMMIT
     (a valid Git commit ID represented as a hexadecimal string), or
     BRANCH.

‘--channels=FILE’
‘-C FILE’
     Read the list of channels from FILE.  FILE must contain Scheme code
     that evaluates to a list of channel objects.  *Note 通道:: for more
     information.

   As for ‘guix pull’, the absence of any options means that the the
latest commit on the master branch will be used.  The command

     guix time-machine -- build hello

   will thus build the package ‘hello’ as defined in the master branch,
which is in general a newer revision of Guix than you have installed.
Time travel works in both directions!

   Note that ‘guix time-machine’ can trigger builds of channels and
their dependencies, and these are controlled by the standard build
options (*note 普通的构建选项::).


File: guix.zh_CN.info,  Node: Inferiors,  Next: 调用guix describe,  Prev: Invoking guix time-machine,  Up: 软件包管理

4.9 Inferiors
=============

     注: The functionality described here is a “technology preview” as
     of version 1.0.1.17089-7e269.  As such, the interface is subject to
     change.

   Sometimes you might need to mix packages from the revision of Guix
you’re currently running with packages available in a different revision
of Guix.  Guix “inferiors” allow you to achieve that by composing
different Guix revisions in arbitrary ways.

   Technically, an “inferior” is essentially a separate Guix process
connected to your main Guix process through a REPL (*note 调用guix
repl::).  The ‘(guix inferior)’ module allows you to create inferiors
and to communicate with them.  It also provides a high-level interface
to browse and manipulate the packages that an inferior
provides—“inferior packages”.

   When combined with channels (*note 通道::), inferiors provide a
simple way to interact with a separate revision of Guix.  For example,
let’s assume you want to install in your profile the current ‘guile’
package, along with the ‘guile-json’ as it existed in an older revision
of Guix—perhaps because the newer ‘guile-json’ has an incompatible API
and you want to run your code against the old API.  To do that, you
could write a manifest for use by ‘guix package --manifest’ (*note
调用guix package::); in that manifest, you would create an inferior for
that old Guix revision you care about, and you would look up the
‘guile-json’ package in the inferior:

     (use-modules (guix inferior) (guix channels)
                  (srfi srfi-1))   ;for 'first'

     (define channels
       ;; This is the old revision from which we want to
       ;; extract guile-json.
       (list (channel
              (name 'guix)
              (url "https://git.savannah.gnu.org/git/guix.git")
              (commit
               "65956ad3526ba09e1f7a40722c96c6ef7c0936fe"))))

     (define inferior
       ;; An inferior representing the above revision.
       (inferior-for-channels channels))

     ;; Now create a manifest with the current "guile" package
     ;; and the old "guile-json" package.
     (packages->manifest
      (list (first (lookup-inferior-packages inferior "guile-json"))
            (specification->package "guile")))

   On its first run, ‘guix package --manifest’ might have to build the
channel you specified before it can create the inferior; subsequent runs
will be much faster because the Guix revision will be cached.

   The ‘(guix inferior)’ module provides the following procedures to
open an inferior:

 -- Scheme Procedure: inferior-for-channels CHANNELS [#:cache-directory]
          [#:ttl] Return an inferior for CHANNELS, a list of
     channels.  Use the cache at CACHE-DIRECTORY, where entries can be
     reclaimed after TTL seconds.  This procedure opens a new connection
     to the build daemon.

     As a side effect, this procedure may build or substitute binaries
     for CHANNELS, which can take time.

 -- Scheme Procedure: open-inferior DIRECTORY [#:command "bin/guix"]
          Open the inferior Guix in DIRECTORY, running
     ‘DIRECTORY/COMMAND repl’ or equivalent.  Return ‘#f’ if the
     inferior could not be launched.

   The procedures listed below allow you to obtain and manipulate
inferior packages.

 -- Scheme Procedure: inferior-packages INFERIOR
     Return the list of packages known to INFERIOR.

 -- Scheme Procedure: lookup-inferior-packages INFERIOR NAME [VERSION]
          Return the sorted list of inferior packages matching
     NAME in INFERIOR, with highest version numbers first.  If VERSION
     is true, return only packages with a version number prefixed by
     VERSION.

 -- Scheme Procedure: inferior-package? OBJ
     Return true if OBJ is an inferior package.

 -- Scheme Procedure: inferior-package-name PACKAGE
 -- Scheme Procedure: inferior-package-version PACKAGE
 -- Scheme Procedure: inferior-package-synopsis PACKAGE
 -- Scheme Procedure: inferior-package-description PACKAGE
 -- Scheme Procedure: inferior-package-home-page PACKAGE
 -- Scheme Procedure: inferior-package-location PACKAGE
 -- Scheme Procedure: inferior-package-inputs PACKAGE
 -- Scheme Procedure: inferior-package-native-inputs PACKAGE
 -- Scheme Procedure: inferior-package-propagated-inputs PACKAGE
 -- Scheme Procedure: inferior-package-transitive-propagated-inputs
          PACKAGE
 -- Scheme Procedure: inferior-package-native-search-paths PACKAGE
 -- Scheme Procedure: inferior-package-transitive-native-search-paths
          PACKAGE
 -- Scheme Procedure: inferior-package-search-paths PACKAGE
     These procedures are the counterpart of package record accessors
     (*note 软件包引用::).  Most of them work by querying the inferior
     PACKAGE comes from, so the inferior must still be live when you
     call these procedures.

   Inferior packages can be used transparently like any other package or
file-like object in G-expressions (*note G-表达式::).  They are also
transparently handled by the ‘packages->manifest’ procedure, which is
commonly use in manifests (*note the ‘--manifest’ option of ‘guix
package’: 调用guix package.).  Thus you can insert an inferior package
pretty much anywhere you would insert a regular package: in manifests,
in the ‘packages’ field of your ‘operating-system’ declaration, and so
on.


File: guix.zh_CN.info,  Node: 调用guix describe,  Next: 调用guix archive,  Prev: Inferiors,  Up: 软件包管理

4.10 Invoking ‘guix describe’
=============================

Often you may want to answer questions like: “Which revision of Guix am
I using?” or “Which channels am I using?” This is useful information in
many situations: if you want to _replicate_ an environment on a
different machine or user account, if you want to report a bug or to
determine what change in the channels you are using caused it, or if you
want to record your system state for reproducibility purposes.  The
‘guix describe’ command answers these questions.

   When run from a ‘guix pull’ed ‘guix’, ‘guix describe’ displays the
channel(s) that it was built from, including their repository URL and
commit IDs (*note 通道::):

     $ guix describe
     Generation 10	Sep 03 2018 17:32:44	(current)
       guix e0fa68c
         repository URL: https://git.savannah.gnu.org/git/guix.git
         branch: master
         commit: e0fa68c7718fffd33d81af415279d6ddb518f727

   If you’re familiar with the Git version control system, this is
similar in spirit to ‘git describe’; the output is also similar to that
of ‘guix pull --list-generations’, but limited to the current generation
(*note the ‘--list-generations’ option: 调用guix pull.).  Because the
Git commit ID shown above unambiguously refers to a snapshot of Guix,
this information is all it takes to describe the revision of Guix you’re
using, and also to replicate it.

   To make it easier to replicate Guix, ‘guix describe’ can also be
asked to return a list of channels instead of the human-readable
description above:

     $ guix describe -f channels
     (list (channel
             (name 'guix)
             (url "https://git.savannah.gnu.org/git/guix.git")
             (commit
               "e0fa68c7718fffd33d81af415279d6ddb518f727")))

You can save this to a file and feed it to ‘guix pull -C’ on some other
machine or at a later point in time, which will instantiate _this exact
Guix revision_ (*note the ‘-C’ option: 调用guix pull.).  From there on,
since you’re able to deploy the same revision of Guix, you can just as
well _replicate a complete software environment_.  We humbly think that
this is _awesome_, and we hope you’ll like it too!

   The details of the options supported by ‘guix describe’ are as
follows:

‘--format=FORMAT’
‘-f FORMAT’
     Produce output in the specified FORMAT, one of:

     ‘human’
          produce human-readable output;
     ‘channels’
          produce a list of channel specifications that can be passed to
          ‘guix pull -C’ or installed as ‘~/.config/guix/channels.scm’
          (*note 调用guix pull::);
     ‘json’
          produce a list of channel specifications in JSON format;
     ‘recutils’
          produce a list of channel specifications in Recutils format.

‘--list-formats’
     Display available formats for ‘--format’ option.

‘--profile=PROFILE’
‘-p PROFILE’
     Display information about PROFILE.


File: guix.zh_CN.info,  Node: 调用guix archive,  Prev: 调用guix describe,  Up: 软件包管理

4.11 Invoking ‘guix archive’
============================

The ‘guix archive’ command allows users to “export” files from the store
into a single archive, and to later “import” them on a machine that runs
Guix.  In particular, it allows store files to be transferred from one
machine to the store on another machine.

     注: If you’re looking for a way to produce archives in a format
     suitable for tools other than Guix, *note 调用guix pack::.

   To export store files as an archive to standard output, run:

     guix archive --export OPTIONS SPECIFICATIONS...

   SPECIFICATIONS may be either store file names or package
specifications, as for ‘guix package’ (*note 调用guix package::).  For
instance, the following command creates an archive containing the ‘gui’
output of the ‘git’ package and the main output of ‘emacs’:

     guix archive --export git:gui /gnu/store/...-emacs-24.3 > great.nar

   If the specified packages are not built yet, ‘guix archive’
automatically builds them.  The build process may be controlled with the
common build options (*note 普通的构建选项::).

   To transfer the ‘emacs’ package to a machine connected over SSH, one
would run:

     guix archive --export -r emacs | ssh the-machine guix archive --import

Similarly, a complete user profile may be transferred from one machine
to another like this:

     guix archive --export -r $(readlink -f ~/.guix-profile) | \
       ssh the-machine guix archive --import

However, note that, in both examples, all of ‘emacs’ and the profile as
well as all of their dependencies are transferred (due to ‘-r’),
regardless of what is already available in the store on the target
machine.  The ‘--missing’ option can help figure out which items are
missing from the target store.  The ‘guix copy’ command simplifies and
optimizes this whole process, so this is probably what you should use in
this case (*note 调用guix copy::).

   Archives are stored in the “normalized archive” or “nar” format,
which is comparable in spirit to ‘tar’, but with differences that make
it more appropriate for our purposes.  First, rather than recording all
Unix metadata for each file, the nar format only mentions the file type
(regular, directory, or symbolic link); Unix permissions and owner/group
are dismissed.  Second, the order in which directory entries are stored
always follows the order of file names according to the C locale
collation order.  This makes archive production fully deterministic.

   When exporting, the daemon digitally signs the contents of the
archive, and that digital signature is appended.  When importing, the
daemon verifies the signature and rejects the import in case of an
invalid signature or if the signing key is not authorized.

   The main options are:

‘--export’
     Export the specified store files or packages (see below).  Write
     the resulting archive to the standard output.

     Dependencies are _not_ included in the output, unless ‘--recursive’
     is passed.

‘-r’
‘--recursive’
     When combined with ‘--export’, this instructs ‘guix archive’ to
     include dependencies of the given items in the archive.  Thus, the
     resulting archive is self-contained: it contains the closure of the
     exported store items.

‘--import’
     Read an archive from the standard input, and import the files
     listed therein into the store.  Abort if the archive has an invalid
     digital signature, or if it is signed by a public key not among the
     authorized keys (see ‘--authorize’ below).

‘--missing’
     Read a list of store file names from the standard input, one per
     line, and write on the standard output the subset of these files
     missing from the store.

‘--generate-key[=PARAMETERS]’
     Generate a new key pair for the daemon.  This is a prerequisite
     before archives can be exported with ‘--export’.  Note that this
     operation usually takes time, because it needs to gather enough
     entropy to generate the key pair.

     The generated key pair is typically stored under ‘/etc/guix’, in
     ‘signing-key.pub’ (public key) and ‘signing-key.sec’ (private key,
     which must be kept secret).  When PARAMETERS is omitted, an ECDSA
     key using the Ed25519 curve is generated, or, for Libgcrypt
     versions before 1.6.0, it is a 4096-bit RSA key.  Alternatively,
     PARAMETERS can specify ‘genkey’ parameters suitable for Libgcrypt
     (*note ‘gcry_pk_genkey’: (gcrypt)General public-key related
     Functions.).

‘--authorize’
     Authorize imports signed by the public key passed on standard
     input.  The public key must be in “s-expression advanced
     format”—i.e., the same format as the ‘signing-key.pub’ file.

     The list of authorized keys is kept in the human-editable file
     ‘/etc/guix/acl’.  The file contains “advanced-format s-expressions”
     (https://people.csail.mit.edu/rivest/Sexp.txt) and is structured as
     an access-control list in the Simple Public-Key Infrastructure
     (SPKI) (https://theworld.com/~cme/spki.txt).

‘--extract=DIRECTORY’
‘-x DIRECTORY’
     Read a single-item archive as served by substitute servers (*note
     Substitutes::) and extract it to DIRECTORY.  This is a low-level
     operation needed in only very narrow use cases; see below.

     For example, the following command extracts the substitute for
     Emacs served by ‘ci.guix.gnu.org’ to ‘/tmp/emacs’:

          $ wget -O - \
            https://ci.guix.gnu.org/nar/gzip/...-emacs-24.5 \
            | gunzip | guix archive -x /tmp/emacs

     Single-item archives are different from multiple-item archives
     produced by ‘guix archive --export’; they contain a single store
     item, and they do _not_ embed a signature.  Thus this operation
     does _no_ signature verification and its output should be
     considered unsafe.

     The primary purpose of this operation is to facilitate inspection
     of archive contents coming from possibly untrusted substitute
     servers (*note 调用guix challenge::).

‘--list’
‘-t’
     Read a single-item archive as served by substitute servers (*note
     Substitutes::) and print the list of files it contains, as in this
     example:

          $ wget -O - \
            https://ci.guix.gnu.org/nar/lzip/...-emacs-26.3 \
            | lzip -d | guix archive -t


File: guix.zh_CN.info,  Node: 开发,  Next: 编程接口,  Prev: 软件包管理,  Up: Top

5 开发
******

If you are a software developer, Guix provides tools that you should
find helpful—independently of the language you’re developing in.  This
is what this chapter is about.

   The ‘guix environment’ command provides a convenient way to set up
“development environments” containing all the dependencies and tools
necessary to work on the software package of your choice.  The ‘guix
pack’ command allows you to create “application bundles” that can be
easily distributed to users who do not run Guix.

* Menu:

* 调用guix environment::   设置开发环境。
* 调用guix pack::          创建软件bundle。
* The GCC toolchain::        Working with languages supported by GCC.


File: guix.zh_CN.info,  Node: 调用guix environment,  Next: 调用guix pack,  Up: 开发

5.1 Invoking ‘guix environment’
===============================

The purpose of ‘guix environment’ is to assist hackers in creating
reproducible development environments without polluting their package
profile.  The ‘guix environment’ tool takes one or more packages, builds
all of their inputs, and creates a shell environment to use them.

   The general syntax is:

     guix environment OPTIONS PACKAGE...

   The following example spawns a new shell set up for the development
of GNU Guile:

     guix environment guile

   If the needed dependencies are not built yet, ‘guix environment’
automatically builds them.  The environment of the new shell is an
augmented version of the environment that ‘guix environment’ was run in.
It contains the necessary search paths for building the given package
added to the existing environment variables.  To create a “pure”
environment, in which the original environment variables have been
unset, use the ‘--pure’ option(1).

   ‘guix environment’ defines the ‘GUIX_ENVIRONMENT’ variable in the
shell it spawns; its value is the file name of the profile of this
environment.  This allows users to, say, define a specific prompt for
development environments in their ‘.bashrc’ (*note (bash)Bash Startup
Files::):

     if [ -n "$GUIX_ENVIRONMENT" ]
     then
         export PS1="\u@\h \w [dev]\$ "
     fi

... or to browse the profile:

     $ ls "$GUIX_ENVIRONMENT/bin"

   Additionally, more than one package may be specified, in which case
the union of the inputs for the given packages are used.  For example,
the command below spawns a shell where all of the dependencies of both
Guile and Emacs are available:

     guix environment guile emacs

   Sometimes an interactive shell session is not desired.  An arbitrary
command may be invoked by placing the ‘--’ token to separate the command
from the rest of the arguments:

     guix environment guile -- make -j4

   In other situations, it is more convenient to specify the list of
packages needed in the environment.  For example, the following command
runs ‘python’ from an environment containing Python 2.7 and NumPy:

     guix environment --ad-hoc python2-numpy python-2.7 -- python

   Furthermore, one might want the dependencies of a package and also
some additional packages that are not build-time or runtime
dependencies, but are useful when developing nonetheless.  Because of
this, the ‘--ad-hoc’ flag is positional.  Packages appearing before
‘--ad-hoc’ are interpreted as packages whose dependencies will be added
to the environment.  Packages appearing after are interpreted as
packages that will be added to the environment directly.  For example,
the following command creates a Guix development environment that
additionally includes Git and strace:

     guix environment --pure guix --ad-hoc git strace

   Sometimes it is desirable to isolate the environment as much as
possible, for maximal purity and reproducibility.  In particular, when
using Guix on a host distro that is not Guix System, it is desirable to
prevent access to ‘/usr/bin’ and other system-wide resources from the
development environment.  For example, the following command spawns a
Guile REPL in a “container” where only the store and the current working
directory are mounted:

     guix environment --ad-hoc --container guile -- guile

     注: The ‘--container’ option requires Linux-libre 3.19 or newer.

   Another typical use case for containers is to run security-sensitive
applications such as a web browser.  To run Eolie, we must expose and
share some files and directories; we include ‘nss-certs’ and expose
‘/etc/ssl/certs/’ for HTTPS authentication; finally we preserve the the
‘DISPLAY’ environment variable since containerized graphical
applications won’t display without it.

     guix environment --preserve='^DISPLAY$' --container --network \
       --expose=/etc/machine-id \
       --expose=/etc/ssl/certs/ \
       --share=$HOME/.local/share/eolie/=$HOME/.local/share/eolie/ \
       --ad-hoc eolie nss-certs dbus --  eolie

   The available options are summarized below.

‘--root=FILE’
‘-r FILE’
     Make FILE a symlink to the profile for this environment, and
     register it as a garbage collector root.

     This is useful if you want to protect your environment from garbage
     collection, to make it “persistent”.

     When this option is omitted, the environment is protected from
     garbage collection only for the duration of the ‘guix environment’
     session.  This means that next time you recreate the same
     environment, you could have to rebuild or re-download packages.
     *Note 调用guix gc::, for more on GC roots.

‘--expression=EXPR’
‘-e EXPR’
     Create an environment for the package or list of packages that EXPR
     evaluates to.

     For example, running:

          guix environment -e '(@ (gnu packages maths) petsc-openmpi)'

     starts a shell with the environment for this specific variant of
     the PETSc package.

     Running:

          guix environment --ad-hoc -e '(@ (gnu) %base-packages)'

     starts a shell with all the base system packages available.

     The above commands only use the default output of the given
     packages.  To select other outputs, two element tuples can be
     specified:

          guix environment --ad-hoc -e '(list (@ (gnu packages bash) bash) "include")'

‘--load=FILE’
‘-l FILE’
     Create an environment for the package or list of packages that the
     code within FILE evaluates to.

     As an example, FILE might contain a definition like this (*note
     定义软件包::):

          (use-modules (guix)
                       (gnu packages gdb)
                       (gnu packages autotools)
                       (gnu packages texinfo))
          
          ;; Augment the package definition of GDB with the build tools
          ;; needed when developing GDB (and which are not needed when
          ;; simply installing it.)
          (package (inherit gdb)
            (native-inputs `(("autoconf" ,autoconf-2.64)
                             ("automake" ,automake)
                             ("texinfo" ,texinfo)
                             ,@(package-native-inputs gdb))))

‘--manifest=FILE’
‘-m FILE’
     Create an environment for the packages contained in the manifest
     object returned by the Scheme code in FILE.  This option can be
     repeated several times, in which case the manifests are
     concatenated.

     This is similar to the same-named option in ‘guix package’ (*note
     ‘--manifest’: profile-manifest.) and uses the same manifest files.

‘--ad-hoc’
     Include all specified packages in the resulting environment, as if
     an ad hoc package were defined with them as inputs.  This option is
     useful for quickly creating an environment without having to write
     a package expression to contain the desired inputs.

     For instance, the command:

          guix environment --ad-hoc guile guile-sdl -- guile

     runs ‘guile’ in an environment where Guile and Guile-SDL are
     available.

     Note that this example implicitly asks for the default output of
     ‘guile’ and ‘guile-sdl’, but it is possible to ask for a specific
     output—e.g., ‘glib:bin’ asks for the ‘bin’ output of ‘glib’ (*note
     有多个输出的软件包::).

     This option may be composed with the default behavior of ‘guix
     environment’.  Packages appearing before ‘--ad-hoc’ are interpreted
     as packages whose dependencies will be added to the environment,
     the default behavior.  Packages appearing after are interpreted as
     packages that will be added to the environment directly.

‘--pure’
     Unset existing environment variables when building the new
     environment, except those specified with ‘--preserve’ (see below).
     This has the effect of creating an environment in which search
     paths only contain package inputs.

‘--preserve=REGEXP’
‘-E REGEXP’
     When used alongside ‘--pure’, preserve the environment variables
     matching REGEXP—in other words, put them on a “white list” of
     environment variables that must be preserved.  This option can be
     repeated several times.

          guix environment --pure --preserve=^SLURM --ad-hoc openmpi ... \
            -- mpirun ...

     This example runs ‘mpirun’ in a context where the only environment
     variables defined are ‘PATH’, environment variables whose name
     starts with ‘SLURM’, as well as the usual “precious” variables
     (‘HOME’, ‘USER’, etc.).

‘--search-paths’
     Display the environment variable definitions that make up the
     environment.

‘--system=SYSTEM’
‘-s SYSTEM’
     Attempt to build for SYSTEM—e.g., ‘i686-linux’.

‘--container’
‘-C’
     Run COMMAND within an isolated container.  The current working
     directory outside the container is mapped inside the container.
     Additionally, unless overridden with ‘--user’, a dummy home
     directory is created that matches the current user’s home
     directory, and ‘/etc/passwd’ is configured accordingly.

     The spawned process runs as the current user outside the container.
     Inside the container, it has the same UID and GID as the current
     user, unless ‘--user’ is passed (see below).

‘--network’
‘-N’
     For containers, share the network namespace with the host system.
     Containers created without this flag only have access to the
     loopback device.

‘--link-profile’
‘-P’
     For containers, link the environment profile to ‘~/.guix-profile’
     within the container.  This is equivalent to running the command
     ‘ln -s $GUIX_ENVIRONMENT ~/.guix-profile’ within the container.
     Linking will fail and abort the environment if the directory
     already exists, which will certainly be the case if ‘guix
     environment’ was invoked in the user’s home directory.

     Certain packages are configured to look in ‘~/.guix-profile’ for
     configuration files and data;(2) ‘--link-profile’ allows these
     programs to behave as expected within the environment.

‘--user=USER’
‘-u USER’
     For containers, use the username USER in place of the current user.
     The generated ‘/etc/passwd’ entry within the container will contain
     the name USER, the home directory will be ‘/home/USER’, and no user
     GECOS data will be copied.  Furthermore, the UID and GID inside the
     container are 1000.  USER need not exist on the system.

     Additionally, any shared or exposed path (see ‘--share’ and
     ‘--expose’ respectively) whose target is within the current user’s
     home directory will be remapped relative to ‘/home/USER’; this
     includes the automatic mapping of the current working directory.

          # will expose paths as /home/foo/wd, /home/foo/test, and /home/foo/target
          cd $HOME/wd
          guix environment --container --user=foo \
               --expose=$HOME/test \
               --expose=/tmp/target=$HOME/target

     While this will limit the leaking of user identity through home
     paths and each of the user fields, this is only one useful
     component of a broader privacy/anonymity solution—not one in and of
     itself.

‘--no-cwd’
     For containers, the default behavior is to share the current
     working directory with the isolated container and immediately
     change to that directory within the container.  If this is
     undesirable, ‘--no-cwd’ will cause the current working directory to
     _not_ be automatically shared and will change to the user’s home
     directory within the container instead.  See also ‘--user’.

‘--expose=SOURCE[=TARGET]’
‘--share=SOURCE[=TARGET]’
     For containers, ‘--expose’ (resp.  ‘--share’) exposes the file
     system SOURCE from the host system as the read-only (resp.
     writable) file system TARGET within the container.  If TARGET is
     not specified, SOURCE is used as the target mount point in the
     container.

     The example below spawns a Guile REPL in a container in which the
     user’s home directory is accessible read-only via the ‘/exchange’
     directory:

          guix environment --container --expose=$HOME=/exchange --ad-hoc guile -- guile

   ‘guix environment’ also supports all of the common build options that
‘guix build’ supports (*note 普通的构建选项::) as well as package
transformation options (*note 软件包变换选项。::).

   ---------- Footnotes ----------

   (1) Users sometimes wrongfully augment environment variables such as
‘PATH’ in their ‘~/.bashrc’ file.  As a consequence, when ‘guix
environment’ launches it, Bash may read ‘~/.bashrc’, thereby introducing
“impurities” in these environment variables.  It is an error to define
such environment variables in ‘.bashrc’; instead, they should be defined
in ‘.bash_profile’, which is sourced only by log-in shells.  *Note
(bash)Bash Startup Files::, for details on Bash start-up files.

   (2) For example, the ‘fontconfig’ package inspects
‘~/.guix-profile/share/fonts’ for additional fonts.


File: guix.zh_CN.info,  Node: 调用guix pack,  Next: The GCC toolchain,  Prev: 调用guix environment,  Up: 开发

5.2 Invoking ‘guix pack’
========================

Occasionally you want to pass software to people who are not (yet!)
lucky enough to be using Guix.  You’d tell them to run ‘guix package -i
SOMETHING’, but that’s not possible in this case.  This is where ‘guix
pack’ comes in.

     注: If you are looking for ways to exchange binaries among machines
     that already run Guix, *note 调用guix copy::, *note 调用guix
     publish::, and *note 调用guix archive::.

   The ‘guix pack’ command creates a shrink-wrapped “pack” or “software
bundle”: it creates a tarball or some other archive containing the
binaries of the software you’re interested in, and all its dependencies.
The resulting archive can be used on any machine that does not have
Guix, and people can run the exact same binaries as those you have with
Guix.  The pack itself is created in a bit-reproducible fashion, so
anyone can verify that it really contains the build results that you
pretend to be shipping.

   For example, to create a bundle containing Guile, Emacs, Geiser, and
all their dependencies, you can run:

     $ guix pack guile emacs geiser
     ...
     /gnu/store/...-pack.tar.gz

   The result here is a tarball containing a ‘/gnu/store’ directory with
all the relevant packages.  The resulting tarball contains a “profile”
with the three packages of interest; the profile is the same as would be
created by ‘guix package -i’.  It is this mechanism that is used to
create Guix’s own standalone binary tarball (*note 二进制文件安装::).

   Users of this pack would have to run
‘/gnu/store/...-profile/bin/guile’ to run Guile, which you may find
inconvenient.  To work around it, you can create, say, a ‘/opt/gnu/bin’
symlink to the profile:

     guix pack -S /opt/gnu/bin=bin guile emacs geiser

That way, users can happily type ‘/opt/gnu/bin/guile’ and enjoy.

   What if the recipient of your pack does not have root privileges on
their machine, and thus cannot unpack it in the root file system?  In
that case, you will want to use the ‘--relocatable’ option (see below).
This option produces “relocatable binaries”, meaning they they can be
placed anywhere in the file system hierarchy: in the example above,
users can unpack your tarball in their home directory and directly run
‘./opt/gnu/bin/guile’.

   Alternatively, you can produce a pack in the Docker image format
using the following command:

     guix pack -f docker -S /bin=bin guile guile-readline

The result is a tarball that can be passed to the ‘docker load’ command,
followed by ‘docker run’:

     docker load < FILE
     docker run -ti guile-guile-readline /bin/guile

where FILE is the image returned by GUIX PACK, and
‘guile-guile-readline’ is its “image tag”.  See the Docker documentation
(https://docs.docker.com/engine/reference/commandline/load/) for more
information.

   Yet another option is to produce a SquashFS image with the following
command:

     guix pack -f squashfs bash guile emacs geiser

The result is a SquashFS file system image that can either be mounted or
directly be used as a file system container image with the Singularity
container execution environment (https://www.sylabs.io/docs/), using
commands like ‘singularity shell’ or ‘singularity exec’.

   Several command-line options allow you to customize your pack:

‘--format=FORMAT’
‘-f FORMAT’
     Produce a pack in the given FORMAT.

     The available formats are:

     ‘tarball’
          This is the default format.  It produces a tarball containing
          all the specified binaries and symlinks.

     ‘docker’
          This produces a tarball that follows the Docker Image
          Specification
          (https://github.com/docker/docker/blob/master/image/spec/v1.2.md).
          The “repository name” as it appears in the output of the
          ‘docker images’ command is computed from package names passed
          on the command line or in the manifest file.

     ‘squashfs’
          This produces a SquashFS image containing all the specified
          binaries and symlinks, as well as empty mount points for
          virtual file systems like procfs.

               注: Singularity _requires_ you to provide ‘/bin/sh’ in
               the image.  For that reason, ‘guix pack -f squashfs’
               always implies ‘-S /bin=bin’.  Thus, your ‘guix pack’
               invocation must always start with something like:

                    guix pack -f squashfs bash ...

               If you forget the ‘bash’ (or similar) package,
               ‘singularity run’ and ‘singularity exec’ will fail with
               an unhelpful “no such file or directory” message.

‘--relocatable’
‘-R’
     Produce “relocatable binaries”—i.e., binaries that can be placed
     anywhere in the file system hierarchy and run from there.

     When this option is passed once, the resulting binaries require
     support for “user namespaces” in the kernel Linux; when passed
     _twice_(1), relocatable binaries fall to back to other techniques
     if user namespaces are unavailable, and essentially work
     anywhere—see below for the implications.

     For example, if you create a pack containing Bash with:

          guix pack -RR -S /mybin=bin bash

     ... you can copy that pack to a machine that lacks Guix, and from
     your home directory as a normal user, run:

          tar xf pack.tar.gz
          ./mybin/sh

     In that shell, if you type ‘ls /gnu/store’, you’ll notice that
     ‘/gnu/store’ shows up and contains all the dependencies of ‘bash’,
     even though the machine actually lacks ‘/gnu/store’ altogether!
     That is probably the simplest way to deploy Guix-built software on
     a non-Guix machine.

          注: By default, relocatable binaries rely on the “user
          namespace” feature of the kernel Linux, which allows
          unprivileged users to mount or change root.  Old versions of
          Linux did not support it, and some GNU/Linux distributions
          turn it off.

          To produce relocatable binaries that work even in the absence
          of user namespaces, pass ‘--relocatable’ or ‘-R’ _twice_.  In
          that case, binaries will try user namespace support and fall
          back to another “execution engine” if user namespaces are not
          supported.  The following execution engines are supported:

          ‘default’
               Try user namespaces and fall back to PRoot if user
               namespaces are not supported (see below).

          ‘performance’
               Try user namespaces and fall back to Fakechroot if user
               namespaces are not supported (see below).

          ‘userns’
               Run the program through user namespaces and abort if they
               are not supported.

          ‘proot’
               Run through PRoot.  The PRoot
               (https://proot-me.github.io/) program provides the
               necessary support for file system virtualization.  It
               achieves that by using the ‘ptrace’ system call on the
               running program.  This approach has the advantage to work
               without requiring special kernel support, but it incurs
               run-time overhead every time a system call is made.

          ‘fakechroot’
               Run through Fakechroot.  Fakechroot
               (https://github.com/dex4er/fakechroot/) virtualizes file
               system accesses by intercepting calls to C library
               functions such as ‘open’, ‘stat’, ‘exec’, and so on.
               Unlike PRoot, it incurs very little overhead.  However,
               it does not always work: for example, some file system
               accesses made from within the C library are not
               intercepted, and file system accesses made via direct
               syscalls are not intercepted either, leading to erratic
               behavior.

          When running a wrapped program, you can explicitly request one
          of the execution engines listed above by setting the
          ‘GUIX_EXECUTION_ENGINE’ environment variable accordingly.

‘--entry-point=COMMAND’
     Use COMMAND as the “entry point” of the resulting pack, if the pack
     format supports it—currently ‘docker’ and ‘squashfs’ (Singularity)
     support it.  COMMAND must be relative to the profile contained in
     the pack.

     The entry point specifies the command that tools like ‘docker run’
     or ‘singularity run’ automatically start by default.  For example,
     you can do:

          guix pack -f docker --entry-point=bin/guile guile

     The resulting pack can easily be loaded and ‘docker run’ with no
     extra arguments will spawn ‘bin/guile’:

          docker load -i pack.tar.gz
          docker run IMAGE-ID

‘--expression=EXPR’
‘-e EXPR’
     Consider the package EXPR evaluates to.

     This has the same purpose as the same-named option in ‘guix build’
     (*note ‘--expression’ in ‘guix build’: 额外的构建选项.).

‘--manifest=FILE’
‘-m FILE’
     Use the packages contained in the manifest object returned by the
     Scheme code in FILE.  This option can be repeated several times, in
     which case the manifests are concatenated.

     This has a similar purpose as the same-named option in ‘guix
     package’ (*note ‘--manifest’: profile-manifest.) and uses the same
     manifest files.  It allows you to define a collection of packages
     once and use it both for creating profiles and for creating
     archives for use on machines that do not have Guix installed.  Note
     that you can specify _either_ a manifest file _or_ a list of
     packages, but not both.

‘--system=SYSTEM’
‘-s SYSTEM’
     Attempt to build for SYSTEM—e.g., ‘i686-linux’—instead of the
     system type of the build host.

‘--target=TRIPLET’
     Cross-build for TRIPLET, which must be a valid GNU triplet, such as
     ‘"aarch64-linux-gnu"’ (*note GNU configuration triplets:
     (autoconf)Specifying target triplets.).

‘--compression=TOOL’
‘-C TOOL’
     Compress the resulting tarball using TOOL—one of ‘gzip’, ‘bzip2’,
     ‘xz’, ‘lzip’, or ‘none’ for no compression.

‘--symlink=SPEC’
‘-S SPEC’
     Add the symlinks specified by SPEC to the pack.  This option can
     appear several times.

     SPEC has the form ‘SOURCE=TARGET’, where SOURCE is the symlink that
     will be created and TARGET is the symlink target.

     For instance, ‘-S /opt/gnu/bin=bin’ creates a ‘/opt/gnu/bin’
     symlink pointing to the ‘bin’ sub-directory of the profile.

‘--save-provenance’
     Save provenance information for the packages passed on the command
     line.  Provenance information includes the URL and commit of the
     channels in use (*note 通道::).

     Provenance information is saved in the
     ‘/gnu/store/...-profile/manifest’ file in the pack, along with the
     usual package metadata—the name and version of each package, their
     propagated inputs, and so on.  It is useful information to the
     recipient of the pack, who then knows how the pack was (supposedly)
     obtained.

     This option is not enabled by default because, like timestamps,
     provenance information contributes nothing to the build process.
     In other words, there is an infinity of channel URLs and commit IDs
     that can lead to the same pack.  Recording such “silent” metadata
     in the output thus potentially breaks the source-to-binary bitwise
     reproducibility property.

‘--root=FILE’
‘-r FILE’
     Make FILE a symlink to the resulting pack, and register it as a
     garbage collector root.

‘--localstatedir’
‘--profile-name=NAME’
     Include the “local state directory”, ‘/var/guix’, in the resulting
     pack, and notably the ‘/var/guix/profiles/per-user/root/NAME’
     profile—by default NAME is ‘guix-profile’, which corresponds to
     ‘~root/.guix-profile’.

     ‘/var/guix’ contains the store database (*note 仓库::) as well as
     garbage-collector roots (*note 调用guix gc::).  Providing it in the
     pack means that the store is “complete” and manageable by Guix; not
     providing it pack means that the store is “dead”: items cannot be
     added to it or removed from it after extraction of the pack.

     One use case for this is the Guix self-contained binary tarball
     (*note 二进制文件安装::).

‘--derivation’
‘-d’
     Print the name of the derivation that builds the pack.

‘--bootstrap’
     Use the bootstrap binaries to build the pack.  This option is only
     useful to Guix developers.

   In addition, ‘guix pack’ supports all the common build options (*note
普通的构建选项::) and all the package transformation options (*note
软件包变换选项。::).

   ---------- Footnotes ----------

   (1) Here’s a trick to memorize it: ‘-RR’, which adds PRoot support,
can be thought of as the abbreviation of “Really Relocatable”.  Neat,
isn’t it?


File: guix.zh_CN.info,  Node: The GCC toolchain,  Prev: 调用guix pack,  Up: 开发

5.3 The GCC toolchain
=====================

If you need a complete toolchain for compiling and linking C or C++
source code, use the ‘gcc-toolchain’ package.  This package provides a
complete GCC toolchain for C/C++ development, including GCC itself, the
GNU C Library (headers and binaries, plus debugging symbols in the
‘debug’ output), Binutils, and a linker wrapper.

   The wrapper’s purpose is to inspect the ‘-L’ and ‘-l’ switches passed
to the linker, add corresponding ‘-rpath’ arguments, and invoke the
actual linker with this new set of arguments.  You can instruct the
wrapper to refuse to link against libraries not in the store by setting
the ‘GUIX_LD_WRAPPER_ALLOW_IMPURITIES’ environment variable to ‘no’.

   The package ‘gfortran-toolchain’ provides a complete GCC toolchain
for Fortran development.  For other languages, please use ‘guix search
gcc toolchain’ (*note Invoking guix package: guix-search.).


File: guix.zh_CN.info,  Node: 编程接口,  Next: 工具,  Prev: 开发,  Up: Top

6 编程接口
**********

GNU Guix provides several Scheme programming interfaces (APIs) to
define, build, and query packages.  The first interface allows users to
write high-level package definitions.  These definitions refer to
familiar packaging concepts, such as the name and version of a package,
its build system, and its dependencies.  These definitions can then be
turned into concrete build actions.

   Build actions are performed by the Guix daemon, on behalf of users.
In a standard setup, the daemon has write access to the store—the
‘/gnu/store’ directory—whereas users do not.  The recommended setup also
has the daemon perform builds in chroots, under a specific build users,
to minimize interference with the rest of the system.

   Lower-level APIs are available to interact with the daemon and the
store.  To instruct the daemon to perform a build action, users actually
provide it with a “derivation”.  A derivation is a low-level
representation of the build actions to be taken, and the environment in
which they should occur—derivations are to package definitions what
assembly is to C programs.  The term “derivation” comes from the fact
that build results _derive_ from them.

   This chapter describes all these APIs in turn, starting from
high-level package definitions.

* Menu:

* 软件包模块::          从程序员的角度看软件包。
* 定义软件包::          定义新软件包。
* 构建系统::             指定如何构建软件包。
* 仓库::                   操纵软件包仓库。
* Derivations::              软件包derivation的底层接口。
* 仓库monad::              仓库的纯函数式接口。
* G-表达式::              操纵构建表达式。
* 调用guix repl::          交互式地操作Guix。


File: guix.zh_CN.info,  Node: 软件包模块,  Next: 定义软件包,  Up: 编程接口

6.1 软件包模块
==============

From a programming viewpoint, the package definitions of the GNU
distribution are provided by Guile modules in the ‘(gnu packages ...)’
name space(1) (*note Guile modules: (guile)模块.).  For instance, the
‘(gnu packages emacs)’ module exports a variable named ‘emacs’, which is
bound to a ‘<package>’ object (*note 定义软件包::).

   The ‘(gnu packages ...)’ module name space is automatically scanned
for packages by the command-line tools.  For instance, when running
‘guix install emacs’, all the ‘(gnu packages ...)’ modules are scanned
until one that exports a package object whose name is ‘emacs’ is found.
This package search facility is implemented in the ‘(gnu packages)’
module.

   Users can store package definitions in modules with different
names—e.g., ‘(my-packages emacs)’(2).  There are two ways to make these
package definitions visible to the user interfaces:

  1. By adding the directory containing your package modules to the
     search path with the ‘-L’ flag of ‘guix package’ and other commands
     (*note 普通的构建选项::), or by setting the ‘GUIX_PACKAGE_PATH’
     environment variable described below.

  2. By defining a “channel” and configuring ‘guix pull’ so that it
     pulls from it.  A channel is essentially a Git repository
     containing package modules.  *Note 通道::, for more information on
     how to define and use channels.

   ‘GUIX_PACKAGE_PATH’ works similarly to other search path variables:

 -- Environment Variable: GUIX_PACKAGE_PATH
     This is a colon-separated list of directories to search for
     additional package modules.  Directories listed in this variable
     take precedence over the own modules of the distribution.

   The distribution is fully “bootstrapped” and “self-contained”: each
package is built based solely on other packages in the distribution.
The root of this dependency graph is a small set of “bootstrap
binaries”, provided by the ‘(gnu packages bootstrap)’ module.  For more
information on bootstrapping, *note 引导::.

   ---------- Footnotes ----------

   (1) Note that packages under the ‘(gnu packages ...)’ module name
space are not necessarily “GNU packages”.  This module naming scheme
follows the usual Guile module naming convention: ‘gnu’ means that these
modules are distributed as part of the GNU system, and ‘packages’
identifies modules that define packages.

   (2) Note that the file name and module name must match.  For
instance, the ‘(my-packages emacs)’ module must be stored in a
‘my-packages/emacs.scm’ file relative to the load path specified with
‘--load-path’ or ‘GUIX_PACKAGE_PATH’.  *Note (guile)Modules and the File
System::, for details.


File: guix.zh_CN.info,  Node: 定义软件包,  Next: 构建系统,  Prev: 软件包模块,  Up: 编程接口

6.2 定义软件包
==============

The high-level interface to package definitions is implemented in the
‘(guix packages)’ and ‘(guix build-system)’ modules.  As an example, the
package definition, or “recipe”, for the GNU Hello package looks like
this:

     (define-module (gnu packages hello)
       #:use-module (guix packages)
       #:use-module (guix download)
       #:use-module (guix build-system gnu)
       #:use-module (guix licenses)
       #:use-module (gnu packages gawk))

     (define-public hello
       (package
         (name "hello")
         (version "2.10")
         (source (origin
                   (method url-fetch)
                   (uri (string-append "mirror://gnu/hello/hello-" version
                                       ".tar.gz"))
                   (sha256
                    (base32
                     "0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i"))))
         (build-system gnu-build-system)
         (arguments '(#:configure-flags '("--enable-silent-rules")))
         (inputs `(("gawk" ,gawk)))
         (synopsis "Hello, GNU world: An example GNU package")
         (description "Guess what GNU Hello prints!")
         (home-page "https://www.gnu.org/software/hello/")
         (license gpl3+)))

Without being a Scheme expert, the reader may have guessed the meaning
of the various fields here.  This expression binds the variable ‘hello’
to a ‘<package>’ object, which is essentially a record (*note Scheme
records: (guile)SRFI-9.).  This package object can be inspected using
procedures found in the ‘(guix packages)’ module; for instance,
‘(package-name hello)’ returns—surprise!—‘"hello"’.

   With luck, you may be able to import part or all of the definition of
the package you are interested in from another repository, using the
‘guix import’ command (*note 调用guix import::).

   In the example above, HELLO is defined in a module of its own, ‘(gnu
packages hello)’.  Technically, this is not strictly necessary, but it
is convenient to do so: all the packages defined in modules under ‘(gnu
packages ...)’ are automatically known to the command-line tools (*note
软件包模块::).

   There are a few points worth noting in the above package definition:

   • The ‘source’ field of the package is an ‘<origin>’ object (*note
     origin参考手册::, for the complete reference).  Here, the
     ‘url-fetch’ method from ‘(guix download)’ is used, meaning that the
     source is a file to be downloaded over FTP or HTTP.

     The ‘mirror://gnu’ prefix instructs ‘url-fetch’ to use one of the
     GNU mirrors defined in ‘(guix download)’.

     The ‘sha256’ field specifies the expected SHA256 hash of the file
     being downloaded.  It is mandatory, and allows Guix to check the
     integrity of the file.  The ‘(base32 ...)’ form introduces the
     base32 representation of the hash.  You can obtain this information
     with ‘guix download’ (*note 调用guix download::) and ‘guix hash’
     (*note 调用guix hash::).

     When needed, the ‘origin’ form can also have a ‘patches’ field
     listing patches to be applied, and a ‘snippet’ field giving a
     Scheme expression to modify the source code.

   • The ‘build-system’ field specifies the procedure to build the
     package (*note 构建系统::).  Here, GNU-BUILD-SYSTEM represents the
     familiar GNU Build System, where packages may be configured, built,
     and installed with the usual ‘./configure && make && make check &&
     make install’ command sequence.

   • The ‘arguments’ field specifies options for the build system (*note
     构建系统::).  Here it is interpreted by GNU-BUILD-SYSTEM as a
     request run ‘configure’ with the ‘--enable-silent-rules’ flag.

     What about these quote (‘'’) characters?  They are Scheme syntax to
     introduce a literal list; ‘'’ is synonymous with ‘quote’.  *Note
     quoting: (guile)Expression Syntax, for details.  Here the value of
     the ‘arguments’ field is a list of arguments passed to the build
     system down the road, as with ‘apply’ (*note ‘apply’: (guile)Fly
     Evaluation.).

     The hash-colon (‘#:’) sequence defines a Scheme “keyword” (*note
     (guile)Keywords::), and ‘#:configure-flags’ is a keyword used to
     pass a keyword argument to the build system (*note (guile)Coding
     With Keywords::).

   • The ‘inputs’ field specifies inputs to the build process—i.e.,
     build-time or run-time dependencies of the package.  Here, we
     define an input called ‘"gawk"’ whose value is that of the GAWK
     variable; GAWK is itself bound to a ‘<package>’ object.

     Again, ‘`’ (a backquote, synonymous with ‘quasiquote’) allows us to
     introduce a literal list in the ‘inputs’ field, while ‘,’ (a comma,
     synonymous with ‘unquote’) allows us to insert a value in that list
     (*note unquote: (guile)Expression Syntax.).

     Note that GCC, Coreutils, Bash, and other essential tools do not
     need to be specified as inputs here.  Instead, GNU-BUILD-SYSTEM
     takes care of ensuring that they are present (*note 构建系统::).

     However, any other dependencies need to be specified in the
     ‘inputs’ field.  Any dependency not specified here will simply be
     unavailable to the build process, possibly leading to a build
     failure.

   *Note 软件包引用::, for a full description of possible fields.

   Once a package definition is in place, the package may actually be
built using the ‘guix build’ command-line tool (*note 调用guix build::),
troubleshooting any build failures you encounter (*note 调试构建错误::).
You can easily jump back to the package definition using the ‘guix edit’
command (*note 调用guix edit。::).  *Note 打包指导::, for more
information on how to test package definitions, and *note 调用guix
lint::, for information on how to check a definition for style
conformance.  Lastly, *note 通道::, for information on how to extend the
distribution by adding your own package definitions in a “channel”.

   Finally, updating the package definition to a new upstream version
can be partly automated by the ‘guix refresh’ command (*note 调用guix
refresh::).

   Behind the scenes, a derivation corresponding to the ‘<package>’
object is first computed by the ‘package-derivation’ procedure.  That
derivation is stored in a ‘.drv’ file under ‘/gnu/store’.  The build
actions it prescribes may then be realized by using the
‘build-derivations’ procedure (*note 仓库::).

 -- Scheme Procedure: package-derivation STORE PACKAGE [SYSTEM]
     Return the ‘<derivation>’ object of PACKAGE for SYSTEM (*note
     Derivations::).

     PACKAGE must be a valid ‘<package>’ object, and SYSTEM must be a
     string denoting the target system type—e.g., ‘"x86_64-linux"’ for
     an x86_64 Linux-based GNU system.  STORE must be a connection to
     the daemon, which operates on the store (*note 仓库::).

Similarly, it is possible to compute a derivation that cross-builds a
package for some other system:

 -- Scheme Procedure: package-cross-derivation STORE PACKAGE TARGET
          [SYSTEM] Return the ‘<derivation>’
     object of PACKAGE cross-built from SYSTEM to TARGET.

     TARGET must be a valid GNU triplet denoting the target hardware and
     operating system, such as ‘"aarch64-linux-gnu"’ (*note
     (autoconf)Specifying Target Triplets::).

   Packages can be manipulated in arbitrary ways.  An example of a
useful transformation is “input rewriting”, whereby the dependency tree
of a package is rewritten by replacing specific inputs by others:

 -- Scheme Procedure: package-input-rewriting REPLACEMENTS
          [REWRITE-NAME] Return a procedure that, when passed a package,
     replaces its direct and indirect dependencies (but not its implicit
     inputs) according to REPLACEMENTS.  REPLACEMENTS is a list of
     package pairs; the first element of each pair is the package to
     replace, and the second one is the replacement.

     Optionally, REWRITE-NAME is a one-argument procedure that takes the
     name of a package and returns its new name after rewrite.

Consider this example:

     (define libressl-instead-of-openssl
       ;; This is a procedure to replace OPENSSL by LIBRESSL,
       ;; recursively.
       (package-input-rewriting `((,openssl . ,libressl))))

     (define git-with-libressl
       (libressl-instead-of-openssl git))

Here we first define a rewriting procedure that replaces OPENSSL with
LIBRESSL.  Then we use it to define a “variant” of the GIT package that
uses LIBRESSL instead of OPENSSL.  This is exactly what the
‘--with-input’ command-line option does (*note ‘--with-input’:
软件包变换选项。.).

   The following variant of ‘package-input-rewriting’ can match packages
to be replaced by name rather than by identity.

 -- Scheme Procedure: package-input-rewriting/spec REPLACEMENTS
     Return a procedure that, given a package, applies the given
     REPLACEMENTS to all the package graph (excluding implicit inputs).
     REPLACEMENTS is a list of spec/procedures pair; each spec is a
     package specification such as ‘"gcc"’ or ‘"guile@2"’, and each
     procedure takes a matching package and returns a replacement for
     that package.

   The example above could be rewritten this way:

     (define libressl-instead-of-openssl
       ;; Replace all the packages called "openssl" with LibreSSL.
       (package-input-rewriting/spec `(("openssl" . ,(const libressl)))))

   The key difference here is that, this time, packages are matched by
spec and not by identity.  In other words, any package in the graph that
is called ‘openssl’ will be replaced.

   A more generic procedure to rewrite a package dependency graph is
‘package-mapping’: it supports arbitrary changes to nodes in the graph.

 -- Scheme Procedure: package-mapping PROC [CUT?]
     Return a procedure that, given a package, applies PROC to all the
     packages depended on and returns the resulting package.  The
     procedure stops recursion when CUT? returns true for a given
     package.

* Menu:

* 软件包引用::          软件包数据类型。
* origin参考手册::       origin数据类型。


File: guix.zh_CN.info,  Node: 软件包引用,  Next: origin参考手册,  Up: 定义软件包

6.2.1 ‘package’ Reference
-------------------------

This section summarizes all the options available in ‘package’
declarations (*note 定义软件包::).

 -- Data Type: package
     This is the data type representing a package recipe.

     ‘名字’
          The name of the package, as a string.

     ‘version’
          The version of the package, as a string.

     ‘source’
          An object telling how the source code for the package should
          be acquired.  Most of the time, this is an ‘origin’ object,
          which denotes a file fetched from the Internet (*note
          origin参考手册::).  It can also be any other “file-like”
          object such as a ‘local-file’, which denotes a file from the
          local file system (*note ‘local-file’: G-表达式.).

     ‘build-system’
          The build system that should be used to build the package
          (*note 构建系统::).

     ‘arguments’ (default: ‘'()’)
          The arguments that should be passed to the build system.  This
          is a list, typically containing sequential keyword-value
          pairs.

     ‘inputs’ (default: ‘'()’)
     ‘native-inputs’ (default: ‘'()’)
     ‘propagated-inputs’ (default: ‘'()’)
          These fields list dependencies of the package.  Each one is a
          list of tuples, where each tuple has a label for the input (a
          string) as its first element, a package, origin, or derivation
          as its second element, and optionally the name of the output
          thereof that should be used, which defaults to ‘"out"’ (*note
          有多个输出的软件包::, for more on package outputs).  For
          example, the list below specifies three inputs:

               `(("libffi" ,libffi)
                 ("libunistring" ,libunistring)
                 ("glib:bin" ,glib "bin"))  ;the "bin" output of Glib

          The distinction between ‘native-inputs’ and ‘inputs’ is
          necessary when considering cross-compilation.  When
          cross-compiling, dependencies listed in ‘inputs’ are built for
          the _target_ architecture; conversely, dependencies listed in
          ‘native-inputs’ are built for the architecture of the _build_
          machine.

          ‘native-inputs’ is typically used to list tools needed at
          build time, but not at run time, such as Autoconf, Automake,
          pkg-config, Gettext, or Bison.  ‘guix lint’ can report likely
          mistakes in this area (*note 调用guix lint::).

          Lastly, ‘propagated-inputs’ is similar to ‘inputs’, but the
          specified packages will be automatically installed alongside
          the package they belong to (*note ‘guix package’:
          package-cmd-propagated-inputs, for information on how ‘guix
          package’ deals with propagated inputs).

          For example this is necessary when a C/C++ library needs
          headers of another library to compile, or when a pkg-config
          file refers to another one via its ‘Requires’ field.

          Another example where ‘propagated-inputs’ is useful is for
          languages that lack a facility to record the run-time search
          path akin to the ‘RUNPATH’ of ELF files; this includes Guile,
          Python, Perl, and more.  To ensure that libraries written in
          those languages can find library code they depend on at run
          time, run-time dependencies must be listed in
          ‘propagated-inputs’ rather than ‘inputs’.

     ‘outputs’ (default: ‘'("out")’)
          The list of output names of the package.  *Note
          有多个输出的软件包::, for typical uses of additional outputs.

     ‘native-search-paths’ (default: ‘'()’)
     ‘search-paths’ (default: ‘'()’)
          A list of ‘search-path-specification’ objects describing
          search-path environment variables honored by the package.

     ‘replacement’ (default: ‘#f’)
          This must be either ‘#f’ or a package object that will be used
          as a “replacement” for this package.  *Note grafts: 安全更新,
          for details.

     ‘synopsis’
          A one-line description of the package.

     ‘description’
          A more elaborate description of the package.

     ‘license’
          The license of the package; a value from ‘(guix licenses)’, or
          a list of such values.

     ‘home-page’
          The URL to the home-page of the package, as a string.

     ‘supported-systems’ (default: ‘%supported-systems’)
          The list of systems supported by the package, as strings of
          the form ‘architecture-kernel’, for example ‘"x86_64-linux"’.

     ‘location’ (default: source location of the ‘package’ form)
          The source location of the package.  It is useful to override
          this when inheriting from another package, in which case this
          field is not automatically corrected.

 -- Scheme Syntax: this-package
     When used in the _lexical scope_ of a package field definition,
     this identifier resolves to the package being defined.

     The example below shows how to add a package as a native input of
     itself when cross-compiling:

          (package
            (name "guile")
            ;; ...

            ;; When cross-compiled, Guile, for example, depends on
            ;; a native version of itself.  Add it here.
            (native-inputs (if (%current-target-system)
                               `(("self" ,this-package))
                               '())))

     It is an error to refer to ‘this-package’ outside a package
     definition.


File: guix.zh_CN.info,  Node: origin参考手册,  Prev: 软件包引用,  Up: 定义软件包

6.2.2 ‘origin’ Reference
------------------------

This section summarizes all the options available in ‘origin’
declarations (*note 定义软件包::).

 -- Data Type: origin
     This is the data type representing a source code origin.

     ‘uri’
          An object containing the URI of the source.  The object type
          depends on the ‘method’ (see below).  For example, when using
          the URL-FETCH method of ‘(guix download)’, the valid ‘uri’
          values are: a URL represented as a string, or a list thereof.

     ‘method’
          A procedure that handles the URI.

          Examples include:

          URL-FETCH from ‘(guix download)’
               download a file from the HTTP, HTTPS, or FTP URL
               specified in the ‘uri’ field;

          GIT-FETCH from ‘(guix git-download)’
               clone the Git version control repository, and check out
               the revision specified in the ‘uri’ field as a
               ‘git-reference’ object; a ‘git-reference’ looks like
               this:

                    (git-reference
                      (url "https://git.savannah.gnu.org/git/hello.git")
                      (commit "v2.10"))

     ‘sha256’
          A bytevector containing the SHA-256 hash of the source.  This
          is equivalent to providing a ‘content-hash’ SHA256 object in
          the ‘hash’ field described below.

     ‘hash’
          The ‘content-hash’ object of the source—see below for how to
          use ‘content-hash’.

          You can obtain this information using ‘guix download’ (*note
          调用guix download::) or ‘guix hash’ (*note 调用guix hash::).

     ‘file-name’ (default: ‘#f’)
          The file name under which the source code should be saved.
          When this is ‘#f’, a sensible default value will be used in
          most cases.  In case the source is fetched from a URL, the
          file name from the URL will be used.  For version control
          checkouts, it is recommended to provide the file name
          explicitly because the default is not very descriptive.

     ‘patches’ (default: ‘'()’)
          A list of file names, origins, or file-like objects (*note
          file-like objects: G-表达式.) pointing to patches to be
          applied to the source.

          This list of patches must be unconditional.  In particular, it
          cannot depend on the value of ‘%current-system’ or
          ‘%current-target-system’.

     ‘snippet’ (default: ‘#f’)
          A G-expression (*note G-表达式::) or S-expression that will be
          run in the source directory.  This is a convenient way to
          modify the source, sometimes more convenient than a patch.

     ‘patch-flags’ (default: ‘'("-p1")’)
          A list of command-line flags that should be passed to the
          ‘patch’ command.

     ‘patch-inputs’ (default: ‘#f’)
          Input packages or derivations to the patching process.  When
          this is ‘#f’, the usual set of inputs necessary for patching
          are provided, such as GNU Patch.

     ‘modules’ (default: ‘'()’)
          A list of Guile modules that should be loaded during the
          patching process and while running the code in the ‘snippet’
          field.

     ‘patch-guile’ (default: ‘#f’)
          The Guile package that should be used in the patching process.
          When this is ‘#f’, a sensible default is used.

 -- Data Type: content-hash VALUE [ALGORITHM]
     Construct a content hash object for the given ALGORITHM, and with
     VALUE as its hash value.  When ALGORITHM is omitted, assume it is
     ‘sha256’.

     VALUE can be a literal string, in which case it is base32-decoded,
     or it can be a bytevector.

     The following forms are all equivalent:

          (content-hash "05zxkyz9bv3j9h0xyid1rhvh3klhsmrpkf3bcs6frvlgyr2gwilj")
          (content-hash "05zxkyz9bv3j9h0xyid1rhvh3klhsmrpkf3bcs6frvlgyr2gwilj"
                        sha256)
          (content-hash (base32
                         "05zxkyz9bv3j9h0xyid1rhvh3klhsmrpkf3bcs6frvlgyr2gwilj"))
          (content-hash (base64 "kkb+RPaP7uyMZmu4eXPVkM4BN8yhRd8BTHLslb6f/Rc=")
                        sha256)

     Technically, ‘content-hash’ is currently implemented as a macro.
     It performs sanity checks at macro-expansion time, when possible,
     such as ensuring that VALUE has the right size for ALGORITHM.


File: guix.zh_CN.info,  Node: 构建系统,  Next: 仓库,  Prev: 定义软件包,  Up: 编程接口

6.3 构建系统
============

Each package definition specifies a “build system” and arguments for
that build system (*note 定义软件包::).  This ‘build-system’ field
represents the build procedure of the package, as well as implicit
dependencies of that build procedure.

   Build systems are ‘<build-system>’ objects.  The interface to create
and manipulate them is provided by the ‘(guix build-system)’ module, and
actual build systems are exported by specific modules.

   Under the hood, build systems first compile package objects to
“bags”.  A “bag” is like a package, but with less ornamentation—in other
words, a bag is a lower-level representation of a package, which
includes all the inputs of that package, including some that were
implicitly added by the build system.  This intermediate representation
is then compiled to a derivation (*note Derivations::).

   Build systems accept an optional list of “arguments”.  In package
definitions, these are passed via the ‘arguments’ field (*note
定义软件包::).  They are typically keyword arguments (*note keyword
arguments in Guile: (guile)Optional Arguments.).  The value of these
arguments is usually evaluated in the “build stratum”—i.e., by a Guile
process launched by the daemon (*note Derivations::).

   The main build system is ‘gnu-build-system’, which implements the
standard build procedure for GNU and many other packages.  It is
provided by the ‘(guix build-system gnu)’ module.

 -- Scheme Variable: gnu-build-system
     ‘gnu-build-system’ represents the GNU Build System, and variants
     thereof (*note configuration and makefile conventions:
     (standards)Configuration.).

     In a nutshell, packages using it are configured, built, and
     installed with the usual ‘./configure && make && make check && make
     install’ command sequence.  In practice, a few additional steps are
     often needed.  All these steps are split up in separate “phases”,
     notably(1):

     ‘unpack’
          Unpack the source tarball, and change the current directory to
          the extracted source tree.  If the source is actually a
          directory, copy it to the build tree, and enter that
          directory.

     ‘patch-source-shebangs’
          Patch shebangs encountered in source files so they refer to
          the right store file names.  For instance, this changes
          ‘#!/bin/sh’ to ‘#!/gnu/store/...-bash-4.3/bin/sh’.

     ‘configure’
          Run the ‘configure’ script with a number of default options,
          such as ‘--prefix=/gnu/store/...’, as well as the options
          specified by the ‘#:configure-flags’ argument.

     ‘build’
          Run ‘make’ with the list of flags specified with
          ‘#:make-flags’.  If the ‘#:parallel-build?’ argument is true
          (the default), build with ‘make -j’.

     ‘check’
          Run ‘make check’, or some other target specified with
          ‘#:test-target’, unless ‘#:tests? #f’ is passed.  If the
          ‘#:parallel-tests?’ argument is true (the default), run ‘make
          check -j’.

     ‘install’
          Run ‘make install’ with the flags listed in ‘#:make-flags’.

     ‘patch-shebangs’
          Patch shebangs on the installed executable files.

     ‘strip’
          Strip debugging symbols from ELF files (unless
          ‘#:strip-binaries?’ is false), copying them to the ‘debug’
          output when available (*note 安装调试文件::).

     The build-side module ‘(guix build gnu-build-system)’ defines
     ‘%standard-phases’ as the default list of build phases.
     ‘%standard-phases’ is a list of symbol/procedure pairs, where the
     procedure implements the actual phase.

     The list of phases used for a particular package can be changed
     with the ‘#:phases’ parameter.  For instance, passing:

          #:phases (modify-phases %standard-phases (delete 'configure))

     means that all the phases described above will be used, except the
     ‘configure’ phase.

     In addition, this build system ensures that the “standard”
     environment for GNU packages is available.  This includes tools
     such as GCC, libc, Coreutils, Bash, Make, Diffutils, grep, and sed
     (see the ‘(guix build-system gnu)’ module for a complete list).  We
     call these the “implicit inputs” of a package, because package
     definitions do not have to mention them.

   Other ‘<build-system>’ objects are defined to support other
conventions and tools used by free software packages.  They inherit most
of ‘gnu-build-system’, and differ mainly in the set of inputs implicitly
added to the build process, and in the list of phases executed.  Some of
these build systems are listed below.

 -- Scheme Variable: ant-build-system
     This variable is exported by ‘(guix build-system ant)’.  It
     implements the build procedure for Java packages that can be built
     with Ant build tool (https://ant.apache.org/).

     It adds both ‘ant’ and the “Java Development Kit” (JDK) as provided
     by the ‘icedtea’ package to the set of inputs.  Different packages
     can be specified with the ‘#:ant’ and ‘#:jdk’ parameters,
     respectively.

     When the original package does not provide a suitable Ant build
     file, the parameter ‘#:jar-name’ can be used to generate a minimal
     Ant build file ‘build.xml’ with tasks to build the specified jar
     archive.  In this case the parameter ‘#:source-dir’ can be used to
     specify the source sub-directory, defaulting to “src”.

     The ‘#:main-class’ parameter can be used with the minimal ant
     buildfile to specify the main class of the resulting jar.  This
     makes the jar file executable.  The ‘#:test-include’ parameter can
     be used to specify the list of junit tests to run.  It defaults to
     ‘(list "**/*Test.java")’.  The ‘#:test-exclude’ can be used to
     disable some tests.  It defaults to ‘(list "**/Abstract*.java")’,
     because abstract classes cannot be run as tests.

     The parameter ‘#:build-target’ can be used to specify the Ant task
     that should be run during the ‘build’ phase.  By default the “jar”
     task will be run.

 -- Scheme Variable: android-ndk-build-system
     This variable is exported by ‘(guix build-system android-ndk)’.  It
     implements a build procedure for Android NDK (native development
     kit) packages using a Guix-specific build process.

     The build system assumes that packages install their public
     interface (header) files to the subdirectory ‘include’ of the ‘out’
     output and their libraries to the subdirectory ‘lib’ the ‘out’
     output.

     It’s also assumed that the union of all the dependencies of a
     package has no conflicting files.

     For the time being, cross-compilation is not supported - so right
     now the libraries and header files are assumed to be host tools.

 -- Scheme Variable: asdf-build-system/source
 -- Scheme Variable: asdf-build-system/sbcl
 -- Scheme Variable: asdf-build-system/ecl

     These variables, exported by ‘(guix build-system asdf)’, implement
     build procedures for Common Lisp packages using “ASDF”
     (https://common-lisp.net/project/asdf/).  ASDF is a system
     definition facility for Common Lisp programs and libraries.

     The ‘asdf-build-system/source’ system installs the packages in
     source form, and can be loaded using any common lisp
     implementation, via ASDF. The others, such as
     ‘asdf-build-system/sbcl’, install binary systems in the format
     which a particular implementation understands.  These build systems
     can also be used to produce executable programs, or lisp images
     which contain a set of packages pre-loaded.

     The build system uses naming conventions.  For binary packages, the
     package name should be prefixed with the lisp implementation, such
     as ‘sbcl-’ for ‘asdf-build-system/sbcl’.

     Additionally, the corresponding source package should be labeled
     using the same convention as python packages (see *note
     Python模块::), using the ‘cl-’ prefix.

     For binary packages, each system should be defined as a Guix
     package.  If one package ‘origin’ contains several systems, package
     variants can be created in order to build all the systems.  Source
     packages, which use ‘asdf-build-system/source’, may contain several
     systems.

     In order to create executable programs and images, the build-side
     procedures ‘build-program’ and ‘build-image’ can be used.  They
     should be called in a build phase after the ‘create-symlinks’
     phase, so that the system which was just built can be used within
     the resulting image.  ‘build-program’ requires a list of Common
     Lisp expressions to be passed as the ‘#:entry-program’ argument.

     If the system is not defined within its own ‘.asd’ file of the same
     name, then the ‘#:asd-file’ parameter should be used to specify
     which file the system is defined in.  Furthermore, if the package
     defines a system for its tests in a separate file, it will be
     loaded before the tests are run if it is specified by the
     ‘#:test-asd-file’ parameter.  If it is not set, the files
     ‘<system>-tests.asd’, ‘<system>-test.asd’, ‘tests.asd’, and
     ‘test.asd’ will be tried if they exist.

     If for some reason the package must be named in a different way
     than the naming conventions suggest, the ‘#:asd-system-name’
     parameter can be used to specify the name of the system.

 -- Scheme Variable: cargo-build-system
     This variable is exported by ‘(guix build-system cargo)’.  It
     supports builds of packages using Cargo, the build tool of the Rust
     programming language (https://www.rust-lang.org).

     It adds ‘rustc’ and ‘cargo’ to the set of inputs.  A different Rust
     package can be specified with the ‘#:rust’ parameter.

     Regular cargo dependencies should be added to the package
     definition via the ‘#:cargo-inputs’ parameter as a list of name and
     spec pairs, where the spec can be a package or a source definition.
     Note that the spec must evaluate to a path to a gzipped tarball
     which includes a ‘Cargo.toml’ file at its root, or it will be
     ignored.  Similarly, cargo dev-dependencies should be added to the
     package definition via the ‘#:cargo-development-inputs’ parameter.

     In its ‘configure’ phase, this build system will make any source
     inputs specified in the ‘#:cargo-inputs’ and
     ‘#:cargo-development-inputs’ parameters available to cargo.  It
     will also remove an included ‘Cargo.lock’ file to be recreated by
     ‘cargo’ during the ‘build’ phase.  The ‘install’ phase installs any
     crate the binaries if they are defined by the crate.

 -- Scheme Variable: copy-build-system
     This variable is exported by ‘(guix build-system copy)’.  It
     supports builds of simple packages that don’t require much
     compiling, mostly just moving files around.

     It adds much of the ‘gnu-build-system’ packages to the set of
     inputs.  Because of this, the ‘copy-build-system’ does not require
     all the boilerplate code often needed for the
     ‘trivial-build-system’.

     To further simplify the file installation process, an
     ‘#:install-plan’ argument is exposed to let the packager specify
     which files go where.  The install plan is a list of ‘(SOURCE
     TARGET [FILTERS])’.  FILTERS are optional.

        • When SOURCE matches a file or directory without trailing
          slash, install it to TARGET.
             • If TARGET has a trailing slash, install SOURCE basename
               beneath TARGET.
             • Otherwise install SOURCE as TARGET.

        • When SOURCE is a directory with a trailing slash, or when
          FILTERS are used, the trailing slash of TARGET is implied with
          the same meaning as above.
             • Without FILTERS, install the full SOURCE _content_ to
               TARGET.
             • With FILTERS among ‘#:include’, ‘#:include-regexp’,
               ‘#:exclude’, ‘#:exclude-regexp’, only select files are
               installed depending on the filters.  Each filters is
               specified by a list of strings.
                  • With ‘#:include’, install all the files which the
                    path suffix matches at least one of the elements in
                    the given list.
                  • With ‘#:include-regexp’, install all the files which
                    the subpaths match at least one of the regular
                    expressions in the given list.
                  • The ‘#:exclude’ and ‘#:exclude-regexp’ filters are
                    the complement of their inclusion counterpart.
                    Without ‘#:include’ flags, install all files but
                    those matching the exclusion filters.  If both
                    inclusions and exclusions are specified, the
                    exclusions are done on top of the inclusions.
          In all cases, the paths relative to SOURCE are preserved
          within TARGET.

     Examples:

        • ‘("foo/bar" "share/my-app/")’: Install ‘bar’ to
          ‘share/my-app/bar’.
        • ‘("foo/bar" "share/my-app/baz")’: Install ‘bar’ to
          ‘share/my-app/baz’.
        • ‘("foo/" "share/my-app")’: Install the content of ‘foo’ inside
          ‘share/my-app’, e.g., install ‘foo/sub/file’ to
          ‘share/my-app/sub/file’.
        • ‘("foo/" "share/my-app" #:include ("sub/file"))’: Install only
          ‘foo/sub/file’ to ‘share/my-app/sub/file’.
        • ‘("foo/sub" "share/my-app" #:include ("file"))’: Install
          ‘foo/sub/file’ to ‘share/my-app/file’.

 -- Scheme Variable: clojure-build-system
     This variable is exported by ‘(guix build-system clojure)’.  It
     implements a simple build procedure for Clojure
     (https://clojure.org/) packages using plain old ‘compile’ in
     Clojure.  Cross-compilation is not supported yet.

     It adds ‘clojure’, ‘icedtea’ and ‘zip’ to the set of inputs.
     Different packages can be specified with the ‘#:clojure’, ‘#:jdk’
     and ‘#:zip’ parameters, respectively.

     A list of source directories, test directories and jar names can be
     specified with the ‘#:source-dirs’, ‘#:test-dirs’ and ‘#:jar-names’
     parameters, respectively.  Compile directory and main class can be
     specified with the ‘#:compile-dir’ and ‘#:main-class’ parameters,
     respectively.  Other parameters are documented below.

     This build system is an extension of ‘ant-build-system’, but with
     the following phases changed:

     ‘build’
          This phase calls ‘compile’ in Clojure to compile source files
          and runs ‘jar’ to create jars from both source files and
          compiled files according to the include list and exclude list
          specified in ‘#:aot-include’ and ‘#:aot-exclude’,
          respectively.  The exclude list has priority over the include
          list.  These lists consist of symbols representing Clojure
          libraries or the special keyword ‘#:all’ representing all
          Clojure libraries found under the source directories.  The
          parameter ‘#:omit-source?’ decides if source should be
          included into the jars.

     ‘check’
          This phase runs tests according to the include list and
          exclude list specified in ‘#:test-include’ and
          ‘#:test-exclude’, respectively.  Their meanings are analogous
          to that of ‘#:aot-include’ and ‘#:aot-exclude’, except that
          the special keyword ‘#:all’ now stands for all Clojure
          libraries found under the test directories.  The parameter
          ‘#:tests?’ decides if tests should be run.

     ‘install’
          This phase installs all jars built previously.

     Apart from the above, this build system also contains an additional
     phase:

     ‘install-doc’
          This phase installs all top-level files with base name
          matching ‘%doc-regex’.  A different regex can be specified
          with the ‘#:doc-regex’ parameter.  All files (recursively)
          inside the documentation directories specified in ‘#:doc-dirs’
          are installed as well.

 -- Scheme Variable: cmake-build-system
     This variable is exported by ‘(guix build-system cmake)’.  It
     implements the build procedure for packages using the CMake build
     tool (https://www.cmake.org).

     It automatically adds the ‘cmake’ package to the set of inputs.
     Which package is used can be specified with the ‘#:cmake’
     parameter.

     The ‘#:configure-flags’ parameter is taken as a list of flags
     passed to the ‘cmake’ command.  The ‘#:build-type’ parameter
     specifies in abstract terms the flags passed to the compiler; it
     defaults to ‘"RelWithDebInfo"’ (short for “release mode with
     debugging information”), which roughly means that code is compiled
     with ‘-O2 -g’, as is the case for Autoconf-based packages by
     default.

 -- Scheme Variable: dune-build-system
     This variable is exported by ‘(guix build-system dune)’.  It
     supports builds of packages using Dune (https://dune.build/), a
     build tool for the OCaml programming language.  It is implemented
     as an extension of the ‘ocaml-build-system’ which is described
     below.  As such, the ‘#:ocaml’ and ‘#:findlib’ parameters can be
     passed to this build system.

     It automatically adds the ‘dune’ package to the set of inputs.
     Which package is used can be specified with the ‘#:dune’ parameter.

     There is no ‘configure’ phase because dune packages typically don’t
     need to be configured.  The ‘#:build-flags’ parameter is taken as a
     list of flags passed to the ‘dune’ command during the build.

     The ‘#:jbuild?’ parameter can be passed to use the ‘jbuild’ command
     instead of the more recent ‘dune’ command while building a package.
     Its default value is ‘#f’.

     The ‘#:package’ parameter can be passed to specify a package name,
     which is useful when a package contains multiple packages and you
     want to build only one of them.  This is equivalent to passing the
     ‘-p’ argument to ‘dune’.

 -- Scheme Variable: go-build-system
     This variable is exported by ‘(guix build-system go)’.  It
     implements a build procedure for Go packages using the standard Go
     build mechanisms
     (https://golang.org/cmd/go/#hdr-Compile_packages_and_dependencies).

     The user is expected to provide a value for the key ‘#:import-path’
     and, in some cases, ‘#:unpack-path’.  The import path
     (https://golang.org/doc/code.html#ImportPaths) corresponds to the
     file system path expected by the package’s build scripts and any
     referring packages, and provides a unique way to refer to a Go
     package.  It is typically based on a combination of the package
     source code’s remote URI and file system hierarchy structure.  In
     some cases, you will need to unpack the package’s source code to a
     different directory structure than the one indicated by the import
     path, and ‘#:unpack-path’ should be used in such cases.

     Packages that provide Go libraries should install their source code
     into the built output.  The key ‘#:install-source?’, which defaults
     to ‘#t’, controls whether or not the source code is installed.  It
     can be set to ‘#f’ for packages that only provide executable files.

 -- Scheme Variable: glib-or-gtk-build-system
     This variable is exported by ‘(guix build-system glib-or-gtk)’.  It
     is intended for use with packages making use of GLib or GTK+.

     This build system adds the following two phases to the ones defined
     by ‘gnu-build-system’:

     ‘glib-or-gtk-wrap’
          The phase ‘glib-or-gtk-wrap’ ensures that programs in ‘bin/’
          are able to find GLib “schemas” and GTK+ modules
          (https://developer.gnome.org/gtk3/stable/gtk-running.html).
          This is achieved by wrapping the programs in launch scripts
          that appropriately set the ‘XDG_DATA_DIRS’ and ‘GTK_PATH’
          environment variables.

          It is possible to exclude specific package outputs from that
          wrapping process by listing their names in the
          ‘#:glib-or-gtk-wrap-excluded-outputs’ parameter.  This is
          useful when an output is known not to contain any GLib or GTK+
          binaries, and where wrapping would gratuitously add a
          dependency of that output on GLib and GTK+.

     ‘glib-or-gtk-compile-schemas’
          The phase ‘glib-or-gtk-compile-schemas’ makes sure that all
          GSettings schemas
          (https://developer.gnome.org/gio/stable/glib-compile-schemas.html)
          of GLib are compiled.  Compilation is performed by the
          ‘glib-compile-schemas’ program.  It is provided by the package
          ‘glib:bin’ which is automatically imported by the build
          system.  The ‘glib’ package providing ‘glib-compile-schemas’
          can be specified with the ‘#:glib’ parameter.

     Both phases are executed after the ‘install’ phase.

 -- Scheme Variable: guile-build-system
     This build system is for Guile packages that consist exclusively of
     Scheme code and that are so lean that they don’t even have a
     makefile, let alone a ‘configure’ script.  It compiles Scheme code
     using ‘guild compile’ (*note (guile)Compilation::) and installs the
     ‘.scm’ and ‘.go’ files in the right place.  It also installs
     documentation.

     This build system supports cross-compilation by using the
     ‘--target’ option of ‘guild compile’.

     Packages built with ‘guile-build-system’ must provide a Guile
     package in their ‘native-inputs’ field.

 -- Scheme Variable: julia-build-system
     This variable is exported by ‘(guix build-system julia)’.  It
     implements the build procedure used by julia
     (https://julialang.org/) packages, which essentially is similar to
     running ‘julia -e 'using Pkg; Pkg.add(package)'’ in an environment
     where ‘JULIA_LOAD_PATH’ contains the paths to all Julia package
     inputs.  Tests are run not run.

     Julia packages require the source ‘file-name’ to be the real name
     of the package, correctly capitalized.

     For packages requiring shared library dependencies, you may need to
     write the ‘/deps/deps.jl’ file manually.  It’s usually a line of
     ‘const variable = /gnu/store/library.so’ for each dependency, plus
     a void function ‘check_deps() = nothing’.

     Some older packages that aren’t using ‘Package.toml’ yet, will
     require this file to be created, too.  The function
     ‘julia-create-package-toml’ helps creating the file.  You need to
     pass the outputs and the source of the package, it’s name (the same
     as the ‘file-name’ parameter), the package uuid, the package
     version, and a list of dependencies specified by their name and
     their uuid.

 -- Scheme Variable: minify-build-system
     This variable is exported by ‘(guix build-system minify)’.  It
     implements a minification procedure for simple JavaScript packages.

     It adds ‘uglify-js’ to the set of inputs and uses it to compress
     all JavaScript files in the ‘src’ directory.  A different minifier
     package can be specified with the ‘#:uglify-js’ parameter, but it
     is expected that the package writes the minified code to the
     standard output.

     When the input JavaScript files are not all located in the ‘src’
     directory, the parameter ‘#:javascript-files’ can be used to
     specify a list of file names to feed to the minifier.

 -- Scheme Variable: ocaml-build-system
     This variable is exported by ‘(guix build-system ocaml)’.  It
     implements a build procedure for OCaml (https://ocaml.org)
     packages, which consists of choosing the correct set of commands to
     run for each package.  OCaml packages can expect many different
     commands to be run.  This build system will try some of them.

     When the package has a ‘setup.ml’ file present at the top-level, it
     will run ‘ocaml setup.ml -configure’, ‘ocaml setup.ml -build’ and
     ‘ocaml setup.ml -install’.  The build system will assume that this
     file was generated by OASIS (http://oasis.forge.ocamlcore.org/) and
     will take care of setting the prefix and enabling tests if they are
     not disabled.  You can pass configure and build flags with the
     ‘#:configure-flags’ and ‘#:build-flags’.  The ‘#:test-flags’ key
     can be passed to change the set of flags used to enable tests.  The
     ‘#:use-make?’ key can be used to bypass this system in the build
     and install phases.

     When the package has a ‘configure’ file, it is assumed that it is a
     hand-made configure script that requires a different argument
     format than in the ‘gnu-build-system’.  You can add more flags with
     the ‘#:configure-flags’ key.

     When the package has a ‘Makefile’ file (or ‘#:use-make?’ is ‘#t’),
     it will be used and more flags can be passed to the build and
     install phases with the ‘#:make-flags’ key.

     Finally, some packages do not have these files and use a somewhat
     standard location for its build system.  In that case, the build
     system will run ‘ocaml pkg/pkg.ml’ or ‘ocaml pkg/build.ml’ and take
     care of providing the path to the required findlib module.
     Additional flags can be passed via the ‘#:build-flags’ key.
     Install is taken care of by ‘opam-installer’.  In this case, the
     ‘opam’ package must be added to the ‘native-inputs’ field of the
     package definition.

     Note that most OCaml packages assume they will be installed in the
     same directory as OCaml, which is not what we want in guix.  In
     particular, they will install ‘.so’ files in their module’s
     directory, which is usually fine because it is in the OCaml
     compiler directory.  In guix though, these libraries cannot be
     found and we use ‘CAML_LD_LIBRARY_PATH’.  This variable points to
     ‘lib/ocaml/site-lib/stubslibs’ and this is where ‘.so’ libraries
     should be installed.

 -- Scheme Variable: python-build-system
     This variable is exported by ‘(guix build-system python)’.  It
     implements the more or less standard build procedure used by Python
     packages, which consists in running ‘python setup.py build’ and
     then ‘python setup.py install --prefix=/gnu/store/...’.

     For packages that install stand-alone Python programs under ‘bin/’,
     it takes care of wrapping these programs so that their ‘PYTHONPATH’
     environment variable points to all the Python libraries they depend
     on.

     Which Python package is used to perform the build can be specified
     with the ‘#:python’ parameter.  This is a useful way to force a
     package to be built for a specific version of the Python
     interpreter, which might be necessary if the package is only
     compatible with a single interpreter version.

     By default guix calls ‘setup.py’ under control of ‘setuptools’,
     much like ‘pip’ does.  Some packages are not compatible with
     setuptools (and pip), thus you can disable this by setting the
     ‘#:use-setuptools?’ parameter to ‘#f’.

 -- Scheme Variable: perl-build-system
     This variable is exported by ‘(guix build-system perl)’.  It
     implements the standard build procedure for Perl packages, which
     either consists in running ‘perl Build.PL --prefix=/gnu/store/...’,
     followed by ‘Build’ and ‘Build install’; or in running ‘perl
     Makefile.PL PREFIX=/gnu/store/...’, followed by ‘make’ and ‘make
     install’, depending on which of ‘Build.PL’ or ‘Makefile.PL’ is
     present in the package distribution.  Preference is given to the
     former if both ‘Build.PL’ and ‘Makefile.PL’ exist in the package
     distribution.  This preference can be reversed by specifying ‘#t’
     for the ‘#:make-maker?’ parameter.

     The initial ‘perl Makefile.PL’ or ‘perl Build.PL’ invocation passes
     flags specified by the ‘#:make-maker-flags’ or
     ‘#:module-build-flags’ parameter, respectively.

     Which Perl package is used can be specified with ‘#:perl’.

 -- Scheme Variable: qt-build-system
     This variable is exported by ‘(guix build-system qt)’.  It is
     intended for use with applications using Qt or KDE.

     This build system adds the following two phases to the ones defined
     by ‘cmake-build-system’:

     ‘check-setup’
          The phase ‘check-setup’ prepares the environment for running
          the checks as commonly used by Qt test programs.  For now this
          only sets some environment variables:
          ‘QT_QPA_PLATFORM=offscreen’, ‘DBUS_FATAL_WARNINGS=0’ and
          ‘CTEST_OUTPUT_ON_FAILURE=1’.

          This phase is added before the ‘check’ phase.  It’s a separate
          phase to ease adjusting if necessary.

     ‘qt-wrap’
          The phase ‘qt-wrap’ searches for Qt5 plugin paths, QML paths
          and some XDG in the inputs and output.  In case some path is
          found, all programs in the output’s ‘bin/’, ‘sbin/’,
          ‘libexec/’ and ‘lib/libexec/’ directories are wrapped in
          scripts defining the necessary environment variables.

          It is possible to exclude specific package outputs from that
          wrapping process by listing their names in the
          ‘#:qt-wrap-excluded-outputs’ parameter.  This is useful when
          an output is known not to contain any Qt binaries, and where
          wrapping would gratuitously add a dependency of that output on
          Qt, KDE, or such.

          This phase is added after the ‘install’ phase.

 -- Scheme Variable: r-build-system
     This variable is exported by ‘(guix build-system r)’.  It
     implements the build procedure used by R (https://r-project.org)
     packages, which essentially is little more than running ‘R CMD
     INSTALL --library=/gnu/store/...’ in an environment where
     ‘R_LIBS_SITE’ contains the paths to all R package inputs.  Tests
     are run after installation using the R function
     ‘tools::testInstalledPackage’.

 -- Scheme Variable: rakudo-build-system
     This variable is exported by ‘(guix build-system rakudo)’.  It
     implements the build procedure used by Rakudo (https://rakudo.org/)
     for Perl6 (https://perl6.org/) packages.  It installs the package
     to ‘/gnu/store/.../NAME-VERSION/share/perl6’ and installs the
     binaries, library files and the resources, as well as wrap the
     files under the ‘bin/’ directory.  Tests can be skipped by passing
     ‘#f’ to the ‘tests?’ parameter.

     Which rakudo package is used can be specified with ‘rakudo’.  Which
     perl6-tap-harness package used for the tests can be specified with
     ‘#:prove6’ or removed by passing ‘#f’ to the ‘with-prove6?’
     parameter.  Which perl6-zef package used for tests and installing
     can be specified with ‘#:zef’ or removed by passing ‘#f’ to the
     ‘with-zef?’ parameter.

 -- Scheme Variable: texlive-build-system
     This variable is exported by ‘(guix build-system texlive)’.  It is
     used to build TeX packages in batch mode with a specified engine.
     The build system sets the ‘TEXINPUTS’ variable to find all TeX
     source files in the inputs.

     By default it runs ‘luatex’ on all files ending on ‘ins’.  A
     different engine and format can be specified with the
     ‘#:tex-format’ argument.  Different build targets can be specified
     with the ‘#:build-targets’ argument, which expects a list of file
     names.  The build system adds only ‘texlive-bin’ and
     ‘texlive-latex-base’ (both from ‘(gnu packages tex’) to the inputs.
     Both can be overridden with the arguments ‘#:texlive-bin’ and
     ‘#:texlive-latex-base’, respectively.

     The ‘#:tex-directory’ parameter tells the build system where to
     install the built files under the texmf tree.

 -- Scheme Variable: ruby-build-system
     This variable is exported by ‘(guix build-system ruby)’.  It
     implements the RubyGems build procedure used by Ruby packages,
     which involves running ‘gem build’ followed by ‘gem install’.

     The ‘source’ field of a package that uses this build system
     typically references a gem archive, since this is the format that
     Ruby developers use when releasing their software.  The build
     system unpacks the gem archive, potentially patches the source,
     runs the test suite, repackages the gem, and installs it.
     Additionally, directories and tarballs may be referenced to allow
     building unreleased gems from Git or a traditional source release
     tarball.

     Which Ruby package is used can be specified with the ‘#:ruby’
     parameter.  A list of additional flags to be passed to the ‘gem’
     command can be specified with the ‘#:gem-flags’ parameter.

 -- Scheme Variable: waf-build-system
     This variable is exported by ‘(guix build-system waf)’.  It
     implements a build procedure around the ‘waf’ script.  The common
     phases—‘configure’, ‘build’, and ‘install’—are implemented by
     passing their names as arguments to the ‘waf’ script.

     The ‘waf’ script is executed by the Python interpreter.  Which
     Python package is used to run the script can be specified with the
     ‘#:python’ parameter.

 -- Scheme Variable: scons-build-system
     This variable is exported by ‘(guix build-system scons)’.  It
     implements the build procedure used by the SCons software
     construction tool.  This build system runs ‘scons’ to build the
     package, ‘scons test’ to run tests, and then ‘scons install’ to
     install the package.

     Additional flags to be passed to ‘scons’ can be specified with the
     ‘#:scons-flags’ parameter.  The default build and install targets
     can be overridden with ‘#:build-targets’ and ‘#:install-targets’
     respectively.  The version of Python used to run SCons can be
     specified by selecting the appropriate SCons package with the
     ‘#:scons’ parameter.

 -- Scheme Variable: haskell-build-system
     This variable is exported by ‘(guix build-system haskell)’.  It
     implements the Cabal build procedure used by Haskell packages,
     which involves running ‘runhaskell Setup.hs configure
     --prefix=/gnu/store/...’ and ‘runhaskell Setup.hs build’.  Instead
     of installing the package by running ‘runhaskell Setup.hs install’,
     to avoid trying to register libraries in the read-only compiler
     store directory, the build system uses ‘runhaskell Setup.hs copy’,
     followed by ‘runhaskell Setup.hs register’.  In addition, the build
     system generates the package documentation by running ‘runhaskell
     Setup.hs haddock’, unless ‘#:haddock? #f’ is passed.  Optional
     Haddock parameters can be passed with the help of the
     ‘#:haddock-flags’ parameter.  If the file ‘Setup.hs’ is not found,
     the build system looks for ‘Setup.lhs’ instead.

     Which Haskell compiler is used can be specified with the
     ‘#:haskell’ parameter which defaults to ‘ghc’.

 -- Scheme Variable: dub-build-system
     This variable is exported by ‘(guix build-system dub)’.  It
     implements the Dub build procedure used by D packages, which
     involves running ‘dub build’ and ‘dub run’.  Installation is done
     by copying the files manually.

     Which D compiler is used can be specified with the ‘#:ldc’
     parameter which defaults to ‘ldc’.

 -- Scheme Variable: emacs-build-system
     This variable is exported by ‘(guix build-system emacs)’.  It
     implements an installation procedure similar to the packaging
     system of Emacs itself (*note (emacs)Packages::).

     It first creates the ‘package-autoloads.el’ file, then it byte
     compiles all Emacs Lisp files.  Differently from the Emacs
     packaging system, the Info documentation files are moved to the
     standard documentation directory and the ‘dir’ file is deleted.
     The Elisp package files are installed directly under
     ‘share/emacs/site-lisp’.

 -- Scheme Variable: font-build-system
     This variable is exported by ‘(guix build-system font)’.  It
     implements an installation procedure for font packages where
     upstream provides pre-compiled TrueType, OpenType, etc. font files
     that merely need to be copied into place.  It copies font files to
     standard locations in the output directory.

 -- Scheme Variable: meson-build-system
     This variable is exported by ‘(guix build-system meson)’.  It
     implements the build procedure for packages that use Meson
     (https://mesonbuild.com) as their build system.

     It adds both Meson and Ninja (https://ninja-build.org/) to the set
     of inputs, and they can be changed with the parameters ‘#:meson’
     and ‘#:ninja’ if needed.  The default Meson is ‘meson-for-build’,
     which is special because it doesn’t clear the ‘RUNPATH’ of binaries
     and libraries when they are installed.

     This build system is an extension of ‘gnu-build-system’, but with
     the following phases changed to some specific for Meson:

     ‘configure’
          The phase runs ‘meson’ with the flags specified in
          ‘#:configure-flags’.  The flag ‘--buildtype’ is always set to
          ‘debugoptimized’ unless something else is specified in
          ‘#:build-type’.

     ‘build’
          The phase runs ‘ninja’ to build the package in parallel by
          default, but this can be changed with ‘#:parallel-build?’.

     ‘check’
          The phase runs ‘ninja’ with the target specified in
          ‘#:test-target’, which is ‘"test"’ by default.

     ‘install’
          The phase runs ‘ninja install’ and can not be changed.

     Apart from that, the build system also adds the following phases:

     ‘fix-runpath’
          This phase ensures that all binaries can find the libraries
          they need.  It searches for required libraries in
          subdirectories of the package being built, and adds those to
          ‘RUNPATH’ where needed.  It also removes references to
          libraries left over from the build phase by ‘meson-for-build’,
          such as test dependencies, that aren’t actually required for
          the program to run.

     ‘glib-or-gtk-wrap’
          This phase is the phase provided by
          ‘glib-or-gtk-build-system’, and it is not enabled by default.
          It can be enabled with ‘#:glib-or-gtk?’.

     ‘glib-or-gtk-compile-schemas’
          This phase is the phase provided by
          ‘glib-or-gtk-build-system’, and it is not enabled by default.
          It can be enabled with ‘#:glib-or-gtk?’.

 -- Scheme Variable: linux-module-build-system
     ‘linux-module-build-system’ allows building Linux kernel modules.

     This build system is an extension of ‘gnu-build-system’, but with
     the following phases changed:

     ‘configure’
          This phase configures the environment so that the Linux
          kernel’s Makefile can be used to build the external kernel
          module.

     ‘build’
          This phase uses the Linux kernel’s Makefile in order to build
          the external kernel module.

     ‘install’
          This phase uses the Linux kernel’s Makefile in order to
          install the external kernel module.

     It is possible and useful to specify the Linux kernel to use for
     building the module (in the ‘arguments’ form of a package using the
     ‘linux-module-build-system’, use the key ‘#:linux’ to specify it).

 -- Scheme Variable: node-build-system
     This variable is exported by ‘(guix build-system node)’.  It
     implements the build procedure used by Node.js
     (https://nodejs.org), which implements an approximation of the ‘npm
     install’ command, followed by an ‘npm test’ command.

     Which Node.js package is used to interpret the ‘npm’ commands can
     be specified with the ‘#:node’ parameter which defaults to ‘node’.

   Lastly, for packages that do not need anything as sophisticated, a
“trivial” build system is provided.  It is trivial in the sense that it
provides basically no support: it does not pull any implicit inputs, and
does not have a notion of build phases.

 -- Scheme Variable: trivial-build-system
     This variable is exported by ‘(guix build-system trivial)’.

     This build system requires a ‘#:builder’ argument.  This argument
     must be a Scheme expression that builds the package output(s)—as
     with ‘build-expression->derivation’ (*note
     ‘build-expression->derivation’: Derivations.).

   ---------- Footnotes ----------

   (1) Please see the ‘(guix build gnu-build-system)’ modules for more
details about the build phases.


File: guix.zh_CN.info,  Node: 仓库,  Next: Derivations,  Prev: 构建系统,  Up: 编程接口

6.4 仓库
========

Conceptually, the “store” is the place where derivations that have been
built successfully are stored—by default, ‘/gnu/store’.  Sub-directories
in the store are referred to as “store items” or sometimes “store
paths”.  The store has an associated database that contains information
such as the store paths referred to by each store path, and the list of
_valid_ store items—results of successful builds.  This database resides
in ‘LOCALSTATEDIR/guix/db’, where LOCALSTATEDIR is the state directory
specified via ‘--localstatedir’ at configure time, usually ‘/var’.

   The store is _always_ accessed by the daemon on behalf of its clients
(*note 调用guix-daemon::).  To manipulate the store, clients connect to
the daemon over a Unix-domain socket, send requests to it, and read the
result—these are remote procedure calls, or RPCs.

     注: Users must _never_ modify files under ‘/gnu/store’ directly.
     This would lead to inconsistencies and break the immutability
     assumptions of Guix’s functional model (*note 介绍::).

     *Note ‘guix gc --verify’: 调用guix gc, for information on how to
     check the integrity of the store and attempt recovery from
     accidental modifications.

   The ‘(guix store)’ module provides procedures to connect to the
daemon, and to perform RPCs.  These are described below.  By default,
‘open-connection’, and thus all the ‘guix’ commands, connect to the
local daemon or to the URI specified by the ‘GUIX_DAEMON_SOCKET’
environment variable.

 -- Environment Variable: GUIX_DAEMON_SOCKET
     When set, the value of this variable should be a file name or a URI
     designating the daemon endpoint.  When it is a file name, it
     denotes a Unix-domain socket to connect to.  In addition to file
     names, the supported URI schemes are:

     ‘file’
     ‘unix’
          These are for Unix-domain sockets.
          ‘file:///var/guix/daemon-socket/socket’ is equivalent to
          ‘/var/guix/daemon-socket/socket’.

     ‘guix’
          These URIs denote connections over TCP/IP, without encryption
          nor authentication of the remote host.  The URI must specify
          the host name and optionally a port number (by default port
          44146 is used):

               guix://master.guix.example.org:1234

          This setup is suitable on local networks, such as clusters,
          where only trusted nodes may connect to the build daemon at
          ‘master.guix.example.org’.

          The ‘--listen’ option of ‘guix-daemon’ can be used to instruct
          it to listen for TCP connections (*note ‘--listen’:
          调用guix-daemon.).

     ‘ssh’
          These URIs allow you to connect to a remote daemon over SSH.
          This feature requires Guile-SSH (*note 需求::) and a working
          ‘guile’ binary in ‘PATH’ on the destination machine.  It
          supports public key and GSSAPI authentication.  A typical URL
          might look like this:

               ssh://charlie@guix.example.org:22

          As for ‘guix copy’, the usual OpenSSH client configuration
          files are honored (*note 调用guix copy::).

     Additional URI schemes may be supported in the future.

          注: The ability to connect to remote build daemons is
          considered experimental as of 1.0.1.17089-7e269.  Please get
          in touch with us to share any problems or suggestions you may
          have (*note 贡献::).

 -- Scheme Procedure: open-connection [URI] [#:reserve-space? #t]
     Connect to the daemon over the Unix-domain socket at URI (a
     string).  When RESERVE-SPACE? is true, instruct it to reserve a
     little bit of extra space on the file system so that the garbage
     collector can still operate should the disk become full.  Return a
     server object.

     FILE defaults to ‘%default-socket-path’, which is the normal
     location given the options that were passed to ‘configure’.

 -- Scheme Procedure: close-connection SERVER
     Close the connection to SERVER.

 -- Scheme Variable: current-build-output-port
     This variable is bound to a SRFI-39 parameter, which refers to the
     port where build and error logs sent by the daemon should be
     written.

   Procedures that make RPCs all take a server object as their first
argument.

 -- Scheme Procedure: valid-path? SERVER PATH
     Return ‘#t’ when PATH designates a valid store item and ‘#f’
     otherwise (an invalid item may exist on disk but still be invalid,
     for instance because it is the result of an aborted or failed
     build).

     A ‘&store-protocol-error’ condition is raised if PATH is not
     prefixed by the store directory (‘/gnu/store’).

 -- Scheme Procedure: add-text-to-store SERVER NAME TEXT [REFERENCES]
     Add TEXT under file NAME in the store, and return its store path.
     REFERENCES is the list of store paths referred to by the resulting
     store path.

 -- Scheme Procedure: build-derivations STORE DERIVATIONS [MODE] Build
          DERIVATIONS, a list of ‘<derivation>’ objects,
     ‘.drv’ file names, or derivation/output pairs, using the specified
     MODE—‘(build-mode normal)’ by default.

   Note that the ‘(guix monads)’ module provides a monad as well as
monadic versions of the above procedures, with the goal of making it
more convenient to work with code that accesses the store (*note
仓库monad::).

   This section is currently incomplete.


File: guix.zh_CN.info,  Node: Derivations,  Next: 仓库monad,  Prev: 仓库,  Up: 编程接口

6.5 Derivations
===============

Low-level build actions and the environment in which they are performed
are represented by “derivations”.  A derivation contains the following
pieces of information:

   • The outputs of the derivation—derivations produce at least one file
     or directory in the store, but may produce more.

   • The inputs of the derivations—i.e., its build-time
     dependencies—which may be other derivations or plain files in the
     store (patches, build scripts, etc.).

   • The system type targeted by the derivation—e.g., ‘x86_64-linux’.

   • The file name of a build script in the store, along with the
     arguments to be passed.

   • A list of environment variables to be defined.

   Derivations allow clients of the daemon to communicate build actions
to the store.  They exist in two forms: as an in-memory representation,
both on the client- and daemon-side, and as files in the store whose
name end in ‘.drv’—these files are referred to as “derivation paths”.
Derivations paths can be passed to the ‘build-derivations’ procedure to
perform the build actions they prescribe (*note 仓库::).

   Operations such as file downloads and version-control checkouts for
which the expected content hash is known in advance are modeled as
“fixed-output derivations”.  Unlike regular derivations, the outputs of
a fixed-output derivation are independent of its inputs—e.g., a source
code download produces the same result regardless of the download method
and tools being used.

   The outputs of derivations—i.e., the build results—have a set of
“references”, as reported by the ‘references’ RPC or the ‘guix gc
--references’ command (*note 调用guix gc::).  References are the set of
run-time dependencies of the build results.  References are a subset of
the inputs of the derivation; this subset is automatically computed by
the build daemon by scanning all the files in the outputs.

   The ‘(guix derivations)’ module provides a representation of
derivations as Scheme objects, along with procedures to create and
otherwise manipulate derivations.  The lowest-level primitive to create
a derivation is the ‘derivation’ procedure:

 -- Scheme Procedure: derivation STORE NAME BUILDER ARGS [#:outputs
          '("out")] [#:hash #f] [#:hash-algo #f]  [#:recursive?
     #f] [#:inputs ’()] [#:env-vars ’()]  [#:system (%current-system)]
     [#:references-graphs #f]  [#:allowed-references #f]
     [#:disallowed-references #f]  [#:leaked-env-vars #f]
     [#:local-build?  #f]  [#:substitutable?  #t] [#:properties ’()]
     Build a derivation with the given arguments, and return the
     resulting ‘<derivation>’ object.

     When HASH and HASH-ALGO are given, a “fixed-output derivation” is
     created—i.e., one whose result is known in advance, such as a file
     download.  If, in addition, RECURSIVE? is true, then that fixed
     output may be an executable file or a directory and HASH must be
     the hash of an archive containing this output.

     When REFERENCES-GRAPHS is true, it must be a list of file
     name/store path pairs.  In that case, the reference graph of each
     store path is exported in the build environment in the
     corresponding file, in a simple text format.

     When ALLOWED-REFERENCES is true, it must be a list of store items
     or outputs that the derivation’s output may refer to.  Likewise,
     DISALLOWED-REFERENCES, if true, must be a list of things the
     outputs may _not_ refer to.

     When LEAKED-ENV-VARS is true, it must be a list of strings denoting
     environment variables that are allowed to “leak” from the daemon’s
     environment to the build environment.  This is only applicable to
     fixed-output derivations—i.e., when HASH is true.  The main use is
     to allow variables such as ‘http_proxy’ to be passed to derivations
     that download files.

     When LOCAL-BUILD? is true, declare that the derivation is not a
     good candidate for offloading and should rather be built locally
     (*note 下发工作给后台进程的设置::).  This is the case for small
     derivations where the costs of data transfers would outweigh the
     benefits.

     When SUBSTITUTABLE? is false, declare that substitutes of the
     derivation’s output should not be used (*note Substitutes::).  This
     is useful, for instance, when building packages that capture
     details of the host CPU instruction set.

     PROPERTIES must be an association list describing “properties” of
     the derivation.  It is kept as-is, uninterpreted, in the
     derivation.

Here’s an example with a shell script as its builder, assuming STORE is
an open connection to the daemon, and BASH points to a Bash executable
in the store:

     (use-modules (guix utils)
                  (guix store)
                  (guix derivations))

     (let ((builder   ; add the Bash script to the store
             (add-text-to-store store "my-builder.sh"
                                "echo hello world > $out\n" '())))
       (derivation store "foo"
                   bash `("-e" ,builder)
                   #:inputs `((,bash) (,builder))
                   #:env-vars '(("HOME" . "/homeless"))))
     ⇒ #<derivation /gnu/store/...-foo.drv => /gnu/store/...-foo>

   As can be guessed, this primitive is cumbersome to use directly.  A
better approach is to write build scripts in Scheme, of course!  The
best course of action for that is to write the build code as a
“G-expression”, and to pass it to ‘gexp->derivation’.  For more
information, *note G-表达式::.

   Once upon a time, ‘gexp->derivation’ did not exist and constructing
derivations with build code written in Scheme was achieved with
‘build-expression->derivation’, documented below.  This procedure is now
deprecated in favor of the much nicer ‘gexp->derivation’.

 -- Scheme Procedure: build-expression->derivation STORE NAME EXP
           [#:system (%current-system)] [#:inputs '()] [#:outputs
          '("out")] [#:hash #f] [#:hash-algo #f]  [#:recursive? #f]
     [#:env-vars ’()] [#:modules ’()]  [#:references-graphs #f]
     [#:allowed-references #f]  [#:disallowed-references #f]
      [#:local-build?  #f] [#:substitutable?  #t] [#:guile-for-build #f]
     Return a derivation that executes Scheme expression EXP as a
     builder for derivation NAME.  INPUTS must be a list of ‘(name
     drv-path sub-drv)’ tuples; when SUB-DRV is omitted, ‘"out"’ is
     assumed.  MODULES is a list of names of Guile modules from the
     current search path to be copied in the store, compiled, and made
     available in the load path during the execution of EXP—e.g.,
     ‘((guix build utils) (guix build gnu-build-system))’.

     EXP is evaluated in an environment where ‘%outputs’ is bound to a
     list of output/path pairs, and where ‘%build-inputs’ is bound to a
     list of string/output-path pairs made from INPUTS.  Optionally,
     ENV-VARS is a list of string pairs specifying the name and value of
     environment variables visible to the builder.  The builder
     terminates by passing the result of EXP to ‘exit’; thus, when EXP
     returns ‘#f’, the build is considered to have failed.

     EXP is built using GUILE-FOR-BUILD (a derivation).  When
     GUILE-FOR-BUILD is omitted or is ‘#f’, the value of the
     ‘%guile-for-build’ fluid is used instead.

     See the ‘derivation’ procedure for the meaning of
     REFERENCES-GRAPHS, ALLOWED-REFERENCES, DISALLOWED-REFERENCES,
     LOCAL-BUILD?, and SUBSTITUTABLE?.

Here’s an example of a single-output derivation that creates a directory
containing one file:

     (let ((builder '(let ((out (assoc-ref %outputs "out")))
                       (mkdir out)    ; create /gnu/store/...-goo
                       (call-with-output-file (string-append out "/test")
                         (lambda (p)
                           (display '(hello guix) p))))))
       (build-expression->derivation store "goo" builder))

     ⇒ #<derivation /gnu/store/...-goo.drv => ...>


File: guix.zh_CN.info,  Node: 仓库monad,  Next: G-表达式,  Prev: Derivations,  Up: 编程接口

6.6 仓库monad
=============

The procedures that operate on the store described in the previous
sections all take an open connection to the build daemon as their first
argument.  Although the underlying model is functional, they either have
side effects or depend on the current state of the store.

   The former is inconvenient: the connection to the build daemon has to
be carried around in all those functions, making it impossible to
compose functions that do not take that parameter with functions that
do.  The latter can be problematic: since store operations have side
effects and/or depend on external state, they have to be properly
sequenced.

   This is where the ‘(guix monads)’ module comes in.  This module
provides a framework for working with “monads”, and a particularly
useful monad for our uses, the “store monad”.  Monads are a construct
that allows two things: associating “context” with values (in our case,
the context is the store), and building sequences of computations (here
computations include accesses to the store).  Values in a monad—values
that carry this additional context—are called “monadic values”;
procedures that return such values are called “monadic procedures”.

   Consider this “normal” procedure:

     (define (sh-symlink store)
       ;; Return a derivation that symlinks the 'bash' executable.
       (let* ((drv (package-derivation store bash))
              (out (derivation->output-path drv))
              (sh  (string-append out "/bin/bash")))
         (build-expression->derivation store "sh"
                                       `(symlink ,sh %output))))

   Using ‘(guix monads)’ and ‘(guix gexp)’, it may be rewritten as a
monadic function:

     (define (sh-symlink)
       ;; Same, but return a monadic value.
       (mlet %store-monad ((drv (package->derivation bash)))
         (gexp->derivation "sh"
                           #~(symlink (string-append #$drv "/bin/bash")
                                      #$output))))

   There are several things to note in the second version: the ‘store’
parameter is now implicit and is “threaded” in the calls to the
‘package->derivation’ and ‘gexp->derivation’ monadic procedures, and the
monadic value returned by ‘package->derivation’ is “bound” using ‘mlet’
instead of plain ‘let’.

   As it turns out, the call to ‘package->derivation’ can even be
omitted since it will take place implicitly, as we will see later (*note
G-表达式::):

     (define (sh-symlink)
       (gexp->derivation "sh"
                         #~(symlink (string-append #$bash "/bin/bash")
                                    #$output)))

   Calling the monadic ‘sh-symlink’ has no effect.  As someone once
said, “you exit a monad like you exit a building on fire: by running”.
So, to exit the monad and get the desired effect, one must use
‘run-with-store’:

     (run-with-store (open-connection) (sh-symlink))
     ⇒ /gnu/store/...-sh-symlink

   Note that the ‘(guix monad-repl)’ module extends the Guile REPL with
new “meta-commands” to make it easier to deal with monadic procedures:
‘run-in-store’, and ‘enter-store-monad’.  The former is used to “run” a
single monadic value through the store:

     scheme@(guile-user)> ,run-in-store (package->derivation hello)
     $1 = #<derivation /gnu/store/...-hello-2.9.drv => ...>

   The latter enters a recursive REPL, where all the return values are
automatically run through the store:

     scheme@(guile-user)> ,enter-store-monad
     store-monad@(guile-user) [1]> (package->derivation hello)
     $2 = #<derivation /gnu/store/...-hello-2.9.drv => ...>
     store-monad@(guile-user) [1]> (text-file "foo" "Hello!")
     $3 = "/gnu/store/...-foo"
     store-monad@(guile-user) [1]> ,q
     scheme@(guile-user)>

Note that non-monadic values cannot be returned in the ‘store-monad’
REPL.

   The main syntactic forms to deal with monads in general are provided
by the ‘(guix monads)’ module and are described below.

 -- Scheme Syntax: with-monad MONAD BODY ...
     Evaluate any ‘>>=’ or ‘return’ forms in BODY as being in MONAD.

 -- Scheme Syntax: return VAL
     Return a monadic value that encapsulates VAL.

 -- Scheme Syntax: >>= MVAL MPROC ...
     “Bind” monadic value MVAL, passing its “contents” to monadic
     procedures MPROC...(1).  There can be one MPROC or several of them,
     as in this example:

          (run-with-state
              (with-monad %state-monad
                (>>= (return 1)
                     (lambda (x) (return (+ 1 x)))
                     (lambda (x) (return (* 2 x)))))
            'some-state)

          ⇒ 4
          ⇒ some-state

 -- Scheme Syntax: mlet MONAD ((VAR MVAL) ...) BODY ...
 -- Scheme Syntax: mlet* MONAD ((VAR MVAL) ...) BODY ... Bind the
          variables VAR to the monadic values
     MVAL in BODY, which is a sequence of expressions.  As with the bind
     operator, this can be thought of as “unpacking” the raw,
     non-monadic value “contained” in MVAL and making VAR refer to that
     raw, non-monadic value within the scope of the BODY.  The form (VAR
     -> VAL) binds VAR to the “normal” value VAL, as per ‘let’.  The
     binding operations occur in sequence from left to right.  The last
     expression of BODY must be a monadic expression, and its result
     will become the result of the ‘mlet’ or ‘mlet*’ when run in the
     MONAD.

     ‘mlet*’ is to ‘mlet’ what ‘let*’ is to ‘let’ (*note (guile)Local
     Bindings::).

 -- Scheme System: mbegin MONAD MEXP ...
     Bind MEXP and the following monadic expressions in sequence,
     returning the result of the last expression.  Every expression in
     the sequence must be a monadic expression.

     This is akin to ‘mlet’, except that the return values of the
     monadic expressions are ignored.  In that sense, it is analogous to
     ‘begin’, but applied to monadic expressions.

 -- Scheme System: mwhen CONDITION MEXP0 MEXP* ...
     When CONDITION is true, evaluate the sequence of monadic
     expressions MEXP0..MEXP* as in an ‘mbegin’.  When CONDITION is
     false, return ‘*unspecified*’ in the current monad.  Every
     expression in the sequence must be a monadic expression.

 -- Scheme System: munless CONDITION MEXP0 MEXP* ...
     When CONDITION is false, evaluate the sequence of monadic
     expressions MEXP0..MEXP* as in an ‘mbegin’.  When CONDITION is
     true, return ‘*unspecified*’ in the current monad.  Every
     expression in the sequence must be a monadic expression.

   The ‘(guix monads)’ module provides the “state monad”, which allows
an additional value—the state—to be _threaded_ through monadic procedure
calls.

 -- Scheme Variable: %state-monad
     The state monad.  Procedures in the state monad can access and
     change the state that is threaded.

     Consider the example below.  The ‘square’ procedure returns a value
     in the state monad.  It returns the square of its argument, but
     also increments the current state value:

          (define (square x)
            (mlet %state-monad ((count (current-state)))
              (mbegin %state-monad
                (set-current-state (+ 1 count))
                (return (* x x)))))

          (run-with-state (sequence %state-monad (map square (iota 3))) 0)
          ⇒ (0 1 4)
          ⇒ 3

     When “run” through ‘%state-monad’, we obtain that additional state
     value, which is the number of ‘square’ calls.

 -- Monadic Procedure: current-state
     Return the current state as a monadic value.

 -- Monadic Procedure: set-current-state VALUE
     Set the current state to VALUE and return the previous state as a
     monadic value.

 -- Monadic Procedure: state-push VALUE
     Push VALUE to the current state, which is assumed to be a list, and
     return the previous state as a monadic value.

 -- Monadic Procedure: state-pop
     Pop a value from the current state and return it as a monadic
     value.  The state is assumed to be a list.

 -- Scheme Procedure: run-with-state MVAL [STATE]
     Run monadic value MVAL starting with STATE as the initial state.
     Return two values: the resulting value, and the resulting state.

   The main interface to the store monad, provided by the ‘(guix store)’
module, is as follows.

 -- Scheme Variable: %store-monad
     The store monad—an alias for ‘%state-monad’.

     Values in the store monad encapsulate accesses to the store.  When
     its effect is needed, a value of the store monad must be
     “evaluated” by passing it to the ‘run-with-store’ procedure (see
     below).

 -- Scheme Procedure: run-with-store STORE MVAL [#:guile-for-build]
          [#:system (%current-system)]
     Run MVAL, a monadic value in the store monad, in STORE, an open
     store connection.

 -- Monadic Procedure: text-file NAME TEXT [REFERENCES]
     Return as a monadic value the absolute file name in the store of
     the file containing TEXT, a string.  REFERENCES is a list of store
     items that the resulting text file refers to; it defaults to the
     empty list.

 -- Monadic Procedure: binary-file NAME DATA [REFERENCES]
     Return as a monadic value the absolute file name in the store of
     the file containing DATA, a bytevector.  REFERENCES is a list of
     store items that the resulting binary file refers to; it defaults
     to the empty list.

 -- Monadic Procedure: interned-file FILE [NAME] [#:recursive? #t]
          [#:select? (const #t)] Return the name of FILE once
     interned in the store.  Use NAME as its store name, or the basename
     of FILE if NAME is omitted.

     When RECURSIVE? is true, the contents of FILE are added
     recursively; if FILE designates a flat file and RECURSIVE? is true,
     its contents are added, and its permission bits are kept.

     When RECURSIVE? is true, call ‘(SELECT? FILE STAT)’ for each
     directory entry, where FILE is the entry’s absolute file name and
     STAT is the result of ‘lstat’; exclude entries for which SELECT?
     does not return true.

     The example below adds a file to the store, under two different
     names:

          (run-with-store (open-connection)
            (mlet %store-monad ((a (interned-file "README"))
                                (b (interned-file "README" "LEGU-MIN")))
              (return (list a b))))

          ⇒ ("/gnu/store/rwm...-README" "/gnu/store/44i...-LEGU-MIN")

   The ‘(guix packages)’ module exports the following package-related
monadic procedures:

 -- Monadic Procedure: package-file PACKAGE [FILE] [#:system
          (%current-system)] [#:target #f]  [#:output "out"] Return as a
     monadic value in the absolute file name of FILE within the OUTPUT
     directory of PACKAGE.  When FILE is omitted, return the name of the
     OUTPUT directory of PACKAGE.  When TARGET is true, use it as a
     cross-compilation target triplet.

     Note that this procedure does _not_ build PACKAGE.  Thus, the
     result might or might not designate an existing file.  We recommend
     not using this procedure unless you know what you are doing.

 -- Monadic Procedure: package->derivation PACKAGE [SYSTEM]
 -- Monadic Procedure: package->cross-derivation PACKAGE TARGET [SYSTEM]
          Monadic version of ‘package-derivation’ and
     ‘package-cross-derivation’ (*note 定义软件包::).

   ---------- Footnotes ----------

   (1) This operation is commonly referred to as “bind”, but that name
denotes an unrelated procedure in Guile.  Thus we use this somewhat
cryptic symbol inherited from the Haskell language.


File: guix.zh_CN.info,  Node: G-表达式,  Next: 调用guix repl,  Prev: 仓库monad,  Up: 编程接口

6.7 G-表达式
============

So we have “derivations”, which represent a sequence of build actions to
be performed to produce an item in the store (*note Derivations::).
These build actions are performed when asking the daemon to actually
build the derivations; they are run by the daemon in a container (*note
调用guix-daemon::).

   It should come as no surprise that we like to write these build
actions in Scheme.  When we do that, we end up with two “strata” of
Scheme code(1): the “host code”—code that defines packages, talks to the
daemon, etc.—and the “build code”—code that actually performs build
actions, such as making directories, invoking ‘make’, etc.

   To describe a derivation and its build actions, one typically needs
to embed build code inside host code.  It boils down to manipulating
build code as data, and the homoiconicity of Scheme—code has a direct
representation as data—comes in handy for that.  But we need more than
the normal ‘quasiquote’ mechanism in Scheme to construct build
expressions.

   The ‘(guix gexp)’ module implements “G-expressions”, a form of
S-expressions adapted to build expressions.  G-expressions, or “gexps”,
consist essentially of three syntactic forms: ‘gexp’, ‘ungexp’, and
‘ungexp-splicing’ (or simply: ‘#~’, ‘#$’, and ‘#$@’), which are
comparable to ‘quasiquote’, ‘unquote’, and ‘unquote-splicing’,
respectively (*note ‘quasiquote’: (guile)Expression Syntax.).  However,
there are major differences:

   • Gexps are meant to be written to a file and run or manipulated by
     other processes.

   • When a high-level object such as a package or derivation is
     unquoted inside a gexp, the result is as if its output file name
     had been introduced.

   • Gexps carry information about the packages or derivations they
     refer to, and these dependencies are automatically added as inputs
     to the build processes that use them.

   This mechanism is not limited to package and derivation objects:
“compilers” able to “lower” other high-level objects to derivations or
files in the store can be defined, such that these objects can also be
inserted into gexps.  For example, a useful type of high-level objects
that can be inserted in a gexp is “file-like objects”, which make it
easy to add files to the store and to refer to them in derivations and
such (see ‘local-file’ and ‘plain-file’ below).

   To illustrate the idea, here is an example of a gexp:

     (define build-exp
       #~(begin
           (mkdir #$output)
           (chdir #$output)
           (symlink (string-append #$coreutils "/bin/ls")
                    "list-files")))

   This gexp can be passed to ‘gexp->derivation’; we obtain a derivation
that builds a directory containing exactly one symlink to
‘/gnu/store/...-coreutils-8.22/bin/ls’:

     (gexp->derivation "the-thing" build-exp)

   As one would expect, the ‘"/gnu/store/...-coreutils-8.22"’ string is
substituted to the reference to the COREUTILS package in the actual
build code, and COREUTILS is automatically made an input to the
derivation.  Likewise, ‘#$output’ (equivalent to ‘(ungexp output)’) is
replaced by a string containing the directory name of the output of the
derivation.

   In a cross-compilation context, it is useful to distinguish between
references to the _native_ build of a package—that can run on the
host—versus references to cross builds of a package.  To that end, the
‘#+’ plays the same role as ‘#$’, but is a reference to a native package
build:

     (gexp->derivation "vi"
        #~(begin
            (mkdir #$output)
            (mkdir (string-append #$output "/bin"))
            (system* (string-append #+coreutils "/bin/ln")
                     "-s"
                     (string-append #$emacs "/bin/emacs")
                     (string-append #$output "/bin/vi")))
        #:target "aarch64-linux-gnu")

In the example above, the native build of COREUTILS is used, so that
‘ln’ can actually run on the host; but then the cross-compiled build of
EMACS is referenced.

   Another gexp feature is “imported modules”: sometimes you want to be
able to use certain Guile modules from the “host environment” in the
gexp, so those modules should be imported in the “build environment”.
The ‘with-imported-modules’ form allows you to express that:

     (let ((build (with-imported-modules '((guix build utils))
                    #~(begin
                        (use-modules (guix build utils))
                        (mkdir-p (string-append #$output "/bin"))))))
       (gexp->derivation "empty-dir"
                         #~(begin
                             #$build
                             (display "success!\n")
                             #t)))

In this example, the ‘(guix build utils)’ module is automatically pulled
into the isolated build environment of our gexp, such that ‘(use-modules
(guix build utils))’ works as expected.

   Usually you want the _closure_ of the module to be imported—i.e., the
module itself and all the modules it depends on—rather than just the
module; failing to do that, attempts to use the module will fail because
of missing dependent modules.  The ‘source-module-closure’ procedure
computes the closure of a module by looking at its source file headers,
which comes in handy in this case:

     (use-modules (guix modules))   ;for 'source-module-closure'

     (with-imported-modules (source-module-closure
                              '((guix build utils)
                                (gnu build vm)))
       (gexp->derivation "something-with-vms"
                         #~(begin
                             (use-modules (guix build utils)
                                          (gnu build vm))
                             ...)))

   In the same vein, sometimes you want to import not just pure-Scheme
modules, but also “extensions” such as Guile bindings to C libraries or
other “full-blown” packages.  Say you need the ‘guile-json’ package
available on the build side, here’s how you would do it:

     (use-modules (gnu packages guile))  ;for 'guile-json'

     (with-extensions (list guile-json)
       (gexp->derivation "something-with-json"
                         #~(begin
                             (use-modules (json))
                             ...)))

   The syntactic form to construct gexps is summarized below.

 -- Scheme Syntax: #~EXP
 -- Scheme Syntax: (gexp EXP)
     Return a G-expression containing EXP.  EXP may contain one or more
     of the following forms:

     ‘#$OBJ’
     ‘(ungexp OBJ)’
          Introduce a reference to OBJ.  OBJ may have one of the
          supported types, for example a package or a derivation, in
          which case the ‘ungexp’ form is replaced by its output file
          name—e.g., ‘"/gnu/store/...-coreutils-8.22’.

          If OBJ is a list, it is traversed and references to supported
          objects are substituted similarly.

          If OBJ is another gexp, its contents are inserted and its
          dependencies are added to those of the containing gexp.

          If OBJ is another kind of object, it is inserted as is.

     ‘#$OBJ:OUTPUT’
     ‘(ungexp OBJ OUTPUT)’
          This is like the form above, but referring explicitly to the
          OUTPUT of OBJ—this is useful when OBJ produces multiple
          outputs (*note 有多个输出的软件包::).

     ‘#+OBJ’
     ‘#+OBJ:output’
     ‘(ungexp-native OBJ)’
     ‘(ungexp-native OBJ OUTPUT)’
          Same as ‘ungexp’, but produces a reference to the _native_
          build of OBJ when used in a cross compilation context.

     ‘#$output[:OUTPUT]’
     ‘(ungexp output [OUTPUT])’
          Insert a reference to derivation output OUTPUT, or to the main
          output when OUTPUT is omitted.

          This only makes sense for gexps passed to ‘gexp->derivation’.

     ‘#$@LST’
     ‘(ungexp-splicing LST)’
          Like the above, but splices the contents of LST inside the
          containing list.

     ‘#+@LST’
     ‘(ungexp-native-splicing LST)’
          Like the above, but refers to native builds of the objects
          listed in LST.

     G-expressions created by ‘gexp’ or ‘#~’ are run-time objects of the
     ‘gexp?’ type (see below).

 -- Scheme Syntax: with-imported-modules MODULES BODY...
     Mark the gexps defined in BODY... as requiring MODULES in their
     execution environment.

     Each item in MODULES can be the name of a module, such as ‘(guix
     build utils)’, or it can be a module name, followed by an arrow,
     followed by a file-like object:

          `((guix build utils)
            (guix gcrypt)
            ((guix config) => ,(scheme-file "config.scm"
                                            #~(define-module ...))))

     In the example above, the first two modules are taken from the
     search path, and the last one is created from the given file-like
     object.

     This form has _lexical_ scope: it has an effect on the gexps
     directly defined in BODY..., but not on those defined, say, in
     procedures called from BODY....

 -- Scheme Syntax: with-extensions EXTENSIONS BODY...
     Mark the gexps defined in BODY... as requiring EXTENSIONS in their
     build and execution environment.  EXTENSIONS is typically a list of
     package objects such as those defined in the ‘(gnu packages guile)’
     module.

     Concretely, the packages listed in EXTENSIONS are added to the load
     path while compiling imported modules in BODY...; they are also
     added to the load path of the gexp returned by BODY....

 -- Scheme Procedure: gexp? OBJ
     Return ‘#t’ if OBJ is a G-expression.

   G-expressions are meant to be written to disk, either as code
building some derivation, or as plain files in the store.  The monadic
procedures below allow you to do that (*note 仓库monad::, for more
information about monads).

 -- Monadic Procedure: gexp->derivation NAME EXP [#:system
          (%current-system)] [#:target #f] [#:graft? #t]  [#:hash #f]
     [#:hash-algo #f]  [#:recursive?  #f] [#:env-vars ’()] [#:modules
     ’()]  [#:module-path ‘%load-path’]  [#:effective-version "2.2"]
      [#:references-graphs #f] [#:allowed-references #f]
      [#:disallowed-references #f]  [#:leaked-env-vars #f]
      [#:script-name (string-append NAME "-builder")]
      [#:deprecation-warnings #f]  [#:local-build?  #f]
     [#:substitutable?  #t]  [#:properties ’()] [#:guile-for-build #f]
     Return a derivation NAME that runs EXP (a gexp) with
     GUILE-FOR-BUILD (a derivation) on SYSTEM; EXP is stored in a file
     called SCRIPT-NAME.  When TARGET is true, it is used as the
     cross-compilation target triplet for packages referred to by EXP.

     MODULES is deprecated in favor of ‘with-imported-modules’.  Its
     meaning is to make MODULES available in the evaluation context of
     EXP; MODULES is a list of names of Guile modules searched in
     MODULE-PATH to be copied in the store, compiled, and made available
     in the load path during the execution of EXP—e.g., ‘((guix build
     utils) (guix build gnu-build-system))’.

     EFFECTIVE-VERSION determines the string to use when adding
     extensions of EXP (see ‘with-extensions’) to the search path—e.g.,
     ‘"2.2"’.

     GRAFT? determines whether packages referred to by EXP should be
     grafted when applicable.

     When REFERENCES-GRAPHS is true, it must be a list of tuples of one
     of the following forms:

          (FILE-NAME PACKAGE)
          (FILE-NAME PACKAGE OUTPUT)
          (FILE-NAME DERIVATION)
          (FILE-NAME DERIVATION OUTPUT)
          (FILE-NAME STORE-ITEM)

     The right-hand-side of each element of REFERENCES-GRAPHS is
     automatically made an input of the build process of EXP.  In the
     build environment, each FILE-NAME contains the reference graph of
     the corresponding item, in a simple text format.

     ALLOWED-REFERENCES must be either ‘#f’ or a list of output names
     and packages.  In the latter case, the list denotes store items
     that the result is allowed to refer to.  Any reference to another
     store item will lead to a build error.  Similarly for
     DISALLOWED-REFERENCES, which can list items that must not be
     referenced by the outputs.

     DEPRECATION-WARNINGS determines whether to show deprecation
     warnings while compiling modules.  It can be ‘#f’, ‘#t’, or
     ‘'detailed’.

     The other arguments are as for ‘derivation’ (*note Derivations::).

   The ‘local-file’, ‘plain-file’, ‘computed-file’, ‘program-file’, and
‘scheme-file’ procedures below return “file-like objects”.  That is,
when unquoted in a G-expression, these objects lead to a file in the
store.  Consider this G-expression:

     #~(system* #$(file-append glibc "/sbin/nscd") "-f"
                #$(local-file "/tmp/my-nscd.conf"))

   The effect here is to “intern” ‘/tmp/my-nscd.conf’ by copying it to
the store.  Once expanded, for instance via ‘gexp->derivation’, the
G-expression refers to that copy under ‘/gnu/store’; thus, modifying or
removing the file in ‘/tmp’ does not have any effect on what the
G-expression does.  ‘plain-file’ can be used similarly; it differs in
that the file content is directly passed as a string.

 -- Scheme Procedure: local-file FILE [NAME] [#:recursive? #f]
          [#:select? (const #t)] Return an object representing local
     file FILE to add to the store; this object can be used in a gexp.
     If FILE is a literal string denoting a relative file name, it is
     looked up relative to the source file where it appears; if FILE is
     not a literal string, it is looked up relative to the current
     working directory at run time.  FILE will be added to the store
     under NAME–by default the base name of FILE.

     When RECURSIVE? is true, the contents of FILE are added
     recursively; if FILE designates a flat file and RECURSIVE? is true,
     its contents are added, and its permission bits are kept.

     When RECURSIVE? is true, call ‘(SELECT? FILE STAT)’ for each
     directory entry, where FILE is the entry’s absolute file name and
     STAT is the result of ‘lstat’; exclude entries for which SELECT?
     does not return true.

     This is the declarative counterpart of the ‘interned-file’ monadic
     procedure (*note ‘interned-file’: 仓库monad.).

 -- Scheme Procedure: plain-file NAME CONTENT
     Return an object representing a text file called NAME with the
     given CONTENT (a string or a bytevector) to be added to the store.

     This is the declarative counterpart of ‘text-file’.

 -- Scheme Procedure: computed-file NAME GEXP [#:options
          '(#:local-build? #t)] Return an object representing the store
     item NAME, a file or directory computed by GEXP.  OPTIONS is a list
     of additional arguments to pass to ‘gexp->derivation’.

     This is the declarative counterpart of ‘gexp->derivation’.

 -- Monadic Procedure: gexp->script NAME EXP [#:guile (default-guile)]
          [#:module-path %load-path]  [#:system
     (%current-system)] [#:target #f] Return an executable script NAME
     that runs EXP using GUILE, with EXP’s imported modules in its
     search path.  Look up EXP’s modules in MODULE-PATH.

     The example below builds a script that simply invokes the ‘ls’
     command:

          (use-modules (guix gexp) (gnu packages base))

          (gexp->script "list-files"
                        #~(execl #$(file-append coreutils "/bin/ls")
                                 "ls"))

     When “running” it through the store (*note ‘run-with-store’:
     仓库monad.), we obtain a derivation that produces an executable
     file ‘/gnu/store/...-list-files’ along these lines:

          #!/gnu/store/...-guile-2.0.11/bin/guile -ds
          !#
          (execl "/gnu/store/...-coreutils-8.22"/bin/ls" "ls")

 -- Scheme Procedure: program-file NAME EXP [#:guile #f] [#:module-path
          %load-path] Return an object representing the
     executable store item NAME that runs GEXP.  GUILE is the Guile
     package used to execute that script.  Imported modules of GEXP are
     looked up in MODULE-PATH.

     This is the declarative counterpart of ‘gexp->script’.

 -- Monadic Procedure: gexp->file NAME EXP [#:set-load-path? #t]
          [#:module-path %load-path]  [#:splice? #f]  [#:guile
     (default-guile)] Return a derivation that builds a file NAME
     containing EXP.  When SPLICE? is true, EXP is considered to be a
     list of expressions that will be spliced in the resulting file.

     When SET-LOAD-PATH? is true, emit code in the resulting file to set
     ‘%load-path’ and ‘%load-compiled-path’ to honor EXP’s imported
     modules.  Look up EXP’s modules in MODULE-PATH.

     The resulting file holds references to all the dependencies of EXP
     or a subset thereof.

 -- Scheme Procedure: scheme-file NAME EXP [#:splice? #f]
          [#:set-load-path? #t] Return an object representing the
     Scheme file NAME that contains EXP.

     This is the declarative counterpart of ‘gexp->file’.

 -- Monadic Procedure: text-file* NAME TEXT ...
     Return as a monadic value a derivation that builds a text file
     containing all of TEXT.  TEXT may list, in addition to strings,
     objects of any type that can be used in a gexp: packages,
     derivations, local file objects, etc.  The resulting store file
     holds references to all these.

     This variant should be preferred over ‘text-file’ anytime the file
     to create will reference items from the store.  This is typically
     the case when building a configuration file that embeds store file
     names, like this:

          (define (profile.sh)
            ;; Return the name of a shell script in the store that
            ;; initializes the 'PATH' environment variable.
            (text-file* "profile.sh"
                        "export PATH=" coreutils "/bin:"
                        grep "/bin:" sed "/bin\n"))

     In this example, the resulting ‘/gnu/store/...-profile.sh’ file
     will reference COREUTILS, GREP, and SED, thereby preventing them
     from being garbage-collected during its lifetime.

 -- Scheme Procedure: mixed-text-file NAME TEXT ...
     Return an object representing store file NAME containing TEXT.
     TEXT is a sequence of strings and file-like objects, as in:

          (mixed-text-file "profile"
                           "export PATH=" coreutils "/bin:" grep "/bin")

     This is the declarative counterpart of ‘text-file*’.

 -- Scheme Procedure: file-union NAME FILES
     Return a ‘<computed-file>’ that builds a directory containing all
     of FILES.  Each item in FILES must be a two-element list where the
     first element is the file name to use in the new directory, and the
     second element is a gexp denoting the target file.  Here’s an
     example:

          (file-union "etc"
                      `(("hosts" ,(plain-file "hosts"
                                              "127.0.0.1 localhost"))
                        ("bashrc" ,(plain-file "bashrc"
                                               "alias ls='ls --color=auto'"))))

     This yields an ‘etc’ directory containing these two files.

 -- Scheme Procedure: directory-union NAME THINGS
     Return a directory that is the union of THINGS, where THINGS is a
     list of file-like objects denoting directories.  For example:

          (directory-union "guile+emacs" (list guile emacs))

     yields a directory that is the union of the ‘guile’ and ‘emacs’
     packages.

 -- Scheme Procedure: file-append OBJ SUFFIX ...
     Return a file-like object that expands to the concatenation of OBJ
     and SUFFIX, where OBJ is a lowerable object and each SUFFIX is a
     string.

     As an example, consider this gexp:

          (gexp->script "run-uname"
                        #~(system* #$(file-append coreutils
                                                  "/bin/uname")))

     The same effect could be achieved with:

          (gexp->script "run-uname"
                        #~(system* (string-append #$coreutils
                                                  "/bin/uname")))

     There is one difference though: in the ‘file-append’ case, the
     resulting script contains the absolute file name as a string,
     whereas in the second case, the resulting script contains a
     ‘(string-append ...)’ expression to construct the file name _at run
     time_.

 -- Scheme Syntax: let-system SYSTEM BODY...
 -- Scheme Syntax: let-system (SYSTEM TARGET) BODY...
     Bind SYSTEM to the currently targeted system—e.g.,
     ‘"x86_64-linux"’—within BODY.

     In the second case, additionally bind TARGET to the current
     cross-compilation target—a GNU triplet such as
     ‘"arm-linux-gnueabihf"’—or ‘#f’ if we are not cross-compiling.

     ‘let-system’ is useful in the occasional case where the object
     spliced into the gexp depends on the target system, as in this
     example:

          #~(system*
             #+(let-system system
                 (cond ((string-prefix? "armhf-" system)
                        (file-append qemu "/bin/qemu-system-arm"))
                       ((string-prefix? "x86_64-" system)
                        (file-append qemu "/bin/qemu-system-x86_64"))
                       (else
                        (error "dunno!"))))
             "-net" "user" #$image)

 -- Scheme Syntax: with-parameters ((PARAMETER VALUE) ...) EXP
     This macro is similar to the ‘parameterize’ form for
     dynamically-bound “parameters” (*note (guile)Parameters::).  The
     key difference is that it takes effect when the file-like object
     returned by EXP is lowered to a derivation or store item.

     A typical use of ‘with-parameters’ is to force the system in effect
     for a given object:

          (with-parameters ((%current-system "i686-linux"))
            coreutils)

     The example above returns an object that corresponds to the i686
     build of Coreutils, regardless of the current value of
     ‘%current-system’.

   Of course, in addition to gexps embedded in “host” code, there are
also modules containing build tools.  To make it clear that they are
meant to be used in the build stratum, these modules are kept in the
‘(guix build ...)’ name space.

   Internally, high-level objects are “lowered”, using their compiler,
to either derivations or store items.  For instance, lowering a package
yields a derivation, and lowering a ‘plain-file’ yields a store item.
This is achieved using the ‘lower-object’ monadic procedure.

 -- Monadic Procedure: lower-object OBJ [SYSTEM] [#:target #f] Return as
          a value in ‘%store-monad’ the derivation or
     store item corresponding to OBJ for SYSTEM, cross-compiling for
     TARGET if TARGET is true.  OBJ must be an object that has an
     associated gexp compiler, such as a ‘<package>’.

   ---------- Footnotes ----------

   (1) The term “stratum” in this context was coined by Manuel Serrano
et al. in the context of their work on Hop.  Oleg Kiselyov, who has
written insightful essays and code on this topic
(http://okmij.org/ftp/meta-programming/#meta-scheme), refers to this
kind of code generation as “staging”.

