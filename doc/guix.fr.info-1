This is guix.fr.info, produced by makeinfo version 6.7 from
guix.fr.texi.

Copyright © 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020 Ludovic
Courtès
Copyright © 2013, 2014, 2016 Andreas Enge
Copyright © 2013 Nikita Karetnikov
Copyright © 2014, 2015, 2016 Alex Kost
Copyright © 2015, 2016 Mathieu Lirzin
Copyright © 2014 Pierre-Antoine Rault
Copyright © 2015 Taylan Ulrich Bayırlı/Kammer
Copyright © 2015, 2016, 2017, 2019, 2020 Leo Famulari
Copyright © 2015, 2016, 2017, 2018, 2019, 2020 Ricardo Wurmus
Copyright © 2016 Ben Woodcroft
Copyright © 2016, 2017, 2018 Chris Marusich
Copyright © 2016, 2017, 2018, 2019, 2020 Efraim Flashner
Copyright © 2016 John Darrington
Copyright © 2016, 2017 Nikita Gillmann
Copyright © 2016, 2017, 2018, 2019, 2020 Jan Nieuwenhuizen
Copyright © 2016, 2017, 2018, 2019, 2020 Julien Lepiller
Copyright © 2016 Alex ter Weele
Copyright © 2016, 2017, 2018, 2019 Christopher Baines
Copyright © 2017, 2018, 2019 Clément Lassieur
Copyright © 2017, 2018 Mathieu Othacehe
Copyright © 2017 Federico Beffa
Copyright © 2017, 2018 Carlo Zancanaro
Copyright © 2017 Thomas Danckaert
Copyright © 2017 humanitiesNerd
Copyright © 2017 Christopher Allan Webber
Copyright © 2017, 2018, 2019, 2020 Marius Bakke
Copyright © 2017, 2019, 2020 Hartmut Goebel
Copyright © 2017, 2019, 2020 Maxim Cournoyer
Copyright © 2017, 2018, 2019, 2020 Tobias Geerinckx-Rice
Copyright © 2017 George Clemmer
Copyright © 2017 Andy Wingo
Copyright © 2017, 2018, 2019 Arun Isaac
Copyright © 2017 nee
Copyright © 2018 Rutger Helling
Copyright © 2018 Oleg Pykhalov
Copyright © 2018 Mike Gerwitz
Copyright © 2018 Pierre-Antoine Rouby
Copyright © 2018, 2019 Gábor Boskovits
Copyright © 2018, 2019 Florian Pelz
Copyright © 2018 Laura Lazzati
Copyright © 2018 Alex Vong
Copyright © 2019 Josh Holland
Copyright © 2019, 2020 Diego Nicola Barbato
Copyright © 2019 Ivan Petkov
Copyright © 2019 Jakob L. Kreuze
Copyright © 2019 Kyle Andrews
Copyright © 2019 Alex Griffin
Copyright © 2019 Guillaume Le Vaillant
Copyright © 2020 Leo Prikler
Copyright © 2019, 2020 Simon Tournier
Copyright © 2020 Wiktor Żelazny
Copyright © 2020 Damien Cassou
Copyright © 2020 Jakub Kądziołka
Copyright © 2020 Jack Hill
Copyright © 2020 Naga Malleswari
Copyright © 2020 Brice Waegeneire
Copyright © 2020 R Veera Kumar
Copyright © 2020 Pierre Langlois
Copyright © 2020 pinoaffe

   Vous avez la permission de copier, distribuer ou modifier ce document
sous les termes de la Licence GNU Free Documentation, version 1.3 ou
toute version ultérieure publiée par la Free Software Foundation ; sans
section invariante, texte de couverture et sans texte de quatrième de
couverture. Une copie de la licence est incluse dans la section
intitulée « GNU Free Documentation License ».
INFO-DIR-SECTION Administration système
START-INFO-DIR-ENTRY
* Guix: (guix.fr).           Gérer les logiciels installés et la
                               configuration du système.
* guix package : (guix.fr)Invoquer guix package.  Installer, supprimer et
                                                      mettre à jour des
                                                      paquets.
* guix gc : (guix.fr)Invoquer guix gc.  Récupérer de l’espace disque
                                            inutilisé.
* guix pull : (guix.fr)Invoquer guix pull.  Mettre à jour la liste des
                                                paquets disponibles.
* guix system : (guix.fr)Invoquer guix system.  Gérer la configuration du
                                                    système d’exploitation.
* guix deploy: (guix)Invoking guix deploy.  Manage operating system
                                              configurations for remote hosts.
END-INFO-DIR-ENTRY

INFO-DIR-SECTION Développement logiciel
START-INFO-DIR-ENTRY
* guix environment : (guix.fr)Invoquer guix environment.  Construire des
                                                              environnements
                                                              de construction
                                                              avec Guix.
* guix build : (guix.fr)Invoquer guix build.  Construire des paquets.
* guix pack : (guix.fr) Invoquer guix pack.  Créer des lots binaires.
END-INFO-DIR-ENTRY


File: guix.fr.info,  Node: Top,  Next: Introduction,  Up: (dir)

GNU Guix
********

Cette documentation décrit GNU Guix version 1.0.1.17089-7e269, un outil
de gestion de paquets fonctionnel écrit pour le système GNU.

   This manual is also available in Simplified Chinese (*note
(guix.zh_CN)Top::), French (*note (guix.fr)Top::), German (*note
(guix.de)Top::), Spanish (*note (guix.es)Top::), and Russian (*note
(guix.ru)Top::). If you would like to translate it in your native
language, consider joining the Translation Project
(https://translationproject.org/domain/guix-manual.html).

* Menu:

* Introduction::             Qu’est-ce que Guix ?
* Installation::             Installer Guix.
* Installation du système::  Installer le système d’exploitation complet.
* Gestion de paquets::       Installation des paquets, mises à jour, etc.
* Développement::           Développement logiciel simplifié par Guix.
* Interface de programmation::  Utiliser Guix en Scheme.
* Utilitaires::              Commandes de gestion de paquets.
* Configuration système::   Configurer le système d’exploitation.
* Documentation::            Visualiser les manuels des logiciels.
* Installer les fichiers de débogage::  Nourrir le débogueur.
* Mises à jour de sécurité::  Déployer des correctifs de sécurité
                                   rapidement.
* Bootstrapping::            GNU/Linux depuis zéro.
* Porter::                   Cibler une autre plateforme ou un autre noyau.
* Contribuer::               Nous avons besoin de votre aide !

* Remerciements::            Merci !
* La licence GNU Free Documentation::  La licence de ce manuel.
* Index des concepts::       Les concepts.
* Index de programmation::   Types de données, fonctions et variables.

 — Liste détaillée des nœuds —



Introduction



* Gérer ses logiciels avec Guix::  Ce qui est spécial.
* Distribution GNU::         Les paquets et les outils.

Installation



* Installation binaire::     Commencer à utiliser Guix en un rien de temps
                               !
* Prérequis::               Logiciels requis pour construire et lancer
                               Guix.
* Lancer la suite de tests::  Tester Guix.
* Paramétrer le démon::    Préparer l’environnement du démon de
                               construction.
* Invoquer guix-daemon::     Lancer le démon de construction.
* Réglages applicatifs::    Réglages spécifiques pour les application.

Paramétrer le démon



* Réglages de l'environnement de construction::  Préparer l’environnement
                                                    de construction isolé.
* Réglages du délestage du démon::  Envoyer des constructions à des
                                         machines distantes.
* Support de SELinux::       Utiliser une politique SELinux pour le démon.

Installation du système



* Limitations::              Ce à quoi vous attendre.
* Considérations matérielles::  Matériel supporté.
* Installation depuis une clef USB ou un DVD::  Préparer le média
                                                  d’installation.
* Préparer l'installation::  Réseau, partitionnement, etc.
* Installation graphique guidée::  Installation graphique facile.
* Installation manuelle::    Installation manuelle pour les sorciers.
* Après l'installation du système::  Une fois que l’installation a
                                         réussi.
* Installer Guix dans une VM::  Jouer avec le système Guix.
* Construire l'image d'installation::  D’où vient tout cela.

Installation manuelle



* Disposition du clavier réseau et partitionnement::  Paramètres initiaux.
* Effectuer l'installation::  Installer.

Gestion de paquets



* Fonctionnalités::         Comment Guix va rendre votre vie plus heureuse.
* Invoquer guix package::    Installation, suppression, etc. de paquets.
* Substituts::               Télécharger des binaire déjà construits.
* Des paquets avec plusieurs résultats::  Un seul paquet source, plusieurs
                                             résultats.
* Invoquer guix gc::         Lancer le ramasse-miettes.
* Invoquer guix pull::       Récupérer la dernière version de Guix et de
                               la distribution.
* Canaux::                   Personnaliser la collection des paquets.
* Invoking guix time-machine::  Running an older revision of Guix.
* Inférieurs::              Interagir avec une autre révision de Guix.
* Invoquer guix describe::   Affiche des informations sur la révision Guix
                               actuelle.
* Invoquer guix archive::    Exporter et importer des fichiers du dépôt.

Substituts



* Serveur de substituts officiel::  Une source particulière de substituts.
* Autoriser un serveur de substituts::  Comment activer ou désactiver les
                                          substituts.
* Authentification des substituts::  Comment Guix vérifie les substituts.
* Paramètres de serveur mandataire::  Comment récupérer des substituts à
                                         travers un serveur mandataire.
* Échec de substitution::   Qu’arrive-t-il quand la substitution échoue.
* De la confiance en des binaires::  Comment pouvez-vous avoir confiance en
                                       un paquet binaire ?

Développement



* Invoquer guix environment::  Mettre en place des environnements de
                                 développement.
* Invoquer guix pack::       Créer des lots de logiciels.
* La chaîne d'outils GCC::  Working with languages supported by GCC.

Interface de programmation



* Modules de paquets::       Les paquets du point de vu du programmeur.
* Définition des paquets::  Définir de nouveaux paquets.
* Systèmes de construction::  Spécifier comment construire les paquets.
* Le dépôt::               Manipuler le dépôt de paquets.
* Dérivations::             Interface de bas-niveau avec les dérivations
                               de paquets.
* La monade du dépôt::     Interface purement fonctionnelle avec le
                               dépôt.
* G-Expressions::            Manipuler les expressions de construction.
* Invoquer guix repl::       S’amuser avec Guix de manière interactive.

Définition des paquets



* Référence des paquets::  Le type de donnée des paquets.
* Référence des origines::  Le type de données d’origine.

Utilitaires



* Invoquer guix build::      Construire des paquets depuis la ligne de
                               commande.
* Invoquer guix edit::       Modifier les définitions de paquets.
* Invoquer guix download::   Télécharger un fichier et afficher son hash.
* Invoquer guix hash::       Calculer le hash cryptographique d’un fichier.
* Invoquer guix import::     Importer des définitions de paquets.
* Invoquer guix refresh::    Mettre à jour les définitions de paquets.
* Invoquer guix lint::       Trouver des erreurs dans les définitions de
                               paquets.
* Invoquer guix size::       Profiler l’utilisation du disque.
* Invoquer guix graph::      Visualiser le graphe des paquets.
* Invoquer guix publish::    Partager des substituts.
* Invoquer guix challenge::  Défier les serveurs de substituts.
* Invoquer guix copy::       Copier vers et depuis un dépôt distant.
* Invoquer guix container::  Isolation de processus.
* Invoquer guix weather::    Mesurer la disponibilité des substituts.
* Invoquer guix processes::  Lister les processus clients.

Invoquer ‘guix build’



* Options de construction communes::  Options de construction pour la
                                        plupart des commandes.
* Options de transformation de paquets::  Créer des variantes de paquets.
* Options de construction supplémentaires::  Options spécifiques à «
                                                guix build ».
* Débogage des échecs de construction::  L’empaquetage dans la vraie vie.

Configuration système



* Utiliser le système de configuration::  Personnaliser votre système
                                             GNU.
* Référence de système d'exploitation::  Détail sur la déclaration de
                                              système d’exploitation.
* Systèmes de fichiers::    Configurer les montages de systèmes de
                               fichiers.
* Périphériques mappés::  Gestion des périphériques de bloc.
* Comptes utilisateurs::     Spécifier des comptes utilisateurs.
* Disposition du clavier::   La manière dont le système interprète les
                               touches du clavier.
* Régionalisation::         Paramétrer la langue et les conventions
                               culturelles.
* Services::                 Spécifier les services du système.
* Programmes setuid::        Programmes tournant avec les privilèges root.
* Certificats X.509::        Authentifier les serveurs HTTPS.
* Name Service Switch::      Configurer le « name service switch » de la
                               libc.
* Disque de RAM initial::    Démarrage de Linux-Libre.
* Configuration du chargeur d'amorçage::  Configurer le chargeur
                                             d’amorçage.
* Invoquer guix system::     Instantier une configuration du système.
* Invoking guix deploy::     Deploying a system configuration to a remote
                               host.
* Lancer Guix dans une VM::  Comment lancer Guix dans une machine virtuelle.
* Définir des services::    Ajouter de nouvelles définitions de services.

Services



* Services de base::         Services systèmes essentiels.
* Exécution de tâches planifiées::  Le service mcron.
* Rotation des journaux::    Le service rottlog.
* Services réseau::         Paramètres réseau, démon SSH, etc.
* Système de fenêtrage X::  Affichage graphique.
* Services d'impression::    Support pour les imprimantes locales et
                               distantes.
* Services de bureaux::      D-Bus et les services de bureaux.
* Services de son::          Services ALSA et Pulseaudio.
* Services de bases de données::  Bases SQL, clefs-valeurs, etc.
* Services de courriels::    IMAP, POP3, SMTP, et tout ça.
* Services de messagerie::   Services de messagerie.
* Services de téléphonie::  Services de téléphonie.
* Services de surveillance::  Services de surveillance.
* Services Kerberos::        Services Kerberos.
* Services web::             Services web.
* Services de certificats::  Certificats TLS via Let’s Encrypt.
* Services DNS::             Démons DNS.
* Services VPN::             Démons VPN.
* Système de fichiers en réseau::  Services liés à NFS.
* Intégration continue::    Le service Cuirass.
* Services de gestion de l'énergie::  Augmenter la durée de vie de la
                                         batterie.
* Services audio::           MPD.
* Services de virtualisation::  Services de virtualisation.
* Services de contrôle de version::  Fournit des accès distants à des
                                        dépôts Git.
* Services de jeu::          Serveurs de jeu.
* PAM Mount Service::        Service to mount volumes when logging in.
* Guix Services::            Services relating specifically to Guix.
* Linux Services::           Services tied to the Linux kernel.
* Hurd Services::            Services specific to a Hurd System.
* Services divers::          D’autres services.

Définir des services



* Composition de services::  Le modèle de composition des services.
* Types service et services::  Types et services.
* Référence de service::   Référence de l’API.
* Services Shepherd::        Un type de service particulier.



File: guix.fr.info,  Node: Introduction,  Next: Installation,  Prev: Top,  Up: Top

1 Introduction
**************

GNU Guix(1) est un outil de gestion de paquets et une distribution pour
le système GNU. Guix facilite pour les utilisateur·rice·s non
privilégié·e·s l’installation, la mise à jour et la suppression de
paquets, la restauration à un ensemble de paquets précédent, la
construction de paquets depuis les sources et plus généralement aide à
la création et à la maintenance d’environnements logiciels.

   Vous pouvez installer GNU Guix sur un système GNU/Linux existant pour
compléter les outils disponibles sans interférence (*note
Installation::) ou vous pouvez l’utiliser comme distribution système
indépendante, “Guix System”(2). *Note Distribution GNU::.

* Menu:

* Gérer ses logiciels avec Guix::  Ce qui est spécial.
* Distribution GNU::         Les paquets et les outils.

   ---------- Footnotes ----------

   (1) « Guix » se prononce comme « geeks » (en prononçant le « s »), ou
« ɡiːks » dans l’alphabet phonétique international (API).

   (2) Nous appelions le système Guix « la distribution système Guix »
ou « GuixSD ». nous considérons maintenant qu’il est plus pertinent de
regrouper tout sous la bannière de « Guix » comme, après tout, Guix
System est directement disponible sous la commande ‘guix system’, meme
si vous utilisez une autre distro en dessous !


File: guix.fr.info,  Node: Gérer ses logiciels avec Guix,  Next: Distribution GNU,  Up: Introduction

1.1 Gérer ses logiciels avec Guix
=================================

Guix fournit une interface de gestion des paquets par la ligne de
commande (*note Gestion de paquets::), des outils pour aider au
développement logiciel (*note Développement::), des utilitaires en ligne
de commande pour des utilisations plus avancées (*note Utilitaires::)
ainsi que des interfaces de programmation Scheme (*note Interface de
programmation::). Son “démon de construction” est responsable de la
construction des paquets pour les utilisateur·rice·s (*note Paramétrer
le démon::) et du téléchargement des binaires pré-construits depuis les
sources autorisées (*note Substituts::).

   Guix contient de nombreuses définitions de paquet GNU et non-GNU qui
respectent tous les libertés de l’utilisateur ou utilisatrice
(https://www.gnu.org/philosophy/free-sw.fr.html). Il est _extensible_  :
chacun·e peut écrire ses propres définitions de paquets (*note
Définition des paquets::) et les rendre disponibles dans des modules de
paquets indépendants (*note Modules de paquets::). Il est aussi
_personnalisable_ : on peut _dériver_ des définitions de paquets
spécialisées à partir de définitions existantes, même depuis la ligne de
commande (*note Options de transformation de paquets::).

   Sous le capot, Guix implémente la discipline de “gestion de paquet
fonctionnel” inventé par Nix (*note Remerciements::). Dans Guix le
processus de construction et d’installation des paquets est vu comme une
_fonction_ dans le sens mathématique du terme. Cette fonction a des
entrées (comme des scripts de construction, un compilateur et des
bibliothèques) et renvoie un paquet installé. En tant que fonction pure,
son résultat ne dépend que de ses entrées. Par exemple, il ne peut pas
faire référence à des logiciels ou des scripts qui n’ont pas été
explicitement passés en entrée. Une fonction de construction produit
toujours le même résultat quand on lui donne le même ensemble d’entrée.
Elle ne peut pas modifier l’environnement du système en cours
d’exécution d’aucune manière ; par exemple elle ne peut pas créer,
modifier ou supprimer des fichiers en dehors de ses répertoires de
construction et d’installation. Ce résultat s’obtient en lançant les
processus de construction dans des environnements isolés (ou des
“conteneurs”) où seules les entrées explicites sont visibles.

   Le résultat des fonctions de construction de paquets est mis en
“cache” dans le système de fichier, dans répertoire spécial appelé le
“dépôt” (*note Le dépôt::). Chaque paquet est installé dans son
répertoire propre dans le dépôt — par défaut dans ‘/gnu/store’. Le nom
du répertoire contient un hash de toutes les entrées utilisées pour
construire le paquet ; ainsi, changer une entrée donnera un nom de
répertoire différent.

   Cette approche est le fondement des fonctionnalités les plus
importante de Guix : le support des mises à jour des paquets et des
retours en arrière transactionnels, l’installation différenciée par
utilisateur·rice et le ramassage de miettes pour les paquets (*note
Fonctionnalités::).


File: guix.fr.info,  Node: Distribution GNU,  Prev: Gérer ses logiciels avec Guix,  Up: Introduction

1.2 Distribution GNU
====================

Guix fournit aussi une distribution du système GNU contenant uniquement
des logiciels libres(1). On peut installer la distribution elle-même
(*note Installation du système::), mais on peut aussi installer Guix
comme gestionnaire de paquets par dessus un système GNU/Linux déjà
installé (*note Installation::). Pour distinguer ces deux cas, on
appelle la distribution autonome le « système Guix » ou Guix System.

   La distribution fournit les paquets cœur de GNU comme la GNU libc,
GCC et Binutils, ainsi que de nombreuses applications GNU et non-GNU. La
liste complète des paquets disponibles se trouve en ligne
(http://www.gnu.org/software/guix/packages) ou en lançant ‘guix package’
(*note Invoquer guix package::) :

     guix package --list-available

   Notre but est de fournir une distribution logicielle entièrement
libre de GNU/Linux et d’autres variantes de GNU, en se concentrant sur
la promotion et l’intégration étroite des composants GNU en insistant
sur les programmes et les outils qui aident l’utilisateur·rice à exercer
ses libertés.

   Les paquets sont actuellement disponibles pour les plateformes
suivantes :

‘x86_64-linux’
     l’architecture Intel et AMD ‘x86_64’ avec le noyau Linux-libre ;

‘i686-linux’
     l’architecture Intel 32 bits (IA32) avec le noyau Linux-libre ;

‘armhf-linux’
     l’architecture ARMv7-A avec gestion des flottants matérielle,
     Thumb-2 et NEON, avec l’interface binaire applicative (ABI) EABI
     hard-float et le noyau Linux-libre ;

‘aarch64-linux’
     little-endian 64-bit ARMv8-A processors, Linux-Libre kernel.

‘mips64el-linux (deprecated)’
     little-endian 64-bit MIPS processors, specifically the Loongson
     series, n32 ABI, and Linux-Libre kernel. This configuration is no
     longer fully supported; in particular, there is no ongoing work to
     ensure that this architecture still works. Should someone decide
     they wish to revive this architecture then the code is still
     available.

   Avec Guix System, vous _déclarez_ tous les aspects de la
configuration du système d’exploitation et guix s’occupe d’instancier la
configuration de manière transactionnelle, reproductible et sans état
(*note Configuration système::). Guix System utilise le noyau
Linux-libre, le système d’initialisation Shepherd (*note
(shepherd)Introduction::), les outils GNU et la chaîne d’outils
familière ainsi que l’environnement graphique et les services systèmes
de votre choix.

   Guix System est disponible sur toutes les plateformes ci-dessus à
part ‘mips64el-linux’.

Pour des informations sur comment porter vers d’autres architectures et
d’autres noyau, *note Porter::.

   La construction de cette distribution est un effort collaboratif et
nous vous invitons à nous rejoindre ! *Note Contribuer::, pour des
informations sur la manière de nous aider.

   ---------- Footnotes ----------

   (1) Le terme « libre » se réfère ici bien sûr à la liberté offerte à
la personne qui utilise ces logiciels
(http://www.gnu.org/philosophy/free-sw.fr.html).


File: guix.fr.info,  Node: Installation,  Next: Installation du système,  Prev: Introduction,  Up: Top

2 Installation
**************

     Remarque : Nous vous recommandons d’utiliser ce script shell
     d’installation
     (https://git.savannah.gnu.org/cgit/guix.git/plain/etc/guix-install.sh)
     pour installer Guix sur un système GNU/Linux fonctionnel, que nous
     appelons une “distro externe”(1). Le script automatise le
     téléchargement, l’installation et la configuration initiale de
     Guix. Vous devez l’exécuter en tant que root.

   Lorsqu’il est installé sur une distro externe, GNU Guix complète les
outils disponibles sans interférence. Ses données se trouvent
exclusivement dans deux répertoires, typiquement ‘/gnu/store’ et
‘/var/guix’ ; les autres fichiers de votre système comme ‘/etc’ sont
laissés intacts.

   Une fois installé, Guix peut être mis à jour en lançant ‘guix pull’
(*note Invoquer guix pull::).

   Si vous préférez effectuer les étapes d’installation manuellement ou
si vous voulez les personnaliser, vous trouverez les sections suivantes
utile. Elles décrivent les prérequis logiciels pour Guix, ainsi que la
manière de l’installer manuellement et de se préparer à l’utiliser.

* Menu:

* Installation binaire::     Commencer à utiliser Guix en un rien de temps
                               !
* Prérequis::               Logiciels requis pour construire et lancer
                               Guix.
* Lancer la suite de tests::  Tester Guix.
* Paramétrer le démon::    Préparer l’environnement du démon de
                               construction.
* Invoquer guix-daemon::     Lancer le démon de construction.
* Réglages applicatifs::    Réglages spécifiques pour les application.
* Upgrading Guix::           Upgrading Guix and its build daemon.

   ---------- Footnotes ----------

   (1) Cette section s’occupe de l’installation du gestionnaire de
paquet, ce qui peut se faire sur un système GNU/Linux existant. Si vous
voulez plutôt installer le système d’exploitation GNU complet, *note
Installation du système::.


File: guix.fr.info,  Node: Installation binaire,  Next: Prérequis,  Up: Installation

2.1 Installation binaire
========================

Cette section décrit comment installer Guix sur un système quelconque
depuis un archive autonome qui fournit les binaires pour Guix et toutes
ses dépendances. C’est souvent plus rapide que d’installer depuis les
sources, ce qui est décrit dans les sections suivantes. Le seul
prérequis est d’avoir GNU tar et Xz.

     Remarque : We recommend the use of this shell installer script
     (https://git.savannah.gnu.org/cgit/guix.git/plain/etc/guix-install.sh).
     The script automates the download, installation, and initial
     configuration steps described below. It should be run as the root
     user. As root, you can thus run this:

          cd /tmp
          wget https://git.savannah.gnu.org/cgit/guix.git/plain/etc/guix-install.sh
          chmod +x guix-install.sh
          ./guix-install.sh

   L’installation se comme ceci :

  1. Download the binary tarball from
     ‘https://ftp.gnu.org/gnu/guix/guix-binary-1.0.1.17089-7e269.x86_64-linux.tar.xz’,
     where ‘x86_64-linux’ can be replaced with ‘i686-linux’ for an
     ‘i686’ (32-bits) machine already running the kernel Linux, and so
     on (*note Distribution GNU::).

     Assurez-vous de télécharger le fichier ‘.sig’ associé et de
     vérifier l’authenticité de l’archive avec, comme ceci :

          $ wget https://ftp.gnu.org/gnu/guix/guix-binary-1.0.1.17089-7e269.x86_64-linux.tar.xz.sig
          $ gpg --verify guix-binary-1.0.1.17089-7e269.x86_64-linux.tar.xz.sig

     Si cette commande échoue parce que vous n’avez pas la clef publique
     requise, lancez cette commande pour l’importer :

          $ wget https://sv.gnu.org/people/viewgpg.php?user_id=15145 \
                -qO - | gpg --import -

     et relancez la commande ‘gpg --verify’.

     Take note that a warning like “This key is not certified with a
     trusted signature!” is normal.

  2. Maintenant, vous devez devenir ‘root’. En fonction de votre
     distribution, vous devrez lancer ‘su -’ ou ‘sudo -i’. En tant que
     ‘root’, lancez :

          # cd /tmp
          # tar --warning=no-timestamp -xf \
               /path/to/guix-binary-1.0.1.17089-7e269.x86_64-linux.tar.xz
          # mv var/guix /var/ && mv gnu /

     This creates ‘/gnu/store’ (*note Le dépôt::) and ‘/var/guix’. The
     latter contains a ready-to-use profile for ‘root’ (see next step).

     Ne décompressez _pas_ l’archive sur un système Guix lancé car cela
     écraserait ses propres fichiers essentiels.

     The ‘--warning=no-timestamp’ option makes sure GNU tar does not
     emit warnings about “implausibly old time stamps” (such warnings
     were triggered by GNU tar 1.26 and older; recent versions are
     fine). They stem from the fact that all the files in the archive
     have their modification time set to zero (which means January 1st,
     1970). This is done on purpose to make sure the archive content is
     independent of its creation time, thus making it reproducible.

  3. Rendez le profil disponible sous ‘~root/.config/guix/current’, qui
     est l’emplacement où ‘guix pull’ installera les mises à jour (*note
     Invoquer guix pull::) :

          # mkdir -p ~root/.config/guix
          # ln -sf /var/guix/profiles/per-user/root/current-guix \
                   ~root/.config/guix/current

     Source ‘etc/profile’ to augment ‘PATH’ and other relevant
     environment variables:

          # GUIX_PROFILE="`echo ~root`/.config/guix/current" ; \
            source $GUIX_PROFILE/etc/profile

  4. Créez le groupe et les comptes utilisés pour la construction comme
     expliqué plus loin (*note Réglages de l'environnement de
     construction::).

  5. Lancez le démon et paramétrez-le pour démarrer automatiquement au
     démarrage.

     Si votre distribution hôte utilise le système d’initialisation
     systemd, cela peut se faire avec ces commandes :

          # cp ~root/.config/guix/current/lib/systemd/system/gnu-store.mount \
               ~root/.config/guix/current/lib/systemd/system/guix-daemon.service \
               /etc/systemd/system/
          # systemctl enable --now gnu-store.mount guix-daemon

     Si votre distribution hôte utilise le système d’initialisation
     Upstart :

          # initctl reload-configuration
          # cp ~root/.config/guix/current/lib/upstart/system/guix-daemon.conf \
               /etc/init/
          # start guix-daemon

     Sinon, vous pouvez toujours démarrer le démon manuellement avec :

          # ~root/.config/guix/current/bin/guix-daemon \
                 --build-users-group=guixbuild

  6. Rendez la commande ‘guix’ disponible pour les autres personnes sur
     la machine, par exemple avec :

          # mkdir -p /usr/local/bin
          # cd /usr/local/bin
          # ln -s /var/guix/profiles/per-user/root/current-guix/bin/guix

     C’est aussi une bonne idée de rendre la version Info de ce manuel
     disponible ici :

          # mkdir -p /usr/local/share/info
          # cd /usr/local/share/info
          # for i in /var/guix/profiles/per-user/root/current-guix/share/info/* ;
            do ln -s $i ; done

     That way, assuming ‘/usr/local/share/info’ is in the search path,
     running ‘info guix’ will open this manual (*note (texinfo)Other
     Info Directories::, for more details on changing the Info search
     path).

  7. Pour utiliser les substituts de ‘ci.guix.gnu.org’ ou l’un de ses
     miroirs (*note Substituts::), autorisez-les :

          # guix archive --authorize < \
               ~root/.config/guix/current/share/guix/ci.guix.gnu.org.pub

  8. On peut avoir besoin d’effectuer des étapes supplémentaires pour
     que son environnement Guix soit prêt à être utilisé, *note Réglages
     applicatifs::.

   Voilà, l’installation est terminée !

   Vous pouvez confirmer que Guix fonctionne en installant un paquet
d’exemple dans le profil de root :

     # guix install hello

   L’archive d’installation binaire peut être (re)produite et vérifiée
simplement en lançant la commande suivante dans l’arborescence des
sources de Guix :

     make guix-binary.SYSTEM.tar.xz

… ce qui à son tour lance :

     guix pack -s SYSTEM --localstatedir \
       --profile-name=current-guix guix

   *Note Invoquer guix pack::, pour plus d’info sur cet outil pratique.


File: guix.fr.info,  Node: Prérequis,  Next: Lancer la suite de tests,  Prev: Installation binaire,  Up: Installation

2.2 Prérequis
=============

Cette section dresse la liste des prérequis pour la construction de Guix
depuis les sources. La procédure de construction pour Guix est la même
que pour les autres logiciels GNU, et n’est pas expliquée ici. Regardez
les fichiers ‘README’ et ‘INSTALL’ dans l’arborescence des sources de
Guix pour plus de détails.

   GNU Guix est disponible au téléchargement depuis son site web sur
<http://www.gnu.org/software/guix/>.

   GNU Guix dépend des paquets suivants :

   • GNU Guile (https://gnu.org/software/guile/), version 3.0.x or
     2.2.x;
   • Guile-Gcrypt (https://notabug.org/cwebber/guile-gcrypt), version
     0.1.0 ou supérieure,
   • GnuTLS (https://gnutls.org/), en particulier ses liaisons Guile
     (*note how to install the GnuTLS bindings for Guile:
     (gnutls-guile)Guile Preparations.),
   • Guile-SQLite3 (https://notabug.org/guile-sqlite3/guile-sqlite3),
     version 0.1.0 ou supérieure,
   • Guile-Git (https://gitlab.com/guile-git/guile-git), d’août 2017 ou
     ultérieur,
   • Guile-JSON (https://savannah.nongnu.org/projects/guile-json/) 3.x;
   • zlib (https://zlib.net),
   • GNU Make (https://www.gnu.org/software/make/).

   Les dépendances suivantes sont facultatives :

   • Support for build offloading (*note Réglages du délestage du
     démon::) and ‘guix copy’ (*note Invoquer guix copy::) depends on
     Guile-SSH (https://github.com/artyom-poptsov/guile-ssh), version
     0.12.0 or later.

   • When lzlib (https://www.nongnu.org/lzip/lzlib.html) is available,
     lzlib substitutes can be used and ‘guix publish’ can compress
     substitutes with lzlib.

   • Lorsque libbz2 (http://www.bzip.org) est disponible, ‘guix-daemon’
     peut l’utiliser pour compresser les journaux de construction.

   Unless ‘--disable-daemon’ was passed to ‘configure’, the following
packages are also needed:

   • GNU libgcrypt (https://gnupg.org/),
   • SQLite 3 (https://sqlite.org),
   • GCC’s g++ (https://gcc.gnu.org), avec le support pour le standard
     C++11.

   When configuring Guix on a system that already has a Guix
installation, be sure to specify the same state directory as the
existing installation using the ‘--localstatedir’ option of the
‘configure’ script (*note ‘localstatedir’: (standards)Directory
Variables.). Usually, this LOCALSTATEDIR option is set to the value
‘/var’. The ‘configure’ script protects against unintended
misconfiguration of LOCALSTATEDIR so you do not inadvertently corrupt
your store (*note Le dépôt::).


File: guix.fr.info,  Node: Lancer la suite de tests,  Next: Paramétrer le démon,  Prev: Prérequis,  Up: Installation

2.3 Lancer la suite de tests
============================

Après avoir lancé ‘configure’ et ‘make’ correctement, c’est une bonne
idée de lancer la suite de tests. Elle peut aider à trouver des erreurs
avec la configuration ou l’environnement, ou des bogues dans Guix
lui-même — et vraiment, rapporter des échecs de tests est une bonne
manière d’aider à améliorer le logiciel. Pour lancer la suite de tests,
tapez :

     make check

   Les cas de tests peuvent être lancés en parallèle : vous pouvez
utiliser l’option ‘-j’ de GNU make pour accélérer les choses. Le premier
lancement peut prendre plusieurs minutes sur une machine récente ; les
lancements suivants seront plus rapides car le dépôt créé pour les tests
aura déjà plusieurs choses en cache.

   Il est aussi possible de lancer un sous-ensemble des tests en
définissant la variable makefile ‘TESTS’ comme dans cet exemple :

     make check TESTS="tests/store.scm tests/cpio.scm"

   Par défaut, les résultats des tests sont affichés au niveau du
fichier. Pour voir les détails de chaque cas de test individuel, il est
possible de définir la variable makefile ‘SCM_LOG_DRIVER_FLAGS’ comme
dans cet exemple :

     make check TESTS="tests/base64.scm" SCM_LOG_DRIVER_FLAGS="--brief=no"

   Après un échec, envoyez un courriel à <bug-guix@gnu.org> et attachez
le fichier ‘test-suite.log’. Précisez la version de Guix utilisée ainsi
que les numéros de version de ses dépendances (*note Prérequis::) dans
votre message.

   Guix possède aussi une suite de tests de systèmes complets qui test
des instances complètes du système Guix. Elle ne peut être lancée qui
sur un système où Guix est déjà installé, avec :

     make check-system

ou, de nouveau, en définissant ‘TESTS’ pour choisir un sous-ensemble des
tests à lancer :

     make check-system TESTS="basic mcron"

   Ces tests systèmes sont définis dans les modules ‘(gnu tests ...)’.
Ils fonctionnent en lançant les systèmes d’exploitation sous test avec
une instrumentation légère dans une machine virtuelle (VM). Ils peuvent
être intenses en terme de calculs ou plutôt rapides en fonction de la
disponibilité des substituts de leurs dépendances (*note Substituts::).
Certains requièrent beaucoup d’espace disque pour contenir les images
des VM.

   De nouveau, en cas d’échec, envoyez tous les détails à
<bug-guix@gnu.org>.


File: guix.fr.info,  Node: Paramétrer le démon,  Next: Invoquer guix-daemon,  Prev: Lancer la suite de tests,  Up: Installation

2.4 Paramétrer le démon
=======================

Les opérations comme la construction d’un paquet ou le lancement du
ramasse-miettes sont toutes effectuées par un processus spécialisé, le
“démon de construction”, pour le compte des clients. Seul le démon peut
accéder au dépôt et à sa base de données associée. Ainsi, toute
opération manipulant le dépôt passe par le démon. Par exemple, les
outils en ligne de commande comme ‘guix package’ et ‘guix build’
communiquent avec le démon (via des appels de procédures distantes) pour
lui dire quoi faire.

   Les sections suivantes expliquent comment préparer l’environnement du
démon de construction. Voir aussi *note Substituts:: pour apprendre
comment permettre le téléchargement de binaires pré-construits.

* Menu:

* Réglages de l'environnement de construction::  Préparer l’environnement
                                                    de construction isolé.
* Réglages du délestage du démon::  Envoyer des constructions à des
                                         machines distantes.
* Support de SELinux::       Utiliser une politique SELinux pour le démon.


File: guix.fr.info,  Node: Réglages de l'environnement de construction,  Next: Réglages du délestage du démon,  Up: Paramétrer le démon

2.4.1 Réglages de l’environnement de construction
-------------------------------------------------

Dans une installation standard multi-utilisateur·rice·s, Guix et son
démon — le programme ‘guix-daemon’ — sont installés par la personne qui
administre le système ; ‘/gnu/store’ appartient à ‘root’ et
‘guix-daemon’ est lancé en ‘root’. Les utilisateur·rice·s
non-privilégié·e·s peuvent utiliser les outils Guix pour construire des
paquets ou accéder au dépôt et le démon le fera pour leur compte en
s’assurant que le dépôt garde un état cohérent et permet le partage des
paquets déjà construits entre les utilisateur·rice·s.

   Alors que ‘guix-daemon’ tourne en ‘root’, vous n’avez pas forcément
envie que les processus de construction de paquets tournent aussi en
‘root’, pour des raisons de sécurité évidentes. Pour éviter cela, vous
devriez créer une réserve spéciale de “comptes de construction” que les
processus de construction démarrés par le démon utiliseront. Ces comptes
de construction n’ont pas besoin d’un shell ou d’un répertoire personnel
; ils seront seulement utilisés quand le démon délaissera ses privilèges
‘root’ dans les processus de construction. En ayant plusieurs de ces
comptes, vous permettez au démon de lancer des processus de construction
distincts sous des UID différent, ce qui garanti qu’aucune interférence
n’ait lieu entre les uns et les autres — une fonctionnalité essentielle
puisque les constructions sont supposées être des fonctions pures (*note
Introduction::).

   Sur un système GNU/Linux, on peut créer une réserve de comptes de
construction comme ceci (avec la syntaxe Bash et les commandes ‘shadow’)
:

     # groupadd --system guixbuild
     # for i in `seq -w 1 10`;
       do
         useradd -g guixbuild -G guixbuild           \
                 -d /var/empty -s `which nologin`    \
                 -c "Compte de construction Guix $i" --system    \
                 guixbuilder$i;
       done

Le nombre de comptes de construction détermine le nombre de tâches de
constructions qui peuvent tourner en parallèle, tel que spécifié par
l’option ‘--max-jobs’ (*note ‘--max-jobs’: Invoquer guix-daemon.). Pour
utiliser ‘guix system vm’ et les commandes liées, vous devrez ajouter
les comptes de construction au groupe ‘kvm’ pour qu’ils puissent accéder
à ‘/dev/kvm’ avec ‘-G guixbuild,kvm’ plutôt que ‘-G guixbuild’ (*note
Invoquer guix system::).

   Le programme ‘guix-daemon’ peut ensuite être lancé en ‘root’ avec la
commande suivante(1) :

     # guix-daemon --build-users-group=guixbuild

De cette façon, le démon démarre les processus de construction dans un
chroot, sous un des comptes ‘guixbuilder’. Sur GNU/Linux par défaut,
l’environnement chroot ne contient rien d’autre que :

   • un répertoire ‘/dev’ minimal, créé presque indépendamment du ‘/dev’
     de l’hôte(2) ;

   • le répertoire ‘/proc’ ; il ne montre que les processus du conteneur
     car on utilise une espace de nom séparé pour les PID ;

   • ‘/etc/passwd’ avec une entrée pour le compte actuel et une entrée
     pour le compte ‘nobody’ ;

   • ‘/etc/group’ avec une entrée pour le groupe de ce compte ;

   • ‘/etc/hosts’ avec une entrée qui fait correspondre ‘localhost’ à
     ‘127.0.0.1’ ;

   • un répertoire ‘/tmp’ inscriptible.

   You can influence the directory where the daemon stores build trees
via the ‘TMPDIR’ environment variable. However, the build tree within
the chroot is always called ‘/tmp/guix-build-NAME.drv-0’, where NAME is
the derivation name—e.g., ‘coreutils-8.24’. This way, the value of
‘TMPDIR’ does not leak inside build environments, which avoids
discrepancies in cases where build processes capture the name of their
build tree.

   The daemon also honors the ‘http_proxy’ and ‘https_proxy’ environment
variables for HTTP and HTTPS downloads it performs, be it for
fixed-output derivations (*note Dérivations::) or for substitutes (*note
Substituts::).

   If you are installing Guix as an unprivileged user, it is still
possible to run ‘guix-daemon’ provided you pass ‘--disable-chroot’.
However, build processes will not be isolated from one another, and not
from the rest of the system. Thus, build processes may interfere with
each other, and may access programs, libraries, and other files
available on the system—making it much harder to view them as _pure_
functions.

   ---------- Footnotes ----------

   (1) Si votre machine utilise le système d’initialisation systemd,
copiez le fichier ‘PREFIX/lib/systemd/system/guix-daemon.service’ dans
‘/etc/systemd/system’ pour vous assurer que ‘guix-daemon’ est démarré
automatiquement. De même, si votre machine utilise le système
d’initialisation Upstart, copiez le fichier
‘PREFIX/lib/upstart/system/guix-daemon.conf’ dans ‘/etc/init’.

   (2) « presque », parce que même si l’ensemble des fichiers qui
apparaissent dans le ‘/dev’ du chroot sont déterminés à l’avance, la
plupart de ces fichiers ne peut pas être créée si l’hôte ne les a pas.


File: guix.fr.info,  Node: Réglages du délestage du démon,  Next: Support de SELinux,  Prev: Réglages de l'environnement de construction,  Up: Paramétrer le démon

2.4.2 Utiliser le dispositif de déchargement
--------------------------------------------

Si vous le souhaitez, le démon de construction peut “décharger” des
constructions de dérivations sur d’autres machines Guix avec le “crochet
de construction” ‘offload’(1). Lorsque cette fonctionnalité est activée,
Guix lit une liste de machines de constructions spécifiée par
l’utilisateur·rice dans ‘/etc/guix/machines.scm’ ; à chaque fois qu’une
construction est demandée, par exemple par ‘guix build’, le démon essaie
de la décharger sur une des machines qui satisfont les contraintes de la
dérivation, en particulier le type de système, p. ex. ‘x86_64-linux’.
Les prérequis manquants pour la construction sont copiés par SSH sur la
machine de construction qui procède ensuite à la construction ; si elle
réussit, les sorties de la construction sont copiés vers la machine de
départ.

   Le fichier ‘/etc/guix/machines.scm’ ressemble typiquement à cela :

     (list (build-machine
             (name "eightysix.example.org")
             (system "x86_64-linux")
             (host-key "ssh-ed25519 AAAAC3Nza...")
             (user "bob")
             (speed 2.))     ;très rapide !

           (build-machine
             (name "armeight.example.org")
             (system "aarch64-linux")
             (host-key "ssh-rsa AAAAB3Nza...")
             (user "alice")
             (private-key
              (string-append (getenv "HOME")
                             "/.ssh/identity-for-guix"))))

In the example above we specify a list of two build machines, one for
the ‘x86_64’ architecture and one for the ‘aarch64’ architecture.

   En fait, ce fichier est — et ça ne devrait pas vous surprendre ! — un
fichier Scheme qui est évalué au démarrage du crochet ‘offload’. Sa
valeur de retour doit être une liste d’objets ‘build-machine’. Même si
cet exemple montre une liste fixée de machines de construction, on
pourrait imaginer par exemple utiliser DNS-SD pour renvoyer une liste de
machines de constructions potentielles découvertes sur le réseau local
(*note Guile-Avahi: (guile-avahi)Introduction.). Le type de données
‘build-machine’ est détaillé plus bas.

 -- Type de données : build-machine
     Ce type de données représente les machines de construction sur
     lesquelles le démon peut décharger des constructions. Les champs
     importants sont :

     ‘name’
          Le nom d’hôte de la machine distante.

     ‘system’
          Le type de système de la machine distante, p. ex.
          ‘"x86_64-linux"’.

     ‘user’
          Le compte à utiliser lors de la connexion à la machine
          distante par SSH. Remarquez que la paire de clef SSH ne doit
          _pas_ être protégée par mot de passe pour permettre des
          connexions non-interactives.

     ‘host-key’
          Cela doit être la “clef d’hôte SSH publique” de la machine au
          format OpenSSH. Elle est utilisée pour authentifier la machine
          lors de la connexion. C’est une longue chaîne qui ressemble à
          cela :

               ssh-ed25519 AAAAC3NzaC...mde+UhL hint@example.org

          Si la machine utilise le démon OpenSSH, ‘sshd’, la clef d’hôte
          se trouve dans un fichier comme
          ‘/etc/ssh/ssh_host_ed25519_key.pub’.

          Si la machine utilise le démon SSH de GNU lsh, la clef d’hôte
          est dans ‘/etc/lsh/host-key.pub’ ou un fichier similaire. Elle
          peut être convertie au format OpenSSH avec ‘lsh-export-key’
          (*note (lsh)Converting keys::) :

               $ lsh-export-key --openssh < /etc/lsh/host-key.pub
               ssh-rsa AAAAB3NzaC1yc2EAAAAEOp8FoQAAAQEAs1eB46LV...

     Il y a un certain nombre de champs facultatifs que vous pouvez
     remplir :

     ‘port’ (par défaut : ‘22’)
          Numéro de port du serveur SSH sur la machine.

     ‘private-key’ (par défaut : ‘~root/.ssh/id_rsa’)
          Le fichier de clef privée SSH à utiliser lors de la connexion
          à la machine, au format OpenSSH. Cette clef ne doit pas être
          protégée par phrase de passe.

          Remarquez que la valeur par défaut est la clef privée _du
          compte root_. Assurez-vous qu’elle existe si vous utilisez la
          valeur par défaut.

     ‘compression’ (par défaut : ‘"zlib@openssh.com,zlib"’)
     ‘compression-level’ (par défaut : ‘3’)
          Les méthodes de compression au niveau SSH et le niveau de
          compression demandé.

          Remarquez que le déchargement utilise la compression SSH pour
          réduire la bande passante utilisée lors du transfert vers et
          depuis les machines de construction.

     ‘daemon-socket’ (par défaut : ‘"/var/guix/daemon-socket/socket"’)
          Le nom de fichier du socket Unix-domain sur lequel
          ‘guix-daemon’ écoute sur cette machine.

     ‘parallel-builds’ (par défaut : ‘1’)
          Le nombre de constructions qui peuvent tourner simultanément
          sur la machine.

     ‘speed’ (par défaut : ‘1.0’)
          Un « facteur de vitesse relatif ». L’ordonnanceur des
          constructions tendra à préférer les machines avec un plus
          grand facteur de vitesse.

     ‘features’ (par défaut : ‘'()’)
          Une liste de chaînes qui contient les fonctionnalités
          spécifiques supportées par la machine. Un exemple est ‘"kvm"’
          pour les machines qui ont le module Linux KVM et le support
          matériel correspondant. Les dérivations peuvent demander des
          fonctionnalités par leur nom et seront orchestrées sur les
          machines de construction correspondantes.

   La commande ‘guix’ doit être dans le chemin de recherche des machines
de construction. Vous pouvez vérifier si c’est le cas en lançant :

     ssh build-machine guix repl --version

   Il reste une dernière chose à faire maintenant que ‘machines.scm’ est
en place. Comme expliqué ci-dessus, lors du déchargement les fichiers
sont transférés entre les dépôts des machines. Pour que cela fonctionne,
vous devez d’abord générer une paire de clef sur chaque machine pour
permettre au démon d’exporter des archives signées des fichiers de son
dépôt (*note Invoquer guix archive::) :

     # guix archive --generate-key

Chaque machine de construction doit autoriser la clef de la machine
maîtresse pour qu’ils acceptent les éléments de dépôt de celle-ci :

     # guix archive --authorize < master-public-key.txt

De même, la machine maîtresse doit autoriser les clefs de chaque machine
de construction.

   Toute cette histoire de clefs permet d’exprimer la confiance mutuelle
deux-à-deux entre le maître et les machines de construction.
Concrètement, lorsque le maître reçoit des fichiers d’une machine de
construction (et vice-versa), son démon de construction s’assure qu’ils
sont authentiques, n’ont pas été modifiés par un tiers et qu’il sont
signés par un clef autorisée.

   Pour tester que votre paramétrage fonctionne, lancez cette commande
sur le nœud maître :

     # guix offload test

   Cela essaiera de se connecter à toutes les machines de construction
spécifiées dans ‘/etc/guix/machines.scm’, s’assurera que Guile et les
modules Guix sont disponibles sur toutes les machines et tentera
d’exporter vers la machine et d’importer depuis elle, et rapportera
toute erreur survenu pendant le processus.

   Si vous souhaitez tester un fichier de machines différent,
spécifiez-le sur la ligne de commande :

     # guix offload test machines-qualif.scm

   Enfin, vous pouvez tester un sous-ensemble de machines dont le nom
correspond à une expression rationnelle comme ceci :

     # guix offload test machines.scm '\.gnu\.org$'

   Pour afficher la charge actuelle de tous les hôtes de construction,
lancez cette commande sur le nœud principal :

     # guix offload status

   ---------- Footnotes ----------

   (1) Cette fonctionnalité n’est disponible que si Guile-SSH
(https://github.com/artyom-poptsov/guile-ssh) est présent.


File: guix.fr.info,  Node: Support de SELinux,  Prev: Réglages du délestage du démon,  Up: Paramétrer le démon

2.4.3 Support de SELinux
------------------------

Guix inclus un fichier de politique SELinux dans ‘etc/guix-daemon.cil’
qui peut être installé sur un système où SELinux est activé pour que les
fichiers Guix soient étiquetés et pour spécifier le comportement attendu
du démon. Comme Guix System ne fournit pas de politique SELinux de base,
la politique du démon ne peut pas être utilisée sur le système Guix.

2.4.3.1 Installer la politique SELinux
......................................

Pour installer la politique, lancez cette commande en root :

     semodule -i etc/guix-daemon.cil

   Puis ré-étiquetez le système de fichier avec ‘restorecon’ ou par un
mécanisme différent fournit par votre système.

   Une fois la politique installée, le système de fichier ré-étiqueté et
le démon redémarré, il devrait être lancé dans le contexte
‘guix_daemon_t’. Vous pouvez le confirmer avec la commande suivante :

     ps -Zax | grep guix-daemon

   Surveillez les fichiers journaux de SELinux pendant que vous lancez
une commande comme ‘guix build hello’ pour vous convaincre que SELniux
permet toutes les opérations nécessaires.

2.4.3.2 Limitations
...................

La politique n’est pas parfaite. Voici une liste de limitations et de
bizarreries qui vous devriez prendre en compte avant de déployer la
politique SELinux fournie pour le démon Guix.

  1. ‘guix_daemon_socket_t’ n’est pas vraiment utilisé. Aucune des
     opérations sur les sockets n’impliquent de contextes qui ont quoi
     que ce soit à voir avec ‘guix_daemon_socket_t’. Ça ne fait pas de
     mal d’avoir une étiquette inutilisée, mais il serait préférable de
     définir des règles sur les sockets uniquement pour cette étiquette.

  2. ‘guix gc’ ne peut pas accéder à n’importe quel lien vers les
     profils. Par conception, l’étiquette de fichier de la destination
     d’un lien symbolique est indépendant de l’étiquette du lien
     lui-même. Bien que tous les profils sous $localstatedir aient une
     étiquette, les liens vers ces profils héritent de l’étiquette du
     répertoire dans lequel ils se trouvent. Pour les liens dans le
     répertoire personnel cela sera ‘user_home_t’. Mais pour les liens
     du répertoire personnel de root, ou ‘/tmp’, ou du répertoire de
     travail du serveur HTTP, etc, cela ne fonctionnera pas. SELinux
     empêcherait ‘guix gc’ de lire et de suivre ces liens.

  3. La fonctionnalité du démon d’écouter des connexions TCP pourrait ne
     plus fonctionner. Cela demande des règles supplémentaires car
     SELinux traite les sockets réseau différemment des fichiers.

  4. Actuellement tous les fichiers qui correspondent à l’expression
     rationnelle ‘/gnu/store/.+-(guix-.+|profile)/bin/guix-daemon’
     reçoivent l’étiquette ‘guix_daemon_exec_t’ ; cela signifie que
     _tout_ fichier avec ce nom dans n’importe quel profil serait
     autorisé à se lancer dans le domaine ‘guix_daemon_t’. Ce n’est pas
     idéal. Un attaquant pourrait construire un paquet qui fournit cet
     exécutable et convaincre un·e utilisateur·rice de l’installer et de
     le lancer, ce qui l’élève dans le domaine ‘guix_daemon_t’. À ce
     moment SELinux ne pourrait pas l’empêcher d’accéder à des fichiers
     autorisés pour les processus de ce domaine.

     Nous pourrions générer une politique bien plus restrictive à
     l’installation, pour que seuls les noms de fichiers _exacts_ de
     l’exécutable ‘guix-daemon’ actuellement installé soit étiqueté avec
     ‘guix_daemon_exec_t’, plutôt que d’utiliser une expression
     rationnelle plus large. L’inconvénient c’est que root devrait
     installer ou mettre à jour la politique à l’installation à chaque
     fois que le paquet Guix qui fournit l’exécutable ‘guix-daemon’
     effectivement exécuté est mis à jour.


File: guix.fr.info,  Node: Invoquer guix-daemon,  Next: Réglages applicatifs,  Prev: Paramétrer le démon,  Up: Installation

2.5 Invoquer ‘guix-daemon’
==========================

Le programme ‘guix-daemon’ implémente toutes les fonctionnalités d’accès
au dépôt. Cela inclus le lancement des processus de construction, le
lancement du ramasse-miettes, la demande de disponibilité des résultats
de construction, etc. Il tourne normalement en ‘root’ comme ceci :

     # guix-daemon --build-users-group=guixbuild

Pour des détails sur son paramétrage, *note Paramétrer le démon::.

   By default, ‘guix-daemon’ launches build processes under different
UIDs, taken from the build group specified with ‘--build-users-group’.
In addition, each build process is run in a chroot environment that only
contains the subset of the store that the build process depends on, as
specified by its derivation (*note derivation: Interface de
programmation.), plus a set of specific system directories. By default,
the latter contains ‘/dev’ and ‘/dev/pts’. Furthermore, on GNU/Linux,
the build environment is a “container”: in addition to having its own
file system tree, it has a separate mount name space, its own PID name
space, network name space, etc. This helps achieve reproducible builds
(*note Fonctionnalités::).

   When the daemon performs a build on behalf of the user, it creates a
build directory under ‘/tmp’ or under the directory specified by its
‘TMPDIR’ environment variable. This directory is shared with the
container for the duration of the build, though within the container,
the build tree is always called ‘/tmp/guix-build-NAME.drv-0’.

   Le répertoire de construction est automatiquement supprimé à la fin,
à moins que la construction n’ait échoué et que le client ait spécifié
‘--keep-failed’ (*note ‘--keep-failed’: Invoquer guix build.).

   The daemon listens for connections and spawns one sub-process for
each session started by a client (one of the ‘guix’ sub-commands). The
‘guix processes’ command allows you to get an overview of the activity
on your system by viewing each of the active sessions and clients. *Note
Invoquer guix processes::, for more information.

   Les options en ligne de commande suivantes sont disponibles :

‘--build-users-group=GROUPE’
     Utiliser les comptes du GROUPE pour lancer les processus de
     construction (*note comptes de construction: Paramétrer le démon.).

‘--no-substitutes’
     Ne pas utiliser de substitut pour les résultats de la construction.
     C’est-à-dire, toujours construire localement plutôt que de
     permettre le téléchargement de binaires pré-construits (*note
     Substituts::).

     When the daemon runs with ‘--no-substitutes’, clients can still
     explicitly enable substitution via the ‘set-build-options’ remote
     procedure call (*note Le dépôt::).

‘--substitute-urls=URLS’
     Considérer URLS comme la liste séparée par des espaces des URL des
     sources de substituts par défaut. Lorsque cette option est omise,
     ‘https://ci.guix.gnu.org’ est utilisé.

     Cela signifie que les substituts sont téléchargés depuis les URLS,
     tant qu’ils sont signés par une signature de confiance (*note
     Substituts::).

‘--no-offload’
     Do not use offload builds to other machines (*note Réglages du
     délestage du démon::). That is, always build things locally instead
     of offloading builds to remote machines.

‘--cache-failures’
     Mettre les échecs de construction en cache. Par défaut, seules les
     constructions réussies sont mises en cache.

     Lorsque cette option est utilisée, ‘guix gc --list-failures’ peut
     être utilisé pour demander l’ensemble des éléments du dépôt marqués
     comme échoués ; ‘guix gc --clear-failures’ vide la liste des
     éléments aillant échoué. *Note Invoquer guix gc::.

‘--cores=N’
‘-c N’
     Utiliser N cœurs CPU pour construire chaque dérivation ; ‘0’
     signifie autant que possible.

     The default value is ‘0’, but it may be overridden by clients, such
     as the ‘--cores’ option of ‘guix build’ (*note Invoquer guix
     build::).

     The effect is to define the ‘NIX_BUILD_CORES’ environment variable
     in the build process, which can then use it to exploit internal
     parallelism—for instance, by running ‘make -j$NIX_BUILD_CORES’.

‘--max-jobs=N’
‘-M N’
     Permettre au plus N travaux de construction en parallèle. La valeur
     par défaut est ‘1’. La mettre à ‘0’ signifie qu’aucune construction
     ne sera effectuée localement ; à la place, le démon déchargera les
     constructions (*note Réglages du délestage du démon::) ou échouera.

‘--max-silent-time=SECONDES’
     Lorsque le processus de construction ou de substitution restent
     silencieux pendant plus de SECONDES, le terminer et rapporter une
     erreur de construction.

     La valeur par défaut est ‘0’, ce qui désactive le délai.

     The value specified here can be overridden by clients (*note
     ‘--max-silent-time’: Options de construction communes.).

‘--timeout=SECONDES’
     De même, lorsque le processus de construction ou de substitution
     dure plus de SECONDES, le terminer et rapporter une erreur de
     construction.

     La valeur par défaut est ‘0’, ce qui désactive le délai.

     The value specified here can be overridden by clients (*note
     ‘--timeout’: Options de construction communes.).

‘--rounds=N’
     Construire chaque dérivations N fois à la suite, et lever une
     erreur si les résultats de construction consécutifs ne sont pas
     identiques bit-à-bit. Remarquez que ce paramètre peut être modifié
     par les clients comme ‘guix build’ (*note Invoquer guix build::).

     Lorsqu’utilisé avec ‘--keep-failed’, la sortie différente est
     gardée dans le dépôt sous ‘/gnu/store/...-check’. Cela rend plus
     facile l’étude des différences entre les deux résultats.

‘--debug’
     Produire une sortie de débogage.

     This is useful to debug daemon start-up issues, but then it may be
     overridden by clients, for example the ‘--verbosity’ option of
     ‘guix build’ (*note Invoquer guix build::).

‘--chroot-directory=RÉP’
     Ajouter RÉP au chroot de construction.

     Cela peut changer le résultat d’un processus de construction — par
     exemple s’il utilise une dépendance facultative trouvée dans RÉP
     lorsqu’elle est disponible ou pas sinon. Pour cette raison, il
     n’est pas recommandé d’utiliser cette option. À la place,
     assurez-vous que chaque dérivation déclare toutes les entrées dont
     elle a besoin.

‘--disable-chroot’
     Désactive les constructions dans un chroot.

     Utiliser cette option n’est pas recommandé car, de nouveau, elle
     permet aux processus de construction d’accéder à des dépendances
     non déclarées. Elle est nécessaire cependant lorsque ‘guix-daemon’
     tourne sans privilèges.

‘--log-compression=TYPE’
     Compresser les journaux de construction suivant le TYPE, parmi
     ‘gzip’, ‘bzip2’ ou ‘none’.

     Unless ‘--lose-logs’ is used, all the build logs are kept in the
     LOCALSTATEDIR. To save space, the daemon automatically compresses
     them with Bzip2 by default.

‘--disable-deduplication’
     Désactiver la « déduplication » automatique des fichiers dans le
     dépôt.

     Par défaut, les fichiers ajoutés au dépôt sont automatiquement «
     dédupliqués » : si un nouveau fichier est identique à un autre
     fichier trouvé dans le dépôt, le démon en fait un lien en dur vers
     l’autre fichier. Cela réduit considérablement l’utilisation de
     l’espace disque au prix d’une charge en entrée/sortie plus grande à
     la fin d’un processus de construction. Cette option désactive cette
     optimisation.

‘--gc-keep-outputs[=yes|no]’
     Dire si le ramasse-miettes (GC) doit garder les sorties des
     dérivations utilisées.

     When set to ‘yes’, the GC will keep the outputs of any live
     derivation available in the store—the ‘.drv’ files. The default is
     ‘no’, meaning that derivation outputs are kept only if they are
     reachable from a GC root. *Note Invoquer guix gc::, for more on GC
     roots.

‘--gc-keep-derivations[=yes|no]’
     Dire si le ramasse-miettes (GC) doit garder les dérivations
     correspondant à des sorties utilisées.

     When set to ‘yes’, as is the case by default, the GC keeps
     derivations—i.e., ‘.drv’ files—as long as at least one of their
     outputs is live. This allows users to keep track of the origins of
     items in their store. Setting it to ‘no’ saves a bit of disk space.

     In this way, setting ‘--gc-keep-derivations’ to ‘yes’ causes
     liveness to flow from outputs to derivations, and setting
     ‘--gc-keep-outputs’ to ‘yes’ causes liveness to flow from
     derivations to outputs. When both are set to ‘yes’, the effect is
     to keep all the build prerequisites (the sources, compiler,
     libraries, and other build-time tools) of live objects in the
     store, regardless of whether these prerequisites are reachable from
     a GC root. This is convenient for developers since it saves
     rebuilds or downloads.

‘--impersonate-linux-2.6’
     On Linux-based systems, impersonate Linux 2.6. This means that the
     kernel’s ‘uname’ system call will report 2.6 as the release number.

     Cela peut être utile pour construire des programmes qui dépendent
     (généralement sans fondement) du numéro de version du noyau.

‘--lose-logs’
     Do not keep build logs. By default they are kept under
     ‘LOCALSTATEDIR/guix/log’.

‘--system=SYSTÈME’
     Supposer que SYSTÈME est le type de système actuel. Par défaut
     c’est la paire architecture-noyau trouvée à la configuration, comme
     ‘x86_64-linux’.

‘--listen=EXTRÉMITÉ’
     Écouter les connexions sur EXTRÉMITÉ. EXTRÉMITÉ est interprété
     comme un nom de fichier d’un socket Unix-domain s’il commence par
     ‘/’ (barre oblique). Sinon, EXTRÉMITÉ est interprété comme un nom
     de domaine ou d’hôte et un port sur lequel écouter. Voici quelques
     exemples :

     ‘--listen=/gnu/var/daemon’
          Écouter les connexions sur le socket Unix-domain
          ‘/gnu/var/daemon’ en le créant si besoin.

     ‘--listen=localhost’
          Écouter les connexions TCP sur l’interface réseau
          correspondant à ‘localhost’ sur le port 44146.

     ‘--listen=128.0.0.42:1234’
          Écouter les connexions TCP sur l’interface réseau
          correspondant à ‘128.0.0.42’ sur le port 1234.

     This option can be repeated multiple times, in which case
     ‘guix-daemon’ accepts connections on all the specified endpoints.
     Users can tell client commands what endpoint to connect to by
     setting the ‘GUIX_DAEMON_SOCKET’ environment variable (*note
     ‘GUIX_DAEMON_SOCKET’: Le dépôt.).

          Remarque : The daemon protocol is _unauthenticated and
          unencrypted_. Using ‘--listen=HOST’ is suitable on local
          networks, such as clusters, where only trusted nodes may
          connect to the build daemon. In other cases where remote
          access to the daemon is needed, we recommend using Unix-domain
          sockets along with SSH.

     When ‘--listen’ is omitted, ‘guix-daemon’ listens for connections
     on the Unix-domain socket located at
     ‘LOCALSTATEDIR/guix/daemon-socket/socket’.


File: guix.fr.info,  Node: Réglages applicatifs,  Next: Upgrading Guix,  Prev: Invoquer guix-daemon,  Up: Installation

2.6 Réglages applicatifs
========================

Lorsque vous utilisez Guix par dessus une distribution GNU/Linux qui
n’est pas Guix System — ce qu’on appelle une “distro externe” — quelques
étapes supplémentaires sont requises pour que tout soit en place. En
voici certaines.

2.6.1 Régionalisation
---------------------

Packages installed via Guix will not use the locale data of the host
system. Instead, you must first install one of the locale packages
available with Guix and then define the ‘GUIX_LOCPATH’ environment
variable:

     $ guix install glibc-locales
     $ export GUIX_LOCPATH=$HOME/.guix-profile/lib/locale

   Note that the ‘glibc-locales’ package contains data for all the
locales supported by the GNU libc and weighs in at around 917 MiB.
Alternatively, the ‘glibc-utf8-locales’ is smaller but limited to a few
UTF-8 locales.

   The ‘GUIX_LOCPATH’ variable plays a role similar to ‘LOCPATH’ (*note
‘LOCPATH’: (libc)Locale Names.). There are two important differences
though:

  1. ‘GUIX_LOCPATH’ is honored only by the libc in Guix, and not by the
     libc provided by foreign distros. Thus, using ‘GUIX_LOCPATH’ allows
     you to make sure the programs of the foreign distro will not end up
     loading incompatible locale data.

  2. libc suffixes each entry of ‘GUIX_LOCPATH’ with ‘/X.Y’, where ‘X.Y’
     is the libc version—e.g., ‘2.22’. This means that, should your Guix
     profile contain a mixture of programs linked against different libc
     version, each libc version will only try to load locale data in the
     right format.

   Cela est important car le format des données linguistiques utilisés
par différentes version de la libc peuvent être incompatibles.

2.6.2 Name Service Switch
-------------------------

Lorsque vous utilisez Guix sur une distro externe, nous _recommandons
fortement_ que ce système fasse tourner le “démon de cache de service de
noms” de la bibliothèque C de GNU, ‘nscd’, qui devrait écouter sur le
socket ‘/var/run/nscd/socket’. Sans cela, les applications installées
avec Guix peuvent échouer à résoudre des noms d’hôtes ou de comptes, ou
même planter. Les paragraphes suivants expliquent pourquoi.

   La bibliothèque C de GNU implémente un “name service switch” (NSS),
qui est un mécanisme d’extension pour les « résolutions de noms » en
général : résolution de nom d’hôte, de compte utilisateur·rice et plus
(*note (libc)Name Service Switch::).

   Comme il est extensible, NSS supporte des “greffons” qui fournissent
une nouvelle implémentation de résolution de nom : par exemple le
greffon ‘nss-mdns’ permet la résolution de noms d’hôtes en ‘.local’, le
greffon ‘nis’ permet la résolution de comptes avec le Network
Information Service (NIS), etc. Ces « services de recherches »
supplémentaires sont configurés au niveau du système dans
‘/etc/nsswitch.conf’, et tous les programmes qui tournent sur ce système
honorent ces paramètres (*note (libc)NSS Configuration File::)

   Lorsqu’ils essayent d’effectuer une résolution de nom — par exemple
en appelant la fonction ‘getaddrinfo’ en C — les applications essayent
d’abord de se connecter au nscd ; en cas de réussite, nscd effectue la
résolution de nom pour eux. Si le nscd ne tourne pas, alors ils
effectuent la résolution eux-mêmes, en changeant les service de
résolution dans leur propre espace d’adressage et en le lançant. Ce
services de résolution de noms — les fichiers ‘libnns_*.so’ — sont
‘dlopen’és mais ils peuvent provenir de la bibliothèque C du système,
plutôt que de la bibliothèque C à laquelle l’application est liée (la
bibliothèque C de Guix).

   Et c’est là que se trouve le problème : si votre application est liée
à la bibliothèque C de Guix (disons, glibc-2.24) et essaye de charger
les greffons NSS d’une autre bibliothèque C (disons, ‘libnss_mdns.so’
pour glibc-2.22), il est très probable qu’elle plante ou que sa
résolution de nom échoue de manière inattendue.

   Lancer ‘nscd’ sur le système, entre autres avantages, élimine ce
problème d’incompatibilité binaire car ces fichiers ‘libnss_*.so’ sont
chargés par le processus ‘nscd’, pas par l’application elle-même.

2.6.3 Polices X11
-----------------

The majority of graphical applications use Fontconfig to locate and load
fonts and perform X11-client-side rendering. The ‘fontconfig’ package in
Guix looks for fonts in ‘$HOME/.guix-profile’ by default. Thus, to allow
graphical applications installed with Guix to display fonts, you have to
install fonts with Guix as well. Essential font packages include
‘gs-fonts’, ‘font-dejavu’, and ‘font-gnu-freefont’.

   Once you have installed or removed fonts, or when you notice an
application that does not find fonts, you may need to install Fontconfig
and to force an update of its font cache by running:

     guix install fontconfig
     fc-cache -rv

   Pour afficher des textes écrits en chinois, en japonais ou en coréen
dans les applications graphiques, installez ‘font-adobe-source-han-sans’
ou ‘font-wqy-zenhei’. Le premier a plusieurs sorties, une par famille de
langue (*note Des paquets avec plusieurs résultats::). Par exemple, la
commande suivante installe les polices pour le chinois :

     guix install font-adobe-source-han-sans:cn

   Les vieux programmes comme ‘xterm’ n’utilisent pas fontconfig et
s’appuient sur le rendu du côté du serveur. Ces programmes ont besoin de
spécifier le nom complet de la police en utilisant XLFD (X Logical Font
Description), comme ceci :

     -*-dejavu sans-medium-r-normal-*-*-100-*-*-*-*-*-1

   Pour pouvoir utiliser ces noms complets avec les polices TrueType
installées dans votre profil Guix, vous devez étendre le chemin des
polices du serveur X :

     xset +fp $(dirname $(readlink -f ~/.guix-profile/share/fonts/truetype/fonts.dir))

   Ensuite, vous pouvez lancer ‘xlsfonts’ (du paquet ‘xlsfonts’) pour
vous assurer que vos polices TrueType y sont listées.

2.6.4 Certificats X.509
-----------------------

Le paquet ‘nss-certs’ fournit les certificats X.509 qui permettent aux
programmes d’authentifier les serveurs web par HTTPS.

   Lorsque vous utilisez Guix sur une distribution externe, vous pouvez
installer ce paquet et définir les variables d’environnement adéquates
pour que les paquets sachent où trouver les certificats. *Note
Certificats X.509::, pour des informations détaillées.

2.6.5 Paquets emacs
-------------------

When you install Emacs packages with Guix, the Elisp files are placed
under the ‘share/emacs/site-lisp/’ directory of the profile in which
they are installed. The Elisp libraries are made available to Emacs
through the ‘EMACSLOADPATH’ environment variable, which is set when
installing Emacs itself.

   Additionally, autoload definitions are automatically evaluated at the
initialization of Emacs, by the Guix-specific
‘guix-emacs-autoload-packages’ procedure. If, for some reason, you want
to avoid auto-loading the Emacs packages installed with Guix, you can do
so by running Emacs with the ‘--no-site-file’ option (*note (emacs)Init
File::).


File: guix.fr.info,  Node: Upgrading Guix,  Prev: Réglages applicatifs,  Up: Installation

2.7 Upgrading Guix
==================

To upgrade Guix, run:

     guix pull

   *Note Invoquer guix pull::, for more information.

   On a foreign distro, you can upgrade the build daemon by running:

     sudo -i guix pull

followed by (assuming your distro uses the systemd service management
tool):

     systemctl restart guix-daemon.service

   On Guix System, upgrading the daemon is achieved by reconfiguring the
system (*note ‘guix system reconfigure’: Invoquer guix system.).


File: guix.fr.info,  Node: Installation du système,  Next: Gestion de paquets,  Prev: Installation,  Up: Top

3 Installation du système
*************************

Cette section explique comment installer Guix System sur une machine.
Guix, en tant que gestionnaire de paquets, peut aussi être installé sur
un système GNU/Linux déjà installé, *note Installation::.

     Remarque : Vous lisez cette documentation avec un lecteur Info.
     Pour des détails sur son utilisation, appuyez sur la touche
     <ENTRÉE> (« Entrée » ou « à la ligne ») sur le lien suivant : *note
     Info reader: (info-stnd)Top. Appuyez ensuite sur ‘l’ pour revenir
     ici.

     Alternatively, run ‘info info’ in another tty to keep the manual
     available.

* Menu:

* Limitations::              Ce à quoi vous attendre.
* Considérations matérielles::  Matériel supporté.
* Installation depuis une clef USB ou un DVD::  Préparer le média
                                                  d’installation.
* Préparer l'installation::  Réseau, partitionnement, etc.
* Installation graphique guidée::  Installation graphique facile.
* Installation manuelle::    Installation manuelle pour les sorciers.
* Après l'installation du système::  Une fois que l’installation a
                                         réussi.
* Installer Guix dans une VM::  Jouer avec le système Guix.
* Construire l'image d'installation::  D’où vient tout cela.


File: guix.fr.info,  Node: Limitations,  Next: Considérations matérielles,  Up: Installation du système

3.1 Limitations
===============

Nous considérons Guix System comme prêt pour une grande variété de cas
d’utilisation pour le « bureau » et le serveur. Les garantis de
fiabilité qu’il fournit — les mises à jour transactionnelles, les
retours en arrières et la reproductibilité — en font une solide
fondation.

   Néanmoins, avant de procéder à l’installation, soyez conscient de ces
limitations les plus importantes qui s’appliquent à la version
1.0.1.17089-7e269 :

   • LVM (gestionnaire de volumes logiques) n’est pas supporté.

   • De plus en plus de services systèmes sont fournis (*note
     Services::) mais certains manquent toujours cruellement.

   • GNOME, Xfce, LXDE et Enlightenment sont disponibles (*note Services
     de bureaux::), ainsi qu’un certain nombre de gestionnaires de
     fenêtres X11. Cependant, il manque actuellement KDE.

   Plus qu’un avertissement, c’est une invitation à rapporter les
problèmes (et vos succès !) et à nous rejoindre pour améliorer la
distribution. *Note Contribuer::, pour plus d’info.


File: guix.fr.info,  Node: Considérations matérielles,  Next: Installation depuis une clef USB ou un DVD,  Prev: Limitations,  Up: Installation du système

3.2 Considérations matérielles
==============================

GNU Guix se concentre sur le respect des libertés de ses utilisateurs et
utilisatrices. Il est construit autour du noyau Linux-libre, ce qui
signifie que seuls les matériels pour lesquels des pilotes logiciels et
des microgiciels libres sont disponibles sont pris en charge. De nos
jours, une grande gamme de matériel qu’on peut acheter est prise en
charge par GNU/Linux-libre — des claviers aux cartes graphiques en
passant par les scanners et les contrôleurs Ethernet. Malheureusement,
il reste des produits dont les fabricants refusent de laisser le
contrôle aux utilisateur·rice·s sur leur propre utilisation de
l’ordinateur, et ces matériels ne sont pas pris en charge par Guix
System.

   L’un des types de matériels où les pilotes ou les microgiciels sont
le moins disponibles sont les appareils WiFi. Les appareils WiFi connus
pour fonctionner sont ceux qui utilisent des puces Atheros (AR9271 et
AR7010) qui correspondent au pilote ‘ath9k’ de Linux-libre, et ceux qui
utilisent des puces Broadcom/AirForce (BCM43xx avec la révision
Wireless-Core 5), qui correspondent au pilote ‘b43-open’ de Linux-libre.
Des microgiciels libres existent pour les deux et sont disponibles
directement sur Guix System, dans %BASE-FIRMWARE (*note ‘firmware’:
Référence de système d'exploitation.).

   La Free Software Foundation (https://www.fsf.org/) a un programme de
certification nommé “Respects Your Freedom” (https://www.fsf.org/ryf)
(RYF), pour les produits matériels qui respectent votre liberté et votre
vie privée en s’assurant que vous avez le contrôle sur l’appareil. Nous
vous encourageons à vérifier la liste des appareils certifiés par RYF.

   Une autre ressource utile est le site web H-Node
(https://www.h-node.org/). Il contient un catalogue d’appareils avec des
informations sur leur support dans GNU/Linux.


File: guix.fr.info,  Node: Installation depuis une clef USB ou un DVD,  Next: Préparer l'installation,  Prev: Considérations matérielles,  Up: Installation du système

3.3 Installation depuis une clef USB ou un DVD
==============================================

An ISO-9660 installation image that can be written to a USB stick or
burnt to a DVD can be downloaded from
‘https://ftp.gnu.org/gnu/guix/guix-system-install-1.0.1.17089-7e269.x86_64-linux.iso.xz’,
where you can replace ‘x86_64-linux’ with one of:

‘x86_64-linux’
     pour un système GNU/Linux sur un CPU compatible Intel/AMD 64-bits ;

‘i686-linux’
     pour un système GNU/Linux sur un CPU compatible Intel 32-bits ;

   Assurez-vous de télécharger les fichiers ‘.sig’ associés et de
vérifier l’authenticité de l’image avec, de cette manière :

     $ wget https://ftp.gnu.org/gnu/guix/guix-system-install-1.0.1.17089-7e269.x86_64-linux.iso.xz.sig
     $ gpg --verify guix-system-install-1.0.1.17089-7e269.x86_64-linux.iso.xz.sig

   Si cette commande échoue parce que vous n’avez pas la clef publique
requise, lancez cette commande pour l’importer :

     $ wget https://sv.gnu.org/people/viewgpg.php?user_id=15145 \
           -qO - | gpg --import -

et relancez la commande ‘gpg --verify’.

   Take note that a warning like “This key is not certified with a
trusted signature!” is normal.

   Cette image contient les outils nécessaires à l’installation. Elle
est faite pour être copiée _telle quelle_ sur une clef USB assez grosse
ou un DVD.

Copie sur une clef USB
----------------------

Pour copier l’image sur une clef USB, suivez ces étapes :

  1. Décompressez l’image avec la commande ‘xz’ :

          xz -d guix-system-install-1.0.1.17089-7e269.x86_64-linux.iso.xz

  2. Insérez la clef USB de 1 Gio ou plus dans votre machine et
     déterminez son nom d’appareil. En supposant que la clef usb est
     connue sous le nom de ‘/dev/sdX’, copiez l’image avec :

          dd if=guix-system-install-1.0.1.17089-7e269.x86_64-linux.iso of=/dev/sdX
          sync

     Accéder à ‘/dev/sdX’ requiert généralement les privilèges
     d’administration.

Graver sur un DVD
-----------------

Pour copier l’image sur un DVD, suivez ces étapes :

  1. Décompressez l’image avec la commande ‘xz’ :

          xz -d guix-system-install-1.0.1.17089-7e269.x86_64-linux.iso.xz

  2. Insérez un DVD vierge dans votre machine et déterminez son nom
     d’appareil. En supposant que le DVD soit connu sont le nom de
     ‘/dev/srX’, copiez l’image avec :

          growisofs -dvd-compat -Z /dev/srX=guix-system-install-1.0.1.17089-7e269.x86_64-linux.iso

     Accéder à ‘/dev/srX’ requiert généralement les privilèges root.

Démarrage
---------

Once this is done, you should be able to reboot the system and boot from
the USB stick or DVD. The latter usually requires you to get in the BIOS
or UEFI boot menu, where you can choose to boot from the USB stick. In
order to boot from Libreboot, switch to the command mode by pressing the
‘c’ key and type ‘search_grub usb’.

   *Note Installer Guix dans une VM::, si, à la place, vous souhaitez
installer Guix System dans une machine virtuelle (VM).


File: guix.fr.info,  Node: Préparer l'installation,  Next: Installation graphique guidée,  Prev: Installation depuis une clef USB ou un DVD,  Up: Installation du système

3.4 Préparer l’installation
===========================

Once you have booted, you can use the guided graphical installer, which
makes it easy to get started (*note Installation graphique guidée::).
Alternatively, if you are already familiar with GNU/Linux and if you
want more control than what the graphical installer provides, you can
choose the “manual” installation process (*note Installation
manuelle::).

   L’installateur graphique est disponible sur le TTY1. Vous pouvez
obtenir des shells root sur les TTY 3 à 6 en tapant ‘ctrl-alt-f3’,
‘ctrl-alt-f4’ etc. Le TTY2 affiche cette documentation que vous pouvez
atteindre avec ‘ctrl-alt-f2’. On peut naviguer dans la documentation
avec les commandes du lecteur Info (*note (info-stnd)Top::). Le démon de
souris GPM tourne sur le système d’installation, ce qui vous permet de
sélectionner du texte avec le bouton gauche de la souris et de le coller
en appuyant sur la molette.

     Remarque : L’installation nécessite un accès au réseau pour que les
     dépendances manquantes de votre configuration système puissent être
     téléchargées. Voyez la section « réseau » plus bas.


File: guix.fr.info,  Node: Installation graphique guidée,  Next: Installation manuelle,  Prev: Préparer l'installation,  Up: Installation du système

3.5 Installation graphique guidée
=================================

L’installateur graphique est une interface utilisateur en mode texte. Il
vous guidera, avec des boîtes de dialogue, le long des étapes requises
pour installer GNU Guix System.

   La première boîte de dialogue vous permet de paramétrer le système
comme vous le souhaitez pendant l’installation : vous pouvez choisir la
langue, la disposition du clavier et paramétrer le réseau, qui sera
utilisé pendant l’installation. L’image ci-dessous montre le dialogue
pour le réseau.

 [image src="images/installer-network.png" alt="paramétrage du réseau avec
l'installateur graphique" ]

   Les étapes suivantes vous permettent de partitionner votre disque
dur, comme le montre l’image ci-dessous, de choisir si vous voulez ou
non utiliser des systèmes de fichiers chiffrés, de saisir le nom d’hôte
et le mot de passe root et de créer un compte supplémentaire, entre
autres choses.

 [image src="images/installer-partitions.png" alt="partitionnement du disque avec
l'installateur graphique" ]

   Remarquez que, à tout moment, l’installateur vous permet de sortir de
l’étape d’installation actuelle et de recommencer une étape précédente,
comme le montre l’image ci-dessous.

 [image src="images/installer-resume.png" alt="reprise du processus d'installation" ]

   Une fois que vous avez fini, l’installateur produit une configuration
de système d’exploitation et vous la montre (*note Utiliser le système
de configuration::). À ce moment, vous pouvez appuyer sur « OK » et
l’installation continuera. Lorsqu’elle aura réussi, vous pourrez
redémarrer sur le nouveau système et vous amuser. *Note Après
l'installation du système::, pour la suite des festivités !


File: guix.fr.info,  Node: Installation manuelle,  Next: Après l'installation du système,  Prev: Installation graphique guidée,  Up: Installation du système

3.6 Installation manuelle
=========================

Cette section décrit comme vous pourriez installe « manuellement »
GNU Guix System sur votre machine. Cette option nécessite que vous soyez
familier avec GNU/Linux, le shell et avec les outils d’administration
usuels. Si vous pensez que ce n’est pas pour vous, pensez à utiliser
l’installateur graphique (*note Installation graphique guidée::).

   Le système d’installation fournit des shells root sur les TTY 3 à 6 ;
appuyez sur ‘ctrl-alt-f3’, ‘ctrl-alt-f4’ etc pour y accéder. Il inclus
plusieurs outils usuels pour requis pour cette tâche. Mais c’est aussi
un système Guix complet, ce qui signifie que vous pouvez installer des
paquets supplémentaires si vous en avez besoin, avec ‘guix package’
(*note Invoquer guix package::).

* Menu:

* Disposition du clavier réseau et partitionnement::  Paramètres initiaux.
* Effectuer l'installation::  Installer.


File: guix.fr.info,  Node: Disposition du clavier réseau et partitionnement,  Next: Effectuer l'installation,  Up: Installation manuelle

3.6.1 Disposition du clavier réseau et partitionnement
------------------------------------------------------

Avant que vous ne puissiez installer le système, vous voudrez sans doute
ajuster la disposition du clavier, paramétrer le réseau et partitionner
le disque dur cible. Cette section vous guidera à travers tout cela.

3.6.1.1 Disposition du clavier
..............................

L’image d’installation utilise la disposition clavier qwerty (US). Si
vous voulez la changer, vous pouvez utiliser la commande ‘loadkeys’. Par
exemple, la commande suivante sélectionne la disposition Dvorak :

     loadkeys dvorak

   Consultez les fichiers dans
‘/run/current-system/profile/share/keymaps’ pour trouver une liste des
dispositions disponibles. Lancez ‘man loadkey’ pour plus d’informations.

3.6.1.2 Réseau
..............

Lancez la commande suivante pour voir comment vos interfaces réseau sont
appelées :

     ifconfig -a

... ou, avec la commande spécifique à GNU/Linux ‘ip’ :

     ip address

   Les interfaces filaires ont un nom qui commence par ‘e’ ; par
exemple, l’interface qui correspond au premier contrôleur Ethernet sur
la carte mère est appelé ‘eno1’. Les interfaces sans-fil ont un nom qui
commence par ‘w’, comme ‘w1p2s0’.

Connexion filaire
     Pour configure une connexion filaire, lancez la commande suivante,
     en remplaçant INTERFACE par le nom de l’interface filaire que vous
     voulez utiliser.

          ifconfig INTERFACE up

     ... ou, avec la commande spécifique à GNU/Linux ‘ip’ :

          ip link set INTERFACE up

Connexion sans-fil
     Pour configurer le réseau sans-fil, vous pouvez créer un fichier de
     configuration pour l’outil de configuration ‘wpa_supplicant’ (son
     emplacement importe peu) avec l’un des éditeurs de texte
     disponibles comme ‘nano’ :

          nano wpa_supplicant.conf

     Par exemple, la déclaration qui suit peut aller dans ce fichier et
     fonctionnera pour plusieurs réseaux sans-fil, si vous donnez le
     vrai SSID et la phrase de passe pour le réseau auquel vous vous
     connectez :

          network={
            ssid="MON-SSID"
            key_mgmt=WPA-PSK
            psk="la phrase de passe secrète du réseau"
          }

     Démarrez le service sans-fil et lancez-le en tache de fond avec la
     commande suivante (en remplaçant INTERFACE par le nom de
     l’interface réseau que vous voulez utiliser) :

          wpa_supplicant -c wpa_supplicant.conf -i INTERFACE -B

     Lancez ‘man wpa_supplicant’ pour plus d’informations.

   À partir de ce moment, vous avez besoin d’une adresse IP. Sur les
réseaux où les IP sont automatiquement attribuée par DHCP, vous pouvez
lancer :

     dhclient -v INTERFACE

   Essayez de pinger un serveur pour voir si le réseau fonctionne :

     ping -c 3 gnu.org

   Mettre en place un accès réseau est presque toujours une nécessité
parce que l’image ne contient pas tous les logiciels et les outils dont
vous pourriez avoir besoin.

   If you need HTTP and HTTPS access to go through a proxy, run the
following command:

     herd set-http-proxy guix-daemon URL

where URL is the proxy URL, for example ‘http://example.org:8118’.

   Si vous le souhaitez, vous pouvez continuer l’installation à distance
en démarrant un serveur SSH :

     herd start ssh-daemon

   Assurez-vous soit de définir un mot de passe avec ‘passwd’, soit de
configurer l’authentification par clef OpenSSH avant de vous connecter.

3.6.1.3 Partitionnement
.......................

À moins que vous ne l’ayez déjà fait, l’étape suivante consiste à
partitionner le disque puis à formater les partitions cibles.

   L’image d’installation inclus plusieurs outils de partitionnement,
dont Parted (*note (parted)Overview::), ‘fdisk’, et ‘cfdisk’. Lancez-en
un et paramétrez votre disque avec le partitionnement qui vous convient
:

     cfdisk

   Si votre disque utilise le format des tables de partitions GUID (GPT)
et que vous souhaitez installer un GRUB pour système BIOS (c’est le cas
par défaut), assurez-vous de créer qu’une partition de démarrage BIOS
soit bien disponible (*note (grub)BIOS installation::).

   Si vous souhaitez à la place utilise GRUB pour système EFI, vous
devrez avoir une “partition système EFI” (ESP) en FAT32. Cette partition
peut être montée dans ‘/boot/efi’ par exemple et doit avoir le drapeau
‘esp’. P. ex. pour ‘parted’ :

     parted /dev/sda set 1 esp on

     Remarque : Vous n’êtes pas sûr de savoir si vous devez utiliser un
     GRUB EFI ou BIOS ? Si le répertoire ‘/sys/firmware/efi’ existe sur
     l’image d’installation, vous devriez probablement effectuer une
     installation EFI, avec ‘grub-efi-bootloader’. Sinon, vous devriez
     utiliser le GRUB en BIOS, ‘grub-bootloader’. *Note Configuration du
     chargeur d'amorçage:: pour plus d’information sur le chargeur
     d’amorçage.

   Once you are done partitioning the target hard disk drive, you have
to create a file system on the relevant partition(s)(1). For the ESP, if
you have one and assuming it is ‘/dev/sda1’, run:

     mkfs.fat -F32 /dev/sda1

   Préférez assigner une étiquette au système de fichier pour que vous
puissiez vous y référer de manière fiable dans la déclaration
‘file-system’ (*note Systèmes de fichiers::). On le fait habituellement
avec l’option ‘-L’ de ‘mkfs.ext4’ et des commandes liées. Donc, en
supposant que la partition racine soit sur ‘/dev/sda2’, on peut créer un
système de fichier avec pour étiquette ‘my-root’ avec :

     mkfs.ext4 -L my-root /dev/sda2

   If you are instead planning to encrypt the root partition, you can
use the Cryptsetup/LUKS utilities to do that (see ‘man cryptsetup’ for
more information). Assuming you want to store the root partition on
‘/dev/sda2’, the command sequence would be along these lines:

     cryptsetup luksFormat /dev/sda2
     cryptsetup open --type luks /dev/sda2 my-partition
     mkfs.ext4 -L my-root /dev/mapper/my-partition

   Une fois cela effectué, montez le système de fichier cible dans
‘/mnt’ avec une commande comme (de nouveau, en supposant que ‘my-root’
est l’étiquette du système de fichiers racine) :

     mount LABEL=my-root /mnt

   Montez aussi tous les systèmes de fichiers que vous voudriez utiliser
sur le système cible relativement à ce chemin. Si vous avez choisi
d’avoir un ‘/boot/efi’ comme point de montage EFI par exemple, montez-la
sur ‘/mnt/boot/efi’ maintenant pour qu’elle puisse être trouvée par
‘guix system init’ ensuite.

   Enfin, si vous souhaitez utiliser une ou plusieurs partitions de swap
(*note swap space: (libc)Memory Concepts.), assurez-vous de les
initialiser avec ‘mkswap’. En supposant que vous avez une partition de
swap sur ‘/dev/sda3’, vous pouvez lancer :

     mkswap /dev/sda3
     swapon /dev/sda3

   Autrement, vous pouvez utiliser un fichier de swap. Par exemple, en
supposant que dans le nouveau système vous voulez utiliser le fichier
‘/swapfile’ comme fichier de swap, vous lanceriez(2) :

     # Cela représente 10 Gio d'espace d'échange. Ajustez « count » pour changer la taille.
     dd if=/dev/zero of=/mnt/swapfile bs=1MiB count=10240
     # Par sécurité, laissez le fichier en lecture et en écriture uniquement pour root.
     chmod 600 /mnt/swapfile
     mkswap /mnt/swapfile
     swapon /mnt/swapfile

   Remarquez que si vous avez chiffré la partition racine et créé un
fichier d’échange dans son système de fichier comme décrit ci-dessus,
alors le chiffrement protégera aussi le fichier d’échange, comme
n’importe quel fichier de ce système de fichiers.

   ---------- Footnotes ----------

   (1) Currently Guix System only supports ext4, btrfs, and JFS file
systems. In particular, code that reads file system UUIDs and labels
only works for these file system types.

   (2) Cet exemple fonctionnera sur plusieurs types de systèmes de
fichiers (p. ex. ext4). Cependant, pour les systèmes de fichiers qui
utilisent la copie sur écriture (COW) comme btrfs, les étapes requises
peuvent varier. Pour plus de détails, regardez les pages de manuel de
‘mkswap’ et ‘swapon’.


File: guix.fr.info,  Node: Effectuer l'installation,  Prev: Disposition du clavier réseau et partitionnement,  Up: Installation manuelle

3.6.2 Effectuer l’installation
------------------------------

Lorsque la partition cible est prête et que les autres partitions sont
montées, on est prêt à commencer l’installation. Commencez par :

     herd start cow-store /mnt

   Cela rend ‘/gnu/store’ capable de faire de la copie sur écriture, de
sorte que les paquets ajoutés pendant l’installation sont écrits sur le
disque cible sur ‘/mnt’ plutôt que gardés en mémoire. Cela est
nécessaire parce que la première phase de la commande ‘guix system init’
(voir plus bas) implique de télécharger ou de construire des éléments de
‘/gnu/store’ qui est initialement un système de fichiers en mémoire.

   Ensuite, vous devrez modifier un fichier et fournir la déclaration du
système à installer. Pour cela, le système d’installation propose trois
éditeurs de texte. Nous recommandons GNU nano (*note (nano)Top::), qui
supporte la coloration syntaxique la correspondance de parenthèses ; les
autres éditeurs sont GNU Zile (un clone d’Emacs) et nvi (un clone de
l’éditeur ‘vi’ original de BSD). Nous recommandons vivement de stocker
ce fichier sur le système de fichier racine cible, disons en tant que
‘/mnt/etc/config.scm’. Sinon, vous perdrez votre fichier de
configuration une fois que vous aurez redémarré sur votre nouveau
système.

   *Note Utiliser le système de configuration::, pour un aperçu de
comment créer votre fichier de configuration. Les exemples de
configuration dont on parle dans cette section sont disponibles dans
‘/etc/configuration’ sur l’image d’installation. Ainsi, pour commencer
avec une configuration du système qui fournit un serveur d’affichage
graphique (un système de « bureau »), vous pouvez lancer ce qui suit :

     # mkdir /mnt/etc
     # cp /etc/configuration/desktop.scm /mnt/etc/config.scm
     # nano /mnt/etc/config.scm

   Vous devriez faire attention à ce que contient votre fichier de
configuration, en particulier :

   • Assurez-vous que la forme ‘bootloader-configuration’ se réfère à la
     cible où vous voulez installer GRUB. Elle devrait aussi mentionner
     ‘grub-bootloader’ si vous installer GRUB en mode BIOS (ou « legacy
     ») ou ‘grub-efi-bootloader’ pour les système UEFI plus récents.
     Pour les anciens systèmes, le champs ‘target’ contient un
     périphérique comme ‘/dev/sda’ ; pour les systèmes UEFI il contient
     un chemin vers une partition EFI montée, comme ‘/boot/efi’, et
     assurez-vous bien que ce chemin est monté et qu’il y a une entrée
     ‘file-system’ dans votre configuration.

   • Assurez-vous que les étiquettes de vos systèmes de fichiers
     correspondent aux valeurs de leur champs ‘device’ dans votre
     configuration ‘file-system’, en supposant que la configuration
     ‘file-system’ utilise la procédure ‘file-system-label’ dans son
     champ ‘device’.

   • Si vous avez des partitions RAID ou chiffrées, assurez-vous
     d’ajouter un champ ‘mapped-device’ pour les décrire (*note
     Périphériques mappés::).

   Une fois que vous avez fini les préparatifs sur le fichier de
configuration, le nouveau système peut être initialisé (rappelez-vous
que le système de fichiers racine cible est dans ‘/mnt’) :

     guix system init /mnt/etc/config.scm /mnt

Cela copie tous les fichiers nécessaires et installe GRUB sur ‘/dev/sdX’
à moins que vous ne passiez l’option ‘--no-bootloader’. Pour plus
d’informations, *note Invoquer guix system::. Cette commande peut
engendrer des téléchargements ou des constructions pour les paquets
manquants, ce qui peut prendre du temps.

   Une fois que cette commande a terminé — et on l’espère réussi ! —
vous pouvez lancer ‘reboot’ et démarrer sur votre nouveau système. Le
mot de passe ‘root’ est d’abord vide ; les mots de passe des autres
comptes doivent être initialisés avec la commande ‘passwd’ en tant que
‘root’, à mois que votre configuration ne spécifie autre chose (*note
mot de passe des comptes: user-account-password.). *Note Après
l'installation du système::, pour la suite !


File: guix.fr.info,  Node: Après l'installation du système,  Next: Installer Guix dans une VM,  Prev: Installation manuelle,  Up: Installation du système

3.7 Après l’installation du système
===================================

Bravo ! Vous avez maintenant redémarré sur votre système Guix ! À partir
de maintenant, vous pouvez mettre à jour le système quand vous voudrez,
avec :

     guix pull
     sudo guix system reconfigure /etc/config.scm

Cela crée une nouvelle génération du système avec les derniers paquets
et services (*note Invoquer guix system::). Nous vous recommandons de le
faire régulièrement pour que votre système inclue les dernières misse à
jour de sécurité (*note Mises à jour de sécurité::).

     Remarque : Note that ‘sudo guix’ runs your user’s ‘guix’ command
     and _not_ root’s, because ‘sudo’ leaves ‘PATH’ unchanged. To
     explicitly run root’s ‘guix’, type ‘sudo -i guix ...’.

     The difference matters here, because ‘guix pull’ updates the ‘guix’
     command and package definitions only for the user it is ran as.
     This means that if you choose to use ‘guix system reconfigure’ in
     root’s login shell, you’ll need to ‘guix pull’ separately.

   Rejoignez-nous sur ‘#guix’ sur le réseau IRC Freenode ou sur
‘guix-devel@gnu.org’ pour partager votre expérience !


File: guix.fr.info,  Node: Installer Guix dans une VM,  Next: Construire l'image d'installation,  Prev: Après l'installation du système,  Up: Installation du système

3.8 Installer Guix sur une machine virtuelle
============================================

Si vous souhaitez installer Guix System sur une machine virtuelle (VM)
ou un serveur privé virtuel (VPS) plutôt que sur votre machine chérie,
cette section est faite pour vous.

   Pour démarrer une VM QEMU (https://qemu.org/) pour installer Guix
System sur une image disque, suivez ces étapes :

  1. Tout d’abord récupérez et décompressez l’image d’installation du
     système Guix comme décrit précédemment (*note Installation depuis
     une clef USB ou un DVD::).

  2. Créez une image disque qui contiendra le système installé. Pour
     créer une image qcow2, utilise la commande ‘qemu-img’ :

          qemu-img create -f qcow2 guix-system.img 50G

     Le fichier qui en résulte sera bien plus petit que les 50 Go
     (habituellement moins de 1 Mo) mais il grossira au fur et à mesure
     que le stockage virtuel grossira.

  3. Démarrez l’image d’installation USB dans une VM :

          qemu-system-x86_64 -m 1024 -smp 1 -enable-kvm \
            -nic user,model=virtio-net-pci -boot menu=on,order=d \
            -drive file=guix-system.img \
            -drive media=cdrom,file=guix-system-install-1.0.1.17089-7e269.SYSTEM.iso

     ‘-enable-kvm’ is optional, but significantly improves performance,
     *note Lancer Guix dans une VM::.

  4. Vous êtes maintenant root dans la VM, continuez en suivant la
     procédure d’installation. *Note Préparer l'installation::, et
     suivez les instructions.

   Once installation is complete, you can boot the system that’s on your
‘guix-system.img’ image. *Note Lancer Guix dans une VM::, for how to do
that.


File: guix.fr.info,  Node: Construire l'image d'installation,  Prev: Installer Guix dans une VM,  Up: Installation du système

3.9 Construire l’image d’installation
=====================================

L’image d’installation décrite plus haut a été construite avec la
commande ‘guix system’, plus précisément :

     guix system disk-image --file-system-type=iso9660 \
       gnu/system/install.scm

   Regardez le fichier ‘gnu/system/install.scm’ dans l’arborescence des
sources et regardez aussi *note Invoquer guix system:: pour plus
d’informations sur l’image d’installation.

3.10 Construire l’image d’installation pour les cartes ARM
==========================================================

De nombreuses cartes ARM requièrent une variante spécifique du chargeur
d’amorçage U-Boot (https://www.denx.de/wiki/U-Boot/).

   Si vous construisez une image disque et que le chargeur d’amorçage
n’est pas disponible autrement (sur un autre périphérique d’amorçage
etc), il est recommandé de construire une image qui inclus le chargeur
d’amorçage, plus précisément :

     guix system disk-image --system=armhf-linux -e '((@ (gnu system install) os-with-u-boot) (@ (gnu system install) installation-os) "A20-OLinuXino-Lime2")'

   ‘A20-OLinuXino-Lime2’ est le nom de la carte. Si vous spécifiez une
carte invalide, une liste de cartes possibles sera affichée.


File: guix.fr.info,  Node: Gestion de paquets,  Next: Développement,  Prev: Installation du système,  Up: Top

4 Gestion de paquets
********************

Le but de GNU Guix est de permettre à ses utilisatrices et utilisateurs
d’installer, mettre à jour et supprimer facilement des paquets logiciels
sans devoir connaître leur procédure de construction ou leurs
dépendances. Guix va aussi plus loin que ces fonctionnalités évidentes.

   Ce chapitre décrit les principales fonctionnalités de Guix, ainsi que
des outils de gestion des paquets qu’il fournit. En plus de l’interface
en ligne de commande décrite en dessous de (*note ‘guix package’:
Invoquer guix package.), vous pouvez aussi utiliser l’interface
Emacs-Guix (*note (emacs-guix)Top::), après avoir installé le paquet
‘emacs-guix’ (lancez la commande ‘M-x guix-help’ pour le démarrer) :

     guix install emacs-guix

* Menu:

* Fonctionnalités::         Comment Guix va rendre votre vie plus heureuse.
* Invoquer guix package::    Installation, suppression, etc. de paquets.
* Substituts::               Télécharger des binaire déjà construits.
* Des paquets avec plusieurs résultats::  Un seul paquet source, plusieurs
                                             résultats.
* Invoquer guix gc::         Lancer le ramasse-miettes.
* Invoquer guix pull::       Récupérer la dernière version de Guix et de
                               la distribution.
* Canaux::                   Personnaliser la collection des paquets.
* Invoking guix time-machine::  Running an older revision of Guix.
* Inférieurs::              Interagir avec une autre révision de Guix.
* Invoquer guix describe::   Affiche des informations sur la révision Guix
                               actuelle.
* Invoquer guix archive::    Exporter et importer des fichiers du dépôt.


File: guix.fr.info,  Node: Fonctionnalités,  Next: Invoquer guix package,  Up: Gestion de paquets

4.1 Fonctionnalités
===================

Lorsque vous utilisez Guix, chaque paquet arrive dans “dépôt des
paquets”, dans son propre répertoire — quelque chose comme
‘/gnu/store/xxx-paquet-1.2’, où ‘xxx’ est une chaîne en base32.

   Plutôt que de se rapporter à ces répertoires, les utilisateur·rice·s
ont leur propre “profil” qui pointe vers les paquets qu’ils ou elles
veulent vraiment utiliser. Ces profils sont stockés dans le répertoire
personnel de chacun·e dans ‘$HOME/.guix-profile’.

   Par exemple, ‘alice’ installe GCC 4.7.2. Il en résulte que
‘/home/alice/.guix-profile/bin/gcc’ pointe vers
‘/gnu/store/...-gcc-4.7.2/bin/gcc’. Maintenant, sur la même machine,
‘bob’ a déjà installé GCC 4.8.0. Le profil de ‘bob’ continue simplement
de pointer vers ‘/gnu/store/...-gcc-4.8.0/bin/gcc’ — c.-à-d. les deux
versions de GCC coexistent surs le même système sans aucune
interférence.

   La commande ‘guix package’ est l’outil central pour gérer les paquets
(*note Invoquer guix package::). Il opère sur les profils de chaque
utilisateur·rice et peut être utilisé avec les _privilèges normaux_.

   La commande fournit les opérations évidentes d’installation, de
suppression et de mise à jour. Chaque invocation est en fait une
_transaction_ : soit l’opération demandée réussit, soit rien ne se
passe. Ainsi, si le processus ‘guix package’ est terminé pendant la
transaction ou si une panne de courant arrive pendant la transaction, le
profil reste dans son état précédent et reste utilisable.

   En plus, il est possible _d’annuler_ toute transaction sur les
paquets. Donc si par exemple un mise à jour installe une nouvelle
version d’un paquet qui révèle un bogue sérieux, vous pouvez revenir en
arrière à l’instance précédente de votre profil que vous saviez bien
fonctionner. De même, la configuration globale du système dans Guix est
sujette aux mises à jour transactionnelles et aux annulations (*note
Utiliser le système de configuration::).

   Tout paquet du dépôt des paquets peut être _glané_. Guix peut
déterminer quels paquets sont toujours référencés par les profils des
utilisateur·rice·s et supprimer ceux qui ne sont de tout évidence plus
référencés (*note Invoquer guix gc::). Les utilisateur·rice·s peuvent
toujours explicitement supprimer les anciennes générations de leur
profil pour que les paquets auxquels elles faisaient référence puissent
être glanés.

   Guix prend une approche “purement fonctionnelle” de la gestion de
paquets, telle que décrite dans l’introduction (*note Introduction::).
Chaque nom de répertoire de paquet dans ‘/gnu/store’ contient un hash de
toutes les entrées qui ont été utilisées pendant la construction de ce
paquet — le compilateur, les bibliothèques, les scripts de construction,
etc. Cette correspondance directe permet aux utilisateur·rice·s de
s’assurer que l’installation d’un paquet donné correspond à l’état
actuel de leur distribution. Elle aide aussi à maximiser la
“reproductibilité” : grâce aux environnements de construction utilisés,
une construction donnée a de forte chances de donner des fichiers
identiques bit-à-bit lorsqu’elle est effectuée sur des machines
différentes (*note container: Invoquer guix-daemon.).

   Ce fondement permet à Guix de supporter le “déploiement transparent
de binaire ou source”. Lorsqu’une binaire pré-construit pour une entrée
de ‘/gnu/store’ est disponible depuis une source externe (un
“substitut”), Guix le télécharge simplement et le décompresse ; sinon,
il construit le paquet depuis les sources localement (*note
Substituts::). Comme les résultats des constructions sont généralement
reproductibles au bit près, si vous n’avez pas besoin de faire confiance
aux serveurs qui fournissent les substituts : vous pouvez forcer une
construction locale et _défier_ les fournisseurs (*note Invoquer guix
challenge::).

   Le contrôle de l’environnement de construction est aussi une
fonctionnalité utile pour les développeurs. La commande ‘guix
environment’ permet aux développeurs d’un paquet de mettre en place
rapidement le bon environnement de développement pour leur paquet, sans
avoir à installer manuellement les dépendances du paquet dans leur
profil (*note Invoquer guix environment::).

   La totalité de Guix et des définitions de paquets sont placés sous
contrôle de version, et ‘guix pull’ vous permet de « voyager dans le
temps » de l’historique de Guix lui-même (*note Invoquer guix pull::).
Cela est rend possible la réplication d’une instance Guix sur une
machine différente ou plus tard, ce qui vous permet de _répliquer des
environnements logiciels complets_, tout en garantissant un “suivi de
provenance” précis des logiciels.


File: guix.fr.info,  Node: Invoquer guix package,  Next: Substituts,  Prev: Fonctionnalités,  Up: Gestion de paquets

4.2 Invoquer ‘guix package’
===========================

La commande ‘guix package’ est l’outil qui permet d’installer, mettre à
jour et supprimer les paquets ainsi que de revenir à une configuration
précédente. Elle n’opère que dans le profil de l’utilisateur·rice et
fonctionne avec les privilèges normaux (*note Fonctionnalités::). Sa
syntaxe est :

     guix package OPTIONS

   OPTIONS spécifie d’abord les opérations à effectuer pendant la
transaction. À la fin, une nouvelle génération du profil est créée mais
les “générations” précédentes du profil restent disponibles si
l’utilisateur·rice souhaite y revenir.

   Par exemple, pour supprimer ‘lua’ et installer ‘guile’ et
‘guile-cairo’ en une seule transaction :

     guix package -r lua -i guile guile-cairo

   Parce que c’est pratique, nous fournissons aussi les alias suivants :

   • ‘guix search’ est un alias de ‘guix package -s’,
   • ‘guix install’ est un alias de ‘guix package -i’,
   • ‘guix remove’ est un alias de ‘guix package -r’,
   • ‘guix upgrade’ is an alias for ‘guix package -u’,
   • and ‘guix show’ is an alias for ‘guix package --show=’.

   Ces alias sont moins expressifs que ‘guix package’ et fournissent
moins d’options, donc dans certains cas vous devrez probablement
utiliser ‘guix package’ directement.

   ‘guix package’ supporte aussi une “approche déclarative” où on
spécifie l’ensemble exact des paquets qui doivent être disponibles que
l’on passe via l’option ‘--manifest’ (*note ‘--manifest’:
profile-manifest.).

   For each user, a symlink to the user’s default profile is
automatically created in ‘$HOME/.guix-profile’. This symlink always
points to the current generation of the user’s default profile. Thus,
users can add ‘$HOME/.guix-profile/bin’ to their ‘PATH’ environment
variable, and so on. Si vous n’utilisez pas la distribution système
Guix, vous devriez ajouter les lignes suivantes à votre
‘~/.bash_profile’ (*note (bash)Bash Startup Files::) pour que les shells
créés ensuite aient tous les bonnes définitions des variables
d’environnement :

     GUIX_PROFILE="$HOME/.guix-profile" ; \
     source "$HOME/.guix-profile/etc/profile"

   In a multi-user setup, user profiles are stored in a place registered
as a “garbage-collector root”, which ‘$HOME/.guix-profile’ points to
(*note Invoquer guix gc::). That directory is normally
‘LOCALSTATEDIR/guix/profiles/per-user/USER’, where LOCALSTATEDIR is the
value passed to ‘configure’ as ‘--localstatedir’, and USER is the user
name. The ‘per-user’ directory is created when ‘guix-daemon’ is started,
and the USER sub-directory is created by ‘guix package’.

   Les OPTIONS peuvent être les suivante :

‘--install=PAQUET ...’
‘-i PAQUET ...’
     Installer les PAQUETs spécifiés.

     Each PACKAGE may specify either a simple package name, such as
     ‘guile’, or a package name followed by an at-sign and version
     number, such as ‘guile@1.8.8’ or simply ‘guile@1.8’ (in the latter
     case, the newest version prefixed by ‘1.8’ is selected).

     Si aucun numéro de version n’est spécifié, la version la plus
     récente disponible est choisie. En plus, PAQUET peut contenir un
     deux-points, suivi du nom d’une des sorties du paquet, comme dans
     ‘gcc:doc’ ou ‘binutils@2.22:lib’ (*note Des paquets avec plusieurs
     résultats::). Des paquets avec un nom correspondant et
     (éventuellement une version) sont recherchés dans les modules de la
     distribution GNU (*note Modules de paquets::).

     Parfois les paquets ont des “entrées propagées” : ce sont des
     dépendances qui sont installées automatiquement avec le paquet
     demandé (*note ‘propagated-inputs’ in ‘package’ objects:
     package-propagated-inputs. pour plus d’informations sur les entrées
     propagées dans les définitions des paquets).

     Un exemple est la bibliothèque MPC de GNU : ses fichiers d’en-tête
     C se réfèrent à ceux de la bibliothèque MPFR de GNU, qui se
     réfèrent en retour à ceux de la bibliothèque GMP. Ainsi, lorsqu’on
     installe MPC, les bibliothèques MPFR et GMP sont aussi installées
     dans le profil ; supprimer MPC supprimera aussi MPFR et GMP — à
     moins qu’ils n’aient été aussi installés explicitement par
     l’utilisateur·rice.

     Besides, packages sometimes rely on the definition of environment
     variables for their search paths (see explanation of
     ‘--search-paths’ below). Any missing or possibly incorrect
     environment variable definitions are reported here.

‘--install-from-expression=EXP’
‘-e EXP’
     Installer le paquet évalué par EXP

     EXP doit être une expression Scheme qui s’évalue en un objet
     ‘<package>’. Cette option est notamment utile pour distinguer les
     variantes d’un paquet avec le même nom, avec des expressions comme
     ‘(@ (gnu packages base) guile-final)’.

     Remarquez que cette option installe la première sortie du paquet,
     ce qui peut être insuffisant lorsque vous avez besoin d’une sortie
     spécifique d’un paquet à plusieurs sorties.

‘--install-from-file=FICHIER’
‘-f FICHIER’
     Installer le paquet évalué par le code dans le FICHIER.

     Par exemple, FICHIER peut contenir une définition comme celle-ci
     (*note Définition des paquets::) :

          (use-modules (guix)
                       (guix build-system gnu)
                       (guix licenses))

          (package
            (name "hello")
            (version "2.10")
            (source (origin
                      (method url-fetch)
                      (uri (string-append "mirror://gnu/hello/hello-" version
                                          ".tar.gz"))
                      (sha256
                       (base32
                        "0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i"))))
            (build-system gnu-build-system)
            (synopsis "Hello, GNU world: An example GNU package")
            (description "Guess what GNU Hello prints!")
            (home-page "http://www.gnu.org/software/hello/")
            (license gpl3+))

     Lorsqu’on développe, on peut trouver utile d’inclure un tel fichier
     ‘guix.scm’ à la racine de l’arborescence des sources de son projet
     qui pourrait être utilisé pour tester des versions de développement
     et créer des environnements de développement reproductibles (*note
     Invoquer guix environment::).

     The FILE may also contain a JSON representation of one or more
     package definitions. Running ‘guix package -f’ on ‘hello.json’ with
     the following contents would result in installing the package
     ‘greeter’ after building ‘myhello’:

          [
            {
              "name": "myhello",
              "version": "2.10",
              "source": "mirror://gnu/hello/hello-2.10.tar.gz",
              "build-system": "gnu",
              "arguments": {
                "tests?": false
              }
              "home-page": "https://www.gnu.org/software/hello/",
              "synopsis": "Hello, GNU world: An example GNU package",
              "description": "GNU Hello prints a greeting.",
              "license": "GPL-3.0+",
              "native-inputs": ["gettext"]
            },
            {
              "name": "greeter",
              "version": "1.0",
              "source": "https://example.com/greeter-1.0.tar.gz",
              "build-system": "gnu",
              "arguments": {
                "test-target": "foo",
                "parallel-build?": false,
              },
              "home-page": "https://example.com/",
              "synopsis": "Greeter using GNU Hello",
              "description": "This is a wrapper around GNU Hello.",
              "license": "GPL-3.0+",
              "inputs": ["myhello", "hello"]
            }
          ]

‘--remove=PAQUET ...’
‘-r PAQUET ...’
     Supprimer les PAQUETs spécifiés.

     As for ‘--install’, each PACKAGE may specify a version number
     and/or output name in addition to the package name. For instance,
     ‘-r glibc:debug’ would remove the ‘debug’ output of ‘glibc’.

‘--upgrade[=REGEXP ...]’
‘-u [REGEXP ...]’
     Upgrade all the installed packages. If one or more REGEXPs are
     specified, upgrade only installed packages whose name matches a
     REGEXP. Also see the ‘--do-not-upgrade’ option below.

     Remarquez que cela met à jour vers la dernière version des paquets
     trouvée dans la distribution actuellement installée. Pour mettre à
     jour votre distribution, vous devriez lancer régulièrement ‘guix
     pull’ (*note Invoquer guix pull::).

‘--do-not-upgrade[=REGEXP ...]’
     When used together with the ‘--upgrade’ option, do _not_ upgrade
     any packages whose name matches a REGEXP. For example, to upgrade
     all packages in the current profile except those containing the
     substring “emacs”:

          $ guix package --upgrade . --do-not-upgrade emacs

‘--manifest=FICHIER’
‘-m FICHIER’
     Create a new generation of the profile from the manifest object
     returned by the Scheme code in FILE. This option can be repeated
     several times, in which case the manifests are concatenated.

     This allows you to _declare_ the profile’s contents rather than
     constructing it through a sequence of ‘--install’ and similar
     commands. The advantage is that FILE can be put under version
     control, copied to different machines to reproduce the same
     profile, and so on.

     FICHIER doit retourner un objet “manifest” qui est en gros une
     liste de paquets :

          (use-package-modules guile emacs)

          (packages->manifest
           (list emacs
                 guile-2.0
                 ;; Utiliser une sortie spécifique d'un paquet.
                 (list guile-2.0 "debug")))

     Dans cet exemple on doit savoir quels modules définissent les
     variables ‘emacs’ et ‘guile-2.0’ pour fournir la bonne ligne
     ‘use-package-modules’ ce qui peut être embêtant. On peut à la place
     fournir des spécifications de paquets normales et laisser
     ‘specifications->manifest’ rechercher les objets de paquets
     correspondants, comme ceci :

          (specifications->manifest
           '("emacs" "guile@2.2" "guile@2.2:debug"))

‘--roll-back’
     Revenir à la “génération” précédente du profil c.-à-d. défaire la
     dernière transaction.

     When combined with options such as ‘--install’, roll back occurs
     before any other actions.

     Lorsque vous revenez de la première génération qui contient des
     fichiers, le profil pointera vers la “zéroième génération” qui ne
     contient aucun fichier en dehors de ses propres métadonnées.

     Après être revenu en arrière, l’installation, la suppression et la
     mise à jour de paquets réécrit les futures générations précédentes.
     Ainsi, l’historique des générations dans un profil est toujours
     linéaire.

‘--switch-generation=MOTIF’
‘-S MOTIF’
     Basculer vers une génération particulière définie par le MOTIF.

     PATTERN may be either a generation number or a number prefixed with
     “+” or “-”. The latter means: move forward/backward by a specified
     number of generations. For example, if you want to return to the
     latest generation after ‘--roll-back’, use
     ‘--switch-generation=+1’.

     The difference between ‘--roll-back’ and ‘--switch-generation=-1’
     is that ‘--switch-generation’ will not make a zeroth generation, so
     if a specified generation does not exist, the current generation
     will not be changed.

‘--search-paths[=GENRE]’
     Rapporter les définitions des variables d’environnement dans la
     syntaxe Bash qui peuvent être requises pour utiliser l’ensemble des
     paquets installés. Ces variables d’environnement sont utilisées
     pour spécifier les “chemins de recherche” de fichiers utilisés par
     les paquets installés.

     For example, GCC needs the ‘CPATH’ and ‘LIBRARY_PATH’ environment
     variables to be defined so it can look for headers and libraries in
     the user’s profile (*note (gcc)Environment Variables::). If GCC
     and, say, the C library are installed in the profile, then
     ‘--search-paths’ will suggest setting these variables to
     ‘PROFILE/include’ and ‘PROFILE/lib’, respectively.

     Le cas d’utilisation typique est de définir ces variables
     d’environnement dans le shell :

          $ eval `guix package --search-paths`

     GENRE peut être l’une des valeurs ‘exact’, ‘prefix’ ou ‘suffix’, ce
     qui signifie que les définitions des variables d’environnement
     retournées seront soit les paramètres exactes, ou placés avant ou
     après la valeur actuelle de ces paramètres. Lorsqu’il est omis,
     GENRE a pour valeur par défaut ‘exact’.

     Cette option peut aussi être utilisé pour calculer les chemins de
     recherche _combinés_ de plusieurs profils. Regardez cet exemple :

          $ guix package -p foo -i guile
          $ guix package -p bar -i guile-json
          $ guix package -p foo -p bar --search-paths

     The last command above reports about the ‘GUILE_LOAD_PATH’
     variable, even though, taken individually, neither ‘foo’ nor ‘bar’
     would lead to that recommendation.

‘--profile=PROFIL’
‘-p PROFIL’
     Utiliser le PROFIL à la place du profil par défaut du compte.

     PROFILE must be the name of a file that will be created upon
     completion. Concretely, PROFILE will be a mere symbolic link
     (“symlink”) pointing to the actual profile where packages are
     installed:

          $ guix install hello -p ~/code/my-profile
          ...
          $ ~/code/my-profile/bin/hello
          Hello, world!

     All it takes to get rid of the profile is to remove this symlink
     and its siblings that point to specific generations:

          $ rm ~/code/my-profile ~/code/my-profile-*-link

‘--list-profiles’
     List all the user’s profiles:

          $ guix package --list-profiles
          /home/charlie/.guix-profile
          /home/charlie/code/my-profile
          /home/charlie/code/devel-profile
          /home/charlie/tmp/test

     When running as root, list all the profiles of all the users.

‘--allow-collisions’
     Permettre des collisions de paquets dans le nouveau profil. À
     utiliser à vos risques et périls !

     Par défaut, ‘guix package’ rapporte les “collisions” dans le profil
     comme des erreurs. Les collisions ont lieu quand deux version ou
     variantes d’un paquet donné se retrouvent dans le profil.

‘--bootstrap’
     Utiliser le programme d’amorçage Guile pour compiler le profil.
     Cette option n’est utile qu’aux personnes qui développent la
     distribution.

   En plus de ces actions, ‘guix package’ supporte les options suivantes
pour demander l’état actuel d’un profil ou la disponibilité des paquets
:

‘--search=REGEXP’
‘-s REGEXP’
     Lister les paquets disponibles dont le nom, le synopsis ou la
     description correspondent à la REGEXP (en étant insensible à la
     casse), triés par pertinence. Afficher toutes les métadonnées des
     paquets correspondants au format ‘recutils’ (*note GNU recutils
     databases: (recutils)Top.).

     Cela permet à des champs spécifiques d’être extraits avec la
     commande ‘recsel’, par exemple :

          $ guix package -s malloc | recsel -p name,version,relevance
          name: jemalloc
          version: 4.5.0
          relevance: 6

          name: glibc
          version: 2.25
          relevance: 1

          name: libgc
          version: 7.6.0
          relevance: 1

     De manière similaire, pour montrer le nom de tous les paquets
     disponibles sous license GNU LGPL version 3 :

          $ guix package -s "" | recsel -p name -e 'license ~ "LGPL 3"'
          name: elfutils

          name: gmp
          ...

     Il est aussi possible de raffiner les résultats de la recherche en
     donnant plusieurs options ‘-s’ à ‘guix package’, ou plusieurs
     arguments à ‘guix search’. Par exemple, la commande suivante
     renvoie la liste des jeux de plateau (cette fois-ci avec l’alias
     ‘guix search’) :

          $ guix search '\<board\>' game | recsel -p name
          name: gnubg
          ...

     Si on avait oublié ‘-s game’, on aurait aussi eu les paquets
     logiciels qui s’occupent de circuits imprimés (en anglais : circuit
     board) ; supprimer les chevrons autour de ‘board’ aurait aussi
     ajouté les paquets qui parlent de clavier (en anglais :
     key_board_).

     Et maintenant un exemple plus élaboré. La commande suivante
     recherche les bibliothèques cryptographiques, retire les
     bibliothèques Haskell, Perl, Python et Ruby et affiche le nom et le
     synopsis des paquets correspondants :

          $ guix search crypto library | \
              recsel -e '! (name ~ "^(ghc|perl|python|ruby)")' -p name,synopsis

     *Note (recutils)Selection Expressions:: pour plus d’information sur
     les “expressions de sélection” pour ‘recsel -e’.

‘--show=PAQUET’
     Afficher les détails du PAQUET dans la liste des paquets
     disponibles, au format ‘recutils’ (*note GNU recutils databases:
     (recutils)Top.).

          $ guix package --show=python | recsel -p name,version
          name: python
          version: 2.7.6

          name: python
          version: 3.3.5

     You may also specify the full name of a package to only get details
     about a specific version of it (this time using the ‘guix show’
     alias):
          $ guix show python@3.4 | recsel -p name,version
          name: python
          version: 3.4.3

‘--list-installed[=REGEXP]’
‘-I [REGEXP]’
     Liste les paquets actuellement installés dans le profil spécifié,
     avec les paquets les plus récemment installés en dernier. Lorsque
     REGEXP est spécifié, liste uniquement les paquets installés dont le
     nom correspond à REGEXP.

     Pour chaque paquet installé, affiche les éléments suivants, séparés
     par des tabulations : le nom du paquet, sa version, la partie du
     paquet qui est installé (par exemple, ‘out’ pour la sortie par
     défaut, ‘include’ pour ses en-têtes, etc) et le chemin du paquet
     dans le dépôt.

‘--list-available[=REGEXP]’
‘-A [REGEXP]’
     List packages currently available in the distribution for this
     system (*note Distribution GNU::). When REGEXP is specified, list
     only available packages whose name matches REGEXP.

     Pour chaque paquet, affiche les éléments suivants séparés par des
     tabulations : son nom, sa version, les parties du paquet (*note Des
     paquets avec plusieurs résultats::), et l’emplacement de sa
     définition.

‘--list-generations[=MOTIF]’
‘-l [MOTIF]’
     Renvoyer la liste des générations avec leur date de création ; pour
     chaque génération, montre les paquets installés avec les paquets
     installés les plus récemment en dernier. Remarquez que la zéroième
     génération n’est jamais montrée.

     Pour chaque paquet installé, afficher les éléments suivants,
     séparés par des tabulations : le nom du paquet, sa version, la
     partie du paquet qui a été installée (*note Des paquets avec
     plusieurs résultats::), et l’emplacement du paquet dans le dépôt.

     Lorsque MOTIF est utilisé, la commande ne renvoie que les
     générations correspondantes. Les motifs valides sont :

        • _Des entiers et des entiers séparés par des virgules_. Les
          deux motifs correspondent generation numbers. For instance,
          ‘--list-generations=1’ returns the first one.

          And ‘--list-generations=1,8,2’ outputs three generations in
          the specified order. Neither spaces nor trailing commas are
          allowed.

        • _Ranges_. ‘--list-generations=2..9’ prints the générations
          demandées et tout ce qui se trouve entre elles. Remarquez que
          le début d’un intervalle doit être plus petit que sa fin.

          It is also possible to omit the endpoint. For example,
          ‘--list-generations=2..’, returns all generations starting
          from the second one.

        • _Des durées_. Vous pouvez aussi récupérer les derniers
          _N_ jours, semaines, or months by passing an integer along
          with the first letter of the duration. For example,
          ‘--list-generations=20d’ lists generations that are up to 20
          days old.

‘--delete-generations[=MOTIF]’
‘-d [MOTIF]’
     Lorsque MOTIF est omis, supprimer toutes les générations en dehors
     de l’actuelle.

     This command accepts the same patterns as ‘--list-generations’.
     When PATTERN is specified, delete the matching generations. When
     PATTERN specifies a duration, generations _older_ than the
     specified duration match. For instance, ‘--delete-generations=1m’
     deletes generations that are more than one month old.

     Si la génération actuelle correspond, elle n’est _pas_ supprimée.
     La zéroième génération n’est elle non plus jamais supprimée.

     Remarquez que supprimer des générations empêche de revenir en
     arrière vers elles. Ainsi, cette commande doit être utilisée avec
     précaution.

   Finally, since ‘guix package’ may actually start build processes, it
supports all the common build options (*note Options de construction
communes::). It also supports package transformation options, such as
‘--with-source’ (*note Options de transformation de paquets::). However,
note that package transformations are lost when upgrading; to preserve
transformations across upgrades, you should define your own package
variant in a Guile module and add it to ‘GUIX_PACKAGE_PATH’ (*note
Définition des paquets::).


File: guix.fr.info,  Node: Substituts,  Next: Des paquets avec plusieurs résultats,  Prev: Invoquer guix package,  Up: Gestion de paquets

4.3 Substituts
==============

Guix gère le déploiement depuis des binaires ou des sources de manière
transparente ce qui signifie qu’il peut aussi bien construire localement
que télécharger des éléments pré-construits depuis un serveur ou les
deux. Nous appelons ces éléments pré-construits des “substituts” — ils
se substituent aux résultats des constructions locales. Dans la plupart
des cas, télécharger un substitut est bien plus rapide que de construire
les choses localement.

   Les substituts peuvent être tout ce qui résulte d’une construction de
dérivation (*note Dérivations::). Bien sûr dans le cas général, il
s’agit de paquets binaires pré-construits, mais les archives des sources
par exemple résultent aussi de la construction d’une dérivation qui peut
aussi être disponible en tant que substitut.

* Menu:

* Serveur de substituts officiel::  Une source particulière de substituts.
* Autoriser un serveur de substituts::  Comment activer ou désactiver les
                                          substituts.
* Authentification des substituts::  Comment Guix vérifie les substituts.
* Paramètres de serveur mandataire::  Comment récupérer des substituts à
                                         travers un serveur mandataire.
* Échec de substitution::   Qu’arrive-t-il quand la substitution échoue.
* De la confiance en des binaires::  Comment pouvez-vous avoir confiance en
                                       un paquet binaire ?


File: guix.fr.info,  Node: Serveur de substituts officiel,  Next: Autoriser un serveur de substituts,  Up: Substituts

4.3.1 Serveur de substituts officiel
------------------------------------

Le serveur ‘ci.guix.gnu.org’ est une interface à la ferme de
construction officielle qui construit des paquets pour Guix
continuellement pour certaines architectures et les rend disponibles en
tant que substituts. C’est la source par défaut des substituts ; elle
peut être modifiée en passant l’option ‘--substitute-urls’ soit à
‘guix-daemon’ (*note ‘guix-daemon --substitute-urls’:
daemon-substitute-urls.) soit aux outils clients comme ‘guix package’
(*note client ‘--substitute-urls’ option: client-substitute-urls.).

   Les URL des substituts peuvent être soit en HTTP soit en HTTPS. Le
HTTPS est recommandé parce que les communications sont chiffrées ; à
l’inverse HTTP rend les communications visibles pour un espion qui peut
utiliser les informations accumulées sur vous pour déterminer par
exemple si votre système a des vulnérabilités de sécurités non
corrigées.

   Les substituts de la ferme de construction officielle sont activés
par défaut dans la distribution système Guix (*note Distribution GNU::).
Cependant, ils sont désactivés par défaut lorsque vous utilisez Guix sur
une distribution externe, à moins que vous ne les ayez explicitement
activés via l’une des étapes d’installation recommandées (*note
Installation::). Les paragraphes suivants décrivent comment activer ou
désactiver les substituts pour la ferme de construction officielle ; la
même procédure peut être utilisée pour activer les substituts de
n’importe quel autre serveur de substituts.


File: guix.fr.info,  Node: Autoriser un serveur de substituts,  Next: Authentification des substituts,  Prev: Serveur de substituts officiel,  Up: Substituts

4.3.2 Autoriser un serveur de substituts
----------------------------------------

Pour permettre à Guix de télécharger les substituts depuis
‘ci.guix.gnu.org’ ou un miroir, vous devez ajouter sa clef publique à la
liste de contrôle d’accès (ACL) des imports d’archives, avec la commande
‘guix archive’ (*note Invoquer guix archive::). Cela implique que vous
faîtes confiance à ‘ci.guix.gnu.org’ pour ne pas être compromis et vous
servir des substituts authentiques.

   La clef publique pour ‘ci.guix.gnu.org’ est installée avec Guix, dans
‘PRÉFIXE/share/guix/ci.guix.gnu.org.pub’, où PRÉFIXE est le préfixe
d’installation de Guix. Si vous avez installé Guix depuis les sources,
assurez-vous d’avoir vérifié la signature GPG de
‘guix-1.0.1.17089-7e269.tar.gz’ qui contient ce fichier de clef
publique. Ensuite vous pouvez lancer quelque chose comme ceci :

     # guix archive --authorize < PREFIX/share/guix/ci.guix.gnu.org.pub

   Une fois que cela est en place, la sortie d’une commande comme ‘guix
build’ devrait changer de quelque chose comme :

     $ guix build emacs --dry-run
     Les dérivations suivantes seraient construites :
        /gnu/store/yr7bnx8xwcayd6j95r2clmkdl1qh688w-emacs-24.3.drv
        /gnu/store/x8qsh1hlhgjx6cwsjyvybnfv2i37z23w-dbus-1.6.4.tar.gz.drv
        /gnu/store/1ixwp12fl950d15h2cj11c73733jay0z-alsa-lib-1.0.27.1.tar.bz2.drv
        /gnu/store/nlma1pw0p603fpfiqy7kn4zm105r5dmw-util-linux-2.21.drv
     ...

à quelque chose comme :

     $ guix build emacs --dry-run
     112.3 Mo seraient téléchargés :
        /gnu/store/pk3n22lbq6ydamyymqkkz7i69wiwjiwi-emacs-24.3
        /gnu/store/2ygn4ncnhrpr61rssa6z0d9x22si0va3-libjpeg-8d
        /gnu/store/71yz6lgx4dazma9dwn2mcjxaah9w77jq-cairo-1.12.16
        /gnu/store/7zdhgp0n1518lvfn8mb96sxqfmvqrl7v-libxrender-0.9.7
     ...

The text changed from “The following derivations would be built” to
“112.3 MB would be downloaded”. This indicates that substitutes from
‘ci.guix.gnu.org’ are usable and will be downloaded, when possible, for
future builds.

   The substitute mechanism can be disabled globally by running
‘guix-daemon’ with ‘--no-substitutes’ (*note Invoquer guix-daemon::). It
can also be disabled temporarily by passing the ‘--no-substitutes’
option to ‘guix package’, ‘guix build’, and other command-line tools.


File: guix.fr.info,  Node: Authentification des substituts,  Next: Paramètres de serveur mandataire,  Prev: Autoriser un serveur de substituts,  Up: Substituts

4.3.3 Authentification des substituts
-------------------------------------

Guix détecte et lève une erreur lorsqu’il essaye d’utiliser un substitut
qui a été modifié. De même, il ignore les substituts qui ne sont pas
signés ou qui ne sont pas signés par l’une des clefs listées dans l’ACL.

   Il y a une exception cependant : si un serveur non autorisé fournit
des substituts qui sont _identiques bit-à-bit_ à ceux fournis par un
serveur autorisé, alors le serveur non autorisé devient disponible pour
les téléchargements. Par exemple en supposant qu’on a choisi deux
serveurs de substituts avec cette option :

     --substitute-urls="https://a.example.org https://b.example.org"

If the ACL contains only the key for ‘b.example.org’, and if
‘a.example.org’ happens to serve the _exact same_ substitutes, then Guix
will download substitutes from ‘a.example.org’ because it comes first in
the list and can be considered a mirror of ‘b.example.org’. In practice,
independent build machines usually produce the same binaries, thanks to
bit-reproducible builds (see below).

   When using HTTPS, the server’s X.509 certificate is _not_ validated
(in other words, the server is not authenticated), contrary to what
HTTPS clients such as Web browsers usually do. This is because Guix
authenticates substitute information itself, as explained above, which
is what we care about (whereas X.509 certificates are about
authenticating bindings between domain names and public keys).


File: guix.fr.info,  Node: Paramètres de serveur mandataire,  Next: Échec de substitution,  Prev: Authentification des substituts,  Up: Substituts

4.3.4 Paramètres de serveur mandataire
--------------------------------------

Substitutes are downloaded over HTTP or HTTPS. The ‘http_proxy’ and
‘https_proxy’ environment variables can be set in the environment of
‘guix-daemon’ and are honored for downloads of substitutes. Note that
the value of those environment variables in the environment where ‘guix
build’, ‘guix package’, and other client commands are run has
_absolutely no effect_.


File: guix.fr.info,  Node: Échec de substitution,  Next: De la confiance en des binaires,  Prev: Paramètres de serveur mandataire,  Up: Substituts

4.3.5 Échec de substitution
---------------------------

Même lorsqu’un substitut pour une dérivation est disponible, la
substitution échoue parfois. Cela peut arriver pour plusieurs raisons :
le serveur de substitut peut être hors ligne, le substitut a récemment
été supprimé du serveur, la connexion peut avoir été interrompue, etc.

   When substitutes are enabled and a substitute for a derivation is
available, but the substitution attempt fails, Guix will attempt to
build the derivation locally depending on whether or not ‘--fallback’
was given (*note common build option ‘--fallback’: option de repli.).
Specifically, if ‘--fallback’ was omitted, then no local build will be
performed, and the derivation is considered to have failed. However, if
‘--fallback’ was given, then Guix will attempt to build the derivation
locally, and the success or failure of the derivation depends on the
success or failure of the local build. Note that when substitutes are
disabled or no substitute is available for the derivation in question, a
local build will _always_ be performed, regardless of whether or not
‘--fallback’ was given.

   Pour se donner une idée du nombre de substituts disponibles
maintenant, vous pouvez essayer de lancer la commande ‘guix weather’
(*note Invoquer guix weather::). Cette command fournit des statistiques
sur les substituts fournis par un serveur.


File: guix.fr.info,  Node: De la confiance en des binaires,  Prev: Échec de substitution,  Up: Substituts

4.3.6 De la confiance en des binaires
-------------------------------------

De nos jours, le contrôle individuel sur son utilisation propre de
l’informatique est à la merci d’institutions, de sociétés et de groupes
avec assez de pouvoir et de détermination pour contourner les
infrastructures informatiques et exploiter leurs faiblesses. Bien
qu’utiliser les substituts de ‘ci.guix.gnu.org’ soit pratique, nous
encourageons chacun·e à construire aussi par soi-même, voire à faire
tourner sa propre ferme de construction, pour que ‘ci.guix.gnu.org’
devienne une cible moins intéressante. Une façon d’aider est de publier
les logiciels que vous construisez avec ‘guix publish’ pour que les
autres aient plus de choix de serveurs où télécharger les substituts
(*note Invoquer guix publish::).

   Guix possède les fondations pour maximiser la reproductibilité
logicielle (*note Fonctionnalités::). Dans la plupart des cas, des
constructions indépendantes d’un paquet donnée ou d’une dérivation
devrait donner des résultats identiques au bit près. Ainsi, à travers un
ensemble de constructions de paquets indépendantes il est possible de
renforcer l’intégrité du système. La commande ‘guix challenge’ a pour
but d’aider les utilisateur·rice·s à tester les serveurs de substituts
et à aider les développeur·euse·s à trouver les constructions de paquets
non-déterministes (*note Invoquer guix challenge::). De même, l’option
‘--check’ de ‘guix build’ permet à chaque personne de vérifier si les
substituts précédemment installés sont authentiques en les
reconstruisant localement (*note ‘guix build --check’: vérification de
la construction.).

   À l’avenir, nous aimerions que Guix puisse publier et recevoir des
binaires d’autres personnes, de manière pair-à-pair. Si vous voulez
discuter de ce projet, rejoignez-nous sur <guix-devel@gnu.org>.


File: guix.fr.info,  Node: Des paquets avec plusieurs résultats,  Next: Invoquer guix gc,  Prev: Substituts,  Up: Gestion de paquets

4.4 Des paquets avec plusieurs résultats
========================================

Souvent, les paquets définis dans Guix ont une seule “sortie” — c.-à-d.
que le paquet source conduit à exactement un répertoire dans le dépôt.
Lorsque vous lancez ‘guix install glibc’, vous installez la sortie par
défaut du paquet GNU libc ; la sortie par défaut est appelée ‘out’ mais
son nom peut être omis comme le montre cette commande. Dans ce cas
particulier, la sortie par défaut de ‘glibc’ contient tous les fichiers
d’en-tête C, les bibliothèques partagées, les bibliothèques statiques,
la documentation Info et les autres fichiers de support.

   Parfois il est plus approprié de séparer les divers types de fichiers
produits par un même paquet source en plusieurs sorties. Par exemple, la
bibliothèque C GLib (utilisée par GTK+ et des paquets associés) installe
plus de 20 Mo de documentation de référence dans des pages HTML. Pour
préserver l’espace disque des utilisateurs qui n’en ont pas besoin, la
documentation va dans une sortie séparée nommée ‘doc’. Pour installer la
sortie principale de GLib, qui contient tout sauf la documentation, on
devrait lancer :

     guix install glib

   La commande pour installer la documentation est :

     guix install glib:doc

   Certains paquets installent des programmes avec des « empreintes
dépendances » différentes. Par exemple le paquet WordNet installe à la
fois les outils en ligne de commande et les interfaces graphiques (GUI).
La première ne dépend que de la bibliothèque C, alors que cette dernière
dépend de Tcl/Tk et des bibliothèques X sous-jacentes. Dans ce cas, nous
laissons les outils en ligne de commande dans la sortie par défaut et
l’interface graphique dans une sortie séparée. Cela permet aux
utilisateurs qui n’ont pas besoin d’interface graphique de gagner de la
place. La commande ‘guix size’ peut aider à trouver ces situations
(*note Invoquer guix size::). ‘guix graph’ peut aussi être utile (*note
Invoquer guix graph::).

   Il y a plusieurs paquets à sorties multiples dans la distribution
GNU. D’autres noms de sorties conventionnels sont ‘lib’ pour les
bibliothèques et éventuellement les fichiers d’en-tête, ‘bin’ pour les
programmes indépendants et ‘debug’ pour les informations de débogage
(*note Installer les fichiers de débogage::). Les sorties d’un paquet
sont listés dans la troisième colonne de la sortie de ‘guix package
--list-available’ (*note Invoquer guix package::).


File: guix.fr.info,  Node: Invoquer guix gc,  Next: Invoquer guix pull,  Prev: Des paquets avec plusieurs résultats,  Up: Gestion de paquets

4.5 Invoquer ‘guix gc’
======================

Les paquets qui sont installés mais pas utilisés peuvent être “glanés”.
La commande ‘guix gc’ permet aux utilisateurs de lancer explicitement le
ramasse-miettes pour récupérer de l’espace dans le répertoire
‘/gnu/store’. C’est la _seule_ manière de supprimer des fichiers de
‘/gnu/store’ — supprimer des fichiers ou des répertoires à la main peut
le casser de manière impossible à réparer !

   Le ramasse-miettes a un ensemble de “racines” connues : tout fichier
dans ‘/gnu/store’ atteignable depuis une racine est considéré comme
“utilisé” et ne peut pas être supprimé ; tous les autres fichiers sont
considérés comme “inutilisés” et peuvent être supprimés. L’ensemble des
racines du ramasse-miettes (ou « racines du GC » pour faire court)
inclue les profils par défaut des utilisateurs ; par défaut les liens
symboliques sous ‘/var/guix/gcroots’ représentent ces racines du GC. De
nouvelles racines du GC peuvent être ajoutées avec la ‘guix build --
root’ par exemple (*note Invoquer guix build::). La commande ‘guix gc
--list-roots’ permet de les lister.

   Avant de lancer ‘guix gc --collect-garbage’ pour faire de la place,
c’est souvent utile de supprimer les anciennes génération des profils
utilisateurs ; de cette façon les anciennes constructions de paquets
référencées par ces générations peuvent être glanées. Cela se fait en
lançant ‘guix package --delete-generations’ (*note Invoquer guix
package::).

   Nous recommandons de lancer le ramasse-miettes régulièrement ou
lorsque vous avez besoin d’espace disque. Par exemple pour garantir
qu’au moins 5 Go d’espace reste libre sur votre disque, lancez
simplement :

     guix gc -F 5G

   Il est parfaitement possible de le lancer comme une tâche périodique
non-interactive (*note Exécution de tâches planifiées:: pour apprendre
comment paramétrer une telle tâche). Lancer ‘guix gc’ sans argument
ramassera autant de miettes que possible mais ça n’est pas le plus
pratique : vous pourriez vous retrouver à reconstruire ou re-télécharger
des logiciels « inutilisés » du point de vu du GC mais qui sont
nécessaires pour construire d’autres logiciels — p. ex. la chaîne de
compilation.

   The ‘guix gc’ command has three modes of operation: it can be used to
garbage-collect any dead files (the default), to delete specific files
(the ‘--delete’ option), to print garbage-collector information, or for
more advanced queries. The garbage collection options are as follows:

‘--collect-garbage[=MIN]’
‘-C [MIN]’
     Ramasse les miettes — c.-à-d. les fichiers inaccessibles de
     ‘/gnu/store’ et ses sous-répertoires. C’est l’opération par défaut
     lorsqu’aucune option n’est spécifiée.

     Lorsque MIN est donné, s’arrêter une fois que MIN octets ont été
     collectés. MIN peut être un nombre d’octets ou inclure un suffixe
     d’unité, comme ‘MiB’ pour mébioctet et ‘GB’ pour gigaoctet (*note
     size specifications: (coreutils)Block size.).

     Lorsque MIN est omis, tout glaner.

‘--free-space=LIBRE’
‘-F LIBRE’
     Glaner jusqu’à ce que LIBRE espace soit disponible dans
     ‘/gnu/store’ si possible ; LIBRE est une quantité de stockage comme
     ‘500MiB’ comme décrit ci-dessus.

     Lorsque LIBRE ou plus est disponible dans ‘/gnu/store’ ne rien
     faire et s’arrêter immédiatement.

‘--delete-generations[=DURÉE]’
‘-d [DURÉE]’
     Avant de commencer le glanage, supprimer toutes les générations
     plus vielles que DURÉE, pour tous les profils utilisateurs ;
     lorsque cela est lancé en root, cela s’applique à tous les profils
     _de tous les utilisateurs_.

     Par exemple, cette commande supprime toutes les générations de tous
     vos profils plus vieilles que 2 mois (sauf s’il s’agit de la
     génération actuelle) puis libère de l’espace jusqu’à atteindre au
     moins 10 Go d’espace libre :

          guix gc -d 2m -F 10G

‘--delete’
‘-D’
     Essayer de supprimer tous les fichiers et les répertoires du dépôt
     spécifiés en argument. Cela échoue si certains des fichiers ne sont
     pas dans le dépôt ou s’ils sont toujours utilisés.

‘--list-failures’
     Lister les éléments du dépôt qui correspondent à des échecs de
     construction.

     Cela n’affiche rien à moins que le démon n’ait été démarré avec
     ‘--cache-failures’ (*note ‘--cache-failures’: Invoquer
     guix-daemon.).

‘--list-roots’
     Lister les racines du GC appartenant à l’utilisateur ; lorsque la
     commande est lancée en root, lister _toutes_ les racines du GC.

‘--list-busy’
     List store items in use by currently running processes. These store
     items are effectively considered GC roots: they cannot be deleted.

‘--clear-failures’
     Supprimer les éléments du dépôt spécifiés du cache des
     constructions échouées.

     De nouveau, cette option ne fait de sens que lorsque le démon est
     démarré avec ‘--cache-failures’. Autrement elle ne fait rien.

‘--list-dead’
     Montrer la liste des fichiers et des répertoires inutilisés encore
     présents dans le dépôt — c.-à-d. les fichiers et les répertoires
     qui ne sont plus atteignables par aucune racine.

‘--list-live’
     Montrer la liste des fichiers et des répertoires du dépôt utilisés.

   En plus, les références entre les fichiers existants du dépôt peuvent
être demandés :

‘--references’
‘--referrers’
     Lister les références (respectivement les référents) des fichiers
     du dépôt en argument.

‘--requisites’
‘-R’
     Lister les prérequis des fichiers du dépôt passés en argument. Les
     prérequis sont le fichier du dépôt lui-même, leur références et les
     références de ces références, récursivement. En d’autre termes, la
     liste retournée est la “closure transitive” des fichiers du dépôt.

     *Note Invoquer guix size:: pour un outil pour surveiller la taille
     de la closure d’un élément. *Note Invoquer guix graph:: pour un
     outil pour visualiser le graphe des références.

‘--derivers’
     Renvoie les dérivations menant aux éléments du dépôt donnés (*note
     Dérivations::).

     Par exemple cette commande :

          guix gc --derivers `guix package -I ^emacs$ | cut -f4`

     renvoie les fichiers ‘.drv’ menant au paquet ‘emacs’ installé dans
     votre profil.

     Remarquez qu’il peut n’y avoir aucun fichier ‘.drv’ par exemple
     quand ces fichiers ont été glanés. Il peut aussi y avoir plus d’un
     fichier ‘.drv’ correspondant à cause de dérivations à sortie
     fixées.

   Enfin, les options suivantes vous permettent de vérifier l’intégrité
du dépôt et de contrôler l’utilisation du disque.

‘--verify[=OPTIONS]’
     Vérifier l’intégrité du dépôt.

     Par défaut, s’assurer que tous les éléments du dépôt marqués comme
     valides dans la base de données du démon existent bien dans
     ‘/gnu/store’.

     Lorsqu’elle est fournie, l’OPTION doit être une liste séparée par
     des virgule de l’un ou plus parmi ‘contents’ et ‘repair’.

     Lorsque vous passez ‘--verify=contents’, le démon calcul le hash du
     contenu de chaque élément du dépôt et le compare au hash de sa base
     de données. Les différences de hash sont rapportées comme des
     corruptions de données. Comme elle traverse _tous les fichiers du
     dépôt_, cette commande peut prendre très longtemps pour terminer,
     surtout sur un système avec un disque lent.

     Utiliser ‘--verify=repair’ ou ‘--verify=contents,repair’ fait que
     le démon essaie de réparer les objets du dépôt corrompus en
     récupérant leurs substituts (*note Substituts::). Comme la
     réparation n’est pas atomique et donc potentiellement dangereuse,
     elle n’est disponible que pour l’administrateur système. Une
     alternative plus légère lorsque vous connaissez exactement quelle
     entrée est corrompue consiste à lancer ‘guix build --repair’ (*note
     Invoquer guix build::).

‘--optimize’
     Optimiser le dépôt en liant en dur les fichiers identiques — c’est
     la “déduplication”.

     The daemon performs deduplication after each successful build or
     archive import, unless it was started with
     ‘--disable-deduplication’ (*note ‘--disable-deduplication’:
     Invoquer guix-daemon.). Thus, this option is primarily useful when
     the daemon was running with ‘--disable-deduplication’.


File: guix.fr.info,  Node: Invoquer guix pull,  Next: Canaux,  Prev: Invoquer guix gc,  Up: Gestion de paquets

4.6 Invoquer ‘guix pull’
========================

Les paquets sont installés ou mis à jour vers la dernière version
disponible dans la distribution actuellement disponible sur votre
machine locale. Pour mettre à jour cette distribution, en même temps que
les outils Guix, vous devez lancer ‘guix pull’ ; la commande télécharge
le dernier code source de Guix et des descriptions de paquets et le
déploie. Le code source est téléchargé depuis un dépôt Git
(https://git-scm.com), par défaut le dépôt officiel de GNU Guix, bien
que cela puisse être personnalisé.

   Specifically, ‘guix pull’ downloads code from the “channels” (*note
Canaux::) specified by one of the followings, in this order:

  1. the ‘--channels’ option;
  2. the user’s ‘~/.config/guix/channels.scm’ file;
  3. the system-wide ‘/etc/guix/channels.scm’ file;
  4. the built-in default channels specified in the ‘%default-channels’
     variable.

   À la fin, ‘guix package’ utilisera les paquets et les versions des
paquets de la copie de Guix tout juste récupérée. Non seulement ça, mais
toutes les commandes Guix et les modules Scheme seront aussi récupérés
depuis la dernière version. Les nouvelles sous-commandes de ‘guix’
ajoutés par la mise à jour sont aussi maintenant disponibles.

   Any user can update their Guix copy using ‘guix pull’, and the effect
is limited to the user who ran ‘guix pull’. For instance, when user
‘root’ runs ‘guix pull’, this has no effect on the version of Guix that
user ‘alice’ sees, and vice versa.

   Le résultat après avoir lancé ‘guix pull’ est un “profil” disponible
sous ‘~/.config/guix/current’ contenant la dernière version de Guix.
Ainsi, assurez-vous de l’ajouter au début de votre chemin de recherche
pour que vous utilisiez la dernière version. Le même conseil s’applique
au manuel Info (*note Documentation::) :

     export PATH="$HOME/.config/guix/current/bin:$PATH"
     export INFOPATH="$HOME/.config/guix/current/share/info:$INFOPATH"

   The ‘--list-generations’ or ‘-l’ option lists past generations
produced by ‘guix pull’, along with details about their provenance:

     $ guix pull -l
     Génération 1	10 juin 2018 00:18:18
       guix 65956ad
         URL du dépôt : https://git.savannah.gnu.org/git/guix.git
         branche : origin/master
         commit : 65956ad3526ba09e1f7a40722c96c6ef7c0936fe

     Génération 2	11 juin 2018 11:02:49
       guix e0cc7f6
         URL du dépôt : https://git.savannah.gnu.org/git/guix.git
         branche : origin/master
         commit : e0cc7f669bec22c37481dd03a7941c7d11a64f1d
       2 nouveaux paquets : keepalived, libnfnetlink
       6 paquets mis à jour : emacs-nix-mode@2.0.4,
         guile2.0-guix@0.14.0-12.77a1aac, guix@0.14.0-12.77a1aac,
         heimdal@7.5.0, milkytracker@1.02.00, nix@2.0.4

     Génération 3	13 juin 2018 23:31:07	(actuelle)
       guix 844cc1c
         URL du dépôt : https://git.savannah.gnu.org/git/guix.git
         branche : origin/master
         commit : 844cc1c8f394f03b404c5bb3aee086922373490c
       28 nouveaux paquets : emacs-helm-ls-git, emacs-helm-mu, ...
       69 paquets mis à jour : borg@1.1.6, cheese@3.28.0, ...

   *Note ‘guix describe’: Invoquer guix describe, pour d’autres manières
de décrire le statut actuel de Guix.

   This ‘~/.config/guix/current’ profile works exactly like the profiles
created by ‘guix package’ (*note Invoquer guix package::). That is, you
can list generations, roll back to the previous generation—i.e., the
previous Guix—and so on:

     $ guix pull --roll-back
     switched from generation 3 to 2
     $ guix pull --delete-generations=1
     deleting /var/guix/profiles/per-user/charlie/current-guix-1-link

   You can also use ‘guix package’ (*note Invoquer guix package::) to
manage the profile by naming it explicitly:
     $ guix package -p ~/.config/guix/current --roll-back
     passé de la génération 3 à 2
     $ guix package -p ~/.config/guix/current --delete-generations=1
     suppression de /var/guix/profiles/per-user/charlie/current-guix-1-link

   La commande ‘guix pull’ est typiquement invoquée sans arguments mais
elle prend en charge les options suivantes :

‘--url=URL’
‘--commit=COMMIT’
‘--branch=BRANCHE’
     Télécharger le code pour le canal ‘guix’ depuis l’URL spécifié, au
     COMMIT donné (un commit Git valide représenté par une chaîne
     hexadécimale) ou à la branche BRANCH.

     Ces options sont fournies pour votre confort, mais vous pouvez
     aussi spécifier votre configuration dans le fichier
     ‘~/.config/guix/channels.scm’ ou en utilisant l’option ‘--channels’
     (voir plus bas).

‘--channels=FILE’
‘-C FILE’
     Read the list of channels from FILE instead of
     ‘~/.config/guix/channels.scm’ or ‘/etc/guix/channels.scm’. FILE
     must contain Scheme code that evaluates to a list of channel
     objects. *Note Canaux::, for more information.

‘--news’
‘-N’
     Display the list of packages added or upgraded since the previous
     generation, as well as, occasionally, news written by channel
     authors for their users (*note Writing Channel News: Canaux.).

     The package information is the same as displayed upon ‘guix pull’
     completion, but without ellipses; it is also similar to the output
     of ‘guix pull -l’ for the last generation (see below).

‘--list-generations[=MOTIF]’
‘-l [MOTIF]’
     Liste toutes les générations de ‘~/.config/guix/current’ ou, si
     MOTIF est fournit, le sous-ensemble des générations qui
     correspondent à MOTIF. La syntaxe de MOTIF est la même qu’avec
     ‘guix package --list-generations’ (*note Invoquer guix package::).

‘--roll-back’
     Roll back to the previous “generation” of
     ‘~/.config/guix/current’—i.e., undo the last transaction.

‘--switch-generation=MOTIF’
‘-S MOTIF’
     Basculer vers une génération particulière définie par le MOTIF.

     PATTERN may be either a generation number or a number prefixed with
     “+” or “-”. The latter means: move forward/backward by a specified
     number of generations. For example, if you want to return to the
     latest generation after ‘--roll-back’, use
     ‘--switch-generation=+1’.

‘--delete-generations[=MOTIF]’
‘-d [MOTIF]’
     Lorsque MOTIF est omis, supprimer toutes les générations en dehors
     de l’actuelle.

     This command accepts the same patterns as ‘--list-generations’.
     When PATTERN is specified, delete the matching generations. When
     PATTERN specifies a duration, generations _older_ than the
     specified duration match. For instance, ‘--delete-generations=1m’
     deletes generations that are more than one month old.

     If the current generation matches, it is _not_ deleted.

     Remarquez que supprimer des générations empêche de revenir en
     arrière vers elles. Ainsi, cette commande doit être utilisée avec
     précaution.

     *Note Invoquer guix describe::, pour une manière d’afficher des
     informations sur la génération actuelle uniquement.

‘--profile=PROFIL’
‘-p PROFIL’
     Utiliser le PROFIL à la place de ‘~/.config/guix/current’.

‘--dry-run’
‘-n’
     Montrer quels commits des canaux seraient utilisés et ce qui serait
     construit ou substitué mais ne pas le faire vraiment.

‘--allow-downgrades’
     Allow pulling older or unrelated revisions of channels than those
     currently in use.

     By default, ‘guix pull’ protects against so-called “downgrade
     attacks” whereby the Git repository of a channel would be reset to
     an earlier or unrelated revision of itself, potentially leading you
     to install older, known-vulnerable versions of software packages.

          Remarque : Make sure you understand its security implications
          before using ‘--allow-downgrades’.

‘--system=SYSTÈME’
‘-s SYSTÈME’
     Tenter de construire pour le SYSTÈME — p. ex. ‘i686-linux’ — plutôt
     que pour le type de système de l’hôte de construction.

‘--verbose’
     Produire une sortie verbeuse, en écrivant les journaux de
     construction sur la sortie d’erreur standard.

‘--bootstrap’
     Utiliser le programme d’amorçage Guile pour construire la dernière
     version de Guix. Cette option n’est utile qu’aux personnes qui
     développent Guix.

   Le mécanisme de “canaux” vous permet de dire à ‘guix pull’ quels
répertoires et branches récupérer, ainsi que les dépôts
_supplémentaires_ contenant des modules de paquets qui devraient être
déployés. *Note Canaux:: pour plus d’information.

   En plus, ‘guix pull’ supporte toutes les options de construction
communes (*note Options de construction communes::).


File: guix.fr.info,  Node: Canaux,  Next: Invoking guix time-machine,  Prev: Invoquer guix pull,  Up: Gestion de paquets

4.7 Canaux
==========

Guix et sa collection de paquets sont mis à jour en lançant ‘guix pull’
(*note Invoquer guix pull::). Par défaut ‘guix pull’ télécharge et
déploie Guix lui-même depuis le dépôt officiel de GNU Guix. Cela peut
être personnalisé en définissant des “canaux” dans le fichier
‘~/.config/guix/channels.scm’. Un canal spécifie l’URL et la branche
d’un répertoire Git à déployer et on peut demander à ‘guix pull’ de
récupérer un ou plusieurs canaux. En d’autres termes, les canaux peuvent
être utilisés pour personnaliser et pour _étendre_ Guix, comme on le
verra plus bas.

4.7.1 Utiliser un canal Guix personnalisé
-----------------------------------------

Le canal nommé ‘guix’ spécifie où Guix lui-même — ses outils en ligne de
commande ainsi que sa collection de paquets — sera téléchargé. Par
exemple, supposons que vous voulez effectuer les mises à jour depuis
votre propre copie du dépôt Guix sur ‘example.org’, et plus
particulièrement depuis la branche ‘super-hacks’. Vous pouvez écrire
cette spécification dans ‘~/.config/guix/channels.scm’ :

     ;; Dit à « guix pull » d'utiliser mon propre dépôt.
     (list (channel
             (name 'guix)
             (url "https://example.org/my-guix.git")
             (branch "super-hacks")))

Maintenant, ‘guix pull’ récupérera le code depuis la branche
‘super-hacks’ du dépôt sur ‘example.org’.

4.7.2 Spécifier des canaux supplémentaires
------------------------------------------

Vous pouvez aussi spécifier des _canaux supplémentaires_ à récupérer.
Disons que vous avez un ensemble de paquets personnels ou de variantes
personnalisées qu’il ne vaudrait pas le coup de contribuer au projet
Guix, mais que vous voudriez pouvoir utiliser de manière transparente
sur la ligne de commande. Vous écririez d’abord des modules contenant
ces définitions de paquets (*note Modules de paquets::), en les
maintenant dans un dépôt Git, puis vous ou n’importe qui d’autre
pourrait l’utiliser comme un canal supplémentaire où trouver ces
paquets. Sympa, non ?

     Attention : Avant que vous, cher utilisateur, ne vous exclamiez «
     Oh mais c’est _super génial_ ! » et que vous ne publiez vos canaux
     personnels publiquement, nous voudrions vous donner quelques
     avertissements :

        • Avant de publier un canal, envisagez de contribuer vos
          définitions de paquets dans Guix (*note Contribuer::). Guix en
          tant que projet est ouvert à tous les logiciels libres de
          toutes sortes, et les paquets dans Guix sont déjà disponibles
          à tous les utilisateurs de Guix et bénéficient des processus
          d’assurance qualité du projet.

        • Lorsque vous maintenez des définitions de paquets en dehors de
          Guix, nous, les développeur·euse·s de Guix, considérons que
          _la charge de la compatibilité vous incombe_. Rappelez-vous
          que les modules de paquets et les définitions de paquets ne
          sont que du code Scheme qui utilise diverses interfaces de
          programmation (API). Nous souhaitons rester libres de changer
          ces API pour continuer à améliorer Guix, éventuellement d’une
          manière qui casse votre canal. Nous ne changeons jamais l’API
          gratuitement, mais nous ne nous engageons _pas_ à geler les
          API non plus.

        • Corollaire : si vous utilisez un canal externe et que le canal
          est cassé, merci de _rapporter le problème à l’auteur du
          canal_, pas au projet Guix.

     Vous avez été prévenus ! Maintenant, nous pensons que des canaux
     externes sont une manière pratique d’exercer votre liberté pour
     augmenter la collection de paquets de Guix et de partager vos
     améliorations, qui sont les principes de bases du logiciel libre
     (https://www.gnu.org/philosophy/free-sw.html). Contactez-nous par
     courriel sur <guix-devel@gnu.org> si vous souhaitez discuter à ce
     propos.

   Pour utiliser un canal, écrivez dans ‘~/.config/guix/channels.scm’
pour dire à ‘guix pull’ de récupérer votre canal personnel _en plus_ des
canaux par défaut de Guix :

     ;; Ajouter mes paquets personnels à ceux fournis par Guix.
     (cons (channel
             (name 'my-personal-packages)
             (url "https://example.org/personal-packages.git"))
           %default-channels)

Remarquez que le bout de code au-dessus est (comme toujours !) du code
Scheme ; nous utilisons ‘cons’ pour ajouter un canal à la liste des
canaux que la variable ‘%default-channels’ représente (*note ‘cons’ and
lists: (guile)Pairs.). Avec ce fichier en place, ‘guix pull’ construit
non seulement Guix mais aussi les modules de paquets de votre propre
dépôt. Le résultat dans ‘~/.config/guix/current’ est l’union de Guix et
de vos propres modules de paquets :

     $ guix pull --list-generations
     ...
     Génération 19	Aug 27 2018 16:20:48
       guix d894ab8
         URL du dépôt : https://git.savannah.gnu.org/git/guix.git
         branche : master
         commit : d894ab8e9bfabcefa6c49d9ba2e834dd5a73a300
       my-personal-packages dd3df5e
         URL du dépôt : https://example.org/personal-packages.git
         branche : master
         commit : dd3df5e2c8818760a8fc0bd699e55d3b69fef2bb
       11 nouveaux paquets : my-gimp, my-emacs-with-cool-features, ...
       4 paquets mis à jour : emacs-racket-mode@0.0.2-2.1b78827, ...

La sortie de ‘guix pull’ ci-dessus montre que la génération 19 contient
aussi bien Guix que les paquets du canal ‘my-personal-packages’. Parmi
les nouveaux paquets et les paquets mis à jour qui sont listés, certains
comme ‘my-gimp’ et ‘my-emacs-with-cool-features’ peuvent provenir de
‘my-personal-packages’, tandis que d’autres viennent du canal par défaut
de Guix.

   Pour créer un canal, créez un dépôt Git contenant vos propres modules
de paquets et rendez-le disponible. Le dépôt peut contenir tout ce que
vous voulez, mais un canal utile contiendra des modules Guile qui
exportent des paquets. Une fois que vous avez démarré un canal, Guix se
comportera comme si le répertoire de la racine du dépôt Git de ce canal
était ajouté au chemin de chargement de Guile (*note (guile)Load
Paths::). Par exemple, si votre canal contient un fichier
‘mes-paquets/mes-outils.scm’ qui définit un module Guile, le module sera
disponible sous le nom de ‘(mes-paquets mes-outils)’ et vous pourrez
l’utiliser comme les autres modules (*note (guile)Modules::).

4.7.3 Déclarer des dépendances de canaux
----------------------------------------

Les auteurs de canaux peuvent décider d’augmenter une collection de
paquets fournie par d’autres canaux. Ils peuvent déclarer leur canal
comme dépendant d’autres canaux dans le fichier de métadonnées
‘.guix-channel’ qui doit être placé à la racine de dépôt du canal.

   Le fichier de métadonnées devrait contenir une S-expression simple
comme cela :

     (channel
      (version 0)
      (dependencies
       (channel
        (name une-collection)
        (url "https://exemple.org/premiere-collection.git"))
       (channel
        (name some-autre-collection)
        (url "https://exemple.org/deuxieme-collection.git")
        (branch "testing"))))

   Dans l’exemple ci-dessus, ce canal est déclaré comme dépendant de
deux autres canaux, qui seront récupérés automatiquement. Les modules
fournis par le canal seront compilés dans un environnement où les
modules de tous les canaux déclarés sont disponibles.

   Pour des raisons de fiabilité et de maintenabilité, vous devriez
éviter d’avoir des dépendances sur des canaux que vous ne maîtrisez pas
et vous devriez ajouter le minimum de dépendances possible.

4.7.4 Package Modules in a Sub-directory
----------------------------------------

As a channel author, you may want to keep your channel modules in a
sub-directory. If your modules are in the sub-directory ‘guix’, you must
add a meta-data file ‘.guix-channel’ that contains:

     (channel
       (version 0)
       (directory "guix"))

4.7.5 Writing Channel News
--------------------------

Channel authors may occasionally want to communicate to their users
information about important changes in the channel. You’d send them all
an email, but that’s not convenient.

   Instead, channels can provide a “news file”; when the channel users
run ‘guix pull’, that news file is automatically read and ‘guix pull
--news’ can display the announcements that correspond to the new commits
that have been pulled, if any.

   To do that, channel authors must first declare the name of the news
file in their ‘.guix-channel’ file:

     (channel
       (version 0)
       (news-file "etc/news.txt"))

   The news file itself, ‘etc/news.txt’ in this example, must look
something like this:

     (channel-news
       (version 0)
       (entry (tag "the-bug-fix")
              (title (en "Fixed terrible bug")
                     (fr "Oh la la"))
              (body (en "@emph{Good news}!  It's fixed!")
                    (eo "Certe ĝi pli bone funkcias nun!")))
       (entry (commit "bdcabe815cd28144a2d2b4bc3c5057b051fa9906")
              (title (en "Added a great package")
                     (ca "Què vol dir guix?"))
              (body (en "Don't miss the @code{hello} package!"))))

   The file consists of a list of “news entries”. Each entry is
associated with a commit or tag: it describes changes made in this
commit, possibly in preceding commits as well. Users see entries only
the first time they obtain the commit the entry refers to.

   The ‘title’ field should be a one-line summary while ‘body’ can be
arbitrarily long, and both can contain Texinfo markup (*note
(texinfo)Overview::). Both the title and body are a list of language
tag/message tuples, which allows ‘guix pull’ to display news in the
language that corresponds to the user’s locale.

   If you want to translate news using a gettext-based workflow, you can
extract translatable strings with ‘xgettext’ (*note (gettext)xgettext
Invocation::). For example, assuming you write news entries in English
first, the command below creates a PO file containing the strings to
translate:

     xgettext -o news.po -l scheme -ken etc/news.scm

   To sum up, yes, you could use your channel as a blog. But beware,
this is _not quite_ what your users might expect.

4.7.6 Répliquer Guix
--------------------

La sortie de ‘guix pull --list-generations’ ci-dessus montre précisément
quels commits ont été utilisés pour construire cette instance de Guix.
Nous pouvons donc la répliquer, disons sur une autre machine, en
fournissant une spécification de canal dans
‘~/.config/guix/channels.scm’ qui est « épinglé » à ces commits :

     ;; Deploy specific commits of my channels of interest.
     (list (channel
            (name 'guix)
            (url "https://git.savannah.gnu.org/git/guix.git")
            (commit "d894ab8e9bfabcefa6c49d9ba2e834dd5a73a300"))
           (channel
            (name 'my-personal-packages)
            (url "https://example.org/personal-packages.git")
            (commit "dd3df5e2c8818760a8fc0bd699e55d3b69fef2bb")))

   The ‘guix describe --format=channels’ command can even generate this
list of channels directly (*note Invoquer guix describe::). The
resulting file can be used with the -C options of ‘guix pull’ (*note
Invoquer guix pull::) or ‘guix time-machine’ (*note Invoking guix
time-machine::).

   À ce moment les deux machines font tourner _exactement le même Guix_,
avec l’accès _exactement aux même paquets_. La sortie de ‘guix build
gimp’ sur une machine sera exactement la même, au bit près, que la
sortie de la même commande sur l’autre machine. Cela signifie aussi que
les deux machines ont accès à tous les codes sources de Guix, et
transitivement, à tous les codes sources de tous les paquets qu’il
définit.

   Cela vous donne des super-pouvoirs, ce qui vous permet de suivre la
provenance des artefacts binaires avec un grain très fin et de
reproduire les environnements logiciels à volonté — une sorte de
capacité de « méta-reproductibilité », si vous voulez. *Note
Inférieurs::, pour une autre manière d’utiliser ces super-pouvoirs.


File: guix.fr.info,  Node: Invoking guix time-machine,  Next: Inférieurs,  Prev: Canaux,  Up: Gestion de paquets

4.8 Invoking ‘guix time-machine’
================================

The ‘guix time-machine’ command provides access to other revisions of
Guix, for example to install older versions of packages, or to reproduce
a computation in an identical environment. The revision of Guix to be
used is defined by a commit or by a channel description file created by
‘guix describe’ (*note Invoquer guix describe::).

   La syntaxe générale est :

     guix time-machine OPTIONS... -- COMMAND ARG...

   where COMMAND and ARG... are passed unmodified to the ‘guix’ command
of the specified revision. The OPTIONS that define this revision are the
same as for ‘guix pull’ (*note Invoquer guix pull::):

‘--url=URL’
‘--commit=COMMIT’
‘--branch=BRANCHE’
     Use the ‘guix’ channel from the specified URL, at the given COMMIT
     (a valid Git commit ID represented as a hexadecimal string), or
     BRANCH.

‘--channels=FILE’
‘-C FILE’
     Read the list of channels from FILE. FILE must contain Scheme code
     that evaluates to a list of channel objects. *Note Canaux:: for
     more information.

   As for ‘guix pull’, the absence of any options means that the the
latest commit on the master branch will be used. The command

     guix time-machine -- build hello

   will thus build the package ‘hello’ as defined in the master branch,
which is in general a newer revision of Guix than you have installed.
Time travel works in both directions!

   Note that ‘guix time-machine’ can trigger builds of channels and
their dependencies, and these are controlled by the standard build
options (*note Options de construction communes::).


File: guix.fr.info,  Node: Inférieurs,  Next: Invoquer guix describe,  Prev: Invoking guix time-machine,  Up: Gestion de paquets

4.9 Inférieurs
==============

     Remarque : La fonctionnalité décrite ici est un « démonstrateur
     technique » à la version 1.0.1.17089-7e269. Ainsi, l’interface est
     sujette à changements.

   Parfois vous pourriez avoir à mélanger des paquets de votre révision
de Guix avec des paquets disponibles dans une révision différente de
Guix. Les “inférieurs” de Guix vous permettent d’accomplir cette tâche
en composant différentes versions de Guix de manière arbitraire.

   Techniquement, un « inférieur » est surtout un processus Guix séparé
connecté à votre processus Guix principal à travers un REPL (*note
Invoquer guix repl::). Le module ‘(guix inferior)’ vous permet de créer
des inférieurs et de communiquer avec eux. Il fournit aussi une
interface de haut-niveau pour naviguer dans les paquets d’un inférieur —
“des paquets inférieurs” — et les manipuler.

   Lorsqu’on les combine avec des canaux (*note Canaux::), les
inférieurs fournissent une manière simple d’interagir avec un révision
de Guix séparée. Par exemple, disons que vous souhaitiez installer dans
votre profil le paquet guile actuel, avec le ‘guile-json’ d’une ancienne
révision de Guix — peut-être parce que la nouvelle version de
‘guile-json’ a une API incompatible et que vous voulez lancer du code
avec l’ancienne API. Pour cela, vous pourriez écrire un manifeste à
utiliser avec ‘guix package --manifest’ (*note Invoquer guix package::)
; dans ce manifeste, vous créeriez un inférieur pour l’ancienne révision
de Guix qui vous intéresse et vous chercheriez le paquet ‘guile-json’
dans l’inférieur :

     (use-modules (guix inferior) (guix channels)
                  (srfi srfi-1))   ;pour « first »

     (define channels
       ;; L'ancienne révision depuis laquelle on veut
       ;; extraire guile-json.
       (list (channel
              (name 'guix)
              (url "https://git.savannah.gnu.org/git/guix.git")
              (commit
               "65956ad3526ba09e1f7a40722c96c6ef7c0936fe"))))

     (define inferior
       ;; Un inférieur représentant la révision ci-dessus.
       (inferior-for-channels channels))

     ;; Maintenant on crée un manifeste avec le paquet « guile » actuel
     ;; et l'ancien paquet « guile-json ».
     (packages->manifest
      (list (first (lookup-inferior-packages inferior "guile-json"))
            (specification->package "guile")))

   Durant la première exécution, ‘guix package --manifest’ pourrait
avoir besoin de construire le canal que vous avez spécifié avant de
créer l’inférieur ; les exécutions suivantes seront bien plus rapides
parce que la révision de Guix sera déjà en cache.

   Le module ‘(guix inferior)’ fournit les procédures suivantes pour
ouvrir un inférieur :

 -- Procédure Scheme : inferior-for-channels CHANNELS
          [#:cache-directory] [#:ttl]
     Renvoie un inférieur pour CHANNELS, une liste de canaux. Elle
     utilise le cache dans CACHE-DIRECTORY, où les entrées peuvent être
     glanées après TTL secondes. Cette procédure ouvre une nouvelle
     connexion au démon de construction.

     Elle a pour effet de bord de construire ou de substituer des
     binaires pour CHANNELS, ce qui peut prendre du temps.

 -- Procédure Scheme : open-inferior DIRECTORY [#:command "bin/guix"]
     Ouvre le Guix inférieur dans DIRECTORY et lance ‘DIRECTORY/COMMAND
     repl’ ou équivalent. Renvoie ‘#f’ si l’inférieur n’a pas pu être
     lancé.

   Les procédures listées plus bas vous permettent d’obtenir et de
manipuler des paquets inférieurs.

 -- Procédure Scheme : inferior-packages INFERIOR
     Renvoie la liste des paquets connus de l’inférieur INFERIOR.

 -- Procédure Scheme : lookup-inferior-packages INFERIOR NAME [VERSION]
     Renvoie la liste triée des paquets inférieurs qui correspondent à
     NAME dans INFERIOR, avec le plus haut numéro de version en premier.
     Si VERSION est vrai, renvoie seulement les paquets avec un numéro
     de version préfixé par VERSION.

 -- Procédure Scheme : inferior-package? OBJ
     Renvoie vrai si OBJ est un paquet inférieur.

 -- Procédure Scheme : inferior-package-name PACKAGE
 -- Procédure Scheme : inferior-package-version PACKAGE
 -- Procédure Scheme : inferior-package-synopsis PACKAGE
 -- Procédure Scheme : inferior-package-description PACKAGE
 -- Procédure Scheme : inferior-package-home-page PACKAGE
 -- Procédure Scheme : inferior-package-location PACKAGE
 -- Procédure Scheme : inferior-package-inputs PACKAGE
 -- Procédure Scheme : inferior-package-native-inputs PACKAGE
 -- Procédure Scheme : inferior-package-propagated-inputs PACKAGE
 -- Procédure Scheme : inferior-package-transitive-propagated-inputs
          PACKAGE
 -- Procédure Scheme : inferior-package-native-search-paths PACKAGE
 -- Procédure Scheme : inferior-package-transitive-native-search-paths
          PACKAGE
 -- Procédure Scheme : inferior-package-search-paths PACKAGE
     Ces procédures sont la contrepartie des accesseurs des
     enregistrements de paquets (*note Référence des paquets::). La
     plupart fonctionne en effectuant des requêtes à l’inférieur dont
     provient PACKAGE, donc l’inférieur doit toujours être disponible
     lorsque vous appelez ces procédures.

   Les paquets inférieurs peuvent être utilisés de manière transparente
comme tout autre paquet ou objet simili-fichier dans des G-expressions
(*note G-Expressions::). Ils sont aussi gérés de manière transparente
par la procédure ‘packages->manifest’, qui est typiquement utilisée dans
des manifestes (*note l’option ‘--manifest’ de ‘guix package’: Invoquer
guix package.). Ainsi, vous pouvez insérer un paquet inférieur à peu
près n’importe où vous utiliseriez un paquet normal : dans des
manifestes, dans le champ ‘packages’ de votre déclaration
‘operating-system’, etc.


File: guix.fr.info,  Node: Invoquer guix describe,  Next: Invoquer guix archive,  Prev: Inférieurs,  Up: Gestion de paquets

4.10 Invoquer ‘guix describe’
=============================

Souvent vous voudrez répondre à des questions comme « quelle révision de
Guix j’utilise ? » ou « quels canaux est-ce que j’utilise ? ». C’est une
information utile dans de nombreuses situations : si vous voulez
_répliquer_ un environnement sur une machine différente ou un compte
utilisateur, si vous voulez rapporter un bogue ou pour déterminer quel
changement dans les canaux que vous utilisez l’a causé ou si vous voulez
enregistrer l’état de votre système pour le reproduire. La commande
‘guix describe’ répond à ces questions.

   Lorsqu’elle est lancée depuis un ‘guix’ mis à jour avec ‘guix pull’,
‘guix describe’ affiche les canaux qui ont été construits, avec l’URL de
leur dépôt et l’ID de leur commit (*note Canaux::) :

     $ guix describe
     Generation 10	03 sep. 2018 17:32:44	(actuelle)
       guix e0fa68c
         URL du dépôt : https://git.savannah.gnu.org/git/guix.git
         branche : master
         commit : e0fa68c7718fffd33d81af415279d6ddb518f727

   Si vous connaissez bien le système de contrôle de version Git, cela
ressemble en essence à ‘git describe’ ; la sortie est aussi similaire à
celle de ‘guix pull --list-generations’, mais limitée à la génération
actuelle (*note l’option ‘--list-generations’: Invoquer guix pull.).
Comme l’ID de commit de Git ci-dessus se réfère sans aucune ambiguïté à
un instantané de Guix, cette information est tout ce dont vous avez
besoin pour décrire la révision de Guix que vous utilisez et pour la
répliquer.

   Pour rendre plus facile la réplication de Guix, ‘guix describe’ peut
aussi renvoyer une liste de canaux plutôt que la description lisible par
un humain au-dessus :

     $ guix describe -f channels
     (list (channel
             (name 'guix)
             (url "https://git.savannah.gnu.org/git/guix.git")
             (commit
               "e0fa68c7718fffd33d81af415279d6ddb518f727")))

Vous pouvez sauvegarder ceci dans un fichier et le donner à ‘guix pull
-C’ sur une autre machine ou plus tard, ce qui instantiera _exactement
la même révision de Guix_ (*note l’option ‘-C’: Invoquer guix pull.). À
partir de là, comme vous pouvez déployer la même révision de Guix, vous
pouvez aussi bien _répliquer un environnement logiciel complet_. Nous
pensons humblement que c’est _génial_, et nous espérons que vous aimerez
ça aussi !

   Voici les détails des options supportées par ‘guix describe’ :

‘--format=FORMAT’
‘-f FORMAT’
     Produire la sortie dans le FORMAT donné, parmi :

     ‘human’
          produire une sortie lisible par un humain,
     ‘canaux’
          produire une liste de spécifications de canaux qui peut être
          passée à ‘guix pull -C’ ou installée dans
          ‘~/.config/guix/channels.scm’ (*note Invoquer guix pull::),
     ‘json’
          produire une liste de spécifications de canaux dans le format
          JSON,
     ‘recutils’
          produire une liste de spécifications de canaux dans le format
          Recutils.

‘--list-formats’
     Display available formats for ‘--format’ option.

‘--profile=PROFIL’
‘-p PROFIL’
     Afficher les informations sur le PROFIL.


File: guix.fr.info,  Node: Invoquer guix archive,  Prev: Invoquer guix describe,  Up: Gestion de paquets

4.11 Invoquer ‘guix archive’
============================

La commande ‘guix archive’ permet aux utilisateurs d’“exporter” des
fichiers du dépôt dans une simple archive puis ensuite de les “importer”
sur une machine qui fait tourner Guix. En particulier, elle permet de
transférer des fichiers du dépôt d’une machine vers le dépôt d’une autre
machine.

     Remarque : Si vous chercher une manière de produire des archives
     dans un format adapté pour des outils autres que Guix, *note
     Invoquer guix pack::.

   Pour exporter des fichiers du dépôt comme une archive sur la sortie
standard, lancez :

     guix archive --export OPTIONS SPÉCIFICATIONS...

   SPÉCIFICATIONS peut être soit des noms de fichiers soit des
spécifications de paquets, comme pour ‘guix package’ (*note Invoquer
guix package::). Par exemple, la commande suivante crée une archive
contenant la sortie ‘gui’ du paquet ‘git’ et la sortie principale de
‘emacs’ :

     guix archive --export git:gui /gnu/store/...-emacs-24.3 > great.nar

   Si les paquets spécifiés ne sont pas déjà construits, ‘guix archive’
les construit automatiquement. Le processus de construction peut être
contrôlé avec les options de construction communes (*note Options de
construction communes::).

   Pour transférer le paquet ‘emacs’ vers une machine connectée en SSH,
on pourrait lancer :

     guix archive --export -r emacs | ssh la-machine guix archive --import

De même, on peut transférer un profil utilisateur complet d’une machine
à une autre comme cela :

     guix archive --export -r $(readlink -f ~/.guix-profile) | \
       ssh the-machine guix archive --import

However, note that, in both examples, all of ‘emacs’ and the profile as
well as all of their dependencies are transferred (due to ‘-r’),
regardless of what is already available in the store on the target
machine. The ‘--missing’ option can help figure out which items are
missing from the target store. The ‘guix copy’ command simplifies and
optimizes this whole process, so this is probably what you should use in
this case (*note Invoquer guix copy::).

   Les archives sont stockées au format « archive normalisé » ou « nar
», qui est comparable dans l’esprit à « tar » mais avec des différences
qui le rendent utilisable pour ce qu’on veut faire. Tout d’abord, au
lieu de stocker toutes les métadonnées Unix de chaque fichier, le format
nar ne mentionne que le type de fichier (normal, répertoire ou lien
symbolique) ; les permissions Unix, le groupe et l’utilisateur ne sont
pas mentionnés. Ensuite, l’ordre dans lequel les entrées de répertoires
sont stockés suit toujours l’ordre des noms de fichier dans
l’environnement linguistique C. Cela rend la production des archives
entièrement déterministe.

   Lors de l’export, le démon signe numériquement le contenu de
l’archive et cette signature est ajoutée à la fin du fichier. Lors de
l’import, le démon vérifie la signature et rejette l’import en cas de
signature invalide ou si la clef de signature n’est pas autorisée.

   Les principales options sont :

‘--export’
     Export the specified store files or packages (see below). Write the
     resulting archive to the standard output.

     Dependencies are _not_ included in the output, unless ‘--recursive’
     is passed.

‘-r’
‘--recursive’
     When combined with ‘--export’, this instructs ‘guix archive’ to
     include dependencies of the given items in the archive. Thus, the
     resulting archive is self-contained: it contains the closure of the
     exported store items.

‘--import’
     Read an archive from the standard input, and import the files
     listed therein into the store. Abort if the archive has an invalid
     digital signature, or if it is signed by a public key not among the
     authorized keys (see ‘--authorize’ below).

‘--missing’
     Liste une liste de noms de fichiers du dépôt sur l’entrée standard,
     un par ligne, et écrit sur l’entrée standard le sous-ensemble de
     ces fichiers qui manquent dans le dépôt.

‘--generate-key[=PARAMÈTRES]’
     Generate a new key pair for the daemon. This is a prerequisite
     before archives can be exported with ‘--export’. Note that this
     operation usually takes time, because it needs to gather enough
     entropy to generate the key pair.

     The generated key pair is typically stored under ‘/etc/guix’, in
     ‘signing-key.pub’ (public key) and ‘signing-key.sec’ (private key,
     which must be kept secret). When PARAMETERS is omitted, an ECDSA
     key using the Ed25519 curve is generated, or, for Libgcrypt
     versions before 1.6.0, it is a 4096-bit RSA key. Alternatively,
     PARAMETERS can specify ‘genkey’ parameters suitable for Libgcrypt
     (*note ‘gcry_pk_genkey’: (gcrypt)General public-key related
     Functions.).

‘--authorize’
     Autoriser les imports signés par la clef publique passée sur
     l’entrée standard. La clef publique doit être au « format avancé
     s-expression » — c.-à-d. le même format que le fichier
     ‘signing-key.pub’.

     La liste des clefs autorisées est gardée dans un fichier modifiable
     par des humains dans ‘/etc/guix/acl’. Le fichier contient des «
     s-expressions au format avancé »
     (https://people.csail.mit.edu/rivest/Sexp.txt) et est structuré
     comme une liste de contrôle d’accès dans l’infrastructure à clefs
     publiques simple (SPKI) (https://theworld.com/~cme/spki.txt).

‘--extract=RÉPERTOIRE’
‘-x RÉPERTOIRE’
     Lit une archive à un seul élément telle que servie par un serveur
     de substituts (*note Substituts::) et l’extrait dans RÉPERTOIRE.
     C’est une opération de bas niveau requise seulement dans de rares
     cas d’usage ; voir plus loin.

     Par exemple, la commande suivante extrait le substitut pour Emacs
     servi par ‘ci.guix.gnu.org’ dans ‘/tmp/emacs’ :

          $ wget -O - \
            https://ci.guix.gnu.org/nar/gzip/...-emacs-24.5 \
            | gunzip | guix archive -x /tmp/emacs

     Les archives à un seul élément sont différentes des archives à
     plusieurs éléments produites par ‘guix archive --export’ ; elles
     contiennent un seul élément du dépôt et elles n’embarquent _pas_ de
     signature. Ainsi cette opération ne vérifie _pas_ de signature et
     sa sortie devrait être considérée comme non sûre.

     The primary purpose of this operation is to facilitate inspection
     of archive contents coming from possibly untrusted substitute
     servers (*note Invoquer guix challenge::).

‘--list’
‘-t’
     Read a single-item archive as served by substitute servers (*note
     Substituts::) and print the list of files it contains, as in this
     example:

          $ wget -O - \
            https://ci.guix.gnu.org/nar/lzip/...-emacs-26.3 \
            | lzip -d | guix archive -t


File: guix.fr.info,  Node: Développement,  Next: Interface de programmation,  Prev: Gestion de paquets,  Up: Top

5 Développement
***************

Si vous êtes développeur de logiciels, Guix fournit des outils que vous
devriez trouver utiles — indépendamment du langage dans lequel vous
développez. C’est ce dont parle ce chapitre.

   La commande ‘guix environment’ permet de créer des “environnements de
développement” confortables contenant toutes les dépendances et les
outils nécessaires pour travailler sur le paquet logiciel de votre
choix. La commande ‘guix pack’ vous permet de créer des “lots
applicatifs” qui peuvent facilement être distribués à des utilisateurs
qui n’utilisent pas Guix.

* Menu:

* Invoquer guix environment::  Mettre en place des environnements de
                                 développement.
* Invoquer guix pack::       Créer des lots de logiciels.
* La chaîne d'outils GCC::  Working with languages supported by GCC.


File: guix.fr.info,  Node: Invoquer guix environment,  Next: Invoquer guix pack,  Up: Développement

5.1 Invoquer ‘guix environment’
===============================

Le but de ‘guix environment’ est d’assister les hackers dans la création
d’environnements de développement reproductibles sans polluer leur
profil de paquets. L’outil ‘guix environment’ prend un ou plusieurs
paquets, construit leurs entrées et crée un environnement shell pour
pouvoir les utiliser.

   La syntaxe générale est :

     guix environment OPTIONS PAQUET...

   L’exemple suivant crée un nouveau shell préparé pour le développement
de GNU Guile :

     guix environment guile

   If the needed dependencies are not built yet, ‘guix environment’
automatically builds them. The environment of the new shell is an
augmented version of the environment that ‘guix environment’ was run in.
It contains the necessary search paths for building the given package
added to the existing environment variables. To create a “pure”
environment, in which the original environment variables have been
unset, use the ‘--pure’ option(1).

   ‘guix environment’ defines the ‘GUIX_ENVIRONMENT’ variable in the
shell it spawns; its value is the file name of the profile of this
environment. This allows users to, say, define a specific prompt for
development environments in their ‘.bashrc’ (*note (bash)Bash Startup
Files::):

     if [ -n "$GUIX_ENVIRONMENT" ]
     then
         export PS1="\u@\h \w [dev]\$ "
     fi

… ou de naviguer dans le profil :

     $ ls "$GUIX_ENVIRONMENT/bin"

   De surcroît, plus d’un paquet peut être spécifié, auquel cas l’union
des entrées des paquets données est utilisée. Par exemple, la commande
ci-dessous crée un shell où toutes les dépendances de Guile et Emacs
sont disponibles :

     guix environment guile emacs

   Parfois, une session shell interactive est inutile. On peut invoquer
une commande arbitraire en plaçant le jeton ‘--’ pour séparer la
commande du reste des arguments :

     guix environment guile -- make -j4

   Dans d’autres situations, il est plus pratique de spécifier la liste
des paquets requis dans l’environnement. Par exemple, la commande
suivante lance ‘python’ dans un environnement contenant Python 2.7 et
NumPy :

     guix environment --ad-hoc python2-numpy python-2.7 -- python

   Furthermore, one might want the dependencies of a package and also
some additional packages that are not build-time or runtime
dependencies, but are useful when developing nonetheless. Because of
this, the ‘--ad-hoc’ flag is positional. Packages appearing before
‘--ad-hoc’ are interpreted as packages whose dependencies will be added
to the environment. Packages appearing after are interpreted as packages
that will be added to the environment directly. For example, the
following command creates a Guix development environment that
additionally includes Git and strace:

     guix environment --pure guix --ad-hoc git strace

   Parfois il est souhaitable d’isoler l’environnement le plus possible,
pour une pureté et une reproductibilité maximale. En particulier,
lorsque vous utilisez Guix sur une distribution hôte qui n’est pas le
système Guix, il est souhaitable d’éviter l’accès à ‘/usr/bin’ et
d’autres ressources du système depuis les environnements de
développement. Par exemple, la commande suivante crée un REPL Guile dans
un « conteneur » où seuls le dépôt et le répertoire de travail actuel
sont montés :

     guix environment --ad-hoc --container guile -- guile

     Remarque : The ‘--container’ option requires Linux-libre 3.19 or
     newer.

   Another typical use case for containers is to run security-sensitive
applications such as a web browser. To run Eolie, we must expose and
share some files and directories; we include ‘nss-certs’ and expose
‘/etc/ssl/certs/’ for HTTPS authentication; finally we preserve the the
‘DISPLAY’ environment variable since containerized graphical
applications won’t display without it.

     guix environment --preserve='^DISPLAY$' --container --network \
       --expose=/etc/machine-id \
       --expose=/etc/ssl/certs/ \
       --share=$HOME/.local/share/eolie/=$HOME/.local/share/eolie/ \
       --ad-hoc eolie nss-certs dbus --  eolie

   Les options disponibles sont résumées ci-dessous.

‘--root=FICHIER’
‘-r FICHIER’
     Fait de FICHIER un lien symbolique vers le profil de cet
     environnement, et l’enregistre comme une racine du ramasse-miettes.

     C’est utile si vous souhaitez protéger votre environnement du
     ramasse-miettes, pour le rendre « persistent ».

     Lorsque cette option est omise, l’environnement n’est protégé du
     ramasse-miettes que le temps de la session ‘guix environment’. Cela
     signifie que la prochaine fois que vous créerez le même
     environnement, vous pourriez avoir à reconstruire ou télécharger
     des paquets. *Note Invoquer guix gc::, pour plus d’informations sur
     les racines du GC.

‘--expression=EXPR’
‘-e EXPR’
     Crée un environnement pour le paquet ou la liste de paquets en
     lesquels s’évalue EXPR.

     Par exemple, lancer :

          guix environment -e '(@ (gnu packages maths) petsc-openmpi)'

     démarre un shell avec l’environnement pour cette variante
     spécifique du paquet PETSc.

     Lancer :

          guix environment --ad-hoc -e '(@ (gnu) %base-packages)'

     démarre un shell où tous les paquets de base du système sont
     disponibles.

     Les commande au-dessus n’utilisent que les sorties par défaut des
     paquets donnés. Pour choisir d’autres sorties, on peut spécifier
     des pairs :

          guix environment --ad-hoc -e '(list (@ (gnu packages bash) bash) "include")'

‘--load=FICHIER’
‘-l FICHIER’
     Crée un environnement pour le paquet ou la liste de paquets en
     lesquels FICHIER s’évalue.

     Par exemple, FICHIER peut contenir une définition comme celle-ci
     (*note Définition des paquets::) :

          (use-modules (guix)
                       (gnu packages gdb)
                       (gnu packages autotools)
                       (gnu packages texinfo))
          
          ;; Augment the package definition of GDB with the build tools
          ;; needed when developing GDB (and which are not needed when
          ;; simply installing it.)
          (package (inherit gdb)
            (native-inputs `(("autoconf" ,autoconf-2.64)
                             ("automake" ,automake)
                             ("texinfo" ,texinfo)
                             ,@(package-native-inputs gdb))))

‘--manifest=FICHIER’
‘-m FICHIER’
     Create an environment for the packages contained in the manifest
     object returned by the Scheme code in FILE. This option can be
     repeated several times, in which case the manifests are
     concatenated.

     C’est similaire à l’option de même nom de ‘guix package’ (*note
     ‘--manifest’: profile-manifest.) et utilise les même fichiers
     manifestes.

‘--ad-hoc’
     Inclut tous les paquets spécifiés dans l’environnement qui en
     résulte, comme si un paquet ad hoc était spécifié, avec ces paquets
     comme entrées. Cette option est utile pour créer un environnement
     rapidement sans avoir à écrire une expression de paquet contenant
     les entrées désirées.

     Par exemple la commande :

          guix environment --ad-hoc guile guile-sdl -- guile

     lance ‘guile’ dans un environnement où Guile et Guile-SDDL sont
     disponibles.

     Remarquez que cet exemple demande implicitement la sortie par
     défaut de ‘guile’ et ‘guile-sdl’, mais il est possible de demander
     une sortie spécifique — p. ex. ‘glib:bin’ demande la sortie ‘bin’
     de ‘glib’ (*note Des paquets avec plusieurs résultats::).

     This option may be composed with the default behavior of ‘guix
     environment’. Packages appearing before ‘--ad-hoc’ are interpreted
     as packages whose dependencies will be added to the environment,
     the default behavior. Packages appearing after are interpreted as
     packages that will be added to the environment directly.

‘--pure’
     Unset existing environment variables when building the new
     environment, except those specified with ‘--preserve’ (see below).
     This has the effect of creating an environment in which search
     paths only contain package inputs.

‘--preserve=REGEXP’
‘-E REGEXP’
     Lorsque vous utilisez ‘--pure’, préserver les variables
     d’environnement qui correspondent à REGEXP — en d’autres termes,
     cela les met en « liste blanche » de variables d’environnement qui
     doivent être préservées. Cette option peut être répétée plusieurs
     fois.

          guix environment --pure --preserve=^SLURM --ad-hoc openmpi ... \
            -- mpirun ...

     This example runs ‘mpirun’ in a context where the only environment
     variables defined are ‘PATH’, environment variables whose name
     starts with ‘SLURM’, as well as the usual “precious” variables
     (‘HOME’, ‘USER’, etc.).

‘--search-paths’
     Affiche les définitions des variables d’environnement qui composent
     l’environnement.

‘--system=SYSTÈME’
‘-s SYSTÈME’
     Essaye de construire pour SYSTÈME — p. ex. ‘i686-linux’.

‘--container’
‘-C’
     Run COMMAND within an isolated container. The current working
     directory outside the container is mapped inside the container.
     Additionally, unless overridden with ‘--user’, a dummy home
     directory is created that matches the current user’s home
     directory, and ‘/etc/passwd’ is configured accordingly.

     The spawned process runs as the current user outside the container.
     Inside the container, it has the same UID and GID as the current
     user, unless ‘--user’ is passed (see below).

‘--network’
‘-N’
     Pour les conteneurs, partage l’espace de nom du réseau avec le
     système hôte. Les conteneurs créés sans cette option n’ont accès
     qu’à l’interface de boucle locale.

‘--link-profile’
‘-P’
     For containers, link the environment profile to ‘~/.guix-profile’
     within the container. This is equivalent to running the command ‘ln
     -s $GUIX_ENVIRONMENT ~/.guix-profile’ within the container. Linking
     will fail and abort the environment if the directory already
     exists, which will certainly be the case if ‘guix environment’ was
     invoked in the user’s home directory.

     Certain packages are configured to look in ‘~/.guix-profile’ for
     configuration files and data;(2) ‘--link-profile’ allows these
     programs to behave as expected within the environment.

‘--user=UTILISATEUR’
‘-u UTILISATEUR’
     Pour les conteneurs, utilise le nom d’utilisateur UTILISATEUR à la
     place de l’utilisateur actuel. L’entrée générée dans ‘/etc/passwd’
     dans le conteneur contiendra le nom UTILISATEUR ; le répertoire
     personnel sera ‘/home/UTILISATEUR’ ; et aucune donnée GECOS ne sera
     copiée. En plus, l’UID et le GID dans le conteneur seront 1000.
     USER n’a pas besoin d’exister sur le système.

     Additionally, any shared or exposed path (see ‘--share’ and
     ‘--expose’ respectively) whose target is within the current user’s
     home directory will be remapped relative to ‘/home/USER’; this
     includes the automatic mapping of the current working directory.

          # exposera les chemins comme /home/foo/wd, /home/foo/test et /home/foo/target
          cd $HOME/wd
          guix environment --container --user=foo \
               --expose=$HOME/test \
               --expose=/tmp/target=$HOME/target

     Bien que cela limite la fuite de l’identité de l’utilisateur à
     travers le chemin du répertoire personnel et des champs de
     l’utilisateur, ce n’est qu’un composant utile pour une solution
     d’anonymisation ou de préservation de la vie privée — pas une
     solution en elle-même.

‘--no-cwd’
     For containers, the default behavior is to share the current
     working directory with the isolated container and immediately
     change to that directory within the container. If this is
     undesirable, ‘--no-cwd’ will cause the current working directory to
     _not_ be automatically shared and will change to the user’s home
     directory within the container instead. See also ‘--user’.

‘--expose=SOURCE[=CIBLE]’
‘--share=SOURCE[=CIBLE]’
     For containers, ‘--expose’ (resp. ‘--share’) exposes the file
     system SOURCE from the host system as the read-only (resp.
     writable) file system TARGET within the container. If TARGET is not
     specified, SOURCE is used as the target mount point in the
     container.

     L’exemple ci-dessous crée un REPL Guile dans un conteneur dans
     lequel le répertoire personnel de l’utilisateur est accessible en
     lecture-seule via le répertoire ‘/exchange’ :

          guix environment --container --expose=$HOME=/exchange --ad-hoc guile -- guile

   En plus, ‘guix environment’ prend en charge toutes les options de
construction communes prises en charge par ‘guix build’ (*note Options
de construction communes::) et toutes les options de transformation de
paquets (*note Options de transformation de paquets::).

   ---------- Footnotes ----------

   (1) Users sometimes wrongfully augment environment variables such as
‘PATH’ in their ‘~/.bashrc’ file. As a consequence, when ‘guix
environment’ launches it, Bash may read ‘~/.bashrc’, thereby introducing
“impurities” in these environment variables. It is an error to define
such environment variables in ‘.bashrc’; instead, they should be defined
in ‘.bash_profile’, which is sourced only by log-in shells. *Note
(bash)Bash Startup Files::, for details on Bash start-up files.

   (2) For example, the ‘fontconfig’ package inspects
‘~/.guix-profile/share/fonts’ for additional fonts.


File: guix.fr.info,  Node: Invoquer guix pack,  Next: La chaîne d'outils GCC,  Prev: Invoquer guix environment,  Up: Développement

5.2 Invoquer ‘guix pack’
========================

Parfois vous voulez passer un logiciel à des gens qui n’ont pas (encore
!) la chance d’utiliser Guix. Vous leur diriez bien de lancer ‘guix
package -i QUELQUE CHOSE’ mais ce n’est pas possible dans ce cas. C’est
là que ‘guix pack’ entre en jeu.

     Remarque : Si vous cherchez comment échanger des binaires entre des
     machines où Guix est déjà installé, *note Invoquer guix copy::,
     *note Invoquer guix publish::, et *note Invoquer guix archive::.

   La commande ‘guix pack’ crée un “pack” ou “lot de logiciels” : elle
crée une archive tar ou un autre type d’archive contenant les binaires
pour le logiciel qui vous intéresse ainsi que ses dépendances. L’archive
qui en résulte peut être utilisée sur toutes les machines qui n’ont pas
Guix et les gens peuvent lancer exactement les mêmes binaires que ceux
que vous avez avec Guix. Le pack lui-même est créé d’une manière
reproductible au bit près, pour que n’importe qui puisse vérifier qu’il
contient bien les résultats que vous prétendez proposer.

   Par exemple, pour créer un lot contenant Guile, Emacs, Geiser et
toutes leurs dépendances, vous pouvez lancer :

     $ guix pack guile emacs geiser
     ...
     /gnu/store/...-pack.tar.gz

   Le résultat ici est une archive tar contenant un répertoire
‘/gnu/store’ avec tous les paquets nécessaires. L’archive qui en résulte
contient un “profil” avec les trois paquets qui vous intéressent ; le
profil est le même qui celui qui aurait été créé avec ‘guix package -i’.
C’est ce mécanisme qui est utilisé pour créer les archives tar binaires
indépendantes de Guix (*note Installation binaire::).

   Les utilisateurs de ce pack devraient lancer
‘/gnu/store/...-profile/bin/guile’ pour lancer Guile, ce qui n’est pas
très pratique. Pour éviter cela, vous pouvez créer, disons, un lien
symbolique ‘/opt/gnu/bin’ vers le profil :

     guix pack -S /opt/gnu/bin=bin guile emacs geiser

De cette façon, les utilisateurs peuvent joyeusement taper
‘/opt/gnu/bin/guile’ et profiter.

   What if the recipient of your pack does not have root privileges on
their machine, and thus cannot unpack it in the root file system? In
that case, you will want to use the ‘--relocatable’ option (see below).
This option produces “relocatable binaries”, meaning they they can be
placed anywhere in the file system hierarchy: in the example above,
users can unpack your tarball in their home directory and directly run
‘./opt/gnu/bin/guile’.

   Autrement, vous pouvez produire un pack au format d’image Docker avec
la commande suivante :

     guix pack -f docker -S /bin=bin guile guile-readline

The result is a tarball that can be passed to the ‘docker load’ command,
followed by ‘docker run’:

     docker load < FILE
     docker run -ti guile-guile-readline /bin/guile

where FILE is the image returned by GUIX PACK, and
‘guile-guile-readline’ is its “image tag”. See the Docker documentation
(https://docs.docker.com/engine/reference/commandline/load/) for more
information.

   Autrement, vous pouvez produire une image SquashFS avec la commande
suivante :

     guix pack -f squashfs bash guile emacs geiser

The result is a SquashFS file system image that can either be mounted or
directly be used as a file system container image with the Singularity
container execution environment (https://www.sylabs.io/docs/), using
commands like ‘singularity shell’ or ‘singularity exec’.

   Diverses options en ligne de commande vous permettent de
personnaliser votre pack :

‘--format=FORMAT’
‘-f FORMAT’
     Produire un pack dans le FORMAT donné.

     Les formats disponibles sont :

     ‘tarball’
          C’est le format par défaut. Il produit une archive tar
          contenant tous les binaires et les liens symboliques
          spécifiés.

     ‘docker’
          This produces a tarball that follows the Docker Image
          Specification
          (https://github.com/docker/docker/blob/master/image/spec/v1.2.md).
          The “repository name” as it appears in the output of the
          ‘docker images’ command is computed from package names passed
          on the command line or in the manifest file.

     ‘squashfs’
          Cela produit une image SquashFS contenant tous les binaires et
          liens symboliques spécifiés, ainsi que des points de montages
          vides pour les systèmes de fichiers virtuels comme procfs.

               Remarque : Singularity _requires_ you to provide
               ‘/bin/sh’ in the image. For that reason, ‘guix pack -f
               squashfs’ always implies ‘-S /bin=bin’. Thus, your ‘guix
               pack’ invocation must always start with something like:

                    guix pack -f squashfs bash ...

               If you forget the ‘bash’ (or similar) package,
               ‘singularity run’ and ‘singularity exec’ will fail with
               an unhelpful “no such file or directory” message.

‘--relocatable’
‘-R’
     Produire des “binaires repositionnables” — c.-à-d. des binaires que
     vous pouvez placer n’importe où dans l’arborescence du système de
     fichiers et les lancer à partir de là.

     When this option is passed once, the resulting binaries require
     support for “user namespaces” in the kernel Linux; when passed
     _twice_(1), relocatable binaries fall to back to other techniques
     if user namespaces are unavailable, and essentially work
     anywhere—see below for the implications.

     Par exemple, si vous créez un pack contenant Bash avec :

          guix pack -RR -S /mybin=bin bash

     … vous pouvez copier ce pack sur une machine qui n’a pas Guix et
     depuis votre répertoire personnel en tant qu’utilisateur
     non-privilégié, lancer :

          tar xf pack.tar.gz
          ./mybin/sh

     Dans ce shell, si vous tapez ‘ls /gnu/store’, vous remarquerez que
     ‘/gnu/store’ apparaît et contient toutes les dépendances de ‘bash’,
     même si la machine n’a pas du tout de ‘/gnu/store’ ! C’est sans
     doute la manière la plus simple de déployer du logiciel construit
     avec Guix sur une machine sans Guix.

          Remarque : Par défaut ,les binaires repositionnables
          s’appuient sur les “espaces de noms utilisateurs” du noyau
          Linux, qui permet à des utilisateurs non-privilégiés
          d’effectuer des montages et de changer de racine. Les
          anciennes versions de Linux ne le supportait pas et certaines
          distributions GNU/Linux le désactive.

          To produce relocatable binaries that work even in the absence
          of user namespaces, pass ‘--relocatable’ or ‘-R’ _twice_. In
          that case, binaries will try user namespace support and fall
          back to another “execution engine” if user namespaces are not
          supported. The following execution engines are supported:

          ‘default’
               Try user namespaces and fall back to PRoot if user
               namespaces are not supported (see below).

          ‘performance’
               Try user namespaces and fall back to Fakechroot if user
               namespaces are not supported (see below).

          ‘userns’
               Run the program through user namespaces and abort if they
               are not supported.

          ‘proot’
               Run through PRoot. The PRoot
               (https://proot-me.github.io/) program provides the
               necessary support for file system virtualization. It
               achieves that by using the ‘ptrace’ system call on the
               running program. This approach has the advantage to work
               without requiring special kernel support, but it incurs
               run-time overhead every time a system call is made.

          ‘fakechroot’
               Run through Fakechroot. Fakechroot
               (https://github.com/dex4er/fakechroot/) virtualizes file
               system accesses by intercepting calls to C library
               functions such as ‘open’, ‘stat’, ‘exec’, and so on.
               Unlike PRoot, it incurs very little overhead. However, it
               does not always work: for example, some file system
               accesses made from within the C library are not
               intercepted, and file system accesses made via direct
               syscalls are not intercepted either, leading to erratic
               behavior.

          When running a wrapped program, you can explicitly request one
          of the execution engines listed above by setting the
          ‘GUIX_EXECUTION_ENGINE’ environment variable accordingly.

‘--entry-point=COMMAND’
     Use COMMAND as the “entry point” of the resulting pack, if the pack
     format supports it—currently ‘docker’ and ‘squashfs’ (Singularity)
     support it. COMMAND must be relative to the profile contained in
     the pack.

     The entry point specifies the command that tools like ‘docker run’
     or ‘singularity run’ automatically start by default. For example,
     you can do:

          guix pack -f docker --entry-point=bin/guile guile

     The resulting pack can easily be loaded and ‘docker run’ with no
     extra arguments will spawn ‘bin/guile’:

          docker load -i pack.tar.gz
          docker run IMAGE-ID

‘--expression=EXPR’
‘-e EXPR’
     Considérer le paquet évalué par EXPR.

     This has the same purpose as the same-named option in ‘guix build’
     (*note ‘--expression’ in ‘guix build’: Options de construction
     supplémentaires.).

‘--manifest=FICHIER’
‘-m FICHIER’
     Use the packages contained in the manifest object returned by the
     Scheme code in FILE. This option can be repeated several times, in
     which case the manifests are concatenated.

     Elle a un but similaire à l’option de même nom dans ‘guix package’
     (*note ‘--manifest’: profile-manifest.) et utilise les mêmes
     fichiers manifeste. Ils vous permettent de définir une collection
     de paquets une fois et de l’utiliser aussi bien pour créer des
     profils que pour créer des archives pour des machines qui n’ont pas
     Guix d’installé. Remarquez que vous pouvez spécifier _soit_ un
     fichier manifeste, _soit_ une liste de paquet, mais pas les deux.

‘--system=SYSTÈME’
‘-s SYSTÈME’
     Tenter de construire pour le SYSTÈME — p. ex. ‘i686-linux’ — plutôt
     que pour le type de système de l’hôte de construction.

‘--target=TRIPLET’
     Cross-build for TRIPLET, which must be a valid GNU triplet, such as
     ‘"aarch64-linux-gnu"’ (*note GNU configuration triplets:
     (autoconf)Specifying target triplets.).

‘--compression=OUTIL’
‘-C OUTIL’
     Compresser l’archive résultante avec OUTIL — l’un des outils parmi
     ‘bzip2’, ‘xz’, ‘lzip’ ou ‘none’ pour aucune compression.

‘--symlink=SPEC’
‘-S SPEC’
     Ajouter les liens symboliques spécifiés par SPEC dans le pack.
     Cette option peut apparaître plusieurs fois.

     SPEC a la forme ‘SOURCE=CIBLE’, où SOURCE est le lien symbolique
     qui sera créé et CIBLE est la cible du lien.

     Par exemple, ‘-S /opt/gnu/bin=bin’ crée un lien symbolique
     ‘/opt/gnu/bin’ qui pointe vers le sous-répertoire ‘bin’ du profil.

‘--save-provenance’
     Sauvegarder les informations de provenance des paquets passés sur
     la ligne de commande. Les informations de provenance contiennent
     l’URL et le commit des canaux utilisés (*note Canaux::).

     Les informations de provenance sont sauvegardées dans le fichier
     ‘/gnu/store/...-profile/manifest’ du pack, avec les métadonnées de
     paquets habituelles — le nom et la version de chaque paquet, leurs
     entrées propagées, etc. Ce sont des informations utiles pour le
     destinataire du pack, qui sait alors comment le pack a
     (normalement) été obtenu.

     Cette option n’est pas activée par défaut car, comme l’horodatage,
     les informations de provenance ne contribuent en rien au processus
     de construction. En d’autres termes, il y a une infinité d’URL et
     d’ID de commit qui permettent d’obtenir le même pack. Enregistrer
     de telles métadonnées « silencieuses » dans la sortie casse donc
     éventuellement la propriété de reproductibilité au bit près.

‘--root=FICHIER’
‘-r FICHIER’
     Make FILE a symlink to the resulting pack, and register it as a
     garbage collector root.

‘--localstatedir’
‘--profile-name=NOM’
     Inclus le « répertoire d’état local », ‘/var/guix’, dans le lot qui
     en résulte, et notamment le profil
     ‘/var/guix/profiles/per-user/root/NOM’ — par défaut NOM est
     ‘guix-profile’, ce qui correspond à ‘~root/.guix-profile’.

     ‘/var/guix’ contient la base de données du dépôt (*note Le dépôt::)
     ainsi que les racines du ramasse-miettes (*note Invoquer guix
     gc::). Le fournir dans le pack signifie que le dépôt et « complet »
     et gérable par Guix ; ne pas le fournir dans le pack signifie que
     le dépôt est « mort » : aucun élément ne peut être ajouté ni enlevé
     après l’extraction du pack.

     Un cas d’utilisation est l’archive binaire indépendante de Guix
     (*note Installation binaire::).

‘--derivation’
‘-d’
     Print the name of the derivation that builds the pack.

‘--bootstrap’
     Utiliser les programmes d’amorçage pour construire le pack. Cette
     option n’est utile que pour les personnes qui développent Guix.

   En plus, ‘guix pack’ supporte toutes les options de construction
communes (*note Options de construction communes::) et toutes les
options de transformation de paquets (*note Options de transformation de
paquets::).

   ---------- Footnotes ----------

   (1) Here’s a trick to memorize it: ‘-RR’, which adds PRoot support,
can be thought of as the abbreviation of “Really Relocatable”. Neat,
isn’t it?


File: guix.fr.info,  Node: La chaîne d'outils GCC,  Prev: Invoquer guix pack,  Up: Développement

5.3 La chaîne d’outils GCC
==========================

If you need a complete toolchain for compiling and linking C or C++
source code, use the ‘gcc-toolchain’ package. This package provides a
complete GCC toolchain for C/C++ development, including GCC itself, the
GNU C Library (headers and binaries, plus debugging symbols in the
‘debug’ output), Binutils, and a linker wrapper.

   The wrapper’s purpose is to inspect the ‘-L’ and ‘-l’ switches passed
to the linker, add corresponding ‘-rpath’ arguments, and invoke the
actual linker with this new set of arguments. You can instruct the
wrapper to refuse to link against libraries not in the store by setting
the ‘GUIX_LD_WRAPPER_ALLOW_IMPURITIES’ environment variable to ‘no’.

   The package ‘gfortran-toolchain’ provides a complete GCC toolchain
for Fortran development. For other languages, please use ‘guix search
gcc toolchain’ (*note Invoking guix package: guix-search.).


File: guix.fr.info,  Node: Interface de programmation,  Next: Utilitaires,  Prev: Développement,  Up: Top

6 Interface de programmation
****************************

GNU Guix fournit diverses interface de programmation Scheme (API) qui
pour définir, construire et faire des requêtes sur des paquets. La
première interface permet aux utilisateurs d’écrire des définitions de
paquets de haut-niveau. Ces définitions se réfèrent à des concepts de
création de paquets familiers, comme le nom et la version du paquet, son
système de construction et ses dépendances. Ces définitions peuvent
ensuite être transformées en actions concrètes lors de la construction.

   Les actions de construction sont effectuées par le démon Guix, pour
le compte des utilisateurs. Dans un environnement standard, le démon
possède les droits en écriture sur le dépôt — le répertoire ‘/gnu/store’
— mais pas les utilisateurs. La configuration recommandée permet aussi
au démon d’effectuer la construction dans des chroots, avec un
utilisateur de construction spécifique pour minimiser les interférences
avec le reste du système.

   Il y a des API de plus bas niveau pour interagir avec le démon et le
dépôt. Pour demander au démon d’effectuer une action de construction,
les utilisateurs lui donnent en fait une “dérivation”. Une dérivation
est une représentation à bas-niveau des actions de construction à
entreprendre et l’environnement dans lequel elles devraient avoir lieu —
les dérivations sont aux définitions de paquets ce que l’assembleur est
aux programmes C. Le terme de « dérivation » vient du fait que les
résultats de la construction en _dérivent_.

   Ce chapitre décrit toutes ces API tour à tour, à partir des
définitions de paquets à haut-niveau.

* Menu:

* Modules de paquets::       Les paquets du point de vu du programmeur.
* Définition des paquets::  Définir de nouveaux paquets.
* Systèmes de construction::  Spécifier comment construire les paquets.
* Le dépôt::               Manipuler le dépôt de paquets.
* Dérivations::             Interface de bas-niveau avec les dérivations
                               de paquets.
* La monade du dépôt::     Interface purement fonctionnelle avec le
                               dépôt.
* G-Expressions::            Manipuler les expressions de construction.
* Invoquer guix repl::       S’amuser avec Guix de manière interactive.


File: guix.fr.info,  Node: Modules de paquets,  Next: Définition des paquets,  Up: Interface de programmation

6.1 Modules de paquets
======================

D’un point de vue programmatique, les définitions de paquets de la
distribution GNU sont fournies par des modules Guile dans l’espace de
noms ‘(gnu packages ...)’(1) (*note Guile modules: (guile)Modules.). Par
exemple, le module ‘(gnu packages emacs)’ exporte une variable nommée
‘emacs’, qui est liée à un objet ‘<package>’ (*note Définition des
paquets::).

   L’espace de nom ‘(gnu packages ...)’ est automatiquement scanné par
les outils en ligne de commande. Par exemple, lorsque vous lancez ‘guix
install emacs’, tous les modules ‘(gnu packages ...)’ sont scannés
jusqu’à en trouver un qui exporte un objet de paquet dont le nom est
‘emacs’. Cette capacité à chercher des paquets est implémentée dans le
module ‘(gnu packages)’.

   Users can store package definitions in modules with different
names—e.g., ‘(my-packages emacs)’(2). There are two ways to make these
package definitions visible to the user interfaces:

  1. By adding the directory containing your package modules to the
     search path with the ‘-L’ flag of ‘guix package’ and other commands
     (*note Options de construction communes::), or by setting the
     ‘GUIX_PACKAGE_PATH’ environment variable described below.

  2. En définissant un “canal” et en configurant ‘guix pull’ pour qu’il
     l’utilise. Un canal est essentiellement un dépôt Git contenant des
     modules de paquets. *Note Canaux::, pour plus d’informations sur
     comment définir et utiliser des canaux.

   ‘GUIX_PACKAGE_PATH’ works similarly to other search path variables:

 -- Variable d'environnement : GUIX_PACKAGE_PATH
     C’est une liste séparée par des deux-points de répertoires dans
     lesquels trouver des modules de paquets supplémentaires. Les
     répertoires listés dans cette variable sont prioritaires par
     rapport aux paquets de la distribution.

   La distribution est entièrement “bootstrappée” et “auto-contenue” :
chaque paquet est construit uniquement à partir d’autres paquets de la
distribution. La racine de ce graphe de dépendance est un petit ensemble
de “binaires de bootstrap” fournis par le module ‘(gnu packages
bootstrap)’. Pour plus d’informations sur le bootstrap, *note
Bootstrapping::.

   ---------- Footnotes ----------

   (1) Remarquez que les paquets sous l’espace de nom ‘(gnu packages
...)’ ne sont pas nécessairement des « paquets GNU ». Le nom de ce
module suit la convention de nommage usuelle de Guile : ‘gnu’ signifie
que ces modules sont distribués dans le système GNU, et ‘packages’
identifie les modules qui définissent les paquets.

   (2) Note that the file name and module name must match. For instance,
the ‘(my-packages emacs)’ module must be stored in a
‘my-packages/emacs.scm’ file relative to the load path specified with
‘--load-path’ or ‘GUIX_PACKAGE_PATH’. *Note (guile)Modules and the File
System::, for details.


File: guix.fr.info,  Node: Définition des paquets,  Next: Systèmes de construction,  Prev: Modules de paquets,  Up: Interface de programmation

6.2 Définition des paquets
==========================

L’interface de haut-niveau pour les définitions de paquets est
implémentée dans les modules ‘(guix packages)’ et ‘(guix build-system)’.
Par exemple, la définition du paquet, ou la “recette”, du paquet GNU
Hello ressemble à cela :

     (define-module (gnu packages hello)
       #:use-module (guix packages)
       #:use-module (guix download)
       #:use-module (guix build-system gnu)
       #:use-module (guix licenses)
       #:use-module (gnu packages gawk))

     (define-public hello
       (package
         (name "hello")
         (version "2.10")
         (source (origin
                   (method url-fetch)
                   (uri (string-append "mirror://gnu/hello/hello-" version
                                       ".tar.gz"))
                   (sha256
                    (base32
                     "0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i"))))
         (build-system gnu-build-system)
         (arguments '(#:configure-flags '("--enable-silent-rules")))
         (inputs `(("gawk" ,gawk)))
         (synopsis "Hello, GNU world: An example GNU package")
         (description "Guess what GNU Hello prints!")
         (home-page "https://www.gnu.org/software/hello/")
         (license gpl3+)))

Sans être un expert Scheme, le lecteur peut comprendre la signification
des différents champs présents. Cette expression lie la variable ‘hello’
à un objet ‘<package>’, qui est essentiellement un enregistrement (*note
Scheme records: (guile)SRFI-9.). On peut inspecter cet objet de paquet
avec les procédures qui se trouvent dans le module ‘(guix packages)’ ;
par exemple, ‘(package-name hello)’ renvoie — oh surprise ! — ‘"hello"’.

   Avec un peu de chance, vous pourrez importer tout ou partie de la
définition du paquet qui vous intéresse depuis un autre répertoire avec
la commande ‘guix import’ (*note Invoquer guix import::).

   Dans l’exemple précédent, HELLO est défini dans un module à part,
‘(gnu packages hello)’. Techniquement, cela n’est pas strictement
nécessaire, mais c’est pratique : tous les paquets définis dans des
modules sous ‘(gnu packages ...)’ sont automatiquement connus des outils
en ligne de commande (*note Modules de paquets::).

   Il y a quelques points à remarquer dans la définition de paquet
précédente :

   • Le champ ‘source’ du paquet est un objet ‘<origin>’ (*note
     Référence des origines::, pour la référence complète). Ici, on
     utilise la méthode ‘url-fetch’ de ‘(guix download)’, ce qui
     signifie que la source est un fichier à télécharger par FTP ou
     HTTP.

     Le préfixe ‘mirror://gnu’ demande à ‘url-fetch’ d’utiliser l’un des
     miroirs GNU définis dans ‘(guix download)’.

     Le champ ‘sha256’ spécifie le hash SHA256 attendu pour le fichier
     téléchargé. Il est requis et permet à Guix de vérifier l’intégrité
     du fichier. La forme ‘(base32 ...)’ introduit a représentation en
     base32 du hash. Vous pouvez obtenir cette information avec ‘guix
     download’ (*note Invoquer guix download::) et ‘guix hash’ (*note
     Invoquer guix hash::).

     Lorsque cela est requis, la forme ‘origin’ peut aussi avec un champ
     ‘patches’ qui liste les correctifs à appliquer et un champ
     ‘snippet’ qui donne une expression Scheme pour modifier le code
     source.

   • Le champ ‘build-system’ spécifie la procédure pour construire le
     paquet (*note Systèmes de construction::). Ici, GNU-BUILD-SYSTEM
     représente le système de construction GNU familier, où les paquets
     peuvent être configurés, construits et installés avec la séquence
     ‘./configure && make && make check && make install’ habituelle.

   • The ‘arguments’ field specifies options for the build system (*note
     Systèmes de construction::). Here it is interpreted by
     GNU-BUILD-SYSTEM as a request run ‘configure’ with the
     ‘--enable-silent-rules’ flag.

     Que sont ces apostrophes (‘'’) ? C’est de la syntaxe Scheme pour
     introduire une liste ; ‘'’ est synonyme de la fonction ‘quote’.
     *Note quoting: (guile)Expression Syntax, pour des détails. Ice la
     valeur du champ ‘arguments’ est une liste d’arguments passés au
     système de construction plus tard, comme avec ‘apply’ (*note
     ‘apply’: (guile)Fly Evaluation.).

     La séquence dièse-deux-points (‘#:’) définie un “mot-clef” Scheme
     (*note (guile)Keywords::), et ‘#:configure-flags’ est un mot-clef
     utilisé pour passer un argument au système de construction (*note
     (guile)Coding With Keywords::).

   • Le champ ‘inputs’ spécifie les entrées du processus de construction
     — c.-à-d. les dépendances à la construction ou à l’exécution du
     paquet. Ici on définie une entrée nommée ‘"gawk"’ dont la valeur
     est la variable GAWK ; GAWK est elle-même liée à un objet
     ‘<package>’.

     De nouveau, ‘`’ (un accent grave, synonyme de la fonction
     ‘quasiquote’) nous permet d’introduire une liste littérale dans le
     champ ‘inputs’, tandis que ‘,’ (une virgule, synonyme de la
     fonction ‘unquote’) nous permet d’insérer une valeur dans cette
     liste (*note unquote: (guile)Expression Syntax.).

     Remarquez que GCC, Coreutils, Bash et les autres outils essentiels
     n’ont pas besoin d’être spécifiés en tant qu’entrées ici. À la
     place, le GNU-BUILD-SYSTEM est en charge de s’assurer qu’ils sont
     présents (*note Systèmes de construction::).

     Cependant, toutes les autres dépendances doivent être spécifiées
     dans le champ ‘inputs’. Toute dépendance qui ne serait pas
     spécifiée ici sera simplement indisponible pour le processus de
     construction, ce qui peut mener à un échec de la construction.

   *Note Référence des paquets::, pour une description complète des
champs possibles.

   Lorsqu’une définition de paquet est en place, le paquet peut enfin
être construit avec l’outil en ligne de commande ‘guix build’ (*note
Invoquer guix build::), pour résoudre les échecs de construction que
vous pourriez rencontrer (*note Débogage des échecs de construction::).
Vous pouvez aisément revenir à la définition du paquet avec la commande
‘guix edit’ (*note Invoquer guix edit::). *Note Consignes
d'empaquetage::, pour plus d’informations sur la manière de tester des
définitions de paquets et *note Invoquer guix lint::, pour des
informations sur la manière de vérifier que la définition respecte les
conventions de style. Enfin, *note Canaux:: pour des informations sur la
manière d’étendre la distribution en ajoutant vos propres définitions de
paquets dans un « canal ».

   Finalement, la mise à jour de la définition du paquet à une nouvelle
version amont peut en partie s’automatiser avec la commande ‘guix
refresh’ (*note Invoquer guix refresh::).

   Behind the scenes, a derivation corresponding to the ‘<package>’
object is first computed by the ‘package-derivation’ procedure. That
derivation is stored in a ‘.drv’ file under ‘/gnu/store’. The build
actions it prescribes may then be realized by using the
‘build-derivations’ procedure (*note Le dépôt::).

 -- Procédure Scheme : package-derivation STORE PACKAGE [SYSTEM]
     Renvoie l’objet ‘<derivation>’ du PAQUET pour le SYSTÈME (*note
     Dérivations::).

     PAQUET doit être un objet ‘<package>’ valide et SYSTÈME une chaîne
     indiquant le type de système cible — p.ex. ‘"x86_64-linux"’ pour un
     système GNU x86_64 basé sur Linux. DÉPÔT doit être une connexion au
     démon, qui opère sur les dépôt (*note Le dépôt::).

De manière identique, il est possible de calculer une dérivation qui
effectue une compilation croisée d’un paquet pour un autre système :

 -- Procédure Scheme : package-cross-derivation STORE PAQUET CIBLE
          [SYSTÈME] renvoie l'objet ‘<derivation>’
     du PAQUET construit depuis SYSTÈME pour CIBLE.

     TARGET must be a valid GNU triplet denoting the target hardware and
     operating system, such as ‘"aarch64-linux-gnu"’ (*note
     (autoconf)Specifying Target Triplets::).

   On peut manipuler les paquets de manière arbitraire. Une
transformation utile est par exemple la “réécriture d’entrées” où
l’arbre des dépendances d’un paquet est réécrit en replaçant des entrées
spécifiques par d’autres :

 -- Procédure Scheme : package-input-rewriting REPLACEMENTS
          [NOM-RÉÉCRIT] Renvoie une procédure qui, lorsqu'on lui donne
          un
     paquet, remplace des dépendances directes et indirectes (mais pas
     ses entrées implicites) en fonction de REMPLACEMENTS. REMPLACEMENTS
     est une liste de paires de paquets ; le premier élément de chaque
     pair est le paquet à remplacer, le second son remplaçant.

     De manière facultative, NOM-RÉÉCRIT est une procédure à un argument
     qui prend le nom d’un paquet et renvoie son nouveau nom après
     l’avoir réécrit.

Regardez cet exemple :

     (define libressl-instead-of-openssl
       ;; Cette procédure remplace OPENSSL par LIBRESSL,
       ;; récursivement.
       (package-input-rewriting `((,openssl . ,libressl))))

     (define git-with-libressl
       (libressl-instead-of-openssl git))

Ici nous définissons d’abord une procédure de réécriture qui remplace
OPENSSL par LIBRESSL. Ensuite nous l’utilisons pour définir une
“variante” du paquet GIT qui utilise LIBRESSL plutôt que OPENSSL. cela
est exactement ce que l’option en ligne de commande ‘--with-input’ fait
(*note ‘--with-input’: Options de transformation de paquets.).

   La variante suivante de ‘package-input-rewriting’ peut repérer les
paquets à remplacer par nom à la place de leur identité.

 -- Procédure Scheme : package-input-rewriting/spec REMPLACEMENTS
     Renvoie une procédure qui, étant donné un paquet, applique les
     REMPLACEMENTS à tous le graphe du paquet (en dehors des entrées
     implicites). REMPLACEMENTS est une liste de paires de
     spécifications et de procédures ; chaque spécification est une
     spécification de paquet comme ‘"gcc"’ ou ‘"guile@2"’, et chaque
     procédure prend un paquet correspondant et renvoie un remplaçant
     pour ce paquet.

   L’exemple ci-dessus pourrait être réécrit de cette manière :

     (define libressl-instead-of-openssl
       ;; Remplace tous les paquets nommés « openssl » par LibreSSL.
       (package-input-rewriting/spec `(("openssl" . ,(const libressl)))))

   Le différence clef est que, cette fois-ci, les paquets correspondent
à la spécification et non à l’identité. En d’autres termes, tout paquet
dans le graphe qui est appelé ‘openssl’ sera remplacé.

   Une procédure plus générique pour réécrire un graphe de dépendance
d’un paquet est ‘package-mapping’ : elle supporte n’importe quel
changement dans les nœuds du graphe.

 -- Procédure Scheme : package-mapping PROC [CUT?]
     Renvoie une procédure qui, avec un paquet, applique PROC sur tous
     les paquets dont il dépend et renvoie le paquet qui en résulte. La
     procédure arrête la récursion là où CUT? renvoie vrai pour un
     paquet donné.

* Menu:

* Référence des paquets::  Le type de donnée des paquets.
* Référence des origines::  Le type de données d’origine.


File: guix.fr.info,  Node: Référence des paquets,  Next: Référence des origines,  Up: Définition des paquets

6.2.1 Référence de ‘package’
----------------------------

Cette section résume toutes les options disponibles dans les
déclarations ‘package’ (*note Définition des paquets::).

 -- Type de données : package
     C’est le type de donnée représentant une recette de paquets.

     ‘name’
          Le nom du paquet, comme une chaîne de caractères.

     ‘version’
          La version du paquet, comme une chaîne de caractères.

     ‘source’
          Un objet qui indique comment le code source du paquet devrait
          être récupéré. La plupart du temps, c’est un objet ‘origin’
          qui indique un fichier récupéré depuis internet (*note
          Référence des origines::). Il peut aussi s’agir de tout autre
          objet “simili-fichier” comme un ‘local-file’ qui indique un
          fichier du système de fichier local (*note ‘local-file’:
          G-Expressions.).

     ‘build-system’
          Le système de construction qui devrait être utilisé pour
          construire le paquet (*note Systèmes de construction::).

     ‘arguments’ (par défaut : ‘'()’)
          Les arguments à passer au système de construction. C’est une
          liste qui contient typiquement une séquence de paires de
          clefs-valeurs.

     ‘inputs’ (par défaut : ‘'()’)
     ‘native-inputs’ (par défaut : ‘'()’)
     ‘propagated-inputs’ (par défaut : ‘'()’)
          Ces champs listent les dépendances du paquet. Chacune est une
          liste de tuples, où chaque tuple a une étiquette pour une
          entrée (une chaîne de caractères) comme premier élément, un
          paquet, une origine ou une dérivation comme deuxième élément
          et éventuellement le nom d’une sortie à utiliser qui est
          ‘"out"’ par défaut (*note Des paquets avec plusieurs
          résultats::, pour plus d’informations sur les sorties des
          paquets). Par exemple, la liste suivante spécifie trois
          entrées :

               `(("libffi" ,libffi)
                 ("libunistring" ,libunistring)
                 ("glib:bin" ,glib "bin"))  ;la sortie "bin" de Glib

          La distinction entre ‘native-inputs’ et ‘inputs’ est
          nécessaire lorsqu’on considère la compilation croisée. Lors
          d’une compilation croisée, les dépendances listées dans
          ‘inputs’ sont construites pour l’architecture _cible_ ;
          inversement, les dépendances listées dans ‘native-inputs’ sont
          construites pour l’architecture de la machine de
          _construction_.

          ‘native-inputs’ est typiquement utilisé pour lister les outils
          requis à la construction mais pas à l’exécution, comme
          Autoconf, Automake, pkg-config, Gettext ou Bison. ‘guix lint’
          peut rapporter des erreurs de ce type (*note Invoquer guix
          lint::).

          Lastly, ‘propagated-inputs’ is similar to ‘inputs’, but the
          specified packages will be automatically installed alongside
          the package they belong to (*note ‘guix package’:
          package-cmd-propagated-inputs, for information on how ‘guix
          package’ deals with propagated inputs).

          Par exemple cela est nécessaire lorsque des bibliothèques
          C/C++ ont besoin d’en-têtes d’une autre bibliothèque pour être
          compilé ou lorsqu’un fichier pkg-config se rapporte à un autre
          via son champ ‘Requires’.

          Un autre exemple où ‘propagated-inputs’ est utile est pour les
          langages auxquels il manque un moyen de retenir le chemin de
          recherche comme c’est le cas du ‘RUNPATH’ des fichiers ELF ;
          cela comprend Guile, Python, Perl et plus. Pour s’assurer que
          les bibliothèques écrites dans ces langages peuvent trouver le
          code des bibliothèques dont elles dépendent à l’exécution, les
          dépendances à l’exécution doivent être listées dans
          ‘propagated-inputs’ plutôt que ‘inputs’.

     ‘outputs’ (par défaut : ‘'("out")’)
          La liste des noms de sorties du paquet. *Note Des paquets avec
          plusieurs résultats::, pour des exemples typiques
          d’utilisation de sorties supplémentaires.

     ‘native-search-paths’ (par défaut : ‘'()’)
     ‘search-paths’ (par défaut : ‘'()’)
          Une liste d’objets ‘search-path-specification’ décrivant les
          variables d’environnement de recherche de chemins que ce
          paquet utilise.

     ‘replacement’ (par défaut : ‘#f’)
          Ce champ doit être soit ‘#f’ soit un objet de paquet qui sera
          utilisé comme “remplaçant” de ce paquet. *Note grafts: Mises à
          jour de sécurité, pour plus de détails.

     ‘synopsis’
          Une description sur une ligne du paquet.

     ‘description’
          Une description plus détaillée du paquet.

     ‘license’
          La licence du paquet ; une valeur tirée de ‘(guix licenses)’
          ou une liste de ces valeurs.

     ‘home-page’
          L’URL de la page d’accueil du paquet, en tant que chaîne de
          caractères.

     ‘supported-systems’ (default: ‘%supported-systems’)
          La liste des systèmes supportés par le paquet, comme des
          chaînes de caractères de la forme ‘architecture-noyau’, par
          exemple ‘"x86_64-linux"’.

     ‘location’ (par défaut : emplacement de la source de la forme ‘package’)
          L’emplacement de la source du paquet. C’est utile de le
          remplacer lorsqu’on hérite d’un autre paquet, auquel cas ce
          champ n’est pas automatiquement corrigé.

 -- Syntaxe Scheme : this-package
     Lorsque vous l’utilisez dans la _portée lexicale_ du champ d’une
     définition de paquet, cet identifiant est résolu comme étant le
     paquet définit.

     L’exemple ci-dessous montre l’ajout d’un paquet comme entrée native
     de lui-même pour la compilation croisée :

          (package
            (name "guile")
            ;; ...

            ;; Lors de la compilation croisée, Guile par exemple dépend
            ;; d'une version native de lui-même. On l'ajoute ici.
            (native-inputs (if (%current-target-system)
                               `(("self" ,this-package))
                               '())))

     C’est une erreur que de se référer à ‘this-package’ en dehors de la
     définition d’un paquet.


File: guix.fr.info,  Node: Référence des origines,  Prev: Référence des paquets,  Up: Définition des paquets

6.2.2 Référence de ‘origin’
---------------------------

Cette section résume toutes les options disponibles dans le déclarations
‘origin’ (*note Définition des paquets::).

 -- Type de données : origin
     C’est le type de donnée qui représente l’origine d’un code source.

     ‘uri’
          Un objet contenant l’URI de la source. Le type d’objet dépend
          de la ‘method’ (voir plus bas). Par exemple, avec la méthode
          URL-FETCH de ‘(guix download)’, les valeurs valide d’‘uri’
          sont : une URL représentée par une chaîne de caractères, ou
          une liste de chaînes de caractères.

     ‘method’
          Un procédure qui gère l’URI.

          Quelques exemples :

          URL-FETCH de ‘(guix download)’
               télécharge un fichier depuis l’URL HTTP, HTTPS ou FTP
               spécifiée dans le champ ‘uri’ ;

          GIT-FETCH de ‘(guix git-download)’
               clone le dépôt sous contrôle de version Git et récupère
               la révision spécifiée dans le champ ‘uri’ en tant
               qu’objet ‘git-reference’ ; un objet ‘git-reference’
               ressemble à cela :

                    (git-reference
                      (url "https://git.savannah.gnu.org/git/hello.git")
                      (commit "v2.10"))

     ‘sha256’
          A bytevector containing the SHA-256 hash of the source. This
          is equivalent to providing a ‘content-hash’ SHA256 object in
          the ‘hash’ field described below.

     ‘hash’
          The ‘content-hash’ object of the source—see below for how to
          use ‘content-hash’.

          Vous pouvez obtenir cette information avec ‘guix download’
          (*note Invoquer guix download::) ou ‘guix hash’ (*note
          Invoquer guix hash::).

     ‘file-name’ (par défaut : ‘#f’)
          Le nom de fichier à utiliser pour sauvegarder le fichier.
          Lorsqu’elle est à ‘#f’, une valeur par défaut raisonnable est
          utilisée dans la plupart des cas. Dans le cas où la source est
          récupérée depuis une URL, le nom de fichier est celui de
          l’URL. Pour les sources récupérées depuis un outil de contrôle
          de version, il est recommandé de fournir un nom de fichier
          explicitement parce que le nom par défaut n’est pas très
          descriptif.

     ‘patches’ (par défaut : ‘'()’)
          Une liste de noms de fichiers, d’origines ou d’objets
          simili-fichiers (*note file-like objects: G-Expressions.) qui
          pointent vers des correctifs à appliquer sur la source.

          Cette liste de correctifs doit être inconditionnelle. En
          particulier, elle ne peut pas dépendre des valeurs de
          ‘%current-system’ ou ‘%current-target-system’.

     ‘snippet’ (par défaut : ‘#f’)
          Une G-expression (*note G-Expressions::) ou une S-expression
          qui sera lancée dans le répertoire des sources. C’est une
          manière pratique de modifier la source, parfois plus qu’un
          correctif.

     ‘patch-flags’ (par défaut : ‘'("-p1")’)
          Une liste de drapeaux à passer à la commande ‘patch’.

     ‘patch-inputs’ (par défaut : ‘#f’)
          Paquets d’entrées ou dérivations pour le processus de
          correction. Lorsqu’elle est à ‘#f’, l’ensemble d’entrées
          habituellement nécessaire pour appliquer des correctifs est
          fournit, comme GNU Patch.

     ‘modules’ (par défaut : ‘'()’)
          Une liste de modules Guile qui devraient être chargés pendant
          le processus de correction et pendant que le lancement du code
          du champ ‘snippet’.

     ‘patch-guile’ (par défaut : ‘#f’)
          Le paquet Guile à utiliser dans le processus de correction.
          Lorsqu’elle est à ‘#f’, une valeur par défaut raisonnable est
          utilisée.

 -- Data Type : content-hash VALUE [ALGORITHM]
     Construct a content hash object for the given ALGORITHM, and with
     VALUE as its hash value. When ALGORITHM is omitted, assume it is
     ‘sha256’.

     VALUE can be a literal string, in which case it is base32-decoded,
     or it can be a bytevector.

     The following forms are all equivalent:

          (content-hash "05zxkyz9bv3j9h0xyid1rhvh3klhsmrpkf3bcs6frvlgyr2gwilj")
          (content-hash "05zxkyz9bv3j9h0xyid1rhvh3klhsmrpkf3bcs6frvlgyr2gwilj"
                        sha256)
          (content-hash (base32
                         "05zxkyz9bv3j9h0xyid1rhvh3klhsmrpkf3bcs6frvlgyr2gwilj"))
          (content-hash (base64 "kkb+RPaP7uyMZmu4eXPVkM4BN8yhRd8BTHLslb6f/Rc=")
                        sha256)

     Technically, ‘content-hash’ is currently implemented as a macro. It
     performs sanity checks at macro-expansion time, when possible, such
     as ensuring that VALUE has the right size for ALGORITHM.


File: guix.fr.info,  Node: Systèmes de construction,  Next: Le dépôt,  Prev: Définition des paquets,  Up: Interface de programmation

6.3 Systèmes de construction
============================

Chaque définition de paquet définie un “système de construction” et des
arguments pour ce système de construction (*note Définition des
paquets::). Ce champ ‘build-system’ représente la procédure de
construction du paquet, ainsi que des dépendances implicites pour cette
procédure de construction.

   Les systèmes de construction sont des objets ‘<build-system>’.
L’interface pour les créer et les manipuler est fournie par le module
‘(guix build-system)’ et les systèmes de construction eux-mêmes sont
exportés par des modules spécifiques.

   Sous le capot, les systèmes de construction compilent d’abord des
objets paquets en “sacs”. Un “sac” est comme un paquet, mais avec moins
de décoration — en d’autres mots, un sac est une représentation à
bas-niveau d’un paquet, qui inclus toutes les entrées de ce paquet, dont
certaines ont été implicitement ajoutées par le système de construction.
Cette représentation intermédiaire est ensuite compilée en une
dérivation (*note Dérivations::).

   Les systèmes de construction acceptent une liste d’“arguments”
facultatifs. Dans les définitions de paquets, ils sont passés via le
champ ‘arguments’ (*note Définition des paquets::). Ce sont typiquement
des arguments par mot-clef (*note keyword arguments in Guile:
(guile)Optional Arguments.). La valeur de ces arguments est
habituellement évaluée dans la “strate de construction” — c.-à-d. par un
processus Guile lancé par le démon (*note Dérivations::).

   The main build system is ‘gnu-build-system’, which implements the
standard build procedure for GNU and many other packages. It is provided
by the ‘(guix build-system gnu)’ module.

 -- Variable Scheme : gnu-build-system
     ‘gnu-build-system’ represents the GNU Build System, and variants
     thereof (*note configuration and makefile conventions:
     (standards)Configuration.).

     En résumé, les paquets qui l’utilisent sont configurés, construits
     et installés avec la séquence ‘./configure && make && make check &&
     make install’ habituelle. En pratique, des étapes supplémentaires
     sont souvent requises. Toutes ces étapes sont séparées dans des
     “phases” différentes, notamment(1):

     ‘unpack’
          Décompresse l’archive des sources et se déplace dans
          l’arborescence des sources fraîchement extraites. Si la source
          est en fait un répertoire, le copie dans l’arborescence de
          construction et entre dans ce répertoire.

     ‘patch-source-shebangs’
          Corrige les shebangs (‘#!’) rencontrés dans les fichiers pour
          qu’ils se réfèrent aux bons noms de fichiers. Par exemple,
          elle change ‘#!/bin/sh’ en ‘#!/gnu/store/...-bash-4.3/bin/sh’.

     ‘configure’
          Run the ‘configure’ script with a number of default options,
          such as ‘--prefix=/gnu/store/...’, as well as the options
          specified by the ‘#:configure-flags’ argument.

     ‘build’
          Lance ‘make’ avec la liste des drapeaux spécifiés avec
          ‘#:make-flags’. Si l’argument ‘#:parallel-build?’ est vrai
          (par défaut), construit avec ‘make -j’.

     ‘check’
          Lance ‘make check’, ou une autre cible spécifiée par
          ‘#:test-target’, à moins que ‘#:tests? #f’ ne soit passé. Si
          l’argument ‘#:parallel-tests?’ est vrai (par défaut), lance
          ‘make check -j’.

     ‘install’
          Lance ‘make install’ avec les drapeaux listés dans
          ‘#:make-flags’.

     ‘patch-shebangs’
          Corrige les shebangs des fichiers exécutables installés.

     ‘strip’
          Nettoie les symboles de débogage dans les fichiers ELF (à
          moins que ‘#:strip-binaries?’ ne soit faux), les copie dans la
          sortie ‘debug’ lorsqu’elle est disponible (*note Installer les
          fichiers de débogage::).

     The build-side module ‘(guix build gnu-build-system)’ defines
     ‘%standard-phases’ as the default list of build phases.
     ‘%standard-phases’ is a list of symbol/procedure pairs, where the
     procedure implements the actual phase.

     La liste des phases utilisées par un paquet particulier peut être
     modifiée avec le paramètre ‘#:phases’. Par exemple, en passant :

          #:phases (modify-phases %standard-phases (delete 'configure))

     signifie que toutes les procédures décrites plus haut seront
     utilisées, sauf la phase ‘configure’.

     En plus, ce système de construction s’assure que l’environnement «
     standard » pour les paquets GNU est disponible. Cela inclus des
     outils comme GCC, libc, Coreutils, Bash, Make, Diffutils, grep et
     sed (voir le module ‘(guix build-system gnu)’ pour une liste
     complète). Nous les appelons les “entrées implicites” d’un paquet
     parce que la définition du paquet ne les mentionne pas.

   Other ‘<build-system>’ objects are defined to support other
conventions and tools used by free software packages. They inherit most
of ‘gnu-build-system’, and differ mainly in the set of inputs implicitly
added to the build process, and in the list of phases executed. Some of
these build systems are listed below.

 -- Variable Scheme : ant-build-system
     Cette variable est exportée par ‘(guix build-system ant)’. Elle
     implémente la procédure de construction pour les paquets Java qui
     peuvent être construits avec l’outil de construction Ant
     (https://ant.apache.org/).

     Elle ajoute à la fois ‘ant’ et the “kit de développement Java”
     (JDK) fournit par le paquet ‘icedtea’ à l’ensemble des entrées. Des
     paquets différents peuvent être spécifiés avec les paramètres
     ‘#:ant’ et ‘#:jdk’ respectivement.

     Lorsque le paquet d’origine ne fournit pas de fichier de
     construction Ant acceptable, le paramètre ‘#:jar-name’ peut être
     utilisé pour générer un fichier de construction Ant ‘build.xml’
     minimal, avec des tâches pour construire l’archive jar spécifiée.
     Dans ce cas, le paramètre ‘#:source-dir’ peut être utilisé pour
     spécifier le sous-répertoire des sources, par défaut « src ».

     Le paramètre ‘#:main-class’ peut être utilisé avec le fichier de
     construction minimal pour spécifier la classe principale du jar.
     Cela rend le fichier jar exécutable. Le paramètre ‘#:test-include’
     peut être utilisé pour spécifier la liste des tests junits à
     lancer. Il vaut par défaut ‘(list "**/*Test.java")’. Le paramètre
     ‘#:test-exclude’ peut être utilisé pour désactiver certains tests.
     Sa valeur par défaut est ‘(list "**/Abstract*.java")’, parce que
     les classes abstraites ne peuvent pas être utilisées comme des
     tests.

     Le paramètre ‘#:build-target’ peut être utilisé pour spécifier la
     tâche Ant qui devrait être lancée pendant la phase ‘build’. Par
     défaut la tâche « jar » sera lancée.

 -- Variable Scheme : android-ndk-build-system
     Cette variable est exportée par ‘(guix build-system android-ndk)’.
     Elle implémente une procédure de construction pour les paquets du
     NDK Android (native development kit) avec des processus de
     construction spécifiques à Guix.

     The build system assumes that packages install their public
     interface (header) files to the subdirectory ‘include’ of the ‘out’
     output and their libraries to the subdirectory ‘lib’ the ‘out’
     output.

     Il est aussi supposé que l’union de toutes les dépendances d’un
     paquet n’a pas de fichiers en conflit.

     Pour l’instant, la compilation croisée n’est pas supportées — donc
     pour l’instant les bibliothèques et les fichiers d’en-têtes sont
     supposés être des outils de l’hôte.

 -- Variable Scheme : asdf-build-system/source
 -- Variable Scheme : asdf-build-system/sbcl
 -- Variable Scheme : asdf-build-system/ecl

     Ces variables, exportées par ‘(guix build-system asdf)’,
     implémentent les procédures de constructions pour les paquets en
     Common Lisp qui utilisent “ASDF”
     (https://common-lisp.net/project/asdf/). ASDF est un dispositif de
     définition de systèmes pour les programmes et les bibliothèques en
     Common Lisp.

     Le système ‘asdf-build-system/source’ installe les paquets au
     format source qui peuvent être chargés avec n’importe quelle
     implémentation de common lisp, via ASDF. Les autres, comme
     ‘asdf-build-system/sbcl’, installent des binaires au format qu’un
     implémentation particulière comprend. Ces systèmes de constructions
     peuvent aussi être utilisés pour produire des programmes
     exécutables ou des images lisp qui contiennent un ensemble de
     paquets pré-chargés.

     Le système de construction utilise des conventions de nommage. Pour
     les paquets binaires, le nom du paquet devrait être préfixé par
     l’implémentation lisp, comme ‘sbcl-’ pour ‘asdf-build-system/sbcl’.

     En plus, le paquet source correspondant devrait étiquetté avec la
     même convention que les paquets python (voir *note Modules
     python::), avec le préfixe ‘cl-’.

     Pour les paquets binaires, chaque système devrait être défini comme
     un paquet Guix. Si un paquet ‘origine’ contient plusieurs systèmes,
     on peut créer des variantes du paquet pour construire tous les
     systèmes. Les paquets sources, qui utilisent
     ‘asdf-build-system/source’, peuvent contenir plusieurs systèmes.

     Pour créer des programmes exécutables et des images, les procédures
     côté construction ‘build-program’ et ‘build-image’ peuvent être
     utilisées. Elles devraient être appelées dans une phase de
     construction après la phase ‘create-symlinks’ pour que le système
     qui vient d’être construit puisse être utilisé dans l’image créée.
     ‘build-program’ requiert une liste d’expressions Common Lisp dans
     l’argument ‘#:entry-program’.

     If the system is not defined within its own ‘.asd’ file of the same
     name, then the ‘#:asd-file’ parameter should be used to specify
     which file the system is defined in. Furthermore, if the package
     defines a system for its tests in a separate file, it will be
     loaded before the tests are run if it is specified by the
     ‘#:test-asd-file’ parameter. If it is not set, the files
     ‘<system>-tests.asd’, ‘<system>-test.asd’, ‘tests.asd’, and
     ‘test.asd’ will be tried if they exist.

     Si pour quelque raison que ce soit le paquet doit être nommé d’une
     manière différente de ce que la convention de nommage suggère, le
     paramètre ‘#:asd-system-name’ peut être utilisé pour spécifier le
     nom du système.

 -- Variable Scheme : cargo-build-system
     Cette variable est exportée par ‘(guix build-system cargo)’. Elle
     supporte les construction de paquets avec Cargo, le système de
     construction du langage de programmation Rust
     (https://www.rust-lang.org).

     It adds ‘rustc’ and ‘cargo’ to the set of inputs. A different Rust
     package can be specified with the ‘#:rust’ parameter.

     Regular cargo dependencies should be added to the package
     definition via the ‘#:cargo-inputs’ parameter as a list of name and
     spec pairs, where the spec can be a package or a source definition.
     Note that the spec must evaluate to a path to a gzipped tarball
     which includes a ‘Cargo.toml’ file at its root, or it will be
     ignored. Similarly, cargo dev-dependencies should be added to the
     package definition via the ‘#:cargo-development-inputs’ parameter.

     In its ‘configure’ phase, this build system will make any source
     inputs specified in the ‘#:cargo-inputs’ and
     ‘#:cargo-development-inputs’ parameters available to cargo. It will
     also remove an included ‘Cargo.lock’ file to be recreated by
     ‘cargo’ during the ‘build’ phase. The ‘install’ phase installs any
     crate the binaries if they are defined by the crate.

 -- Scheme Variable : copy-build-system
     This variable is exported by ‘(guix build-system copy)’. It
     supports builds of simple packages that don’t require much
     compiling, mostly just moving files around.

     It adds much of the ‘gnu-build-system’ packages to the set of
     inputs. Because of this, the ‘copy-build-system’ does not require
     all the boilerplate code often needed for the
     ‘trivial-build-system’.

     To further simplify the file installation process, an
     ‘#:install-plan’ argument is exposed to let the packager specify
     which files go where. The install plan is a list of ‘(SOURCE TARGET
     [FILTERS])’. FILTERS are optional.

        • When SOURCE matches a file or directory without trailing
          slash, install it to TARGET.
             • If TARGET has a trailing slash, install SOURCE basename
               beneath TARGET.
             • Otherwise install SOURCE as TARGET.

        • When SOURCE is a directory with a trailing slash, or when
          FILTERS are used, the trailing slash of TARGET is implied with
          the same meaning as above.
             • Without FILTERS, install the full SOURCE _content_ to
               TARGET.
             • With FILTERS among ‘#:include’, ‘#:include-regexp’,
               ‘#:exclude’, ‘#:exclude-regexp’, only select files are
               installed depending on the filters. Each filters is
               specified by a list of strings.
                  • With ‘#:include’, install all the files which the
                    path suffix matches at least one of the elements in
                    the given list.
                  • With ‘#:include-regexp’, install all the files which
                    the subpaths match at least one of the regular
                    expressions in the given list.
                  • The ‘#:exclude’ and ‘#:exclude-regexp’ filters are
                    the complement of their inclusion counterpart.
                    Without ‘#:include’ flags, install all files but
                    those matching the exclusion filters. If both
                    inclusions and exclusions are specified, the
                    exclusions are done on top of the inclusions.
          In all cases, the paths relative to SOURCE are preserved
          within TARGET.

     Examples:

        • ‘("foo/bar" "share/my-app/")’: Install ‘bar’ to
          ‘share/my-app/bar’.
        • ‘("foo/bar" "share/my-app/baz")’: Install ‘bar’ to
          ‘share/my-app/baz’.
        • ‘("foo/" "share/my-app")’: Install the content of ‘foo’ inside
          ‘share/my-app’, e.g., install ‘foo/sub/file’ to
          ‘share/my-app/sub/file’.
        • ‘("foo/" "share/my-app" #:include ("sub/file"))’: Install only
          ‘foo/sub/file’ to ‘share/my-app/sub/file’.
        • ‘("foo/sub" "share/my-app" #:include ("file"))’: Install
          ‘foo/sub/file’ to ‘share/my-app/file’.

 -- Variable Scheme : clojure-build-system
     Cette variable est exportée par ‘(guix build-system clojure)’. Elle
     implémente une procédure de construction des paquets simple qui
     utilise le bon vieux ‘compile’ de Clojure. La compilation croisée
     n’est pas encore supportée.

     Elle ajoute ‘clojure’, ‘icedtea’ et ‘zip’ à l’ensemble des entrées.
     Des paquets différents peuvent être spécifiés avec les paramètres
     ‘#:clojure’, ‘#:jdk’ et ‘#:zip’.

     Une liste de répertoires sources, de répertoires de tests et de
     noms de jar peuvent être spécifiés avec les paramètres
     ‘#:source-dirs’, ‘#:test-dirs’ et ‘#:jar-names’. Le répertoire de
     construction est la classe principale peuvent être spécifiés avec
     les paramètres ‘#:compile-dir’ et ‘#:main-class’. Les autres
     paramètres sont documentés plus bas.

     This build system is an extension of ‘ant-build-system’, but with
     the following phases changed:

     ‘build’
          Cette phase appelle ‘compile’ en Clojure pour compiler les
          fichiers sources et lance ‘jar’ pour créer les fichiers jar à
          partir des fichiers sources et des fichiers compilés en
          suivant la liste d’inclusion et d’exclusion spécifiées dans
          ‘#:aot-include’ et ‘#:aot-exclude’. La liste d’exclusion a la
          priorité sur la liste d’inclusion. Ces listes consistent en
          des symboles représentant des bibliothèque Clojure ou le mot
          clef spécial ‘#:all’, représentant toutes les bibliothèques
          Clojure trouvées dans les répertoires des sources. Le
          paramètre ‘#:omit-source?’ décide si les sources devraient
          être incluses dans les fichiers jar.

     ‘check’
          Cette phase lance les tests en suivant les liste d’inclusion
          et d’exclusion spécifiées dans ‘#:test-include’ et
          ‘#:test-exclude’. Leur signification est analogue à celle de
          ‘#:aot-include’ et ‘#:aot-exclude’, sauf que le mot-clef
          spécial ‘#:all’ signifie maintenant toutes les bibliothèques
          Clojure trouvées dans les répertoires de tests. Le paramètre
          ‘#:tests?’ décide si les tests devraient être lancés.

     ‘install’
          Cette phase installe tous les fichiers jar précédemment
          construits.

     En dehors de cela, le système de construction contient aussi la
     phase suivante :

     ‘install-doc’
          This phase installs all top-level files with base name
          matching ‘%doc-regex’. A different regex can be specified with
          the ‘#:doc-regex’ parameter. All files (recursively) inside
          the documentation directories specified in ‘#:doc-dirs’ are
          installed as well.

 -- Variable Scheme : cmake-build-system
     Cette variable est exportée par ‘(guix build-system cmake)’. Elle
     implémente la procédure de construction des paquets qui utilisent
     l’outil de construction CMake (https://www.cmake.org).

     Elle ajoute automatiquement le paquet ‘cmake’ à l’ensemble des
     entrées. Le paquet utilisé peut être spécifié par le paramètre
     ‘#:cmake’.

     Le paramètre ‘#:configure-flags’ est pris comme une liste de
     drapeaux à passer à la commande ‘cmake’. Le paramètre
     ‘#:build-type’ spécifie en termes abstrait les drapeaux passés au
     compilateur ; sa valeur par défaut est ‘"RelWithDebInfo"’ (ce qui
     veut dire « mode public avec les informations de débogage » en plus
     court), ce qui signifie en gros que le code sera compilé avec ‘-O2
     -g’ comme pour les paquets autoconf par défaut.

 -- Variable Scheme : dune-build-system
     Cette variable est exportée par ‘(guix build-system dune)’. Elle
     prend en charge la construction des paquets qui utilisent Dune
     (https://dune.build/), un outil de construction pour le langage de
     programmation OCaml. Elle est implémentée comme une extension de
     ‘ocaml-build-system’ décrit plus bas. En tant que tel, les
     paramètres ‘#:ocaml’ et ‘#:findlib’ peuvent être passés à ce
     système de construction.

     Elle ajoute automatiquement le paquet ‘dune’ à l’ensemble des
     entrées. Le paquet utilisé peut être spécifié par le paramètre
     ‘#:dune’.

     Il n’y a pas de phase ‘configure’ parce que les paquets dune n’ont
     habituellement pas besoin d’être configurés. Le paramètre
     ‘#:build-flags’ est interprété comme une liste de drapeaux pour la
     commande ‘dune’ pendant la construction.

     Le paramètre ‘#:jbuild?’ peut être passé pour utiliser la commande
     ‘jbuild’ à la place de la commande ‘dune’ plus récente pour la
     construction d’un paquet. Sa valeur par défaut est ‘#f’.

     Le paramètre ‘#:package’ peut être passé pour spécifié un nom de
     paquet, ce qui est utile lorsqu’un paquet contient plusieurs
     paquets et que vous voulez n’en construire qu’un. C’est équivalent
     à passer l’argument ‘-p’ à ‘dune’.

 -- Variable Scheme : go-build-system
     Cette variable est exportée par ‘(guix build-system go)’. Elle
     implémente la procédure pour les paquets Go utilisant les
     mécanismes de construction Go
     (https://golang.org/cmd/go/#hdr-Compile_packages_and_dependencies)
     standard.

     L’utilisateur doit fournir une valeur à la clef ‘#:import-path’ et,
     dans certains cas, ‘#:unpack-path’. Le chemin d’import
     (https://golang.org/doc/code.html#ImportPaths) correspond au chemin
     dans le système de fichiers attendu par le script de construction
     du paquet et les paquets qui s’y réfèrent et fournit une manière
     unique de se référer à un paquet Go. Il est typiquement basé sur
     une combinaison de l’URI du code source du paquet et d’une
     structure hiérarchique du système de fichier. Dans certains cas,
     vous devrez extraire le code source du paquet dans une structure de
     répertoires différente que celle indiquée par le chemin d’import et
     ‘#:unpack-path’ devrait être utilisé dans ces cas-là.

     Les paquets qui fournissent des bibliothèques Go devraient
     installer leur code source dans la sortie du paquet. La clef
     ‘#:install-source?’, qui vaut ‘#t’ par défaut, contrôle
     l’installation du code source. Elle peut être mise à ‘#f’ pour les
     paquets qui ne fournissent que des fichiers exécutables.

 -- Variable Scheme : glib-or-gtk-build-system
     Cette variable est exportée par ‘(guix build-system glib-or-gtk)’.
     Elle est conçue pour être utilisée par des paquets qui utilisent
     GLib ou GTK+.

     This build system adds the following two phases to the ones defined
     by ‘gnu-build-system’:

     ‘glib-or-gtk-wrap’
          The phase ‘glib-or-gtk-wrap’ ensures that programs in ‘bin/’
          are able to find GLib “schemas” and GTK+ modules
          (https://developer.gnome.org/gtk3/stable/gtk-running.html).
          This is achieved by wrapping the programs in launch scripts
          that appropriately set the ‘XDG_DATA_DIRS’ and ‘GTK_PATH’
          environment variables.

          Il est possible d’exclure des sorties spécifiques de ce
          processus d’enveloppage en listant leur nom dans le paramètre
          ‘#:glib-or-gtk-wrap-excluded-outputs’. C’est utile lorsqu’une
          sortie est connue pour ne pas contenir de binaires GLib ou
          GTK+, et où l’enveloppe ajouterait une dépendance inutile vers
          GLib et GTK+.

     ‘glib-or-gtk-compile-schemas’
          La phase ‘glib-or-gtk-compile-schemas’ s’assure que tous les
          schémas GSettings
          (https://developer.gnome.org/gio/stable/glib-compile-schemas.html)
          de GLib sont compilés. La compilation est effectuée par le
          programme ‘glib-compile-schemas’. Il est fournit par le paquet
          ‘glib:bin’ qui est automatiquement importé par le système de
          construction. Le paquet ‘glib’ qui fournit
          ‘glib-compile-schemas’ peut être spécifié avec le paramètre
          ‘#:glib’.

     Ces deux phases sont exécutées après la phase ‘install’.

 -- Variable Scheme : guile-build-system
     Ce système de construction sert aux paquets Guile qui consistent
     exclusivement en code Scheme et qui sont si simple qu’ils n’ont
     même pas un makefile, sans parler d’un script ‘configure’. Il
     compile le code Scheme en utilisant ‘guild compile’ (*note
     (guile)Compilation::) et installe les fichiers ‘.scm’ et ‘.go’ aux
     bons emplacements. Il installe aussi la documentation.

     This build system supports cross-compilation by using the
     ‘--target’ option of ‘guild compile’.

     Les paquets construits avec ‘guile-build-system’ doivent fournir un
     paquet Guile dans leur champ ‘native-inputs’.

 -- Scheme Variable : julia-build-system
     This variable is exported by ‘(guix build-system julia)’. It
     implements the build procedure used by julia
     (https://julialang.org/) packages, which essentially is similar to
     running ‘julia -e 'using Pkg; Pkg.add(package)'’ in an environment
     where ‘JULIA_LOAD_PATH’ contains the paths to all Julia package
     inputs. Tests are run not run.

     Julia packages require the source ‘file-name’ to be the real name
     of the package, correctly capitalized.

     For packages requiring shared library dependencies, you may need to
     write the ‘/deps/deps.jl’ file manually. It’s usually a line of
     ‘const variable = /gnu/store/library.so’ for each dependency, plus
     a void function ‘check_deps() = nothing’.

     Some older packages that aren’t using ‘Package.toml’ yet, will
     require this file to be created, too. The function
     ‘julia-create-package-toml’ helps creating the file. You need to
     pass the outputs and the source of the package, it’s name (the same
     as the ‘file-name’ parameter), the package uuid, the package
     version, and a list of dependencies specified by their name and
     their uuid.

 -- Variable Scheme : minify-build-system
     Cette variable est exportée par ‘(guix build-system minify)’. Elle
     implémente une procédure de minification pour des paquets
     JavaScript simples.

     Elle ajoute ‘uglify-js’ à l’ensemble des entrées et l’utilise pour
     compresser tous les fichiers JavaScript du répertoire ‘src’. Un
     minifieur différent peut être spécifié avec le paramètre
     ‘#:uglify-js’ mais il est attendu que ce paquet écrive le code
     minifié sur la sortie standard.

     Lorsque les fichiers JavaScript d’entrée ne sont pas situés dans le
     répertoire ‘src’, le paramètre ‘#:javascript-files’ peut être
     utilisé pour spécifier une liste de noms de fichiers à donner au
     minifieur.

 -- Variable Scheme : ocaml-build-system
     Cette variable est exportée par ‘(guix build-system ocaml)’. Elle
     implémente une procédure de construction pour les paquets OCaml
     (https://ocaml.org) qui consiste à choisir le bon ensemble de
     commande à lancer pour chaque paquet. Les paquets OCaml peuvent
     demander des commandes diverses pour être construit. Ce système de
     construction en essaye certaines.

     Lorsqu’un fichier ‘setup.ml’ est présent dans le répertoire de plus
     haut niveau, elle lancera ‘ocaml setup.ml -configure’, ‘ocaml
     setup.ml -build’ et ‘ocaml setup.ml -install’. Le système de
     construction supposera que ces fichiers ont été générés par OASIS
     (http://oasis.forge.ocamlcore.org/) et prendra soin d’initialiser
     le préfixe et d’activer les tests s’ils ne sont pas désactivés.
     Vous pouvez passer des drapeaux de configuration et de construction
     avec ‘#:configure-flags’ et ‘#:build-flags’. La clef ‘#:test-flags’
     peut être passée pour changer l’ensemble des drapeaux utilisés pour
     activer les tests. La clef ‘#:use-make?’ peut être utilisée pour
     outrepasser ce système dans les phases de construction et
     d’installation.

     Lorsque le paquet a un fichier ‘configure’, il est supposé qu’il
     s’agit d’un script configure écrit à la main qui demande un format
     différent de celui de ‘gnu-build-system’. Vous pouvez ajouter plus
     de drapeaux avec la clef ‘#:configure-flags’.

     Lorsque le paquet a un fichier ‘Makefile’ (ou ‘#:use-make?’ vaut
     ‘#t’), il sera utilisé et plus de drapeaux peuvent être passés à la
     construction et l’installation avec la clef ‘#:make-flags’.

     Enfin, certains paquets n’ont pas ces fichiers mais utilisent un
     emplacement plus ou moins standard pour leur système de
     construction. Dans ce cas, le système de construction lancera
     ‘ocaml pkg/pkg.ml’ ou ‘pkg/build.ml’ et prendra soin de fournir le
     chemin du module findlib requis. Des drapeaux supplémentaires
     peuvent être passés via la clef ‘#:bulid-flags’. L’installation se
     fait avec ‘opam-installer’. Dans ce cas, le paquet ‘opam’ doit être
     ajouté au champ ‘native-inputs’ de la définition du paquet.

     Note that most OCaml packages assume they will be installed in the
     same directory as OCaml, which is not what we want in guix. In
     particular, they will install ‘.so’ files in their module’s
     directory, which is usually fine because it is in the OCaml
     compiler directory. In guix though, these libraries cannot be found
     and we use ‘CAML_LD_LIBRARY_PATH’. This variable points to
     ‘lib/ocaml/site-lib/stubslibs’ and this is where ‘.so’ libraries
     should be installed.

 -- Variable Scheme : python-build-system
     Cette variable est exportée par ‘(guix build-system python)’. Elle
     implémente la procédure de construction plus ou moins standard
     utilisée pour les paquets Python, qui consiste à lancer ‘python
     setup.py build’ puis ‘python setup.py install
     --prefix=/gnu/store/...’.

     For packages that install stand-alone Python programs under ‘bin/’,
     it takes care of wrapping these programs so that their ‘PYTHONPATH’
     environment variable points to all the Python libraries they depend
     on.

     Le paquet Python utilisé pour effectuer la construction peut être
     spécifié avec le paramètre ‘#:python’. C’est une manière utile de
     forcer un paquet à être construit avec une version particulière de
     l’interpréteur python, ce qui peut être nécessaire si le paquet
     n’est compatible qu’avec une version de l’interpréteur.

     By default guix calls ‘setup.py’ under control of ‘setuptools’,
     much like ‘pip’ does. Some packages are not compatible with
     setuptools (and pip), thus you can disable this by setting the
     ‘#:use-setuptools?’ parameter to ‘#f’.

 -- Variable Scheme : perl-build-system
     Cette variable est exportée par ‘(guix build-system perl)’. Elle
     implémente la procédure de construction standard des paquets Perl,
     qui consiste soit à lancer ‘perl Build.PL --prefix=/gnu/store/...’,
     suivi de ‘Build’ et ‘Build install’ ; ou à lancer ‘perl Makefile.PL
     PREFIX=/gnu/store/...’, suivi de ‘make’ et ‘make install’, en
     fonction de la présence de ‘Build.PL’ ou ‘Makefile.PL’ dans la
     distribution du paquet. Le premier a la préférence si ‘Build.PL’ et
     ‘Makefile.PL’ existent tous deux dans la distribution du paquet.
     Cette préférence peut être inversée en spécifiant ‘#t’ pour le
     paramètre ‘#:make-maker?’.

     L’invocation initiale de ‘perl Makefile.PL’ ou ‘perl Build.PL’
     passe les drapeaux spécifiés par le paramètre ‘#:make-maker-flags’
     ou ‘#:module-build-flags’, respectivement.

     Le paquet Perl utilisé peut être spécifié avec ‘#:perl’.

 -- Scheme Variable : qt-build-system
     This variable is exported by ‘(guix build-system qt)’. It is
     intended for use with applications using Qt or KDE.

     This build system adds the following two phases to the ones defined
     by ‘cmake-build-system’:

     ‘check-setup’
          The phase ‘check-setup’ prepares the environment for running
          the checks as commonly used by Qt test programs. For now this
          only sets some environment variables:
          ‘QT_QPA_PLATFORM=offscreen’, ‘DBUS_FATAL_WARNINGS=0’ and
          ‘CTEST_OUTPUT_ON_FAILURE=1’.

          This phase is added before the ‘check’ phase. It’s a separate
          phase to ease adjusting if necessary.

     ‘qt-wrap’
          The phase ‘qt-wrap’ searches for Qt5 plugin paths, QML paths
          and some XDG in the inputs and output. In case some path is
          found, all programs in the output’s ‘bin/’, ‘sbin/’,
          ‘libexec/’ and ‘lib/libexec/’ directories are wrapped in
          scripts defining the necessary environment variables.

          It is possible to exclude specific package outputs from that
          wrapping process by listing their names in the
          ‘#:qt-wrap-excluded-outputs’ parameter. This is useful when an
          output is known not to contain any Qt binaries, and where
          wrapping would gratuitously add a dependency of that output on
          Qt, KDE, or such.

          This phase is added after the ‘install’ phase.

 -- Variable Scheme : r-build-system
     This variable is exported by ‘(guix build-system r)’. It implements
     the build procedure used by R (https://r-project.org) packages,
     which essentially is little more than running ‘R CMD INSTALL
     --library=/gnu/store/...’ in an environment where ‘R_LIBS_SITE’
     contains the paths to all R package inputs. Tests are run after
     installation using the R function ‘tools::testInstalledPackage’.

 -- Variable Scheme : rakudo-build-system
     Cette variable est exportée par ‘(guix build-system rakudo)’. Elle
     implémente la procédure de construction utilisée par Rakudo
     (https://rakudo.org/) pour les paquets Perl6 (https://perl6.org/).
     Elle installe le paquet dans
     ‘/gnu/store/.../NOM-VERSION/share/perl6’ et installe les binaires,
     les fichiers de bibliothèques et les ressources, et enveloppe les
     fichiers dans le répertoire ‘bin/’. Les tests peuvent être passés
     en indiquant ‘#f’ au paramètres ‘tests?’.

     Le paquet rakudo utilisé peut être spécifié avec ‘rakudo’. Le
     paquet perl6-tap-harness utilisé pour les tests peut être spécifié
     avec ‘#:prove6’ ou supprimé en passant ‘#f’ au paramètre
     ‘with-prove6?’. Le paquet perl6-zef utilisé pour les tests et
     l’installation peut être spécifié avec ‘#:ef’ ou supprimé en
     passant ‘#f’ au paramètre ‘with-zef?’.

 -- Variable Scheme : texlive-build-system
     This variable is exported by ‘(guix build-system texlive)’. It is
     used to build TeX packages in batch mode with a specified engine.
     The build system sets the ‘TEXINPUTS’ variable to find all TeX
     source files in the inputs.

     Par défaut, elle lance ‘luatex’ sur tous les fichiers qui se
     terminent par ‘ins’. Un moteur et un format différent peuvent être
     spécifiés avec l’argument ‘#:tex-format’. Plusieurs cibles de
     constructions peuvent être indiquées avec l’argument
     ‘#:build-targets’ qui attend une liste de noms de fichiers. Le
     système de construction ajoute uniquement ‘texlive-bin’ et
     ‘texlive-latex-base’ (de ‘(gnu packages tex)’ à la liste des
     entrées. Les deux peuvent être remplacés avec les arguments
     ‘#:texlive-bin’ et ‘#:texlive-latex-base’, respectivement.

     Le paramètre ‘#:tex-directory’ dit au système de construction où
     installer les fichiers construit dans l’arbre texmf.

 -- Variable Scheme : ruby-build-system
     Cette variable est exportée par ‘(guix build-system ruby)’. Elle
     implémenter la procédure de construction RubyGems utilisée par les
     paquets Ruby qui consiste à lancer ‘gem build’ suivi de ‘gem
     install’.

     Le champ ‘source’ d’un paquet qui utilise ce système de
     construction référence le plus souvent une archive gem, puisque
     c’est le format utilisé par les personnes qui développent en Ruby
     quand elles publient leur logiciel. Le système de construction
     décompresse l’archive gem, éventuellement en corrigeant les
     sources, lance la suite de tests, recompresse la gemme et
     l’installe. En plus, des répertoires et des archives peuvent être
     référencés pour permettre de construire des gemmes qui n’ont pas
     été publiées depuis Git ou une archive de sources traditionnelle.

     Le paquet Ruby utilisé peut être spécifié avec le paramètre
     ‘#:ruby’. Une liste de drapeaux supplémentaires à passer à la
     commande ‘gem’ peut être spécifiée avec le paramètre ‘#:gem-flags’.

 -- Variable Scheme : waf-build-system
     Cette variable est exportée par ‘(guix build-system waf)’. Elle
     implémente une procédure de construction autour du script ‘waf’.
     Les phases usuelles — ‘configure’, ‘build’ et ‘install’ — sont
     implémentée en passant leur nom en argument au script ‘waf’.

     Le script ‘waf’ est exécuté par l’interpréteur Python. Le paquet
     Python utilisé pour lancer le script peut être spécifié avec le
     paramètre ‘#:python’.

 -- Variable Scheme : scons-build-system
     Cette variable est exportée par ‘(guix build-system scons)’. Elle
     implémente la procédure de construction utilisée par l’outil de
     construction SCons. Ce système de construction lance ‘scons’ pour
     construire le paquet, ‘scons test’ pour lancer les tests puis
     ‘scons install’ pour installer le paquet.

     Additional flags to be passed to ‘scons’ can be specified with the
     ‘#:scons-flags’ parameter. The default build and install targets
     can be overridden with ‘#:build-targets’ and ‘#:install-targets’
     respectively. The version of Python used to run SCons can be
     specified by selecting the appropriate SCons package with the
     ‘#:scons’ parameter.

 -- Variable Scheme : haskell-build-system
     Cette variable est exportée par ‘(guix build-system haskell)’. Elle
     implémente la procédure de construction Cabal utilisée par les
     paquets Haskell, qui consiste à lancer ‘runhaskell Setup.hs
     configure --prefix=/gnu/store/...’ et ‘runhaskell Setup.hs build’.
     Plutôt que d’installer le paquets en lançant ‘runhaskell Setup.hs
     install’, pour éviter d’essayer d’enregistrer les bibliothèques
     dans le répertoire du dépôt en lecture-seule du compilateur, le
     système de construction utilise ‘runhaskell Setup.hs copy’, suivi
     de ‘runhaskell Setup.hs register’. En plus, le système de
     construction génère la documentation du paquet en lançant
     ‘runhaskell Setup.hs haddock’, à moins que ‘#:haddock? #f’ ne soit
     passé. Des paramètres facultatifs pour Haddock peuvent être passés
     à l’aide du paramètre ‘#:haddock-flags’. Si le fichier ‘Setup.hs’
     n’est pas trouvé, le système de construction cherchera ‘Setup.lhs’
     à la place.

     Le compilateur Haskell utilisé peut être spécifié avec le paramètre
     ‘#:haskell’ qui a pour valeur par défaut ‘ghc’.

 -- Variable Scheme : dub-build-system
     Cette variable est exportée par ‘(guix build-system dub)’. Elle
     implémente la procédure de construction Dub utilisée par les
     paquets D qui consiste à lancer ‘dub build’ et ‘dub run’.
     L’installation est effectuée en copiant les fichiers manuellement.

     Le compilateur D utilisé peut être spécifié avec le paramètre
     ‘#:ldc’ qui vaut par défaut ‘ldc’.

 -- Variable Scheme : emacs-build-system
     Cette variable est exportée par ‘(guix build-system emacs)’. Elle
     implémente une procédure d’installation similaire au système de
     gestion de paquet d’Emacs lui-même (*note (emacs)Packages::).

     It first creates the ‘package-autoloads.el’ file, then it byte
     compiles all Emacs Lisp files. Differently from the Emacs packaging
     system, the Info documentation files are moved to the standard
     documentation directory and the ‘dir’ file is deleted. The Elisp
     package files are installed directly under ‘share/emacs/site-lisp’.

 -- Variable Scheme : font-build-system
     Cette variable est exportée par ‘(guix build-system font)’. Elle
     implémente une procédure d’installation pour les paquets de polices
     où des fichiers de polices TrueType, OpenType, etc. sont fournis en
     amont et n’ont qu’à être copiés à leur emplacement final. Elle
     copie les fichiers de polices à l’emplacement standard dans le
     répertoire de sortie.

 -- Variable Scheme : meson-build-system
     Cette variable est exportée par ‘(guix build-system meson)’. Elle
     implémente la procédure de construction des paquets qui utilisent
     Meson (https://mesonbuild.com) comme système de construction.

     Elle ajoute à la fois Meson et Ninja (https://ninja-build.org/) à
     l’ensemble des entrées, et ils peuvent être modifiés avec les
     paramètres ‘#:meson’ et ‘#:ninja’ si requis. Le Meson par défaut
     est ‘meson-for-build’, qui est spécial parce qu’il ne nettoie pas
     le ‘RUNPATH’ des binaires et les bibliothèques qu’il installe.

     This build system is an extension of ‘gnu-build-system’, but with
     the following phases changed to some specific for Meson:

     ‘configure’
          The phase runs ‘meson’ with the flags specified in
          ‘#:configure-flags’. The flag ‘--buildtype’ is always set to
          ‘debugoptimized’ unless something else is specified in
          ‘#:build-type’.

     ‘build’
          La phase lance ‘ninja’ pour construire le paquet en parallèle
          par défaut, mais cela peut être changé avec
          ‘#:parallel-build?’.

     ‘check’
          La phase lance ‘ninja’ avec la cible spécifiée dans
          ‘#:test-target’, qui est ‘"test"’ par défaut.

     ‘install’
          La phase lance ‘ninja install’ et ne peut pas être changée.

     En dehors de cela, le système de construction ajoute aussi la phase
     suivante :

     ‘fix-runpath’
          Cette phase s’assure que tous les binaire peuvent trouver les
          bibliothèques dont ils ont besoin. Elle cherche les
          bibliothèques requises dans les sous-répertoires du paquet en
          construction et les ajoute au ‘RUNPATH’ là où c’est
          nécessaire. Elle supprime aussi les références aux
          bibliothèques laissées là par la phase de construction par
          ‘meson-for-build’ comme les dépendances des tests, qui ne sont
          pas vraiment requises pour le programme.

     ‘glib-or-gtk-wrap’
          Cette phase est la phase fournie par
          ‘glib-or-gtk-build-system’ et n’est pas activée par défaut.
          Elle peut l’être avec ‘#:glib-or-gtk?’.

     ‘glib-or-gtk-compile-schemas’
          Cette phase est la phase fournie par
          ‘glib-or-gtk-build-system’ et n’est pas activée par défaut.
          Elle peut l’être avec ‘#:glib-or-gtk?’.

 -- Variable Scheme : linux-module-build-system
     ‘linux-module-build-system’ allows building Linux kernel modules.

     This build system is an extension of ‘gnu-build-system’, but with
     the following phases changed:

     ‘configure’
          Cette phase configure l’environnement pour que le Makefile du
          noyau Linux puisse être utilisé pour construire le module du
          noyau externe.

     ‘build’
          Cette phase utilise le Makefile du noyau Linux pour construire
          le module du noyau externe.

     ‘install’
          Cette phase utilise le Makefile du noyau Linux pour installer
          le module du noyau externe.

     It is possible and useful to specify the Linux kernel to use for
     building the module (in the ‘arguments’ form of a package using the
     ‘linux-module-build-system’, use the key ‘#:linux’ to specify it).

 -- Scheme Variable : node-build-system
     This variable is exported by ‘(guix build-system node)’. It
     implements the build procedure used by Node.js
     (https://nodejs.org), which implements an approximation of the ‘npm
     install’ command, followed by an ‘npm test’ command.

     Which Node.js package is used to interpret the ‘npm’ commands can
     be specified with the ‘#:node’ parameter which defaults to ‘node’.

   Enfin, pour les paquets qui n’ont pas besoin de choses sophistiquées,
un système de construction « trivial » est disponible. Il est trivial
dans le sens où il ne fournit en gros aucun support : il n’apporte pas
de dépendance implicite, et n’a pas de notion de phase de construction.

 -- Variable Scheme : trivial-build-system
     Cette variable est exportée par ‘(guix build-system trivial)’.

     Ce système de construction requiert un argument ‘#:builder’. Cet
     argument doit être une expression Scheme qui construit la sortie du
     paquet — comme avec ‘build-expression->derivation’ (*note
     ‘build-expression->derivation’: Dérivations.).

   ---------- Footnotes ----------

   (1) Regardez les modules ‘(guix build gnu-build-system)’ pour plus de
détails sur les phases de construction.

