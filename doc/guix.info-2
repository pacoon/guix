This is guix.info, produced by makeinfo version 6.7 from guix.texi.

Copyright © 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020 Ludovic
Courtès
Copyright © 2013, 2014, 2016 Andreas Enge
Copyright © 2013 Nikita Karetnikov
Copyright © 2014, 2015, 2016 Alex Kost
Copyright © 2015, 2016 Mathieu Lirzin
Copyright © 2014 Pierre-Antoine Rault
Copyright © 2015 Taylan Ulrich Bayırlı/Kammer
Copyright © 2015, 2016, 2017, 2019, 2020 Leo Famulari
Copyright © 2015, 2016, 2017, 2018, 2019, 2020 Ricardo Wurmus
Copyright © 2016 Ben Woodcroft
Copyright © 2016, 2017, 2018 Chris Marusich
Copyright © 2016, 2017, 2018, 2019, 2020 Efraim Flashner
Copyright © 2016 John Darrington
Copyright © 2016, 2017 Nikita Gillmann
Copyright © 2016, 2017, 2018, 2019, 2020 Jan Nieuwenhuizen
Copyright © 2016, 2017, 2018, 2019, 2020 Julien Lepiller
Copyright © 2016 Alex ter Weele
Copyright © 2016, 2017, 2018, 2019 Christopher Baines
Copyright © 2017, 2018, 2019 Clément Lassieur
Copyright © 2017, 2018 Mathieu Othacehe
Copyright © 2017 Federico Beffa
Copyright © 2017, 2018 Carlo Zancanaro
Copyright © 2017 Thomas Danckaert
Copyright © 2017 humanitiesNerd
Copyright © 2017 Christopher Allan Webber
Copyright © 2017, 2018, 2019, 2020 Marius Bakke
Copyright © 2017, 2019, 2020 Hartmut Goebel
Copyright © 2017, 2019, 2020 Maxim Cournoyer
Copyright © 2017, 2018, 2019, 2020 Tobias Geerinckx-Rice
Copyright © 2017 George Clemmer
Copyright © 2017 Andy Wingo
Copyright © 2017, 2018, 2019 Arun Isaac
Copyright © 2017 nee
Copyright © 2018 Rutger Helling
Copyright © 2018 Oleg Pykhalov
Copyright © 2018 Mike Gerwitz
Copyright © 2018 Pierre-Antoine Rouby
Copyright © 2018, 2019 Gábor Boskovits
Copyright © 2018, 2019 Florian Pelz
Copyright © 2018 Laura Lazzati
Copyright © 2018 Alex Vong
Copyright © 2019 Josh Holland
Copyright © 2019, 2020 Diego Nicola Barbato
Copyright © 2019 Ivan Petkov
Copyright © 2019 Jakob L. Kreuze
Copyright © 2019 Kyle Andrews
Copyright © 2019 Alex Griffin
Copyright © 2019 Guillaume Le Vaillant
Copyright © 2020 Leo Prikler
Copyright © 2019, 2020 Simon Tournier
Copyright © 2020 Wiktor Żelazny
Copyright © 2020 Damien Cassou
Copyright © 2020 Jakub Kądziołka
Copyright © 2020 Jack Hill
Copyright © 2020 Naga Malleswari
Copyright © 2020 Brice Waegeneire
Copyright © 2020 R Veera Kumar
Copyright © 2020 Pierre Langlois
Copyright © 2020 pinoaffe

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled “GNU Free
Documentation License”.
INFO-DIR-SECTION System administration
START-INFO-DIR-ENTRY
* Guix: (guix).       Manage installed software and system configuration.
* guix package: (guix)Invoking guix package.  Installing, removing, and upgrading packages.
* guix gc: (guix)Invoking guix gc.            Reclaiming unused disk space.
* guix pull: (guix)Invoking guix pull.        Update the list of available packages.
* guix system: (guix)Invoking guix system.    Manage the operating system configuration.
* guix deploy: (guix)Invoking guix deploy.    Manage operating system configurations for remote hosts.
END-INFO-DIR-ENTRY

INFO-DIR-SECTION Software development
START-INFO-DIR-ENTRY
* guix environment: (guix)Invoking guix environment. Building development environments with Guix.
* guix build: (guix)Invoking guix build.      Building packages.
* guix pack: (guix)Invoking guix pack.        Creating binary bundles.
END-INFO-DIR-ENTRY


File: guix.info,  Node: G-Expressions,  Next: Invoking guix repl,  Prev: The Store Monad,  Up: Programming Interface

6.7 G-Expressions
=================

So we have “derivations”, which represent a sequence of build actions to
be performed to produce an item in the store (*note Derivations::).
These build actions are performed when asking the daemon to actually
build the derivations; they are run by the daemon in a container (*note
Invoking guix-daemon::).

   It should come as no surprise that we like to write these build
actions in Scheme.  When we do that, we end up with two “strata” of
Scheme code(1): the “host code”—code that defines packages, talks to the
daemon, etc.—and the “build code”—code that actually performs build
actions, such as making directories, invoking ‘make’, etc.

   To describe a derivation and its build actions, one typically needs
to embed build code inside host code.  It boils down to manipulating
build code as data, and the homoiconicity of Scheme—code has a direct
representation as data—comes in handy for that.  But we need more than
the normal ‘quasiquote’ mechanism in Scheme to construct build
expressions.

   The ‘(guix gexp)’ module implements “G-expressions”, a form of
S-expressions adapted to build expressions.  G-expressions, or “gexps”,
consist essentially of three syntactic forms: ‘gexp’, ‘ungexp’, and
‘ungexp-splicing’ (or simply: ‘#~’, ‘#$’, and ‘#$@’), which are
comparable to ‘quasiquote’, ‘unquote’, and ‘unquote-splicing’,
respectively (*note ‘quasiquote’: (guile)Expression Syntax.).  However,
there are major differences:

   • Gexps are meant to be written to a file and run or manipulated by
     other processes.

   • When a high-level object such as a package or derivation is
     unquoted inside a gexp, the result is as if its output file name
     had been introduced.

   • Gexps carry information about the packages or derivations they
     refer to, and these dependencies are automatically added as inputs
     to the build processes that use them.

   This mechanism is not limited to package and derivation objects:
“compilers” able to “lower” other high-level objects to derivations or
files in the store can be defined, such that these objects can also be
inserted into gexps.  For example, a useful type of high-level objects
that can be inserted in a gexp is “file-like objects”, which make it
easy to add files to the store and to refer to them in derivations and
such (see ‘local-file’ and ‘plain-file’ below).

   To illustrate the idea, here is an example of a gexp:

     (define build-exp
       #~(begin
           (mkdir #$output)
           (chdir #$output)
           (symlink (string-append #$coreutils "/bin/ls")
                    "list-files")))

   This gexp can be passed to ‘gexp->derivation’; we obtain a derivation
that builds a directory containing exactly one symlink to
‘/gnu/store/...-coreutils-8.22/bin/ls’:

     (gexp->derivation "the-thing" build-exp)

   As one would expect, the ‘"/gnu/store/...-coreutils-8.22"’ string is
substituted to the reference to the COREUTILS package in the actual
build code, and COREUTILS is automatically made an input to the
derivation.  Likewise, ‘#$output’ (equivalent to ‘(ungexp output)’) is
replaced by a string containing the directory name of the output of the
derivation.

   In a cross-compilation context, it is useful to distinguish between
references to the _native_ build of a package—that can run on the
host—versus references to cross builds of a package.  To that end, the
‘#+’ plays the same role as ‘#$’, but is a reference to a native package
build:

     (gexp->derivation "vi"
        #~(begin
            (mkdir #$output)
            (mkdir (string-append #$output "/bin"))
            (system* (string-append #+coreutils "/bin/ln")
                     "-s"
                     (string-append #$emacs "/bin/emacs")
                     (string-append #$output "/bin/vi")))
        #:target "aarch64-linux-gnu")

In the example above, the native build of COREUTILS is used, so that
‘ln’ can actually run on the host; but then the cross-compiled build of
EMACS is referenced.

   Another gexp feature is “imported modules”: sometimes you want to be
able to use certain Guile modules from the “host environment” in the
gexp, so those modules should be imported in the “build environment”.
The ‘with-imported-modules’ form allows you to express that:

     (let ((build (with-imported-modules '((guix build utils))
                    #~(begin
                        (use-modules (guix build utils))
                        (mkdir-p (string-append #$output "/bin"))))))
       (gexp->derivation "empty-dir"
                         #~(begin
                             #$build
                             (display "success!\n")
                             #t)))

In this example, the ‘(guix build utils)’ module is automatically pulled
into the isolated build environment of our gexp, such that ‘(use-modules
(guix build utils))’ works as expected.

   Usually you want the _closure_ of the module to be imported—i.e., the
module itself and all the modules it depends on—rather than just the
module; failing to do that, attempts to use the module will fail because
of missing dependent modules.  The ‘source-module-closure’ procedure
computes the closure of a module by looking at its source file headers,
which comes in handy in this case:

     (use-modules (guix modules))   ;for 'source-module-closure'

     (with-imported-modules (source-module-closure
                              '((guix build utils)
                                (gnu build vm)))
       (gexp->derivation "something-with-vms"
                         #~(begin
                             (use-modules (guix build utils)
                                          (gnu build vm))
                             ...)))

   In the same vein, sometimes you want to import not just pure-Scheme
modules, but also “extensions” such as Guile bindings to C libraries or
other “full-blown” packages.  Say you need the ‘guile-json’ package
available on the build side, here’s how you would do it:

     (use-modules (gnu packages guile))  ;for 'guile-json'

     (with-extensions (list guile-json)
       (gexp->derivation "something-with-json"
                         #~(begin
                             (use-modules (json))
                             ...)))

   The syntactic form to construct gexps is summarized below.

 -- Scheme Syntax: #~EXP
 -- Scheme Syntax: (gexp EXP)
     Return a G-expression containing EXP.  EXP may contain one or more
     of the following forms:

     ‘#$OBJ’
     ‘(ungexp OBJ)’
          Introduce a reference to OBJ.  OBJ may have one of the
          supported types, for example a package or a derivation, in
          which case the ‘ungexp’ form is replaced by its output file
          name—e.g., ‘"/gnu/store/...-coreutils-8.22’.

          If OBJ is a list, it is traversed and references to supported
          objects are substituted similarly.

          If OBJ is another gexp, its contents are inserted and its
          dependencies are added to those of the containing gexp.

          If OBJ is another kind of object, it is inserted as is.

     ‘#$OBJ:OUTPUT’
     ‘(ungexp OBJ OUTPUT)’
          This is like the form above, but referring explicitly to the
          OUTPUT of OBJ—this is useful when OBJ produces multiple
          outputs (*note Packages with Multiple Outputs::).

     ‘#+OBJ’
     ‘#+OBJ:output’
     ‘(ungexp-native OBJ)’
     ‘(ungexp-native OBJ OUTPUT)’
          Same as ‘ungexp’, but produces a reference to the _native_
          build of OBJ when used in a cross compilation context.

     ‘#$output[:OUTPUT]’
     ‘(ungexp output [OUTPUT])’
          Insert a reference to derivation output OUTPUT, or to the main
          output when OUTPUT is omitted.

          This only makes sense for gexps passed to ‘gexp->derivation’.

     ‘#$@LST’
     ‘(ungexp-splicing LST)’
          Like the above, but splices the contents of LST inside the
          containing list.

     ‘#+@LST’
     ‘(ungexp-native-splicing LST)’
          Like the above, but refers to native builds of the objects
          listed in LST.

     G-expressions created by ‘gexp’ or ‘#~’ are run-time objects of the
     ‘gexp?’ type (see below).

 -- Scheme Syntax: with-imported-modules MODULES BODY...
     Mark the gexps defined in BODY... as requiring MODULES in their
     execution environment.

     Each item in MODULES can be the name of a module, such as ‘(guix
     build utils)’, or it can be a module name, followed by an arrow,
     followed by a file-like object:

          `((guix build utils)
            (guix gcrypt)
            ((guix config) => ,(scheme-file "config.scm"
                                            #~(define-module ...))))

     In the example above, the first two modules are taken from the
     search path, and the last one is created from the given file-like
     object.

     This form has _lexical_ scope: it has an effect on the gexps
     directly defined in BODY..., but not on those defined, say, in
     procedures called from BODY....

 -- Scheme Syntax: with-extensions EXTENSIONS BODY...
     Mark the gexps defined in BODY... as requiring EXTENSIONS in their
     build and execution environment.  EXTENSIONS is typically a list of
     package objects such as those defined in the ‘(gnu packages guile)’
     module.

     Concretely, the packages listed in EXTENSIONS are added to the load
     path while compiling imported modules in BODY...; they are also
     added to the load path of the gexp returned by BODY....

 -- Scheme Procedure: gexp? OBJ
     Return ‘#t’ if OBJ is a G-expression.

   G-expressions are meant to be written to disk, either as code
building some derivation, or as plain files in the store.  The monadic
procedures below allow you to do that (*note The Store Monad::, for more
information about monads).

 -- Monadic Procedure: gexp->derivation NAME EXP [#:system
          (%current-system)] [#:target #f] [#:graft? #t] [#:hash #f]
          [#:hash-algo #f] [#:recursive? #f] [#:env-vars '()] [#:modules
          '()] [#:module-path ‘%load-path’] [#:effective-version "2.2"]
          [#:references-graphs #f] [#:allowed-references #f]
          [#:disallowed-references #f] [#:leaked-env-vars #f]
          [#:script-name (string-append NAME "-builder")]
          [#:deprecation-warnings #f] [#:local-build? #f]
          [#:substitutable? #t] [#:properties '()] [#:guile-for-build
          #f]
     Return a derivation NAME that runs EXP (a gexp) with
     GUILE-FOR-BUILD (a derivation) on SYSTEM; EXP is stored in a file
     called SCRIPT-NAME.  When TARGET is true, it is used as the
     cross-compilation target triplet for packages referred to by EXP.

     MODULES is deprecated in favor of ‘with-imported-modules’.  Its
     meaning is to make MODULES available in the evaluation context of
     EXP; MODULES is a list of names of Guile modules searched in
     MODULE-PATH to be copied in the store, compiled, and made available
     in the load path during the execution of EXP—e.g., ‘((guix build
     utils) (guix build gnu-build-system))’.

     EFFECTIVE-VERSION determines the string to use when adding
     extensions of EXP (see ‘with-extensions’) to the search path—e.g.,
     ‘"2.2"’.

     GRAFT? determines whether packages referred to by EXP should be
     grafted when applicable.

     When REFERENCES-GRAPHS is true, it must be a list of tuples of one
     of the following forms:

          (FILE-NAME PACKAGE)
          (FILE-NAME PACKAGE OUTPUT)
          (FILE-NAME DERIVATION)
          (FILE-NAME DERIVATION OUTPUT)
          (FILE-NAME STORE-ITEM)

     The right-hand-side of each element of REFERENCES-GRAPHS is
     automatically made an input of the build process of EXP.  In the
     build environment, each FILE-NAME contains the reference graph of
     the corresponding item, in a simple text format.

     ALLOWED-REFERENCES must be either ‘#f’ or a list of output names
     and packages.  In the latter case, the list denotes store items
     that the result is allowed to refer to.  Any reference to another
     store item will lead to a build error.  Similarly for
     DISALLOWED-REFERENCES, which can list items that must not be
     referenced by the outputs.

     DEPRECATION-WARNINGS determines whether to show deprecation
     warnings while compiling modules.  It can be ‘#f’, ‘#t’, or
     ‘'detailed’.

     The other arguments are as for ‘derivation’ (*note Derivations::).

   The ‘local-file’, ‘plain-file’, ‘computed-file’, ‘program-file’, and
‘scheme-file’ procedures below return “file-like objects”.  That is,
when unquoted in a G-expression, these objects lead to a file in the
store.  Consider this G-expression:

     #~(system* #$(file-append glibc "/sbin/nscd") "-f"
                #$(local-file "/tmp/my-nscd.conf"))

   The effect here is to “intern” ‘/tmp/my-nscd.conf’ by copying it to
the store.  Once expanded, for instance via ‘gexp->derivation’, the
G-expression refers to that copy under ‘/gnu/store’; thus, modifying or
removing the file in ‘/tmp’ does not have any effect on what the
G-expression does.  ‘plain-file’ can be used similarly; it differs in
that the file content is directly passed as a string.

 -- Scheme Procedure: local-file FILE [NAME] [#:recursive? #f]
          [#:select? (const #t)]
     Return an object representing local file FILE to add to the store;
     this object can be used in a gexp.  If FILE is a literal string
     denoting a relative file name, it is looked up relative to the
     source file where it appears; if FILE is not a literal string, it
     is looked up relative to the current working directory at run time.
     FILE will be added to the store under NAME–by default the base name
     of FILE.

     When RECURSIVE? is true, the contents of FILE are added
     recursively; if FILE designates a flat file and RECURSIVE? is true,
     its contents are added, and its permission bits are kept.

     When RECURSIVE? is true, call ‘(SELECT? FILE STAT)’ for each
     directory entry, where FILE is the entry’s absolute file name and
     STAT is the result of ‘lstat’; exclude entries for which SELECT?
     does not return true.

     This is the declarative counterpart of the ‘interned-file’ monadic
     procedure (*note ‘interned-file’: The Store Monad.).

 -- Scheme Procedure: plain-file NAME CONTENT
     Return an object representing a text file called NAME with the
     given CONTENT (a string or a bytevector) to be added to the store.

     This is the declarative counterpart of ‘text-file’.

 -- Scheme Procedure: computed-file NAME GEXP [#:options
          '(#:local-build? #t)]
     Return an object representing the store item NAME, a file or
     directory computed by GEXP.  OPTIONS is a list of additional
     arguments to pass to ‘gexp->derivation’.

     This is the declarative counterpart of ‘gexp->derivation’.

 -- Monadic Procedure: gexp->script NAME EXP [#:guile (default-guile)]
          [#:module-path %load-path] [#:system (%current-system)]
          [#:target #f]
     Return an executable script NAME that runs EXP using GUILE, with
     EXP’s imported modules in its search path.  Look up EXP’s modules
     in MODULE-PATH.

     The example below builds a script that simply invokes the ‘ls’
     command:

          (use-modules (guix gexp) (gnu packages base))

          (gexp->script "list-files"
                        #~(execl #$(file-append coreutils "/bin/ls")
                                 "ls"))

     When “running” it through the store (*note ‘run-with-store’: The
     Store Monad.), we obtain a derivation that produces an executable
     file ‘/gnu/store/...-list-files’ along these lines:

          #!/gnu/store/...-guile-2.0.11/bin/guile -ds
          !#
          (execl "/gnu/store/...-coreutils-8.22"/bin/ls" "ls")

 -- Scheme Procedure: program-file NAME EXP [#:guile #f] [#:module-path
          %load-path]
     Return an object representing the executable store item NAME that
     runs GEXP.  GUILE is the Guile package used to execute that script.
     Imported modules of GEXP are looked up in MODULE-PATH.

     This is the declarative counterpart of ‘gexp->script’.

 -- Monadic Procedure: gexp->file NAME EXP [#:set-load-path? #t]
          [#:module-path %load-path] [#:splice? #f] [#:guile
          (default-guile)]
     Return a derivation that builds a file NAME containing EXP.  When
     SPLICE? is true, EXP is considered to be a list of expressions that
     will be spliced in the resulting file.

     When SET-LOAD-PATH? is true, emit code in the resulting file to set
     ‘%load-path’ and ‘%load-compiled-path’ to honor EXP’s imported
     modules.  Look up EXP’s modules in MODULE-PATH.

     The resulting file holds references to all the dependencies of EXP
     or a subset thereof.

 -- Scheme Procedure: scheme-file NAME EXP [#:splice? #f]
          [#:set-load-path? #t]
     Return an object representing the Scheme file NAME that contains
     EXP.

     This is the declarative counterpart of ‘gexp->file’.

 -- Monadic Procedure: text-file* NAME TEXT ...
     Return as a monadic value a derivation that builds a text file
     containing all of TEXT.  TEXT may list, in addition to strings,
     objects of any type that can be used in a gexp: packages,
     derivations, local file objects, etc.  The resulting store file
     holds references to all these.

     This variant should be preferred over ‘text-file’ anytime the file
     to create will reference items from the store.  This is typically
     the case when building a configuration file that embeds store file
     names, like this:

          (define (profile.sh)
            ;; Return the name of a shell script in the store that
            ;; initializes the 'PATH' environment variable.
            (text-file* "profile.sh"
                        "export PATH=" coreutils "/bin:"
                        grep "/bin:" sed "/bin\n"))

     In this example, the resulting ‘/gnu/store/...-profile.sh’ file
     will reference COREUTILS, GREP, and SED, thereby preventing them
     from being garbage-collected during its lifetime.

 -- Scheme Procedure: mixed-text-file NAME TEXT ...
     Return an object representing store file NAME containing TEXT.
     TEXT is a sequence of strings and file-like objects, as in:

          (mixed-text-file "profile"
                           "export PATH=" coreutils "/bin:" grep "/bin")

     This is the declarative counterpart of ‘text-file*’.

 -- Scheme Procedure: file-union NAME FILES
     Return a ‘<computed-file>’ that builds a directory containing all
     of FILES.  Each item in FILES must be a two-element list where the
     first element is the file name to use in the new directory, and the
     second element is a gexp denoting the target file.  Here’s an
     example:

          (file-union "etc"
                      `(("hosts" ,(plain-file "hosts"
                                              "127.0.0.1 localhost"))
                        ("bashrc" ,(plain-file "bashrc"
                                               "alias ls='ls --color=auto'"))))

     This yields an ‘etc’ directory containing these two files.

 -- Scheme Procedure: directory-union NAME THINGS
     Return a directory that is the union of THINGS, where THINGS is a
     list of file-like objects denoting directories.  For example:

          (directory-union "guile+emacs" (list guile emacs))

     yields a directory that is the union of the ‘guile’ and ‘emacs’
     packages.

 -- Scheme Procedure: file-append OBJ SUFFIX ...
     Return a file-like object that expands to the concatenation of OBJ
     and SUFFIX, where OBJ is a lowerable object and each SUFFIX is a
     string.

     As an example, consider this gexp:

          (gexp->script "run-uname"
                        #~(system* #$(file-append coreutils
                                                  "/bin/uname")))

     The same effect could be achieved with:

          (gexp->script "run-uname"
                        #~(system* (string-append #$coreutils
                                                  "/bin/uname")))

     There is one difference though: in the ‘file-append’ case, the
     resulting script contains the absolute file name as a string,
     whereas in the second case, the resulting script contains a
     ‘(string-append ...)’ expression to construct the file name _at run
     time_.

 -- Scheme Syntax: let-system SYSTEM BODY...
 -- Scheme Syntax: let-system (SYSTEM TARGET) BODY...
     Bind SYSTEM to the currently targeted system—e.g.,
     ‘"x86_64-linux"’—within BODY.

     In the second case, additionally bind TARGET to the current
     cross-compilation target—a GNU triplet such as
     ‘"arm-linux-gnueabihf"’—or ‘#f’ if we are not cross-compiling.

     ‘let-system’ is useful in the occasional case where the object
     spliced into the gexp depends on the target system, as in this
     example:

          #~(system*
             #+(let-system system
                 (cond ((string-prefix? "armhf-" system)
                        (file-append qemu "/bin/qemu-system-arm"))
                       ((string-prefix? "x86_64-" system)
                        (file-append qemu "/bin/qemu-system-x86_64"))
                       (else
                        (error "dunno!"))))
             "-net" "user" #$image)

 -- Scheme Syntax: with-parameters ((PARAMETER VALUE) ...) EXP
     This macro is similar to the ‘parameterize’ form for
     dynamically-bound “parameters” (*note (guile)Parameters::).  The
     key difference is that it takes effect when the file-like object
     returned by EXP is lowered to a derivation or store item.

     A typical use of ‘with-parameters’ is to force the system in effect
     for a given object:

          (with-parameters ((%current-system "i686-linux"))
            coreutils)

     The example above returns an object that corresponds to the i686
     build of Coreutils, regardless of the current value of
     ‘%current-system’.

   Of course, in addition to gexps embedded in “host” code, there are
also modules containing build tools.  To make it clear that they are
meant to be used in the build stratum, these modules are kept in the
‘(guix build ...)’ name space.

   Internally, high-level objects are “lowered”, using their compiler,
to either derivations or store items.  For instance, lowering a package
yields a derivation, and lowering a ‘plain-file’ yields a store item.
This is achieved using the ‘lower-object’ monadic procedure.

 -- Monadic Procedure: lower-object OBJ [SYSTEM] [#:target #f]
     Return as a value in ‘%store-monad’ the derivation or store item
     corresponding to OBJ for SYSTEM, cross-compiling for TARGET if
     TARGET is true.  OBJ must be an object that has an associated gexp
     compiler, such as a ‘<package>’.

   ---------- Footnotes ----------

   (1) The term “stratum” in this context was coined by Manuel Serrano
et al. in the context of their work on Hop.  Oleg Kiselyov, who has
written insightful essays and code on this topic
(http://okmij.org/ftp/meta-programming/#meta-scheme), refers to this
kind of code generation as “staging”.


File: guix.info,  Node: Invoking guix repl,  Prev: G-Expressions,  Up: Programming Interface

6.8 Invoking ‘guix repl’
========================

The ‘guix repl’ command spawns a Guile “read-eval-print loop” (REPL) for
interactive programming (*note (guile)Using Guile Interactively::).
Compared to just launching the ‘guile’ command, ‘guix repl’ guarantees
that all the Guix modules and all its dependencies are available in the
search path.  You can use it this way:

     $ guix repl
     scheme@(guile-user)> ,use (gnu packages base)
     scheme@(guile-user)> coreutils
     $1 = #<package coreutils@8.29 gnu/packages/base.scm:327 3e28300>

   In addition, ‘guix repl’ implements a simple machine-readable REPL
protocol for use by ‘(guix inferior)’, a facility to interact with
“inferiors”, separate processes running a potentially different revision
of Guix.

   The available options are as follows:

‘--type=TYPE’
‘-t TYPE’
     Start a REPL of the given TYPE, which can be one of the following:

     ‘guile’
          This is default, and it spawns a standard full-featured Guile
          REPL.
     ‘machine’
          Spawn a REPL that uses the machine-readable protocol.  This is
          the protocol that the ‘(guix inferior)’ module speaks.

‘--listen=ENDPOINT’
     By default, ‘guix repl’ reads from standard input and writes to
     standard output.  When this option is passed, it will instead
     listen for connections on ENDPOINT.  Here are examples of valid
     options:

     ‘--listen=tcp:37146’
          Accept connections on localhost on port 37146.

     ‘--listen=unix:/tmp/socket’
          Accept connections on the Unix-domain socket ‘/tmp/socket’.

‘--load-path=DIRECTORY’
‘-L DIRECTORY’
     Add DIRECTORY to the front of the package module search path (*note
     Package Modules::).

     This allows users to define their own packages and make them
     visible to the command-line tool.

‘-q’
     Inhibit loading of the ‘~/.guile’ file.  By default, that
     configuration file is loaded when spawning a ‘guile’ REPL.


File: guix.info,  Node: Utilities,  Next: System Configuration,  Prev: Programming Interface,  Up: Top

7 Utilities
***********

This section describes Guix command-line utilities.  Some of them are
primarily targeted at developers and users who write new package
definitions, while others are more generally useful.  They complement
the Scheme programming interface of Guix in a convenient way.

* Menu:

* Invoking guix build::         Building packages from the command line.
* Invoking guix edit::          Editing package definitions.
* Invoking guix download::      Downloading a file and printing its hash.
* Invoking guix hash::          Computing the cryptographic hash of a file.
* Invoking guix import::        Importing package definitions.
* Invoking guix refresh::       Updating package definitions.
* Invoking guix lint::          Finding errors in package definitions.
* Invoking guix size::          Profiling disk usage.
* Invoking guix graph::         Visualizing the graph of packages.
* Invoking guix publish::       Sharing substitutes.
* Invoking guix challenge::     Challenging substitute servers.
* Invoking guix copy::          Copying to and from a remote store.
* Invoking guix container::     Process isolation.
* Invoking guix weather::       Assessing substitute availability.
* Invoking guix processes::     Listing client processes.


File: guix.info,  Node: Invoking guix build,  Next: Invoking guix edit,  Up: Utilities

7.1 Invoking ‘guix build’
=========================

The ‘guix build’ command builds packages or derivations and their
dependencies, and prints the resulting store paths.  Note that it does
not modify the user’s profile—this is the job of the ‘guix package’
command (*note Invoking guix package::).  Thus, it is mainly useful for
distribution developers.

   The general syntax is:

     guix build OPTIONS PACKAGE-OR-DERIVATION...

   As an example, the following command builds the latest versions of
Emacs and of Guile, displays their build logs, and finally displays the
resulting directories:

     guix build emacs guile

   Similarly, the following command builds all the available packages:

     guix build --quiet --keep-going \
       `guix package -A | cut -f1,2 --output-delimiter=@`

   PACKAGE-OR-DERIVATION may be either the name of a package found in
the software distribution such as ‘coreutils’ or ‘coreutils@8.20’, or a
derivation such as ‘/gnu/store/...-coreutils-8.19.drv’.  In the former
case, a package with the corresponding name (and optionally version) is
searched for among the GNU distribution modules (*note Package
Modules::).

   Alternatively, the ‘--expression’ option may be used to specify a
Scheme expression that evaluates to a package; this is useful when
disambiguating among several same-named packages or package variants is
needed.

   There may be zero or more OPTIONS.  The available options are
described in the subsections below.

* Menu:

* Common Build Options::        Build options for most commands.
* Package Transformation Options::  Creating variants of packages.
* Additional Build Options::    Options specific to ’guix build’.
* Debugging Build Failures::    Real life packaging experience.


File: guix.info,  Node: Common Build Options,  Next: Package Transformation Options,  Up: Invoking guix build

7.1.1 Common Build Options
--------------------------

A number of options that control the build process are common to ‘guix
build’ and other commands that can spawn builds, such as ‘guix package’
or ‘guix archive’.  These are the following:

‘--load-path=DIRECTORY’
‘-L DIRECTORY’
     Add DIRECTORY to the front of the package module search path (*note
     Package Modules::).

     This allows users to define their own packages and make them
     visible to the command-line tools.

‘--keep-failed’
‘-K’
     Keep the build tree of failed builds.  Thus, if a build fails, its
     build tree is kept under ‘/tmp’, in a directory whose name is shown
     at the end of the build log.  This is useful when debugging build
     issues.  *Note Debugging Build Failures::, for tips and tricks on
     how to debug build issues.

     This option implies ‘--no-offload’, and it has no effect when
     connecting to a remote daemon with a ‘guix://’ URI (*note the
     ‘GUIX_DAEMON_SOCKET’ variable: The Store.).

‘--keep-going’
‘-k’
     Keep going when some of the derivations fail to build; return only
     once all the builds have either completed or failed.

     The default behavior is to stop as soon as one of the specified
     derivations has failed.

‘--dry-run’
‘-n’
     Do not build the derivations.

‘--fallback’
     When substituting a pre-built binary fails, fall back to building
     packages locally (*note Substitution Failure::).

‘--substitute-urls=URLS’
     Consider URLS the whitespace-separated list of substitute source
     URLs, overriding the default list of URLs of ‘guix-daemon’ (*note
     ‘guix-daemon’ URLs: daemon-substitute-urls.).

     This means that substitutes may be downloaded from URLS, provided
     they are signed by a key authorized by the system administrator
     (*note Substitutes::).

     When URLS is the empty string, substitutes are effectively
     disabled.

‘--no-substitutes’
     Do not use substitutes for build products.  That is, always build
     things locally instead of allowing downloads of pre-built binaries
     (*note Substitutes::).

‘--no-grafts’
     Do not “graft” packages.  In practice, this means that package
     updates available as grafts are not applied.  *Note Security
     Updates::, for more information on grafts.

‘--rounds=N’
     Build each derivation N times in a row, and raise an error if
     consecutive build results are not bit-for-bit identical.

     This is a useful way to detect non-deterministic builds processes.
     Non-deterministic build processes are a problem because they make
     it practically impossible for users to _verify_ whether third-party
     binaries are genuine.  *Note Invoking guix challenge::, for more.

     Note that, currently, the differing build results are not kept
     around, so you will have to manually investigate in case of an
     error—e.g., by stashing one of the build results with ‘guix archive
     --export’ (*note Invoking guix archive::), then rebuilding, and
     finally comparing the two results.

‘--no-offload’
     Do not use offload builds to other machines (*note Daemon Offload
     Setup::).  That is, always build things locally instead of
     offloading builds to remote machines.

‘--max-silent-time=SECONDS’
     When the build or substitution process remains silent for more than
     SECONDS, terminate it and report a build failure.

     By default, the daemon’s setting is honored (*note
     ‘--max-silent-time’: Invoking guix-daemon.).

‘--timeout=SECONDS’
     Likewise, when the build or substitution process lasts for more
     than SECONDS, terminate it and report a build failure.

     By default, the daemon’s setting is honored (*note ‘--timeout’:
     Invoking guix-daemon.).

‘-v LEVEL’
‘--verbosity=LEVEL’
     Use the given verbosity LEVEL, an integer.  Choosing 0 means that
     no output is produced, 1 is for quiet output, and 2 shows all the
     build log output on standard error.

‘--cores=N’
‘-c N’
     Allow the use of up to N CPU cores for the build.  The special
     value ‘0’ means to use as many CPU cores as available.

‘--max-jobs=N’
‘-M N’
     Allow at most N build jobs in parallel.  *Note ‘--max-jobs’:
     Invoking guix-daemon, for details about this option and the
     equivalent ‘guix-daemon’ option.

‘--debug=LEVEL’
     Produce debugging output coming from the build daemon.  LEVEL must
     be an integer between 0 and 5; higher means more verbose output.
     Setting a level of 4 or more may be helpful when debugging setup
     issues with the build daemon.

   Behind the scenes, ‘guix build’ is essentially an interface to the
‘package-derivation’ procedure of the ‘(guix packages)’ module, and to
the ‘build-derivations’ procedure of the ‘(guix derivations)’ module.

   In addition to options explicitly passed on the command line, ‘guix
build’ and other ‘guix’ commands that support building honor the
‘GUIX_BUILD_OPTIONS’ environment variable.

 -- Environment Variable: GUIX_BUILD_OPTIONS
     Users can define this variable to a list of command line options
     that will automatically be used by ‘guix build’ and other ‘guix’
     commands that can perform builds, as in the example below:

          $ export GUIX_BUILD_OPTIONS="--no-substitutes -c 2 -L /foo/bar"

     These options are parsed independently, and the result is appended
     to the parsed command-line options.


File: guix.info,  Node: Package Transformation Options,  Next: Additional Build Options,  Prev: Common Build Options,  Up: Invoking guix build

7.1.2 Package Transformation Options
------------------------------------

Another set of command-line options supported by ‘guix build’ and also
‘guix package’ are “package transformation options”.  These are options
that make it possible to define “package variants”—for instance,
packages built from different source code.  This is a convenient way to
create customized packages on the fly without having to type in the
definitions of package variants (*note Defining Packages::).

‘--with-source=SOURCE’
‘--with-source=PACKAGE=SOURCE’
‘--with-source=PACKAGE@VERSION=SOURCE’
     Use SOURCE as the source of PACKAGE, and VERSION as its version
     number.  SOURCE must be a file name or a URL, as for ‘guix
     download’ (*note Invoking guix download::).

     When PACKAGE is omitted, it is taken to be the package name
     specified on the command line that matches the base of SOURCE—e.g.,
     if SOURCE is ‘/src/guile-2.0.10.tar.gz’, the corresponding package
     is ‘guile’.

     Likewise, when VERSION is omitted, the version string is inferred
     from SOURCE; in the previous example, it is ‘2.0.10’.

     This option allows users to try out versions of packages other than
     the one provided by the distribution.  The example below downloads
     ‘ed-1.7.tar.gz’ from a GNU mirror and uses that as the source for
     the ‘ed’ package:

          guix build ed --with-source=mirror://gnu/ed/ed-1.7.tar.gz

     As a developer, ‘--with-source’ makes it easy to test release
     candidates:

          guix build guile --with-source=../guile-2.0.9.219-e1bb7.tar.xz

     ... or to build from a checkout in a pristine environment:

          $ git clone git://git.sv.gnu.org/guix.git
          $ guix build guix --with-source=guix@1.0=./guix

‘--with-input=PACKAGE=REPLACEMENT’
     Replace dependency on PACKAGE by a dependency on REPLACEMENT.
     PACKAGE must be a package name, and REPLACEMENT must be a package
     specification such as ‘guile’ or ‘guile@1.8’.

     For instance, the following command builds Guix, but replaces its
     dependency on the current stable version of Guile with a dependency
     on the legacy version of Guile, ‘guile@2.0’:

          guix build --with-input=guile=guile@2.0 guix

     This is a recursive, deep replacement.  So in this example, both
     ‘guix’ and its dependency ‘guile-json’ (which also depends on
     ‘guile’) get rebuilt against ‘guile@2.0’.

     This is implemented using the ‘package-input-rewriting’ Scheme
     procedure (*note ‘package-input-rewriting’: Defining Packages.).

‘--with-graft=PACKAGE=REPLACEMENT’
     This is similar to ‘--with-input’ but with an important difference:
     instead of rebuilding the whole dependency chain, REPLACEMENT is
     built and then “grafted” onto the binaries that were initially
     referring to PACKAGE.  *Note Security Updates::, for more
     information on grafts.

     For example, the command below grafts version 3.5.4 of GnuTLS onto
     Wget and all its dependencies, replacing references to the version
     of GnuTLS they currently refer to:

          guix build --with-graft=gnutls=gnutls@3.5.4 wget

     This has the advantage of being much faster than rebuilding
     everything.  But there is a caveat: it works if and only if PACKAGE
     and REPLACEMENT are strictly compatible—for example, if they
     provide a library, the application binary interface (ABI) of those
     libraries must be compatible.  If REPLACEMENT is somehow
     incompatible with PACKAGE, then the resulting package may be
     unusable.  Use with care!

‘--with-git-url=PACKAGE=URL’
     Build PACKAGE from the latest commit of the ‘master’ branch of the
     Git repository at URL.  Git sub-modules of the repository are
     fetched, recursively.

     For example, the following command builds the NumPy Python library
     against the latest commit of the master branch of Python itself:

          guix build python-numpy \
            --with-git-url=python=https://github.com/python/cpython

     This option can also be combined with ‘--with-branch’ or
     ‘--with-commit’ (see below).

     Obviously, since it uses the latest commit of the given branch, the
     result of such a command varies over time.  Nevertheless it is a
     convenient way to rebuild entire software stacks against the latest
     commit of one or more packages.  This is particularly useful in the
     context of continuous integration (CI).

     Checkouts are kept in a cache under ‘~/.cache/guix/checkouts’ to
     speed up consecutive accesses to the same repository.  You may want
     to clean it up once in a while to save disk space.

‘--with-branch=PACKAGE=BRANCH’
     Build PACKAGE from the latest commit of BRANCH.  If the ‘source’
     field of PACKAGE is an origin with the ‘git-fetch’ method (*note
     origin Reference::) or a ‘git-checkout’ object, the repository URL
     is taken from that ‘source’.  Otherwise you have to use
     ‘--with-git-url’ to specify the URL of the Git repository.

     For instance, the following command builds ‘guile-sqlite3’ from the
     latest commit of its ‘master’ branch, and then builds ‘guix’ (which
     depends on it) and ‘cuirass’ (which depends on ‘guix’) against this
     specific ‘guile-sqlite3’ build:

          guix build --with-branch=guile-sqlite3=master cuirass

‘--with-commit=PACKAGE=COMMIT’
     This is similar to ‘--with-branch’, except that it builds from
     COMMIT rather than the tip of a branch.  COMMIT must be a valid Git
     commit SHA1 identifier or a tag.


File: guix.info,  Node: Additional Build Options,  Next: Debugging Build Failures,  Prev: Package Transformation Options,  Up: Invoking guix build

7.1.3 Additional Build Options
------------------------------

The command-line options presented below are specific to ‘guix build’.

‘--quiet’
‘-q’
     Build quietly, without displaying the build log; this is equivalent
     to ‘--verbosity=0’.  Upon completion, the build log is kept in
     ‘/var’ (or similar) and can always be retrieved using the
     ‘--log-file’ option.

‘--file=FILE’
‘-f FILE’
     Build the package, derivation, or other file-like object that the
     code within FILE evaluates to (*note file-like objects:
     G-Expressions.).

     As an example, FILE might contain a package definition like this
     (*note Defining Packages::):

          (use-modules (guix)
                       (guix build-system gnu)
                       (guix licenses))

          (package
            (name "hello")
            (version "2.10")
            (source (origin
                      (method url-fetch)
                      (uri (string-append "mirror://gnu/hello/hello-" version
                                          ".tar.gz"))
                      (sha256
                       (base32
                        "0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i"))))
            (build-system gnu-build-system)
            (synopsis "Hello, GNU world: An example GNU package")
            (description "Guess what GNU Hello prints!")
            (home-page "http://www.gnu.org/software/hello/")
            (license gpl3+))

     The FILE may also contain a JSON representation of one or more
     package definitions.  Running ‘guix build -f’ on ‘hello.json’ with
     the following contents would result in building the packages
     ‘myhello’ and ‘greeter’:

          [
            {
              "name": "myhello",
              "version": "2.10",
              "source": "mirror://gnu/hello/hello-2.10.tar.gz",
              "build-system": "gnu",
              "arguments": {
                "tests?": false
              }
              "home-page": "https://www.gnu.org/software/hello/",
              "synopsis": "Hello, GNU world: An example GNU package",
              "description": "GNU Hello prints a greeting.",
              "license": "GPL-3.0+",
              "native-inputs": ["gettext"]
            },
            {
              "name": "greeter",
              "version": "1.0",
              "source": "https://example.com/greeter-1.0.tar.gz",
              "build-system": "gnu",
              "arguments": {
                "test-target": "foo",
                "parallel-build?": false,
              },
              "home-page": "https://example.com/",
              "synopsis": "Greeter using GNU Hello",
              "description": "This is a wrapper around GNU Hello.",
              "license": "GPL-3.0+",
              "inputs": ["myhello", "hello"]
            }
          ]

‘--manifest=MANIFEST’
‘-m MANIFEST’
     Build all packages listed in the given MANIFEST (*note
     ‘--manifest’: profile-manifest.).

‘--expression=EXPR’
‘-e EXPR’
     Build the package or derivation EXPR evaluates to.

     For example, EXPR may be ‘(@ (gnu packages guile) guile-1.8)’,
     which unambiguously designates this specific variant of version 1.8
     of Guile.

     Alternatively, EXPR may be a G-expression, in which case it is used
     as a build program passed to ‘gexp->derivation’ (*note
     G-Expressions::).

     Lastly, EXPR may refer to a zero-argument monadic procedure (*note
     The Store Monad::).  The procedure must return a derivation as a
     monadic value, which is then passed through ‘run-with-store’.

‘--source’
‘-S’
     Build the source derivations of the packages, rather than the
     packages themselves.

     For instance, ‘guix build -S gcc’ returns something like
     ‘/gnu/store/...-gcc-4.7.2.tar.bz2’, which is the GCC source
     tarball.

     The returned source tarball is the result of applying any patches
     and code snippets specified in the package ‘origin’ (*note Defining
     Packages::).

     Note that ‘guix build -S’ compiles the sources only of the
     specified packages.  They do not include the sources of statically
     linked dependencies and by themselves are insufficient for
     reproducing the packages.

‘--sources’
     Fetch and return the source of PACKAGE-OR-DERIVATION and all their
     dependencies, recursively.  This is a handy way to obtain a local
     copy of all the source code needed to build PACKAGES, allowing you
     to eventually build them even without network access.  It is an
     extension of the ‘--source’ option and can accept one of the
     following optional argument values:

     ‘package’
          This value causes the ‘--sources’ option to behave in the same
          way as the ‘--source’ option.

     ‘all’
          Build the source derivations of all packages, including any
          source that might be listed as ‘inputs’.  This is the default
          value.

               $ guix build --sources tzdata
               The following derivations will be built:
                  /gnu/store/...-tzdata2015b.tar.gz.drv
                  /gnu/store/...-tzcode2015b.tar.gz.drv

     ‘transitive’
          Build the source derivations of all packages, as well of all
          transitive inputs to the packages.  This can be used e.g. to
          prefetch package source for later offline building.

               $ guix build --sources=transitive tzdata
               The following derivations will be built:
                  /gnu/store/...-tzcode2015b.tar.gz.drv
                  /gnu/store/...-findutils-4.4.2.tar.xz.drv
                  /gnu/store/...-grep-2.21.tar.xz.drv
                  /gnu/store/...-coreutils-8.23.tar.xz.drv
                  /gnu/store/...-make-4.1.tar.xz.drv
                  /gnu/store/...-bash-4.3.tar.xz.drv
               ...

‘--system=SYSTEM’
‘-s SYSTEM’
     Attempt to build for SYSTEM—e.g., ‘i686-linux’—instead of the
     system type of the build host.  The ‘guix build’ command allows you
     to repeat this option several times, in which case it builds for
     all the specified systems; other commands ignore extraneous ‘-s’
     options.

          Note: The ‘--system’ flag is for _native_ compilation and must
          not be confused with cross-compilation.  See ‘--target’ below
          for information on cross-compilation.

     An example use of this is on Linux-based systems, which can emulate
     different personalities.  For instance, passing
     ‘--system=i686-linux’ on an ‘x86_64-linux’ system or
     ‘--system=armhf-linux’ on an ‘aarch64-linux’ system allows you to
     build packages in a complete 32-bit environment.

          Note: Building for an ‘armhf-linux’ system is unconditionally
          enabled on ‘aarch64-linux’ machines, although certain aarch64
          chipsets do not allow for this functionality, notably the
          ThunderX.

     Similarly, when transparent emulation with QEMU and ‘binfmt_misc’
     is enabled (*note ‘qemu-binfmt-service-type’: Virtualization
     Services.), you can build for any system for which a QEMU
     ‘binfmt_misc’ handler is installed.

     Builds for a system other than that of the machine you are using
     can also be offloaded to a remote machine of the right
     architecture.  *Note Daemon Offload Setup::, for more information
     on offloading.

‘--target=TRIPLET’
     Cross-build for TRIPLET, which must be a valid GNU triplet, such as
     ‘"aarch64-linux-gnu"’ (*note GNU configuration triplets:
     (autoconf)Specifying Target Triplets.).

‘--check’
     Rebuild PACKAGE-OR-DERIVATION, which are already available in the
     store, and raise an error if the build results are not bit-for-bit
     identical.

     This mechanism allows you to check whether previously installed
     substitutes are genuine (*note Substitutes::), or whether the build
     result of a package is deterministic.  *Note Invoking guix
     challenge::, for more background information and tools.

     When used in conjunction with ‘--keep-failed’, the differing output
     is kept in the store, under ‘/gnu/store/...-check’.  This makes it
     easy to look for differences between the two results.

‘--repair’
     Attempt to repair the specified store items, if they are corrupt,
     by re-downloading or rebuilding them.

     This operation is not atomic and thus restricted to ‘root’.

‘--derivations’
‘-d’
     Return the derivation paths, not the output paths, of the given
     packages.

‘--root=FILE’
‘-r FILE’
     Make FILE a symlink to the result, and register it as a garbage
     collector root.

     Consequently, the results of this ‘guix build’ invocation are
     protected from garbage collection until FILE is removed.  When that
     option is omitted, build results are eligible for garbage
     collection as soon as the build completes.  *Note Invoking guix
     gc::, for more on GC roots.

‘--log-file’
     Return the build log file names or URLs for the given
     PACKAGE-OR-DERIVATION, or raise an error if build logs are missing.

     This works regardless of how packages or derivations are specified.
     For instance, the following invocations are equivalent:

          guix build --log-file `guix build -d guile`
          guix build --log-file `guix build guile`
          guix build --log-file guile
          guix build --log-file -e '(@ (gnu packages guile) guile-2.0)'

     If a log is unavailable locally, and unless ‘--no-substitutes’ is
     passed, the command looks for a corresponding log on one of the
     substitute servers (as specified with ‘--substitute-urls’).

     So for instance, imagine you want to see the build log of GDB on
     MIPS, but you are actually on an ‘x86_64’ machine:

          $ guix build --log-file gdb -s aarch64-linux
          https://ci.guix.gnu.org/log/...-gdb-7.10

     You can freely access a huge library of build logs!


File: guix.info,  Node: Debugging Build Failures,  Prev: Additional Build Options,  Up: Invoking guix build

7.1.4 Debugging Build Failures
------------------------------

When defining a new package (*note Defining Packages::), you will
probably find yourself spending some time debugging and tweaking the
build until it succeeds.  To do that, you need to operate the build
commands yourself in an environment as close as possible to the one the
build daemon uses.

   To that end, the first thing to do is to use the ‘--keep-failed’ or
‘-K’ option of ‘guix build’, which will keep the failed build tree in
‘/tmp’ or whatever directory you specified as ‘TMPDIR’ (*note
‘--keep-failed’: Invoking guix build.).

   From there on, you can ‘cd’ to the failed build tree and source the
‘environment-variables’ file, which contains all the environment
variable definitions that were in place when the build failed.  So let’s
say you’re debugging a build failure in package ‘foo’; a typical session
would look like this:

     $ guix build foo -K
     ... build fails
     $ cd /tmp/guix-build-foo.drv-0
     $ source ./environment-variables
     $ cd foo-1.2

   Now, you can invoke commands as if you were the daemon (almost) and
troubleshoot your build process.

   Sometimes it happens that, for example, a package’s tests pass when
you run them manually but they fail when the daemon runs them.  This can
happen because the daemon runs builds in containers where, unlike in our
environment above, network access is missing, ‘/bin/sh’ does not exist,
etc.  (*note Build Environment Setup::).

   In such cases, you may need to run inspect the build process from
within a container similar to the one the build daemon creates:

     $ guix build -K foo
     ...
     $ cd /tmp/guix-build-foo.drv-0
     $ guix environment --no-grafts -C foo --ad-hoc strace gdb
     [env]# source ./environment-variables
     [env]# cd foo-1.2

   Here, ‘guix environment -C’ creates a container and spawns a new
shell in it (*note Invoking guix environment::).  The ‘--ad-hoc strace
gdb’ part adds the ‘strace’ and ‘gdb’ commands to the container, which
you may find handy while debugging.  The ‘--no-grafts’ option makes sure
we get the exact same environment, with ungrafted packages (*note
Security Updates::, for more info on grafts).

   To get closer to a container like that used by the build daemon, we
can remove ‘/bin/sh’:

     [env]# rm /bin/sh

   (Don’t worry, this is harmless: this is all happening in the
throw-away container created by ‘guix environment’.)

   The ‘strace’ command is probably not in the search path, but we can
run:

     [env]# $GUIX_ENVIRONMENT/bin/strace -f -o log make check

   In this way, not only you will have reproduced the environment
variables the daemon uses, you will also be running the build process in
a container similar to the one the daemon uses.


File: guix.info,  Node: Invoking guix edit,  Next: Invoking guix download,  Prev: Invoking guix build,  Up: Utilities

7.2 Invoking ‘guix edit’
========================

So many packages, so many source files!  The ‘guix edit’ command
facilitates the life of users and packagers by pointing their editor at
the source file containing the definition of the specified packages.
For instance:

     guix edit gcc@4.9 vim

launches the program specified in the ‘VISUAL’ or in the ‘EDITOR’
environment variable to view the recipe of GCC 4.9.3 and that of Vim.

   If you are using a Guix Git checkout (*note Building from Git::), or
have created your own packages on ‘GUIX_PACKAGE_PATH’ (*note Package
Modules::), you will be able to edit the package recipes.  In other
cases, you will be able to examine the read-only recipes for packages
currently in the store.

   Instead of ‘GUIX_PACKAGE_PATH’, the command-line option
‘--load-path=DIRECTORY’ (or in short ‘-L DIRECTORY’) allows you to add
DIRECTORY to the front of the package module search path and so make
your own packages visible.


File: guix.info,  Node: Invoking guix download,  Next: Invoking guix hash,  Prev: Invoking guix edit,  Up: Utilities

7.3 Invoking ‘guix download’
============================

When writing a package definition, developers typically need to download
a source tarball, compute its SHA256 hash, and write that hash in the
package definition (*note Defining Packages::).  The ‘guix download’
tool helps with this task: it downloads a file from the given URI, adds
it to the store, and prints both its file name in the store and its
SHA256 hash.

   The fact that the downloaded file is added to the store saves
bandwidth: when the developer eventually tries to build the newly
defined package with ‘guix build’, the source tarball will not have to
be downloaded again because it is already in the store.  It is also a
convenient way to temporarily stash files, which may be deleted
eventually (*note Invoking guix gc::).

   The ‘guix download’ command supports the same URIs as used in package
definitions.  In particular, it supports ‘mirror://’ URIs.  ‘https’ URIs
(HTTP over TLS) are supported _provided_ the Guile bindings for GnuTLS
are available in the user’s environment; when they are not available, an
error is raised.  *Note how to install the GnuTLS bindings for Guile:
(gnutls-guile)Guile Preparations, for more information.

   ‘guix download’ verifies HTTPS server certificates by loading the
certificates of X.509 authorities from the directory pointed to by the
‘SSL_CERT_DIR’ environment variable (*note X.509 Certificates::), unless
‘--no-check-certificate’ is used.

   The following options are available:

‘--hash=ALGORITHM’
‘-H ALGORITHM’
     Compute a hash using the specified ALGORITHM.  *Note Invoking guix
     hash::, for more information.

‘--format=FMT’
‘-f FMT’
     Write the hash in the format specified by FMT.  For more
     information on the valid values for FMT, *note Invoking guix
     hash::.

‘--no-check-certificate’
     Do not validate the X.509 certificates of HTTPS servers.

     When using this option, you have _absolutely no guarantee_ that you
     are communicating with the authentic server responsible for the
     given URL, which makes you vulnerable to “man-in-the-middle”
     attacks.

‘--output=FILE’
‘-o FILE’
     Save the downloaded file to FILE instead of adding it to the store.


File: guix.info,  Node: Invoking guix hash,  Next: Invoking guix import,  Prev: Invoking guix download,  Up: Utilities

7.4 Invoking ‘guix hash’
========================

The ‘guix hash’ command computes the SHA256 hash of a file.  It is
primarily a convenience tool for anyone contributing to the
distribution: it computes the cryptographic hash of a file, which can be
used in the definition of a package (*note Defining Packages::).

   The general syntax is:

     guix hash OPTION FILE

   When FILE is ‘-’ (a hyphen), ‘guix hash’ computes the hash of data
read from standard input.  ‘guix hash’ has the following options:

‘--hash=ALGORITHM’
‘-H ALGORITHM’
     Compute a hash using the specified ALGORITHM, ‘sha256’ by default.

     ALGORITHM must the name of a cryptographic hash algorithm supported
     by Libgcrypt via Guile-Gcrypt—e.g., ‘sha512’ or ‘sha3-256’ (*note
     (guile-gcrypt)Hash Functions::).

‘--format=FMT’
‘-f FMT’
     Write the hash in the format specified by FMT.

     Supported formats: ‘base64’, ‘nix-base32’, ‘base32’, ‘base16’
     (‘hex’ and ‘hexadecimal’ can be used as well).

     If the ‘--format’ option is not specified, ‘guix hash’ will output
     the hash in ‘nix-base32’.  This representation is used in the
     definitions of packages.

‘--recursive’
‘-r’
     Compute the hash on FILE recursively.

     In this case, the hash is computed on an archive containing FILE,
     including its children if it is a directory.  Some of the metadata
     of FILE is part of the archive; for instance, when FILE is a
     regular file, the hash is different depending on whether FILE is
     executable or not.  Metadata such as time stamps has no impact on
     the hash (*note Invoking guix archive::).

‘--exclude-vcs’
‘-x’
     When combined with ‘--recursive’, exclude version control system
     directories (‘.bzr’, ‘.git’, ‘.hg’, etc.).

     As an example, here is how you would compute the hash of a Git
     checkout, which is useful when using the ‘git-fetch’ method (*note
     origin Reference::):

          $ git clone http://example.org/foo.git
          $ cd foo
          $ guix hash -rx .


File: guix.info,  Node: Invoking guix import,  Next: Invoking guix refresh,  Prev: Invoking guix hash,  Up: Utilities

7.5 Invoking ‘guix import’
==========================

The ‘guix import’ command is useful for people who would like to add a
package to the distribution with as little work as possible—a legitimate
demand.  The command knows of a few repositories from which it can
“import” package metadata.  The result is a package definition, or a
template thereof, in the format we know (*note Defining Packages::).

   The general syntax is:

     guix import IMPORTER OPTIONS...

   IMPORTER specifies the source from which to import package metadata,
and OPTIONS specifies a package identifier and other options specific to
IMPORTER.

   Some of the importers rely on the ability to run the ‘gpgv’ command.
For these, GnuPG must be installed and in ‘$PATH’; run ‘guix install
gnupg’ if needed.

   Currently, the available “importers” are:

‘gnu’
     Import metadata for the given GNU package.  This provides a
     template for the latest version of that GNU package, including the
     hash of its source tarball, and its canonical synopsis and
     description.

     Additional information such as the package dependencies and its
     license needs to be figured out manually.

     For example, the following command returns a package definition for
     GNU Hello:

          guix import gnu hello

     Specific command-line options are:

     ‘--key-download=POLICY’
          As for ‘guix refresh’, specify the policy to handle missing
          OpenPGP keys when verifying the package signature.  *Note
          ‘--key-download’: Invoking guix refresh.

‘pypi’
     Import metadata from the Python Package Index
     (https://pypi.python.org/).  Information is taken from the
     JSON-formatted description available at ‘pypi.python.org’ and
     usually includes all the relevant information, including package
     dependencies.  For maximum efficiency, it is recommended to install
     the ‘unzip’ utility, so that the importer can unzip Python wheels
     and gather data from them.

     The command below imports metadata for the ‘itsdangerous’ Python
     package:

          guix import pypi itsdangerous

     ‘--recursive’
     ‘-r’
          Traverse the dependency graph of the given upstream package
          recursively and generate package expressions for all those
          packages that are not yet in Guix.

‘gem’
     Import metadata from RubyGems (https://rubygems.org/).  Information
     is taken from the JSON-formatted description available at
     ‘rubygems.org’ and includes most relevant information, including
     runtime dependencies.  There are some caveats, however.  The
     metadata doesn’t distinguish between synopses and descriptions, so
     the same string is used for both fields.  Additionally, the details
     of non-Ruby dependencies required to build native extensions is
     unavailable and left as an exercise to the packager.

     The command below imports metadata for the ‘rails’ Ruby package:

          guix import gem rails

     ‘--recursive’
     ‘-r’
          Traverse the dependency graph of the given upstream package
          recursively and generate package expressions for all those
          packages that are not yet in Guix.

‘cpan’
     Import metadata from MetaCPAN (https://www.metacpan.org/).
     Information is taken from the JSON-formatted metadata provided
     through MetaCPAN’s API (https://fastapi.metacpan.org/) and includes
     most relevant information, such as module dependencies.  License
     information should be checked closely.  If Perl is available in the
     store, then the ‘corelist’ utility will be used to filter core
     modules out of the list of dependencies.

     The command command below imports metadata for the Acme::Boolean
     Perl module:

          guix import cpan Acme::Boolean

‘cran’
     Import metadata from CRAN (https://cran.r-project.org/), the
     central repository for the GNU R statistical and graphical
     environment (https://r-project.org).

     Information is extracted from the ‘DESCRIPTION’ file of the
     package.

     The command command below imports metadata for the Cairo R package:

          guix import cran Cairo

     When ‘--recursive’ is added, the importer will traverse the
     dependency graph of the given upstream package recursively and
     generate package expressions for all those packages that are not
     yet in Guix.

     When ‘--archive=bioconductor’ is added, metadata is imported from
     Bioconductor (https://www.bioconductor.org/), a repository of R
     packages for for the analysis and comprehension of high-throughput
     genomic data in bioinformatics.

     Information is extracted from the ‘DESCRIPTION’ file contained in
     the package archive.

     The command below imports metadata for the GenomicRanges R package:

          guix import cran --archive=bioconductor GenomicRanges

     Finally, you can also import R packages that have not yet been
     published on CRAN or Bioconductor as long as they are in a git
     repository.  Use ‘--archive=git’ followed by the URL of the git
     repository:

          guix import cran --archive=git https://github.com/immunogenomics/harmony

‘texlive’
     Import metadata from CTAN (https://www.ctan.org/), the
     comprehensive TeX archive network for TeX packages that are part of
     the TeX Live distribution (https://www.tug.org/texlive/).

     Information about the package is obtained through the XML API
     provided by CTAN, while the source code is downloaded from the SVN
     repository of the Tex Live project.  This is done because the CTAN
     does not keep versioned archives.

     The command command below imports metadata for the ‘fontspec’ TeX
     package:

          guix import texlive fontspec

     When ‘--archive=DIRECTORY’ is added, the source code is downloaded
     not from the ‘latex’ sub-directory of the ‘texmf-dist/source’ tree
     in the TeX Live SVN repository, but from the specified sibling
     DIRECTORY under the same root.

     The command below imports metadata for the ‘ifxetex’ package from
     CTAN while fetching the sources from the directory
     ‘texmf/source/generic’:

          guix import texlive --archive=generic ifxetex

‘json’
     Import package metadata from a local JSON file.  Consider the
     following example package definition in JSON format:

          {
            "name": "hello",
            "version": "2.10",
            "source": "mirror://gnu/hello/hello-2.10.tar.gz",
            "build-system": "gnu",
            "home-page": "https://www.gnu.org/software/hello/",
            "synopsis": "Hello, GNU world: An example GNU package",
            "description": "GNU Hello prints a greeting.",
            "license": "GPL-3.0+",
            "native-inputs": ["gettext"]
          }

     The field names are the same as for the ‘<package>’ record (*Note
     Defining Packages::).  References to other packages are provided as
     JSON lists of quoted package specification strings such as ‘guile’
     or ‘guile@2.0’.

     The importer also supports a more explicit source definition using
     the common fields for ‘<origin>’ records:

          {
            ...
            "source": {
              "method": "url-fetch",
              "uri": "mirror://gnu/hello/hello-2.10.tar.gz",
              "sha256": {
                "base32": "0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i"
              }
            }
            ...
          }

     The command below reads metadata from the JSON file ‘hello.json’
     and outputs a package expression:

          guix import json hello.json

‘nix’
     Import metadata from a local copy of the source of the Nixpkgs
     distribution (https://nixos.org/nixpkgs/)(1).  Package definitions
     in Nixpkgs are typically written in a mixture of Nix-language and
     Bash code.  This command only imports the high-level package
     structure that is written in the Nix language.  It normally
     includes all the basic fields of a package definition.

     When importing a GNU package, the synopsis and descriptions are
     replaced by their canonical upstream variant.

     Usually, you will first need to do:

          export NIX_REMOTE=daemon

     so that ‘nix-instantiate’ does not try to open the Nix database.

     As an example, the command below imports the package definition of
     LibreOffice (more precisely, it imports the definition of the
     package bound to the ‘libreoffice’ top-level attribute):

          guix import nix ~/path/to/nixpkgs libreoffice

‘hackage’
     Import metadata from the Haskell community’s central package
     archive Hackage (https://hackage.haskell.org/).  Information is
     taken from Cabal files and includes all the relevant information,
     including package dependencies.

     Specific command-line options are:

     ‘--stdin’
     ‘-s’
          Read a Cabal file from standard input.
     ‘--no-test-dependencies’
     ‘-t’
          Do not include dependencies required only by the test suites.
     ‘--cabal-environment=ALIST’
     ‘-e ALIST’
          ALIST is a Scheme alist defining the environment in which the
          Cabal conditionals are evaluated.  The accepted keys are:
          ‘os’, ‘arch’, ‘impl’ and a string representing the name of a
          flag.  The value associated with a flag has to be either the
          symbol ‘true’ or ‘false’.  The value associated with other
          keys has to conform to the Cabal file format definition.  The
          default value associated with the keys ‘os’, ‘arch’ and ‘impl’
          is ‘linux’, ‘x86_64’ and ‘ghc’, respectively.
     ‘--recursive’
     ‘-r’
          Traverse the dependency graph of the given upstream package
          recursively and generate package expressions for all those
          packages that are not yet in Guix.

     The command below imports metadata for the latest version of the
     HTTP Haskell package without including test dependencies and
     specifying the value of the flag ‘network-uri’ as ‘false’:

          guix import hackage -t -e "'((\"network-uri\" . false))" HTTP

     A specific package version may optionally be specified by following
     the package name by an at-sign and a version number as in the
     following example:

          guix import hackage mtl@2.1.3.1

‘stackage’
     The ‘stackage’ importer is a wrapper around the ‘hackage’ one.  It
     takes a package name, looks up the package version included in a
     long-term support (LTS) Stackage (https://www.stackage.org) release
     and uses the ‘hackage’ importer to retrieve its metadata.  Note
     that it is up to you to select an LTS release compatible with the
     GHC compiler used by Guix.

     Specific command-line options are:

     ‘--no-test-dependencies’
     ‘-t’
          Do not include dependencies required only by the test suites.
     ‘--lts-version=VERSION’
     ‘-l VERSION’
          VERSION is the desired LTS release version.  If omitted the
          latest release is used.
     ‘--recursive’
     ‘-r’
          Traverse the dependency graph of the given upstream package
          recursively and generate package expressions for all those
          packages that are not yet in Guix.

     The command below imports metadata for the HTTP Haskell package
     included in the LTS Stackage release version 7.18:

          guix import stackage --lts-version=7.18 HTTP

‘elpa’
     Import metadata from an Emacs Lisp Package Archive (ELPA) package
     repository (*note (emacs)Packages::).

     Specific command-line options are:

     ‘--archive=REPO’
     ‘-a REPO’
          REPO identifies the archive repository from which to retrieve
          the information.  Currently the supported repositories and
          their identifiers are:
             - GNU (https://elpa.gnu.org/packages), selected by the
               ‘gnu’ identifier.  This is the default.

               Packages from ‘elpa.gnu.org’ are signed with one of the
               keys contained in the GnuPG keyring at
               ‘share/emacs/25.1/etc/package-keyring.gpg’ (or similar)
               in the ‘emacs’ package (*note ELPA package signatures:
               (emacs)Package Installation.).

             - MELPA-Stable (https://stable.melpa.org/packages),
               selected by the ‘melpa-stable’ identifier.

             - MELPA (https://melpa.org/packages), selected by the
               ‘melpa’ identifier.

     ‘--recursive’
     ‘-r’
          Traverse the dependency graph of the given upstream package
          recursively and generate package expressions for all those
          packages that are not yet in Guix.

‘crate’
     Import metadata from the crates.io Rust package repository
     crates.io (https://crates.io), as in this example:

          guix import crate blake2-rfc

     The crate importer also allows you to specify a version string:

          guix import crate constant-time-eq@0.1.0

     Additional options include:

     ‘--recursive’
     ‘-r’
          Traverse the dependency graph of the given upstream package
          recursively and generate package expressions for all those
          packages that are not yet in Guix.

‘opam’
     Import metadata from the OPAM (https://opam.ocaml.org/) package
     repository used by the OCaml community.

   The structure of the ‘guix import’ code is modular.  It would be
useful to have more importers for other package formats, and your help
is welcome here (*note Contributing::).

   ---------- Footnotes ----------

   (1) This relies on the ‘nix-instantiate’ command of Nix
(https://nixos.org/nix/).


File: guix.info,  Node: Invoking guix refresh,  Next: Invoking guix lint,  Prev: Invoking guix import,  Up: Utilities

7.6 Invoking ‘guix refresh’
===========================

The primary audience of the ‘guix refresh’ command is developers of the
GNU software distribution.  By default, it reports any packages provided
by the distribution that are outdated compared to the latest upstream
version, like this:

     $ guix refresh
     gnu/packages/gettext.scm:29:13: gettext would be upgraded from 0.18.1.1 to 0.18.2.1
     gnu/packages/glib.scm:77:12: glib would be upgraded from 2.34.3 to 2.37.0

   Alternatively, one can specify packages to consider, in which case a
warning is emitted for packages that lack an updater:

     $ guix refresh coreutils guile guile-ssh
     gnu/packages/ssh.scm:205:2: warning: no updater for guile-ssh
     gnu/packages/guile.scm:136:12: guile would be upgraded from 2.0.12 to 2.0.13

   ‘guix refresh’ browses the upstream repository of each package and
determines the highest version number of the releases therein.  The
command knows how to update specific types of packages: GNU packages,
ELPA packages, etc.—see the documentation for ‘--type’ below.  There are
many packages, though, for which it lacks a method to determine whether
a new upstream release is available.  However, the mechanism is
extensible, so feel free to get in touch with us to add a new method!

‘--recursive’
     Consider the packages specified, and all the packages upon which
     they depend.

          $ guix refresh --recursive coreutils
          gnu/packages/acl.scm:35:2: warning: no updater for acl
          gnu/packages/m4.scm:30:12: info: 1.4.18 is already the latest version of m4
          gnu/packages/xml.scm:68:2: warning: no updater for expat
          gnu/packages/multiprecision.scm:40:12: info: 6.1.2 is already the latest version of gmp
          ...

   Sometimes the upstream name differs from the package name used in
Guix, and ‘guix refresh’ needs a little help.  Most updaters honor the
‘upstream-name’ property in package definitions, which can be used to
that effect:

     (define-public network-manager
       (package
         (name "network-manager")
         ;; ...
         (properties '((upstream-name . "NetworkManager")))))

   When passed ‘--update’, it modifies distribution source files to
update the version numbers and source tarball hashes of those package
recipes (*note Defining Packages::).  This is achieved by downloading
each package’s latest source tarball and its associated OpenPGP
signature, authenticating the downloaded tarball against its signature
using ‘gpgv’, and finally computing its hash—note that GnuPG must be
installed and in ‘$PATH’; run ‘guix install gnupg’ if needed.

   When the public key used to sign the tarball is missing from the
user’s keyring, an attempt is made to automatically retrieve it from a
public key server; when this is successful, the key is added to the
user’s keyring; otherwise, ‘guix refresh’ reports an error.

   The following options are supported:

‘--expression=EXPR’
‘-e EXPR’
     Consider the package EXPR evaluates to.

     This is useful to precisely refer to a package, as in this example:

          guix refresh -l -e '(@@ (gnu packages commencement) glibc-final)'

     This command lists the dependents of the “final” libc (essentially
     all the packages).

‘--update’
‘-u’
     Update distribution source files (package recipes) in place.  This
     is usually run from a checkout of the Guix source tree (*note
     Running Guix Before It Is Installed::):

          $ ./pre-inst-env guix refresh -s non-core -u

     *Note Defining Packages::, for more information on package
     definitions.

‘--select=[SUBSET]’
‘-s SUBSET’
     Select all the packages in SUBSET, one of ‘core’ or ‘non-core’.

     The ‘core’ subset refers to all the packages at the core of the
     distribution—i.e., packages that are used to build “everything
     else”.  This includes GCC, libc, Binutils, Bash, etc.  Usually,
     changing one of these packages in the distribution entails a
     rebuild of all the others.  Thus, such updates are an inconvenience
     to users in terms of build time or bandwidth used to achieve the
     upgrade.

     The ‘non-core’ subset refers to the remaining packages.  It is
     typically useful in cases where an update of the core packages
     would be inconvenient.

‘--manifest=FILE’
‘-m FILE’
     Select all the packages from the manifest in FILE.  This is useful
     to check if any packages of the user manifest can be updated.

‘--type=UPDATER’
‘-t UPDATER’
     Select only packages handled by UPDATER (may be a comma-separated
     list of updaters).  Currently, UPDATER may be one of:

     ‘gnu’
          the updater for GNU packages;
     ‘gnome’
          the updater for GNOME packages;
     ‘kde’
          the updater for KDE packages;
     ‘xorg’
          the updater for X.org packages;
     ‘kernel.org’
          the updater for packages hosted on kernel.org;
     ‘elpa’
          the updater for ELPA (https://elpa.gnu.org/) packages;
     ‘cran’
          the updater for CRAN (https://cran.r-project.org/) packages;
     ‘bioconductor’
          the updater for Bioconductor (https://www.bioconductor.org/) R
          packages;
     ‘cpan’
          the updater for CPAN (https://www.cpan.org/) packages;
     ‘pypi’
          the updater for PyPI (https://pypi.python.org) packages.
     ‘gem’
          the updater for RubyGems (https://rubygems.org) packages.
     ‘github’
          the updater for GitHub (https://github.com) packages.
     ‘hackage’
          the updater for Hackage (https://hackage.haskell.org)
          packages.
     ‘stackage’
          the updater for Stackage (https://www.stackage.org) packages.
     ‘crate’
          the updater for Crates (https://crates.io) packages.
     ‘launchpad’
          the updater for Launchpad (https://launchpad.net) packages.

     For instance, the following command only checks for updates of
     Emacs packages hosted at ‘elpa.gnu.org’ and for updates of CRAN
     packages:

          $ guix refresh --type=elpa,cran
          gnu/packages/statistics.scm:819:13: r-testthat would be upgraded from 0.10.0 to 0.11.0
          gnu/packages/emacs.scm:856:13: emacs-auctex would be upgraded from 11.88.6 to 11.88.9

   In addition, ‘guix refresh’ can be passed one or more package names,
as in this example:

     $ ./pre-inst-env guix refresh -u emacs idutils gcc@4.8

The command above specifically updates the ‘emacs’ and ‘idutils’
packages.  The ‘--select’ option would have no effect in this case.

   When considering whether to upgrade a package, it is sometimes
convenient to know which packages would be affected by the upgrade and
should be checked for compatibility.  For this the following option may
be used when passing ‘guix refresh’ one or more package names:

‘--list-updaters’
‘-L’
     List available updaters and exit (see ‘--type’ above).

     For each updater, display the fraction of packages it covers; at
     the end, display the fraction of packages covered by all these
     updaters.

‘--list-dependent’
‘-l’
     List top-level dependent packages that would need to be rebuilt as
     a result of upgrading one or more packages.

     *Note the ‘reverse-package’ type of ‘guix graph’: Invoking guix
     graph, for information on how to visualize the list of dependents
     of a package.

   Be aware that the ‘--list-dependent’ option only _approximates_ the
rebuilds that would be required as a result of an upgrade.  More
rebuilds might be required under some circumstances.

     $ guix refresh --list-dependent flex
     Building the following 120 packages would ensure 213 dependent packages are rebuilt:
     hop@2.4.0 geiser@0.4 notmuch@0.18 mu@0.9.9.5 cflow@1.4 idutils@4.6 ...

   The command above lists a set of packages that could be built to
check for compatibility with an upgraded ‘flex’ package.

‘--list-transitive’
     List all the packages which one or more packages depend upon.

          $ guix refresh --list-transitive flex
          flex@2.6.4 depends on the following 25 packages: perl@5.28.0 help2man@1.47.6
          bison@3.0.5 indent@2.2.10 tar@1.30 gzip@1.9 bzip2@1.0.6 xz@5.2.4 file@5.33 ...

   The command above lists a set of packages which, when changed, would
cause ‘flex’ to be rebuilt.

   The following options can be used to customize GnuPG operation:

‘--gpg=COMMAND’
     Use COMMAND as the GnuPG 2.x command.  COMMAND is searched for in
     ‘$PATH’.

‘--keyring=FILE’
     Use FILE as the keyring for upstream keys.  FILE must be in the
     “keybox format”.  Keybox files usually have a name ending in ‘.kbx’
     and the GNU Privacy Guard (GPG) can manipulate these files (*note
     ‘kbxutil’: (gnupg)kbxutil, for information on a tool to manipulate
     keybox files).

     When this option is omitted, ‘guix refresh’ uses
     ‘~/.config/guix/upstream/trustedkeys.kbx’ as the keyring for
     upstream signing keys.  OpenPGP signatures are checked against keys
     from this keyring; missing keys are downloaded to this keyring as
     well (see ‘--key-download’ below).

     You can export keys from your default GPG keyring into a keybox
     file using commands like this one:

          gpg --export rms@gnu.org | kbxutil --import-openpgp >> mykeyring.kbx

     Likewise, you can fetch keys to a specific keybox file like this:

          gpg --no-default-keyring --keyring mykeyring.kbx \
            --recv-keys 3CE464558A84FDC69DB40CFB090B11993D9AEBB5

     *note ‘--keyring’: (gnupg)GPG Configuration Options, for more
     information on GPG’s ‘--keyring’ option.

‘--key-download=POLICY’
     Handle missing OpenPGP keys according to POLICY, which may be one
     of:

     ‘always’
          Always download missing OpenPGP keys from the key server, and
          add them to the user’s GnuPG keyring.

     ‘never’
          Never try to download missing OpenPGP keys.  Instead just bail
          out.

     ‘interactive’
          When a package signed with an unknown OpenPGP key is
          encountered, ask the user whether to download it or not.  This
          is the default behavior.

‘--key-server=HOST’
     Use HOST as the OpenPGP key server when importing a public key.

‘--load-path=DIRECTORY’
     Add DIRECTORY to the front of the package module search path (*note
     Package Modules::).

     This allows users to define their own packages and make them
     visible to the command-line tools.

   The ‘github’ updater uses the GitHub API
(https://developer.github.com/v3/) to query for new releases.  When used
repeatedly e.g. when refreshing all packages, GitHub will eventually
refuse to answer any further API requests.  By default 60 API requests
per hour are allowed, and a full refresh on all GitHub packages in Guix
requires more than this.  Authentication with GitHub through the use of
an API token alleviates these limits.  To use an API token, set the
environment variable ‘GUIX_GITHUB_TOKEN’ to a token procured from
<https://github.com/settings/tokens> or otherwise.


File: guix.info,  Node: Invoking guix lint,  Next: Invoking guix size,  Prev: Invoking guix refresh,  Up: Utilities

7.7 Invoking ‘guix lint’
========================

The ‘guix lint’ command is meant to help package developers avoid common
errors and use a consistent style.  It runs a number of checks on a
given set of packages in order to find common mistakes in their
definitions.  Available “checkers” include (see ‘--list-checkers’ for a
complete list):

‘synopsis’
‘description’
     Validate certain typographical and stylistic rules about package
     descriptions and synopses.

‘inputs-should-be-native’
     Identify inputs that should most likely be native inputs.

‘source’
‘home-page’
‘mirror-url’
‘github-url’
‘source-file-name’
     Probe ‘home-page’ and ‘source’ URLs and report those that are
     invalid.  Suggest a ‘mirror://’ URL when applicable.  If the
     ‘source’ URL redirects to a GitHub URL, recommend usage of the
     GitHub URL. Check that the source file name is meaningful, e.g. is
     not just a version number or “git-checkout”, without a declared
     ‘file-name’ (*note origin Reference::).

‘source-unstable-tarball’
     Parse the ‘source’ URL to determine if a tarball from GitHub is
     autogenerated or if it is a release tarball.  Unfortunately
     GitHub’s autogenerated tarballs are sometimes regenerated.

‘archival’
     Checks whether the package’s source code is archived at Software
     Heritage (https://www.softwareheritage.org).

     When the source code that is not archived comes from a
     version-control system (VCS)—e.g., it’s obtained with ‘git-fetch’,
     send Software Heritage a “save” request so that it eventually
     archives it.  This ensures that the source will remain available in
     the long term, and that Guix can fall back to Software Heritage
     should the source code disappear from its original host.  The
     status of recent “save” requests can be viewed on-line
     (https://archive.softwareheritage.org/save/#requests).

     When source code is a tarball obtained with ‘url-fetch’, simply
     print a message when it is not archived.  As of this writing,
     Software Heritage does not allow requests to save arbitrary
     tarballs; we are working on ways to ensure that non-VCS source code
     is also archived.

     Software Heritage limits the request rate per IP address
     (https://archive.softwareheritage.org/api/#rate-limiting).  When
     the limit is reached, ‘guix lint’ prints a message and the
     ‘archival’ checker stops doing anything until that limit has been
     reset.

‘cve’
     Report known vulnerabilities found in the Common Vulnerabilities
     and Exposures (CVE) databases of the current and past year
     published by the US NIST (https://nvd.nist.gov/vuln/data-feeds).

     To view information about a particular vulnerability, visit pages
     such as:

        • 
          ‘https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-YYYY-ABCD’
        • ‘https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-YYYY-ABCD’

     where ‘CVE-YYYY-ABCD’ is the CVE identifier—e.g., ‘CVE-2015-7554’.

     Package developers can specify in package recipes the Common
     Platform Enumeration (CPE) (https://nvd.nist.gov/products/cpe) name
     and version of the package when they differ from the name or
     version that Guix uses, as in this example:

          (package
            (name "grub")
            ;; ...
            ;; CPE calls this package "grub2".
            (properties '((cpe-name . "grub2")
                          (cpe-version . "2.3"))))

     Some entries in the CVE database do not specify which version of a
     package they apply to, and would thus “stick around” forever.
     Package developers who found CVE alerts and verified they can be
     ignored can declare them as in this example:

          (package
            (name "t1lib")
            ;; ...
            ;; These CVEs no longer apply and can be safely ignored.
            (properties `((lint-hidden-cve . ("CVE-2011-0433"
                                              "CVE-2011-1553"
                                              "CVE-2011-1554"
                                              "CVE-2011-5244")))))

‘formatting’
     Warn about obvious source code formatting issues: trailing white
     space, use of tabulations, etc.

   The general syntax is:

     guix lint OPTIONS PACKAGE...

   If no package is given on the command line, then all packages are
checked.  The OPTIONS may be zero or more of the following:

‘--list-checkers’
‘-l’
     List and describe all the available checkers that will be run on
     packages and exit.

‘--checkers’
‘-c’
     Only enable the checkers specified in a comma-separated list using
     the names returned by ‘--list-checkers’.

‘--load-path=DIRECTORY’
‘-L DIRECTORY’
     Add DIRECTORY to the front of the package module search path (*note
     Package Modules::).

     This allows users to define their own packages and make them
     visible to the command-line tools.


File: guix.info,  Node: Invoking guix size,  Next: Invoking guix graph,  Prev: Invoking guix lint,  Up: Utilities

7.8 Invoking ‘guix size’
========================

The ‘guix size’ command helps package developers profile the disk usage
of packages.  It is easy to overlook the impact of an additional
dependency added to a package, or the impact of using a single output
for a package that could easily be split (*note Packages with Multiple
Outputs::).  Such are the typical issues that ‘guix size’ can highlight.

   The command can be passed one or more package specifications such as
‘gcc@4.8’ or ‘guile:debug’, or a file name in the store.  Consider this
example:

     $ guix size coreutils
     store item                               total    self
     /gnu/store/...-gcc-5.5.0-lib           60.4    30.1  38.1%
     /gnu/store/...-glibc-2.27              30.3    28.8  36.6%
     /gnu/store/...-coreutils-8.28          78.9    15.0  19.0%
     /gnu/store/...-gmp-6.1.2               63.1     2.7   3.4%
     /gnu/store/...-bash-static-4.4.12       1.5     1.5   1.9%
     /gnu/store/...-acl-2.2.52              61.1     0.4   0.5%
     /gnu/store/...-attr-2.4.47             60.6     0.2   0.3%
     /gnu/store/...-libcap-2.25             60.5     0.2   0.2%
     total: 78.9 MiB

   The store items listed here constitute the “transitive closure” of
Coreutils—i.e., Coreutils and all its dependencies, recursively—as would
be returned by:

     $ guix gc -R /gnu/store/...-coreutils-8.23

   Here the output shows three columns next to store items.  The first
column, labeled “total”, shows the size in mebibytes (MiB) of the
closure of the store item—that is, its own size plus the size of all its
dependencies.  The next column, labeled “self”, shows the size of the
item itself.  The last column shows the ratio of the size of the item
itself to the space occupied by all the items listed here.

   In this example, we see that the closure of Coreutils weighs in at
79 MiB, most of which is taken by libc and GCC’s run-time support
libraries.  (That libc and GCC’s libraries represent a large fraction of
the closure is not a problem per se because they are always available on
the system anyway.)

   Since the command also accepts store file names, assessing the size
of a build result is straightforward:

     guix size $(guix system build config.scm)

   When the package(s) passed to ‘guix size’ are available in the
store(1), ‘guix size’ queries the daemon to determine its dependencies,
and measures its size in the store, similar to ‘du -ms --apparent-size’
(*note (coreutils)du invocation::).

   When the given packages are _not_ in the store, ‘guix size’ reports
information based on the available substitutes (*note Substitutes::).
This makes it possible it to profile disk usage of store items that are
not even on disk, only available remotely.

   You can also specify several package names:

     $ guix size coreutils grep sed bash
     store item                               total    self
     /gnu/store/...-coreutils-8.24          77.8    13.8  13.4%
     /gnu/store/...-grep-2.22               73.1     0.8   0.8%
     /gnu/store/...-bash-4.3.42             72.3     4.7   4.6%
     /gnu/store/...-readline-6.3            67.6     1.2   1.2%
     ...
     total: 102.3 MiB

In this example we see that the combination of the four packages takes
102.3 MiB in total, which is much less than the sum of each closure
since they have a lot of dependencies in common.

   When looking at the profile returned by ‘guix size’, you may find
yourself wondering why a given package shows up in the profile at all.
To understand it, you can use ‘guix graph --path -t references’ to
display the shortest path between the two packages (*note Invoking guix
graph::).

   The available options are:

‘--substitute-urls=URLS’
     Use substitute information from URLS.  *Note the same option for
     ‘guix build’: client-substitute-urls.

‘--sort=KEY’
     Sort lines according to KEY, one of the following options:

     ‘self’
          the size of each item (the default);
     ‘closure’
          the total size of the item’s closure.

‘--map-file=FILE’
     Write a graphical map of disk usage in PNG format to FILE.

     For the example above, the map looks like this:

 [image src="images/coreutils-size-map.png" alt="map of Coreutils disk usage
produced by guix size" ]

     This option requires that Guile-Charting
     (https://wingolog.org/software/guile-charting/) be installed and
     visible in Guile’s module search path.  When that is not the case,
     ‘guix size’ fails as it tries to load it.

‘--system=SYSTEM’
‘-s SYSTEM’
     Consider packages for SYSTEM—e.g., ‘x86_64-linux’.

‘--load-path=DIRECTORY’
‘-L DIRECTORY’
     Add DIRECTORY to the front of the package module search path (*note
     Package Modules::).

     This allows users to define their own packages and make them
     visible to the command-line tools.

   ---------- Footnotes ----------

   (1) More precisely, ‘guix size’ looks for the _ungrafted_ variant of
the given package(s), as returned by ‘guix build PACKAGE --no-grafts’.
*Note Security Updates::, for information on grafts.


File: guix.info,  Node: Invoking guix graph,  Next: Invoking guix publish,  Prev: Invoking guix size,  Up: Utilities

7.9 Invoking ‘guix graph’
=========================

Packages and their dependencies form a “graph”, specifically a directed
acyclic graph (DAG). It can quickly become difficult to have a mental
model of the package DAG, so the ‘guix graph’ command provides a visual
representation of the DAG. By default, ‘guix graph’ emits a DAG
representation in the input format of Graphviz
(https://www.graphviz.org/), so its output can be passed directly to the
‘dot’ command of Graphviz.  It can also emit an HTML page with embedded
JavaScript code to display a “chord diagram” in a Web browser, using the
d3.js (https://d3js.org/) library, or emit Cypher queries to construct a
graph in a graph database supporting the openCypher
(https://www.opencypher.org/) query language.  With ‘--path’, it simply
displays the shortest path between two packages.  The general syntax is:

     guix graph OPTIONS PACKAGE...

   For example, the following command generates a PDF file representing
the package DAG for the GNU Core Utilities, showing its build-time
dependencies:

     guix graph coreutils | dot -Tpdf > dag.pdf

   The output looks like this:

 [image src="images/coreutils-graph.png" alt="Dependency graph of the GNU Coreutils" ]

   Nice little graph, no?

   You may find it more pleasant to navigate the graph interactively
with ‘xdot’ (from the ‘xdot’ package):

     guix graph coreutils | xdot -

   But there is more than one graph!  The one above is concise: it is
the graph of package objects, omitting implicit inputs such as GCC,
libc, grep, etc.  It is often useful to have such a concise graph, but
sometimes one may want to see more details.  ‘guix graph’ supports
several types of graphs, allowing you to choose the level of detail:

‘package’
     This is the default type used in the example above.  It shows the
     DAG of package objects, excluding implicit dependencies.  It is
     concise, but filters out many details.

‘reverse-package’
     This shows the _reverse_ DAG of packages.  For example:

          guix graph --type=reverse-package ocaml

     ... yields the graph of packages that _explicitly_ depend on OCaml
     (if you are also interested in cases where OCaml is an implicit
     dependency, see ‘reverse-bag’ below).

     Note that for core packages this can yield huge graphs.  If all you
     want is to know the number of packages that depend on a given
     package, use ‘guix refresh --list-dependent’ (*note
     ‘--list-dependent’: Invoking guix refresh.).

‘bag-emerged’
     This is the package DAG, _including_ implicit inputs.

     For instance, the following command:

          guix graph --type=bag-emerged coreutils

     ... yields this bigger graph:

 [image src="images/coreutils-bag-graph.png" alt="Detailed dependency graph of the GNU Coreutils" ]

     At the bottom of the graph, we see all the implicit inputs of
     GNU-BUILD-SYSTEM (*note ‘gnu-build-system’: Build Systems.).

     Now, note that the dependencies of these implicit inputs—that is,
     the “bootstrap dependencies” (*note Bootstrapping::)—are not shown
     here, for conciseness.

‘bag’
     Similar to ‘bag-emerged’, but this time including all the bootstrap
     dependencies.

‘bag-with-origins’
     Similar to ‘bag’, but also showing origins and their dependencies.

‘reverse-bag’
     This shows the _reverse_ DAG of packages.  Unlike
     ‘reverse-package’, it also takes implicit dependencies into
     account.  For example:

          guix graph -t reverse-bag dune

     ... yields the graph of all packages that depend on Dune, directly
     or indirectly.  Since Dune is an _implicit_ dependency of many
     packages via ‘dune-build-system’, this shows a large number of
     packages, whereas ‘reverse-package’ would show very few if any.

‘derivation’
     This is the most detailed representation: It shows the DAG of
     derivations (*note Derivations::) and plain store items.  Compared
     to the above representation, many additional nodes are visible,
     including build scripts, patches, Guile modules, etc.

     For this type of graph, it is also possible to pass a ‘.drv’ file
     name instead of a package name, as in:

          guix graph -t derivation `guix system build -d my-config.scm`

‘module’
     This is the graph of “package modules” (*note Package Modules::).
     For example, the following command shows the graph for the package
     module that defines the ‘guile’ package:

          guix graph -t module guile | xdot -

   All the types above correspond to _build-time dependencies_.  The
following graph type represents the _run-time dependencies_:

‘references’
     This is the graph of “references” of a package output, as returned
     by ‘guix gc --references’ (*note Invoking guix gc::).

     If the given package output is not available in the store, ‘guix
     graph’ attempts to obtain dependency information from substitutes.

     Here you can also pass a store file name instead of a package name.
     For example, the command below produces the reference graph of your
     profile (which can be big!):

          guix graph -t references `readlink -f ~/.guix-profile`

‘referrers’
     This is the graph of the “referrers” of a store item, as returned
     by ‘guix gc --referrers’ (*note Invoking guix gc::).

     This relies exclusively on local information from your store.  For
     instance, let us suppose that the current Inkscape is available in
     10 profiles on your machine; ‘guix graph -t referrers inkscape’
     will show a graph rooted at Inkscape and with those 10 profiles
     linked to it.

     It can help determine what is preventing a store item from being
     garbage collected.

   Often, the graph of the package you are interested in does not fit on
your screen, and anyway all you want to know is _why_ that package
actually depends on some seemingly unrelated package.  The ‘--path’
option instructs ‘guix graph’ to display the shortest path between two
packages (or derivations, or store items, etc.):

     $ guix graph --path emacs libunistring
     emacs@26.3
     mailutils@3.9
     libunistring@0.9.10
     $ guix graph --path -t derivation emacs libunistring
     /gnu/store/...-emacs-26.3.drv
     /gnu/store/...-mailutils-3.9.drv
     /gnu/store/...-libunistring-0.9.10.drv
     $ guix graph --path -t references emacs libunistring
     /gnu/store/...-emacs-26.3
     /gnu/store/...-libidn2-2.2.0
     /gnu/store/...-libunistring-0.9.10

   The available options are the following:

‘--type=TYPE’
‘-t TYPE’
     Produce a graph output of TYPE, where TYPE must be one of the
     values listed above.

‘--list-types’
     List the supported graph types.

‘--backend=BACKEND’
‘-b BACKEND’
     Produce a graph using the selected BACKEND.

‘--list-backends’
     List the supported graph backends.

     Currently, the available backends are Graphviz and d3.js.

‘--path’
     Display the shortest path between two nodes of the type specified
     by ‘--type’.  The example below shows the shortest path between
     ‘libreoffice’ and ‘llvm’ according to the references of
     ‘libreoffice’:

          $ guix graph --path -t references libreoffice llvm
          /gnu/store/...-libreoffice-6.4.2.2
          /gnu/store/...-libepoxy-1.5.4
          /gnu/store/...-mesa-19.3.4
          /gnu/store/...-llvm-9.0.1

‘--expression=EXPR’
‘-e EXPR’
     Consider the package EXPR evaluates to.

     This is useful to precisely refer to a package, as in this example:

          guix graph -e '(@@ (gnu packages commencement) gnu-make-final)'

‘--system=SYSTEM’
‘-s SYSTEM’
     Display the graph for SYSTEM—e.g., ‘i686-linux’.

     The package dependency graph is largely architecture-independent,
     but there are some architecture-dependent bits that this option
     allows you to visualize.

‘--load-path=DIRECTORY’
‘-L DIRECTORY’
     Add DIRECTORY to the front of the package module search path (*note
     Package Modules::).

     This allows users to define their own packages and make them
     visible to the command-line tools.

   On top of that, ‘guix graph’ supports all the usual package
transformation options (*note Package Transformation Options::).  This
makes it easy to view the effect of a graph-rewriting transformation
such as ‘--with-input’.  For example, the command below outputs the
graph of ‘git’ once ‘openssl’ has been replaced by ‘libressl’ everywhere
in the graph:

     guix graph git --with-input=openssl=libressl

   So many possibilities, so much fun!


File: guix.info,  Node: Invoking guix publish,  Next: Invoking guix challenge,  Prev: Invoking guix graph,  Up: Utilities

7.10 Invoking ‘guix publish’
============================

The purpose of ‘guix publish’ is to enable users to easily share their
store with others, who can then use it as a substitute server (*note
Substitutes::).

   When ‘guix publish’ runs, it spawns an HTTP server which allows
anyone with network access to obtain substitutes from it.  This means
that any machine running Guix can also act as if it were a build farm,
since the HTTP interface is compatible with Cuirass, the software behind
the ‘ci.guix.gnu.org’ build farm.

   For security, each substitute is signed, allowing recipients to check
their authenticity and integrity (*note Substitutes::).  Because ‘guix
publish’ uses the signing key of the system, which is only readable by
the system administrator, it must be started as root; the ‘--user’
option makes it drop root privileges early on.

   The signing key pair must be generated before ‘guix publish’ is
launched, using ‘guix archive --generate-key’ (*note Invoking guix
archive::).

   The general syntax is:

     guix publish OPTIONS...

   Running ‘guix publish’ without any additional arguments will spawn an
HTTP server on port 8080:

     guix publish

   Once a publishing server has been authorized (*note Invoking guix
archive::), the daemon may download substitutes from it:

     guix-daemon --substitute-urls=http://example.org:8080

   By default, ‘guix publish’ compresses archives on the fly as it
serves them.  This “on-the-fly” mode is convenient in that it requires
no setup and is immediately available.  However, when serving lots of
clients, we recommend using the ‘--cache’ option, which enables caching
of the archives before they are sent to clients—see below for details.
The ‘guix weather’ command provides a handy way to check what a server
provides (*note Invoking guix weather::).

   As a bonus, ‘guix publish’ also serves as a content-addressed mirror
for source files referenced in ‘origin’ records (*note origin
Reference::).  For instance, assuming ‘guix publish’ is running on
‘example.org’, the following URL returns the raw ‘hello-2.10.tar.gz’
file with the given SHA256 hash (represented in ‘nix-base32’ format,
*note Invoking guix hash::):

     http://example.org/file/hello-2.10.tar.gz/sha256/0ssi1...ndq1i

   Obviously, these URLs only work for files that are in the store; in
other cases, they return 404 (“Not Found”).

   Build logs are available from ‘/log’ URLs like:

     http://example.org/log/gwspk...-guile-2.2.3

When ‘guix-daemon’ is configured to save compressed build logs, as is
the case by default (*note Invoking guix-daemon::), ‘/log’ URLs return
the compressed log as-is, with an appropriate ‘Content-Type’ and/or
‘Content-Encoding’ header.  We recommend running ‘guix-daemon’ with
‘--log-compression=gzip’ since Web browsers can automatically decompress
it, which is not the case with Bzip2 compression.

   The following options are available:

‘--port=PORT’
‘-p PORT’
     Listen for HTTP requests on PORT.

‘--listen=HOST’
     Listen on the network interface for HOST.  The default is to accept
     connections from any interface.

‘--user=USER’
‘-u USER’
     Change privileges to USER as soon as possible—i.e., once the server
     socket is open and the signing key has been read.

‘--compression[=METHOD[:LEVEL]]’
‘-C [METHOD[:LEVEL]]’
     Compress data using the given METHOD and LEVEL.  METHOD is one of
     ‘lzip’ and ‘gzip’; when METHOD is omitted, ‘gzip’ is used.

     When LEVEL is zero, disable compression.  The range 1 to 9
     corresponds to different compression levels: 1 is the fastest, and
     9 is the best (CPU-intensive).  The default is 3.

     Usually, ‘lzip’ compresses noticeably better than ‘gzip’ for a
     small increase in CPU usage; see benchmarks on the lzip Web page
     (https://nongnu.org/lzip/lzip_benchmark.html).

     Unless ‘--cache’ is used, compression occurs on the fly and the
     compressed streams are not cached.  Thus, to reduce load on the
     machine that runs ‘guix publish’, it may be a good idea to choose a
     low compression level, to run ‘guix publish’ behind a caching
     proxy, or to use ‘--cache’.  Using ‘--cache’ has the advantage that
     it allows ‘guix publish’ to add ‘Content-Length’ HTTP header to its
     responses.

     This option can be repeated, in which case every substitute gets
     compressed using all the selected methods, and all of them are
     advertised.  This is useful when users may not support all the
     compression methods: they can select the one they support.

‘--cache=DIRECTORY’
‘-c DIRECTORY’
     Cache archives and meta-data (‘.narinfo’ URLs) to DIRECTORY and
     only serve archives that are in cache.

     When this option is omitted, archives and meta-data are created
     on-the-fly.  This can reduce the available bandwidth, especially
     when compression is enabled, since this may become CPU-bound.
     Another drawback of the default mode is that the length of archives
     is not known in advance, so ‘guix publish’ does not add a
     ‘Content-Length’ HTTP header to its responses, which in turn
     prevents clients from knowing the amount of data being downloaded.

     Conversely, when ‘--cache’ is used, the first request for a store
     item (via a ‘.narinfo’ URL) returns 404 and triggers a background
     process to “bake” the archive—computing its ‘.narinfo’ and
     compressing the archive, if needed.  Once the archive is cached in
     DIRECTORY, subsequent requests succeed and are served directly from
     the cache, which guarantees that clients get the best possible
     bandwidth.

     The “baking” process is performed by worker threads.  By default,
     one thread per CPU core is created, but this can be customized.
     See ‘--workers’ below.

     When ‘--ttl’ is used, cached entries are automatically deleted when
     they have expired.

‘--workers=N’
     When ‘--cache’ is used, request the allocation of N worker threads
     to “bake” archives.

‘--ttl=TTL’
     Produce ‘Cache-Control’ HTTP headers that advertise a time-to-live
     (TTL) of TTL.  TTL must denote a duration: ‘5d’ means 5 days, ‘1m’
     means 1 month, and so on.

     This allows the user’s Guix to keep substitute information in cache
     for TTL.  However, note that ‘guix publish’ does not itself
     guarantee that the store items it provides will indeed remain
     available for as long as TTL.

     Additionally, when ‘--cache’ is used, cached entries that have not
     been accessed for TTL and that no longer have a corresponding item
     in the store, may be deleted.

‘--nar-path=PATH’
     Use PATH as the prefix for the URLs of “nar” files (*note
     normalized archives: Invoking guix archive.).

     By default, nars are served at a URL such as
     ‘/nar/gzip/...-coreutils-8.25’.  This option allows you to change
     the ‘/nar’ part to PATH.

‘--public-key=FILE’
‘--private-key=FILE’
     Use the specific FILEs as the public/private key pair used to sign
     the store items being published.

     The files must correspond to the same key pair (the private key is
     used for signing and the public key is merely advertised in the
     signature metadata).  They must contain keys in the canonical
     s-expression format as produced by ‘guix archive --generate-key’
     (*note Invoking guix archive::).  By default,
     ‘/etc/guix/signing-key.pub’ and ‘/etc/guix/signing-key.sec’ are
     used.

‘--repl[=PORT]’
‘-r [PORT]’
     Spawn a Guile REPL server (*note (guile)REPL Servers::) on PORT
     (37146 by default).  This is used primarily for debugging a running
     ‘guix publish’ server.

   Enabling ‘guix publish’ on Guix System is a one-liner: just
instantiate a ‘guix-publish-service-type’ service in the ‘services’
field of the ‘operating-system’ declaration (*note
‘guix-publish-service-type’: guix-publish-service-type.).

   If you are instead running Guix on a “foreign distro”, follow these
instructions:

   • If your host distro uses the systemd init system:

          # ln -s ~root/.guix-profile/lib/systemd/system/guix-publish.service \
                  /etc/systemd/system/
          # systemctl start guix-publish && systemctl enable guix-publish

   • If your host distro uses the Upstart init system:

          # ln -s ~root/.guix-profile/lib/upstart/system/guix-publish.conf /etc/init/
          # start guix-publish

   • Otherwise, proceed similarly with your distro’s init system.


File: guix.info,  Node: Invoking guix challenge,  Next: Invoking guix copy,  Prev: Invoking guix publish,  Up: Utilities

7.11 Invoking ‘guix challenge’
==============================

Do the binaries provided by this server really correspond to the source
code it claims to build?  Is a package build process deterministic?
These are the questions the ‘guix challenge’ command attempts to answer.

   The former is obviously an important question: Before using a
substitute server (*note Substitutes::), one had better _verify_ that it
provides the right binaries, and thus _challenge_ it.  The latter is
what enables the former: If package builds are deterministic, then
independent builds of the package should yield the exact same result,
bit for bit; if a server provides a binary different from the one
obtained locally, it may be either corrupt or malicious.

   We know that the hash that shows up in ‘/gnu/store’ file names is the
hash of all the inputs of the process that built the file or
directory—compilers, libraries, build scripts, etc.  (*note
Introduction::).  Assuming deterministic build processes, one store file
name should map to exactly one build output.  ‘guix challenge’ checks
whether there is, indeed, a single mapping by comparing the build
outputs of several independent builds of any given store item.

   The command output looks like this:

     $ guix challenge --substitute-urls="https://ci.guix.gnu.org https://guix.example.org"
     updating list of substitutes from 'https://ci.guix.gnu.org'... 100.0%
     updating list of substitutes from 'https://guix.example.org'... 100.0%
     /gnu/store/...-openssl-1.0.2d contents differ:
       local hash: 0725l22r5jnzazaacncwsvp9kgf42266ayyp814v7djxs7nk963q
       https://ci.guix.gnu.org/nar/...-openssl-1.0.2d: 0725l22r5jnzazaacncwsvp9kgf42266ayyp814v7djxs7nk963q
       https://guix.example.org/nar/...-openssl-1.0.2d: 1zy4fmaaqcnjrzzajkdn3f5gmjk754b43qkq47llbyak9z0qjyim
       differing files:
         /lib/libcrypto.so.1.1
         /lib/libssl.so.1.1

     /gnu/store/...-git-2.5.0 contents differ:
       local hash: 00p3bmryhjxrhpn2gxs2fy0a15lnip05l97205pgbk5ra395hyha
       https://ci.guix.gnu.org/nar/...-git-2.5.0: 069nb85bv4d4a6slrwjdy8v1cn4cwspm3kdbmyb81d6zckj3nq9f
       https://guix.example.org/nar/...-git-2.5.0: 0mdqa9w1p6cmli6976v4wi0sw9r4p5prkj7lzfd1877wk11c9c73
       differing file:
         /libexec/git-core/git-fsck

     /gnu/store/...-pius-2.1.1 contents differ:
       local hash: 0k4v3m9z1zp8xzzizb7d8kjj72f9172xv078sq4wl73vnq9ig3ax
       https://ci.guix.gnu.org/nar/...-pius-2.1.1: 0k4v3m9z1zp8xzzizb7d8kjj72f9172xv078sq4wl73vnq9ig3ax
       https://guix.example.org/nar/...-pius-2.1.1: 1cy25x1a4fzq5rk0pmvc8xhwyffnqz95h2bpvqsz2mpvlbccy0gs
       differing file:
         /share/man/man1/pius.1.gz

     ...

     6,406 store items were analyzed:
       - 4,749 (74.1%) were identical
       - 525 (8.2%) differed
       - 1,132 (17.7%) were inconclusive

In this example, ‘guix challenge’ first scans the store to determine the
set of locally-built derivations—as opposed to store items that were
downloaded from a substitute server—and then queries all the substitute
servers.  It then reports those store items for which the servers
obtained a result different from the local build.

   As an example, ‘guix.example.org’ always gets a different answer.
Conversely, ‘ci.guix.gnu.org’ agrees with local builds, except in the
case of Git.  This might indicate that the build process of Git is
non-deterministic, meaning that its output varies as a function of
various things that Guix does not fully control, in spite of building
packages in isolated environments (*note Features::).  Most common
sources of non-determinism include the addition of timestamps in build
results, the inclusion of random numbers, and directory listings sorted
by inode number.  See <https://reproducible-builds.org/docs/>, for more
information.

   To find out what is wrong with this Git binary, the easiest approach
is to run:

     guix challenge git \
       --diff=diffoscope \
       --substitute-urls="https://ci.guix.gnu.org https://guix.example.org"

   This automatically invokes ‘diffoscope’, which displays detailed
information about files that differ.

   Alternatively, we can do something along these lines (*note Invoking
guix archive::):

     $ wget -q -O - https://ci.guix.gnu.org/nar/lzip/...-git-2.5.0 \
        | lzip -d | guix archive -x /tmp/git
     $ diff -ur --no-dereference /gnu/store/...-git.2.5.0 /tmp/git

   This command shows the difference between the files resulting from
the local build, and the files resulting from the build on
‘ci.guix.gnu.org’ (*note Comparing and Merging Files:
(diffutils)Overview.).  The ‘diff’ command works great for text files.
When binary files differ, a better option is Diffoscope
(https://diffoscope.org/), a tool that helps visualize differences for
all kinds of files.

   Once you have done that work, you can tell whether the differences
are due to a non-deterministic build process or to a malicious server.
We try hard to remove sources of non-determinism in packages to make it
easier to verify substitutes, but of course, this is a process that
involves not just Guix, but a large part of the free software community.
In the meantime, ‘guix challenge’ is one tool to help address the
problem.

   If you are writing packages for Guix, you are encouraged to check
whether ‘ci.guix.gnu.org’ and other substitute servers obtain the same
build result as you did with:

     $ guix challenge PACKAGE

where PACKAGE is a package specification such as ‘guile@2.0’ or
‘glibc:debug’.

   The general syntax is:

     guix challenge OPTIONS [PACKAGES...]

   When a difference is found between the hash of a locally-built item
and that of a server-provided substitute, or among substitutes provided
by different servers, the command displays it as in the example above
and its exit code is 2 (other non-zero exit codes denote other kinds of
errors).

   The one option that matters is:

‘--substitute-urls=URLS’
     Consider URLS the whitespace-separated list of substitute source
     URLs to compare to.

‘--diff=MODE’
     Upon mismatches, show differences according to MODE, one of:

     ‘simple’ (the default)
          Show the list of files that differ.

     ‘diffoscope’
     COMMAND
          Invoke Diffoscope (https://diffoscope.org/), passing it two
          directories whose contents do not match.

          When COMMAND is an absolute file name, run COMMAND instead of
          Diffoscope.

     ‘none’
          Do not show further details about the differences.

     Thus, unless ‘--diff=none’ is passed, ‘guix challenge’ downloads
     the store items from the given substitute servers so that it can
     compare them.

‘--verbose’
‘-v’
     Show details about matches (identical contents) in addition to
     information about mismatches.


File: guix.info,  Node: Invoking guix copy,  Next: Invoking guix container,  Prev: Invoking guix challenge,  Up: Utilities

7.12 Invoking ‘guix copy’
=========================

The ‘guix copy’ command copies items from the store of one machine to
that of another machine over a secure shell (SSH) connection(1).  For
example, the following command copies the ‘coreutils’ package, the
user’s profile, and all their dependencies over to HOST, logged in as
USER:

     guix copy --to=USER@HOST \
               coreutils `readlink -f ~/.guix-profile`

   If some of the items to be copied are already present on HOST, they
are not actually sent.

   The command below retrieves ‘libreoffice’ and ‘gimp’ from HOST,
assuming they are available there:

     guix copy --from=HOST libreoffice gimp

   The SSH connection is established using the Guile-SSH client, which
is compatible with OpenSSH: it honors ‘~/.ssh/known_hosts’ and
‘~/.ssh/config’, and uses the SSH agent for authentication.

   The key used to sign items that are sent must be accepted by the
remote machine.  Likewise, the key used by the remote machine to sign
items you are retrieving must be in ‘/etc/guix/acl’ so it is accepted by
your own daemon.  *Note Invoking guix archive::, for more information
about store item authentication.

   The general syntax is:

     guix copy [--to=SPEC|--from=SPEC] ITEMS...

   You must always specify one of the following options:

‘--to=SPEC’
‘--from=SPEC’
     Specify the host to send to or receive from.  SPEC must be an SSH
     spec such as ‘example.org’, ‘charlie@example.org’, or
     ‘charlie@example.org:2222’.

   The ITEMS can be either package names, such as ‘gimp’, or store
items, such as ‘/gnu/store/...-idutils-4.6’.

   When specifying the name of a package to send, it is first built if
needed, unless ‘--dry-run’ was specified.  Common build options are
supported (*note Common Build Options::).

   ---------- Footnotes ----------

   (1) This command is available only when Guile-SSH was found.  *Note
Requirements::, for details.


File: guix.info,  Node: Invoking guix container,  Next: Invoking guix weather,  Prev: Invoking guix copy,  Up: Utilities

7.13 Invoking ‘guix container’
==============================

     Note: As of version 1.0.1.17089-7e269, this tool is experimental.
     The interface is subject to radical change in the future.

   The purpose of ‘guix container’ is to manipulate processes running
within an isolated environment, commonly known as a “container”,
typically created by the ‘guix environment’ (*note Invoking guix
environment::) and ‘guix system container’ (*note Invoking guix
system::) commands.

   The general syntax is:

     guix container ACTION OPTIONS...

   ACTION specifies the operation to perform with a container, and
OPTIONS specifies the context-specific arguments for the action.

   The following actions are available:

‘exec’
     Execute a command within the context of a running container.

     The syntax is:

          guix container exec PID PROGRAM ARGUMENTS...

     PID specifies the process ID of the running container.  PROGRAM
     specifies an executable file name within the root file system of
     the container.  ARGUMENTS are the additional options that will be
     passed to PROGRAM.

     The following command launches an interactive login shell inside a
     Guix system container, started by ‘guix system container’, and
     whose process ID is 9001:

          guix container exec 9001 /run/current-system/profile/bin/bash --login

     Note that the PID cannot be the parent process of a container.  It
     must be PID 1 of the container or one of its child processes.


File: guix.info,  Node: Invoking guix weather,  Next: Invoking guix processes,  Prev: Invoking guix container,  Up: Utilities

7.14 Invoking ‘guix weather’
============================

Occasionally you’re grumpy because substitutes are lacking and you end
up building packages by yourself (*note Substitutes::).  The ‘guix
weather’ command reports on substitute availability on the specified
servers so you can have an idea of whether you’ll be grumpy today.  It
can sometimes be useful info as a user, but it is primarily useful to
people running ‘guix publish’ (*note Invoking guix publish::).

   Here’s a sample run:

     $ guix weather --substitute-urls=https://guix.example.org
     computing 5,872 package derivations for x86_64-linux...
     looking for 6,128 store items on https://guix.example.org..
     updating list of substitutes from 'https://guix.example.org'... 100.0%
     https://guix.example.org
       43.4% substitutes available (2,658 out of 6,128)
       7,032.5 MiB of nars (compressed)
       19,824.2 MiB on disk (uncompressed)
       0.030 seconds per request (182.9 seconds in total)
       33.5 requests per second

       9.8% (342 out of 3,470) of the missing items are queued
       867 queued builds
           x86_64-linux: 518 (59.7%)
           i686-linux: 221 (25.5%)
           aarch64-linux: 128 (14.8%)
       build rate: 23.41 builds per hour
           x86_64-linux: 11.16 builds per hour
           i686-linux: 6.03 builds per hour
           aarch64-linux: 6.41 builds per hour

   As you can see, it reports the fraction of all the packages for which
substitutes are available on the server—regardless of whether
substitutes are enabled, and regardless of whether this server’s signing
key is authorized.  It also reports the size of the compressed archives
(“nars”) provided by the server, the size the corresponding store items
occupy in the store (assuming deduplication is turned off), and the
server’s throughput.  The second part gives continuous integration (CI)
statistics, if the server supports it.  In addition, using the
‘--coverage’ option, ‘guix weather’ can list “important” package
substitutes missing on the server (see below).

   To achieve that, ‘guix weather’ queries over HTTP(S) meta-data
(“narinfos”) for all the relevant store items.  Like ‘guix challenge’,
it ignores signatures on those substitutes, which is innocuous since the
command only gathers statistics and cannot install those substitutes.

   The general syntax is:

     guix weather OPTIONS... [PACKAGES...]

   When PACKAGES is omitted, ‘guix weather’ checks the availability of
substitutes for _all_ the packages, or for those specified with
‘--manifest’; otherwise it only considers the specified packages.  It is
also possible to query specific system types with ‘--system’.  ‘guix
weather’ exits with a non-zero code when the fraction of available
substitutes is below 100%.

   The available options are listed below.

‘--substitute-urls=URLS’
     URLS is the space-separated list of substitute server URLs to
     query.  When this option is omitted, the default set of substitute
     servers is queried.

‘--system=SYSTEM’
‘-s SYSTEM’
     Query substitutes for SYSTEM—e.g., ‘aarch64-linux’.  This option
     can be repeated, in which case ‘guix weather’ will query
     substitutes for several system types.

‘--manifest=FILE’
     Instead of querying substitutes for all the packages, only ask for
     those specified in FILE.  FILE must contain a “manifest”, as with
     the ‘-m’ option of ‘guix package’ (*note Invoking guix package::).

     This option can be repeated several times, in which case the
     manifests are concatenated.

‘--coverage[=COUNT]’
‘-c [COUNT]’
     Report on substitute coverage for packages: list packages with at
     least COUNT dependents (zero by default) for which substitutes are
     unavailable.  Dependent packages themselves are not listed: if B
     depends on A and A has no substitutes, only A is listed, even
     though B usually lacks substitutes as well.  The result looks like
     this:

          $ guix weather --substitute-urls=https://ci.guix.gnu.org -c 10
          computing 8,983 package derivations for x86_64-linux...
          looking for 9,343 store items on https://ci.guix.gnu.org...
          updating substitutes from 'https://ci.guix.gnu.org'... 100.0%
          https://ci.guix.gnu.org
            64.7% substitutes available (6,047 out of 9,343)
          ...
          2502 packages are missing from 'https://ci.guix.gnu.org' for 'x86_64-linux', among which:
              58  kcoreaddons@5.49.0      /gnu/store/...-kcoreaddons-5.49.0
              46  qgpgme@1.11.1           /gnu/store/...-qgpgme-1.11.1
              37  perl-http-cookiejar@0.008  /gnu/store/...-perl-http-cookiejar-0.008
              ...

     What this example shows is that ‘kcoreaddons’ and presumably the 58
     packages that depend on it have no substitutes at ‘ci.guix.info’;
     likewise for ‘qgpgme’ and the 46 packages that depend on it.

     If you are a Guix developer, or if you are taking care of this
     build farm, you’ll probably want to have a closer look at these
     packages: they may simply fail to build.

‘--display-missing’
     Display the list of store items for which substitutes are missing.


File: guix.info,  Node: Invoking guix processes,  Prev: Invoking guix weather,  Up: Utilities

7.15 Invoking ‘guix processes’
==============================

The ‘guix processes’ command can be useful to developers and system
administrators, especially on multi-user machines and on build farms: it
lists the current sessions (connections to the daemon), as well as
information about the processes involved(1).  Here’s an example of the
information it returns:

     $ sudo guix processes
     SessionPID: 19002
     ClientPID: 19090
     ClientCommand: guix environment --ad-hoc python

     SessionPID: 19402
     ClientPID: 19367
     ClientCommand: guix publish -u guix-publish -p 3000 -C 9 ...

     SessionPID: 19444
     ClientPID: 19419
     ClientCommand: cuirass --cache-directory /var/cache/cuirass ...
     LockHeld: /gnu/store/...-perl-ipc-cmd-0.96.lock
     LockHeld: /gnu/store/...-python-six-bootstrap-1.11.0.lock
     LockHeld: /gnu/store/...-libjpeg-turbo-2.0.0.lock
     ChildProcess: 20495: guix offload x86_64-linux 7200 1 28800
     ChildProcess: 27733: guix offload x86_64-linux 7200 1 28800
     ChildProcess: 27793: guix offload x86_64-linux 7200 1 28800

   In this example we see that ‘guix-daemon’ has three clients: ‘guix
environment’, ‘guix publish’, and the Cuirass continuous integration
tool; their process identifier (PID) is given by the ‘ClientPID’ field.
The ‘SessionPID’ field gives the PID of the ‘guix-daemon’ sub-process of
this particular session.

   The ‘LockHeld’ fields show which store items are currently locked by
this session, which corresponds to store items being built or
substituted (the ‘LockHeld’ field is not displayed when ‘guix processes’
is not running as root).  Last, by looking at the ‘ChildProcess’ field,
we understand that these three builds are being offloaded (*note Daemon
Offload Setup::).

   The output is in Recutils format so we can use the handy ‘recsel’
command to select sessions of interest (*note (recutils)Selection
Expressions::).  As an example, the command shows the command line and
PID of the client that triggered the build of a Perl package:

     $ sudo guix processes | \
         recsel -p ClientPID,ClientCommand -e 'LockHeld ~ "perl"'
     ClientPID: 19419
     ClientCommand: cuirass --cache-directory /var/cache/cuirass ...

   ---------- Footnotes ----------

   (1) Remote sessions, when ‘guix-daemon’ is started with ‘--listen’
specifying a TCP endpoint, are _not_ listed.


File: guix.info,  Node: System Configuration,  Next: Documentation,  Prev: Utilities,  Up: Top

8 System Configuration
**********************

Guix System supports a consistent whole-system configuration mechanism.
By that we mean that all aspects of the global system configuration—such
as the available system services, timezone and locale settings, user
accounts—are declared in a single place.  Such a “system configuration”
can be “instantiated”—i.e., effected.

   One of the advantages of putting all the system configuration under
the control of Guix is that it supports transactional system upgrades,
and makes it possible to roll back to a previous system instantiation,
should something go wrong with the new one (*note Features::).  Another
advantage is that it makes it easy to replicate the exact same
configuration across different machines, or at different points in time,
without having to resort to additional administration tools layered on
top of the own tools of the system.

   This section describes this mechanism.  First we focus on the system
administrator’s viewpoint—explaining how the system is configured and
instantiated.  Then we show how this mechanism can be extended, for
instance to support new system services.

* Menu:

* Using the Configuration System::  Customizing your GNU system.
* operating-system Reference::  Detail of operating-system declarations.
* File Systems::                Configuring file system mounts.
* Mapped Devices::              Block device extra processing.
* User Accounts::               Specifying user accounts.
* Keyboard Layout::             How the system interprets key strokes.
* Locales::                     Language and cultural convention settings.
* Services::                    Specifying system services.
* Setuid Programs::             Programs running with root privileges.
* X.509 Certificates::          Authenticating HTTPS servers.
* Name Service Switch::         Configuring libc’s name service switch.
* Initial RAM Disk::            Linux-Libre bootstrapping.
* Bootloader Configuration::    Configuring the boot loader.
* Invoking guix system::        Instantiating a system configuration.
* Invoking guix deploy::        Deploying a system configuration to a remote host.
* Running Guix in a VM::        How to run Guix System in a virtual machine.
* Defining Services::           Adding new service definitions.


File: guix.info,  Node: Using the Configuration System,  Next: operating-system Reference,  Up: System Configuration

8.1 Using the Configuration System
==================================

The operating system is configured by providing an ‘operating-system’
declaration in a file that can then be passed to the ‘guix system’
command (*note Invoking guix system::).  A simple setup, with the
default system services, the default Linux-Libre kernel, initial RAM
disk, and boot loader looks like this:

     ;; This is an operating system configuration template
     ;; for a "bare bones" setup, with no X11 display server.

     (use-modules (gnu))
     (use-service-modules networking ssh)
     (use-package-modules screen)

     (operating-system
       (host-name "komputilo")
       (timezone "Europe/Berlin")
       (locale "en_US.utf8")

       ;; Boot in "legacy" BIOS mode, assuming /dev/sdX is the
       ;; target hard disk, and "my-root" is the label of the target
       ;; root file system.
       (bootloader (bootloader-configuration
                     (bootloader grub-bootloader)
                     (target "/dev/sdX")))
       (file-systems (cons (file-system
                             (device (file-system-label "my-root"))
                             (mount-point "/")
                             (type "ext4"))
                           %base-file-systems))

       ;; This is where user accounts are specified.  The "root"
       ;; account is implicit, and is initially created with the
       ;; empty password.
       (users (cons (user-account
                     (name "alice")
                     (comment "Bob's sister")
                     (group "users")

                     ;; Adding the account to the "wheel" group
                     ;; makes it a sudoer.  Adding it to "audio"
                     ;; and "video" allows the user to play sound
                     ;; and access the webcam.
                     (supplementary-groups '("wheel"
                                             "audio" "video")))
                    %base-user-accounts))

       ;; Globally-installed packages.
       (packages (cons screen %base-packages))

       ;; Add services to the baseline: a DHCP client and
       ;; an SSH server.
       (services (append (list (service dhcp-client-service-type)
                               (service openssh-service-type
                                        (openssh-configuration
                                         (port-number 2222))))
                         %base-services)))

   This example should be self-describing.  Some of the fields defined
above, such as ‘host-name’ and ‘bootloader’, are mandatory.  Others,
such as ‘packages’ and ‘services’, can be omitted, in which case they
get a default value.

   Below we discuss the effect of some of the most important fields
(*note operating-system Reference::, for details about all the available
fields), and how to “instantiate” the operating system using ‘guix
system’.

Bootloader
----------

The ‘bootloader’ field describes the method that will be used to boot
your system.  Machines based on Intel processors can boot in “legacy”
BIOS mode, as in the example above.  However, more recent machines rely
instead on the “Unified Extensible Firmware Interface” (UEFI) to boot.
In that case, the ‘bootloader’ field should contain something along
these lines:

     (bootloader-configuration
       (bootloader grub-efi-bootloader)
       (target "/boot/efi"))

   *Note Bootloader Configuration::, for more information on the
available configuration options.

Globally-Visible Packages
-------------------------

The ‘packages’ field lists packages that will be globally visible on the
system, for all user accounts—i.e., in every user’s ‘PATH’ environment
variable—in addition to the per-user profiles (*note Invoking guix
package::).  The ‘%base-packages’ variable provides all the tools one
would expect for basic user and administrator tasks—including the GNU
Core Utilities, the GNU Networking Utilities, the GNU Zile lightweight
text editor, ‘find’, ‘grep’, etc.  The example above adds GNU Screen to
those, taken from the ‘(gnu packages screen)’ module (*note Package
Modules::).  The ‘(list package output)’ syntax can be used to add a
specific output of a package:

     (use-modules (gnu packages))
     (use-modules (gnu packages dns))

     (operating-system
       ;; ...
       (packages (cons (list bind "utils")
                       %base-packages)))

   Referring to packages by variable name, like ‘bind’ above, has the
advantage of being unambiguous; it also allows typos and such to be
diagnosed right away as “unbound variables”.  The downside is that one
needs to know which module defines which package, and to augment the
‘use-package-modules’ line accordingly.  To avoid that, one can use the
‘specification->package’ procedure of the ‘(gnu packages)’ module, which
returns the best package for a given name or name and version:

     (use-modules (gnu packages))

     (operating-system
       ;; ...
       (packages (append (map specification->package
                              '("tcpdump" "htop" "gnupg@2.0"))
                         %base-packages)))

System Services
---------------

The ‘services’ field lists “system services” to be made available when
the system starts (*note Services::).  The ‘operating-system’
declaration above specifies that, in addition to the basic services, we
want the OpenSSH secure shell daemon listening on port 2222 (*note
‘openssh-service-type’: Networking Services.).  Under the hood,
‘openssh-service-type’ arranges so that ‘sshd’ is started with the right
command-line options, possibly with supporting configuration files
generated as needed (*note Defining Services::).

   Occasionally, instead of using the base services as is, you will want
to customize them.  To do this, use ‘modify-services’ (*note
‘modify-services’: Service Reference.) to modify the list.

   For example, suppose you want to modify ‘guix-daemon’ and Mingetty
(the console log-in) in the ‘%base-services’ list (*note
‘%base-services’: Base Services.).  To do that, you can write the
following in your operating system declaration:

     (define %my-services
       ;; My very own list of services.
       (modify-services %base-services
         (guix-service-type config =>
                            (guix-configuration
                             (inherit config)
                             (use-substitutes? #f)
                             (extra-options '("--gc-keep-derivations"))))
         (mingetty-service-type config =>
                                (mingetty-configuration
                                 (inherit config)))))

     (operating-system
       ;; ...
       (services %my-services))

   This changes the configuration—i.e., the service parameters—of the
‘guix-service-type’ instance, and that of all the
‘mingetty-service-type’ instances in the ‘%base-services’ list.  Observe
how this is accomplished: first, we arrange for the original
configuration to be bound to the identifier ‘config’ in the BODY, and
then we write the BODY so that it evaluates to the desired
configuration.  In particular, notice how we use ‘inherit’ to create a
new configuration which has the same values as the old configuration,
but with a few modifications.

   The configuration for a typical “desktop” usage, with an encrypted
root partition, the X11 display server, GNOME and Xfce (users can choose
which of these desktop environments to use at the log-in screen by
pressing ‘F1’), network management, power management, and more, would
look like this:

     ;; This is an operating system configuration template
     ;; for a "desktop" setup with GNOME and Xfce where the
     ;; root partition is encrypted with LUKS.

     (use-modules (gnu) (gnu system nss))
     (use-service-modules desktop xorg)
     (use-package-modules certs gnome)

     (operating-system
       (host-name "antelope")
       (timezone "Europe/Paris")
       (locale "en_US.utf8")

       ;; Choose US English keyboard layout.  The "altgr-intl"
       ;; variant provides dead keys for accented characters.
       (keyboard-layout (keyboard-layout "us" "altgr-intl"))

       ;; Use the UEFI variant of GRUB with the EFI System
       ;; Partition mounted on /boot/efi.
       (bootloader (bootloader-configuration
                     (bootloader grub-efi-bootloader)
                     (target "/boot/efi")
                     (keyboard-layout keyboard-layout)))

       ;; Specify a mapped device for the encrypted root partition.
       ;; The UUID is that returned by 'cryptsetup luksUUID'.
       (mapped-devices
        (list (mapped-device
               (source (uuid "12345678-1234-1234-1234-123456789abc"))
               (target "my-root")
               (type luks-device-mapping))))

       (file-systems (append
                      (list (file-system
                              (device (file-system-label "my-root"))
                              (mount-point "/")
                              (type "ext4")
                              (dependencies mapped-devices))
                            (file-system
                              (device (uuid "1234-ABCD" 'fat))
                              (mount-point "/boot/efi")
                              (type "vfat")))
                      %base-file-systems))

       (users (cons (user-account
                     (name "bob")
                     (comment "Alice's brother")
                     (group "users")
                     (supplementary-groups '("wheel" "netdev"
                                             "audio" "video")))
                    %base-user-accounts))

       ;; This is where we specify system-wide packages.
       (packages (append (list
                          ;; for HTTPS access
                          nss-certs
                          ;; for user mounts
                          gvfs)
                         %base-packages))

       ;; Add GNOME and Xfce---we can choose at the log-in screen
       ;; by clicking the gear.  Use the "desktop" services, which
       ;; include the X11 log-in service, networking with
       ;; NetworkManager, and more.
       (services (append (list (service gnome-desktop-service-type)
                               (service xfce-desktop-service-type)
                               (set-xorg-configuration
                                (xorg-configuration
                                 (keyboard-layout keyboard-layout))))
                         %desktop-services))

       ;; Allow resolution of '.local' host names with mDNS.
       (name-service-switch %mdns-host-lookup-nss))

   A graphical system with a choice of lightweight window managers
instead of full-blown desktop environments would look like this:

     ;; This is an operating system configuration template
     ;; for a "desktop" setup without full-blown desktop
     ;; environments.

     (use-modules (gnu) (gnu system nss))
     (use-service-modules desktop)
     (use-package-modules bootloaders certs ratpoison suckless wm)
     (use-package-modules bootloaders certs ratpoison suckless wm xorg)

     (operating-system
       (host-name "antelope")
       (timezone "Europe/Paris")
       (locale "en_US.utf8")

       ;; Use the UEFI variant of GRUB with the EFI System
       ;; Partition mounted on /boot/efi.
       (bootloader (bootloader-configuration
                     (bootloader grub-efi-bootloader)
                     (target "/boot/efi")))

       ;; Assume the target root file system is labelled "my-root",
       ;; and the EFI System Partition has UUID 1234-ABCD.
       (file-systems (append
                      (list (file-system
                              (device (file-system-label "my-root"))
                              (mount-point "/")
                              (type "ext4"))
                            (file-system
                              (device (uuid "1234-ABCD" 'fat))
                              (mount-point "/boot/efi")
                              (type "vfat")))
                      %base-file-systems))

       (users (cons (user-account
                     (name "alice")
                     (comment "Bob's sister")
                     (group "users")
                     (supplementary-groups '("wheel" "netdev"
                                             "audio" "video")))
                    %base-user-accounts))

       ;; Add a bunch of window managers; we can choose one at
       ;; the log-in screen with F1.
       (packages (append (list
                          ;; window managers
                          ratpoison i3-wm i3status dmenu
                          ;; terminal emulator
                          xterm
                          ;; for HTTPS access
                          nss-certs)
                         %base-packages))

       ;; Use the "desktop" services, which include the X11
       ;; log-in service, networking with NetworkManager, and more.
       (services %desktop-services)

       ;; Allow resolution of '.local' host names with mDNS.
       (name-service-switch %mdns-host-lookup-nss))

   This example refers to the ‘/boot/efi’ file system by its UUID,
‘1234-ABCD’.  Replace this UUID with the right UUID on your system, as
returned by the ‘blkid’ command.

   *Note Desktop Services::, for the exact list of services provided by
‘%desktop-services’.  *Note X.509 Certificates::, for background
information about the ‘nss-certs’ package that is used here.

   Again, ‘%desktop-services’ is just a list of service objects.  If you
want to remove services from there, you can do so using the procedures
for list filtering (*note (guile)SRFI-1 Filtering and Partitioning::).
For instance, the following expression returns a list that contains all
the services in ‘%desktop-services’ minus the Avahi service:

     (remove (lambda (service)
               (eq? (service-kind service) avahi-service-type))
             %desktop-services)

Instantiating the System
------------------------

Assuming the ‘operating-system’ declaration is stored in the
‘my-system-config.scm’ file, the ‘guix system reconfigure
my-system-config.scm’ command instantiates that configuration, and makes
it the default GRUB boot entry (*note Invoking guix system::).

   The normal way to change the system configuration is by updating this
file and re-running ‘guix system reconfigure’.  One should never have to
touch files in ‘/etc’ or to run commands that modify the system state
such as ‘useradd’ or ‘grub-install’.  In fact, you must avoid that since
that would not only void your warranty but also prevent you from rolling
back to previous versions of your system, should you ever need to.

   Speaking of roll-back, each time you run ‘guix system reconfigure’, a
new “generation” of the system is created—without modifying or deleting
previous generations.  Old system generations get an entry in the
bootloader boot menu, allowing you to boot them in case something went
wrong with the latest generation.  Reassuring, no?  The ‘guix system
list-generations’ command lists the system generations available on
disk.  It is also possible to roll back the system via the commands
‘guix system roll-back’ and ‘guix system switch-generation’.

   Although the ‘guix system reconfigure’ command will not modify
previous generations, you must take care when the current generation is
not the latest (e.g., after invoking ‘guix system roll-back’), since the
operation might overwrite a later generation (*note Invoking guix
system::).

The Programming Interface
-------------------------

At the Scheme level, the bulk of an ‘operating-system’ declaration is
instantiated with the following monadic procedure (*note The Store
Monad::):

 -- Monadic Procedure: operating-system-derivation os
     Return a derivation that builds OS, an ‘operating-system’ object
     (*note Derivations::).

     The output of the derivation is a single directory that refers to
     all the packages, configuration files, and other supporting files
     needed to instantiate OS.

   This procedure is provided by the ‘(gnu system)’ module.  Along with
‘(gnu services)’ (*note Services::), this module contains the guts of
Guix System.  Make sure to visit it!


File: guix.info,  Node: operating-system Reference,  Next: File Systems,  Prev: Using the Configuration System,  Up: System Configuration

8.2 ‘operating-system’ Reference
================================

This section summarizes all the options available in ‘operating-system’
declarations (*note Using the Configuration System::).

 -- Data Type: operating-system
     This is the data type representing an operating system
     configuration.  By that, we mean all the global system
     configuration, not per-user configuration (*note Using the
     Configuration System::).

     ‘kernel’ (default: ‘linux-libre’)
          The package object of the operating system kernel to use(1).

     ‘hurd’ (default: ‘#f’)
          The package object of the hurd to be started by the kernel.
          When this field is set, produce a GNU/Hurd operating system.
          In that case, ‘kernel’ must also be set to the ‘gnumach’
          package—the microkernel the Hurd runs on.

               Warning: This feature is experimental and only supported
               for disk images.

     ‘kernel-loadable-modules’ (default: ’())
          A list of objects (usually packages) to collect loadable
          kernel modules from–e.g.  ‘(list ddcci-driver-linux)’.

     ‘kernel-arguments’ (default: ‘%default-kernel-arguments’)
          List of strings or gexps representing additional arguments to
          pass on the command-line of the kernel—e.g.,
          ‘("console=ttyS0")’.

     ‘bootloader’
          The system bootloader configuration object.  *Note Bootloader
          Configuration::.

     ‘label’
          This is the label (a string) as it appears in the bootloader’s
          menu entry.  The default label includes the kernel name and
          version.

     ‘keyboard-layout’ (default: ‘#f’)
          This field specifies the keyboard layout to use in the
          console.  It can be either ‘#f’, in which case the default
          keyboard layout is used (usually US English), or a
          ‘<keyboard-layout>’ record.

          This keyboard layout is in effect as soon as the kernel has
          booted.  For instance, it is the keyboard layout in effect
          when you type a passphrase if your root file system is on a
          ‘luks-device-mapping’ mapped device (*note Mapped Devices::).

               Note: This does _not_ specify the keyboard layout used by
               the bootloader, nor that used by the graphical display
               server.  *Note Bootloader Configuration::, for
               information on how to specify the bootloader’s keyboard
               layout.  *Note X Window::, for information on how to
               specify the keyboard layout used by the X Window System.

     ‘initrd-modules’ (default: ‘%base-initrd-modules’)
          The list of Linux kernel modules that need to be available in
          the initial RAM disk.  *Note Initial RAM Disk::.

     ‘initrd’ (default: ‘base-initrd’)
          A procedure that returns an initial RAM disk for the Linux
          kernel.  This field is provided to support low-level
          customization and should rarely be needed for casual use.
          *Note Initial RAM Disk::.

     ‘firmware’ (default: ‘%base-firmware’)
          List of firmware packages loadable by the operating system
          kernel.

          The default includes firmware needed for Atheros- and
          Broadcom-based WiFi devices (Linux-libre modules ‘ath9k’ and
          ‘b43-open’, respectively).  *Note Hardware Considerations::,
          for more info on supported hardware.

     ‘host-name’
          The host name.

     ‘hosts-file’
          A file-like object (*note file-like objects: G-Expressions.)
          for use as ‘/etc/hosts’ (*note (libc)Host Names::).  The
          default is a file with entries for ‘localhost’ and HOST-NAME.

     ‘mapped-devices’ (default: ‘'()’)
          A list of mapped devices.  *Note Mapped Devices::.

     ‘file-systems’
          A list of file systems.  *Note File Systems::.

     ‘swap-devices’ (default: ‘'()’)
          A list of strings identifying devices or files to be used for
          “swap space” (*note (libc)Memory Concepts::).  For example,
          ‘'("/dev/sda3")’ or ‘'("/swapfile")’.  It is possible to
          specify a swap file in a file system on a mapped device,
          provided that the necessary device mapping and file system are
          also specified.  *Note Mapped Devices:: and *note File
          Systems::.

     ‘users’ (default: ‘%base-user-accounts’)
     ‘groups’ (default: ‘%base-groups’)
          List of user accounts and groups.  *Note User Accounts::.

          If the ‘users’ list lacks a user account with UID 0, a “root”
          account with UID 0 is automatically added.

     ‘skeletons’ (default: ‘(default-skeletons)’)
          A list target file name/file-like object tuples (*note
          file-like objects: G-Expressions.).  These are the skeleton
          files that will be added to the home directory of
          newly-created user accounts.

          For instance, a valid value may look like this:

               `((".bashrc" ,(plain-file "bashrc" "echo Hello\n"))
                 (".guile" ,(plain-file "guile"
                                        "(use-modules (ice-9 readline))
                                         (activate-readline)")))

     ‘issue’ (default: ‘%default-issue’)
          A string denoting the contents of the ‘/etc/issue’ file, which
          is displayed when users log in on a text console.

     ‘packages’ (default: ‘%base-packages’)
          The set of packages installed in the global profile, which is
          accessible at ‘/run/current-system/profile’.

          The default set includes core utilities and it is good
          practice to install non-core utilities in user profiles (*note
          Invoking guix package::).

     ‘timezone’
          A timezone identifying string—e.g., ‘"Europe/Paris"’.

          You can run the ‘tzselect’ command to find out which timezone
          string corresponds to your region.  Choosing an invalid
          timezone name causes ‘guix system’ to fail.

     ‘locale’ (default: ‘"en_US.utf8"’)
          The name of the default locale (*note (libc)Locale Names::).
          *Note Locales::, for more information.

     ‘locale-definitions’ (default: ‘%default-locale-definitions’)
          The list of locale definitions to be compiled and that may be
          used at run time.  *Note Locales::.

     ‘locale-libcs’ (default: ‘(list GLIBC)’)
          The list of GNU libc packages whose locale data and tools are
          used to build the locale definitions.  *Note Locales::, for
          compatibility considerations that justify this option.

     ‘name-service-switch’ (default: ‘%default-nss’)
          Configuration of the libc name service switch (NSS)—a
          ‘<name-service-switch>’ object.  *Note Name Service Switch::,
          for details.

     ‘services’ (default: ‘%base-services’)
          A list of service objects denoting system services.  *Note
          Services::.

     ‘essential-services’ (default: ...)
          The list of “essential services”—i.e., things like instances
          of ‘system-service-type’ and ‘host-name-service-type’ (*note
          Service Reference::), which are derived from the operating
          system definition itself.  As a user you should _never_ need
          to touch this field.

     ‘pam-services’ (default: ‘(base-pam-services)’)
          Linux “pluggable authentication module” (PAM) services.

     ‘setuid-programs’ (default: ‘%setuid-programs’)
          List of string-valued G-expressions denoting setuid programs.
          *Note Setuid Programs::.

     ‘sudoers-file’ (default: ‘%sudoers-specification’)
          The contents of the ‘/etc/sudoers’ file as a file-like object
          (*note ‘local-file’ and ‘plain-file’: G-Expressions.).

          This file specifies which users can use the ‘sudo’ command,
          what they are allowed to do, and what privileges they may
          gain.  The default is that only ‘root’ and members of the
          ‘wheel’ group may use ‘sudo’.

      -- Scheme Syntax: this-operating-system
          When used in the _lexical scope_ of an operating system field
          definition, this identifier resolves to the operating system
          being defined.

          The example below shows how to refer to the operating system
          being defined in the definition of the ‘label’ field:

               (use-modules (gnu) (guix))

               (operating-system
                 ;; ...
                 (label (package-full-name
                         (operating-system-kernel this-operating-system))))

          It is an error to refer to ‘this-operating-system’ outside an
          operating system definition.

   ---------- Footnotes ----------

   (1) Currently only the Linux-libre kernel is fully supported.  Using
GNU mach with the GNU Hurd is experimental and only available when
building a virtual machine disk image.


File: guix.info,  Node: File Systems,  Next: Mapped Devices,  Prev: operating-system Reference,  Up: System Configuration

8.3 File Systems
================

The list of file systems to be mounted is specified in the
‘file-systems’ field of the operating system declaration (*note Using
the Configuration System::).  Each file system is declared using the
‘file-system’ form, like this:

     (file-system
       (mount-point "/home")
       (device "/dev/sda3")
       (type "ext4"))

   As usual, some of the fields are mandatory—those shown in the example
above—while others can be omitted.  These are described below.

 -- Data Type: file-system
     Objects of this type represent file systems to be mounted.  They
     contain the following members:

     ‘type’
          This is a string specifying the type of the file system—e.g.,
          ‘"ext4"’.

     ‘mount-point’
          This designates the place where the file system is to be
          mounted.

     ‘device’
          This names the “source” of the file system.  It can be one of
          three things: a file system label, a file system UUID, or the
          name of a ‘/dev’ node.  Labels and UUIDs offer a way to refer
          to file systems without having to hard-code their actual
          device name(1).

          File system labels are created using the ‘file-system-label’
          procedure, UUIDs are created using ‘uuid’, and ‘/dev’ node are
          plain strings.  Here’s an example of a file system referred to
          by its label, as shown by the ‘e2label’ command:

               (file-system
                 (mount-point "/home")
                 (type "ext4")
                 (device (file-system-label "my-home")))

          UUIDs are converted from their string representation (as shown
          by the ‘tune2fs -l’ command) using the ‘uuid’ form(2), like
          this:

               (file-system
                 (mount-point "/home")
                 (type "ext4")
                 (device (uuid "4dab5feb-d176-45de-b287-9b0a6e4c01cb")))

          When the source of a file system is a mapped device (*note
          Mapped Devices::), its ‘device’ field _must_ refer to the
          mapped device name—e.g., ‘"/dev/mapper/root-partition"’.  This
          is required so that the system knows that mounting the file
          system depends on having the corresponding device mapping
          established.

     ‘flags’ (default: ‘'()’)
          This is a list of symbols denoting mount flags.  Recognized
          flags include ‘read-only’, ‘bind-mount’, ‘no-dev’ (disallow
          access to special files), ‘no-suid’ (ignore setuid and setgid
          bits), ‘no-atime’ (do not update file access times),
          ‘strict-atime’ (update file access time), ‘lazy-time’ (only
          update time on the in-memory version of the file inode), and
          ‘no-exec’ (disallow program execution).  *Note
          (libc)Mount-Unmount-Remount::, for more information on these
          flags.

     ‘options’ (default: ‘#f’)
          This is either ‘#f’, or a string denoting mount options passed
          to the file system driver.  *Note
          (libc)Mount-Unmount-Remount::, for details and run ‘man 8
          mount’ for options for various file systems.  Note that the
          ‘file-system-options->alist’ and ‘alist->file-system-options’
          procedures from ‘(gnu system file-systems)’ can be used to
          convert file system options given as an association list to
          the string representation, and vice-versa.

     ‘mount?’ (default: ‘#t’)
          This value indicates whether to automatically mount the file
          system when the system is brought up.  When set to ‘#f’, the
          file system gets an entry in ‘/etc/fstab’ (read by the ‘mount’
          command) but is not automatically mounted.

     ‘needed-for-boot?’ (default: ‘#f’)
          This Boolean value indicates whether the file system is needed
          when booting.  If that is true, then the file system is
          mounted when the initial RAM disk (initrd) is loaded.  This is
          always the case, for instance, for the root file system.

     ‘check?’ (default: ‘#t’)
          This Boolean indicates whether the file system needs to be
          checked for errors before being mounted.

     ‘create-mount-point?’ (default: ‘#f’)
          When true, the mount point is created if it does not exist
          yet.

     ‘dependencies’ (default: ‘'()’)
          This is a list of ‘<file-system>’ or ‘<mapped-device>’ objects
          representing file systems that must be mounted or mapped
          devices that must be opened before (and unmounted or closed
          after) this one.

          As an example, consider a hierarchy of mounts:
          ‘/sys/fs/cgroup’ is a dependency of ‘/sys/fs/cgroup/cpu’ and
          ‘/sys/fs/cgroup/memory’.

          Another example is a file system that depends on a mapped
          device, for example for an encrypted partition (*note Mapped
          Devices::).

   The ‘(gnu system file-systems)’ exports the following useful
variables.

 -- Scheme Variable: %base-file-systems
     These are essential file systems that are required on normal
     systems, such as ‘%pseudo-terminal-file-system’ and
     ‘%immutable-store’ (see below).  Operating system declarations
     should always contain at least these.

 -- Scheme Variable: %pseudo-terminal-file-system
     This is the file system to be mounted as ‘/dev/pts’.  It supports
     “pseudo-terminals” created via ‘openpty’ and similar functions
     (*note (libc)Pseudo-Terminals::).  Pseudo-terminals are used by
     terminal emulators such as ‘xterm’.

 -- Scheme Variable: %shared-memory-file-system
     This file system is mounted as ‘/dev/shm’ and is used to support
     memory sharing across processes (*note ‘shm_open’:
     (libc)Memory-mapped I/O.).

 -- Scheme Variable: %immutable-store
     This file system performs a read-only “bind mount” of ‘/gnu/store’,
     making it read-only for all the users including ‘root’.  This
     prevents against accidental modification by software running as
     ‘root’ or by system administrators.

     The daemon itself is still able to write to the store: it remounts
     it read-write in its own “name space.”

 -- Scheme Variable: %binary-format-file-system
     The ‘binfmt_misc’ file system, which allows handling of arbitrary
     executable file types to be delegated to user space.  This requires
     the ‘binfmt.ko’ kernel module to be loaded.

 -- Scheme Variable: %fuse-control-file-system
     The ‘fusectl’ file system, which allows unprivileged users to mount
     and unmount user-space FUSE file systems.  This requires the
     ‘fuse.ko’ kernel module to be loaded.

* Menu:

* Btrfs file system::

   ---------- Footnotes ----------

   (1) Note that, while it is tempting to use ‘/dev/disk/by-uuid’ and
similar device names to achieve the same result, this is not
recommended: These special device nodes are created by the udev daemon
and may be unavailable at the time the device is mounted.

   (2) The ‘uuid’ form expects 16-byte UUIDs as defined in RFC 4122
(https://tools.ietf.org/html/rfc4122).  This is the form of UUID used by
the ext2 family of file systems and others, but it is different from
“UUIDs” found in FAT file systems, for instance.


File: guix.info,  Node: Btrfs file system,  Up: File Systems

8.3.1 Btrfs file system
-----------------------

The Btrfs has special features, such as subvolumes, that merit being
explained in more details.  The following section attempts to cover
basic as well as complex uses of a Btrfs file system with the Guix
System.

   In its simplest usage, a Btrfs file system can be described, for
example, by:

     (file-system
       (mount-point "/home")
       (type "btrfs")
       (device (file-system-label "my-home")))

   The example below is more complex, as it makes use of a Btrfs
subvolume, named ‘rootfs’.  The parent Btrfs file system is labeled
‘my-btrfs-pool’, and is located on an encrypted device (hence the
dependency on ‘mapped-devices’):

     (file-system
       (device (file-system-label "my-btrfs-pool"))
       (mount-point "/")
       (type "btrfs")
       (options "subvol=rootfs")
       (dependencies mapped-devices))

   Some bootloaders, for example GRUB, only mount a Btrfs partition at
its top level during the early boot, and rely on their configuration to
refer to the correct subvolume path within that top level.  The
bootloaders operating in this way typically produce their configuration
on a running system where the Btrfs partitions are already mounted and
where the subvolume information is readily available.  As an example,
‘grub-mkconfig’, the configuration generator command shipped with GRUB,
reads ‘/proc/self/mountinfo’ to determine the top-level path of a
subvolume.

   The Guix System produces a bootloader configuration using the
operating system configuration as its sole input; it is therefore
necessary to extract the subvolume name on which ‘/gnu/store’ lives (if
any) from that operating system configuration.  To better illustrate,
consider a subvolume named ’rootfs’ which contains the root file system
data.  In such situation, the GRUB bootloader would only see the top
level of the root Btrfs partition, e.g.:

     /                   (top level)
     ├── rootfs          (subvolume directory)
         ├── gnu         (normal directory)
             ├── store   (normal directory)
     [...]

   Thus, the subvolume name must be prepended to the ‘/gnu/store’ path
of the kernel, initrd binaries and any other files referred to in the
GRUB configuration that must be found during the early boot.

   The next example shows a nested hierarchy of subvolumes and
directories:

     /                   (top level)
     ├── rootfs          (subvolume)
         ├── gnu         (normal directory)
             ├── store   (subvolume)
     [...]

   This scenario would work without mounting the ’store’ subvolume.
Mounting ’rootfs’ is sufficient, since the subvolume name matches its
intended mount point in the file system hierarchy.  Alternatively, the
’store’ subvolume could be referred to by setting the ‘subvol’ option to
either ‘/rootfs/gnu/store’ or ‘rootfs/gnu/store’.

   Finally, a more contrived example of nested subvolumes:

     /                           (top level)
     ├── root-snapshots          (subvolume)
         ├── root-current        (subvolume)
             ├── guix-store      (subvolume)
     [...]

   Here, the ’guix-store’ subvolume doesn’t match its intended mount
point, so it is necessary to mount it.  The subvolume must be fully
specified, by passing its file name to the ‘subvol’ option.  To
illustrate, the ’guix-store’ subvolume could be mounted on ‘/gnu/store’
by using a file system declaration such as:

     (file-system
       (device (file-system-label "btrfs-pool-1"))
       (mount-point "/gnu/store")
       (type "btrfs")
       (options "subvol=root-snapshots/root-current/guix-store,\
     compress-force=zstd,space_cache=v2"))


File: guix.info,  Node: Mapped Devices,  Next: User Accounts,  Prev: File Systems,  Up: System Configuration

8.4 Mapped Devices
==================

The Linux kernel has a notion of “device mapping”: a block device, such
as a hard disk partition, can be “mapped” into another device, usually
in ‘/dev/mapper/’, with additional processing over the data that flows
through it(1).  A typical example is encryption device mapping: all
writes to the mapped device are encrypted, and all reads are deciphered,
transparently.  Guix extends this notion by considering any device or
set of devices that are “transformed” in some way to create a new
device; for instance, RAID devices are obtained by “assembling” several
other devices, such as hard disks or partitions, into a new one that
behaves as one partition.  Other examples, not yet implemented, are LVM
logical volumes.

   Mapped devices are declared using the ‘mapped-device’ form, defined
as follows; for examples, see below.

 -- Data Type: mapped-device
     Objects of this type represent device mappings that will be made
     when the system boots up.

     ‘source’
          This is either a string specifying the name of the block
          device to be mapped, such as ‘"/dev/sda3"’, or a list of such
          strings when several devices need to be assembled for creating
          a new one.

     ‘target’
          This string specifies the name of the resulting mapped device.
          For kernel mappers such as encrypted devices of type
          ‘luks-device-mapping’, specifying ‘"my-partition"’ leads to
          the creation of the ‘"/dev/mapper/my-partition"’ device.  For
          RAID devices of type ‘raid-device-mapping’, the full device
          name such as ‘"/dev/md0"’ needs to be given.

     ‘type’
          This must be a ‘mapped-device-kind’ object, which specifies
          how SOURCE is mapped to TARGET.

 -- Scheme Variable: luks-device-mapping
     This defines LUKS block device encryption using the ‘cryptsetup’
     command from the package with the same name.  It relies on the
     ‘dm-crypt’ Linux kernel module.

 -- Scheme Variable: raid-device-mapping
     This defines a RAID device, which is assembled using the ‘mdadm’
     command from the package with the same name.  It requires a Linux
     kernel module for the appropriate RAID level to be loaded, such as
     ‘raid456’ for RAID-4, RAID-5 or RAID-6, or ‘raid10’ for RAID-10.

   The following example specifies a mapping from ‘/dev/sda3’ to
‘/dev/mapper/home’ using LUKS—the Linux Unified Key Setup
(https://gitlab.com/cryptsetup/cryptsetup), a standard mechanism for
disk encryption.  The ‘/dev/mapper/home’ device can then be used as the
‘device’ of a ‘file-system’ declaration (*note File Systems::).

     (mapped-device
       (source "/dev/sda3")
       (target "home")
       (type luks-device-mapping))

   Alternatively, to become independent of device numbering, one may
obtain the LUKS UUID (“unique identifier”) of the source device by a
command like:

     cryptsetup luksUUID /dev/sda3

   and use it as follows:

     (mapped-device
       (source (uuid "cb67fc72-0d54-4c88-9d4b-b225f30b0f44"))
       (target "home")
       (type luks-device-mapping))

   It is also desirable to encrypt swap space, since swap space may
contain sensitive data.  One way to accomplish that is to use a swap
file in a file system on a device mapped via LUKS encryption.  In this
way, the swap file is encrypted because the entire device is encrypted.
*Note Disk Partitioning: Preparing for Installation, for an example.

   A RAID device formed of the partitions ‘/dev/sda1’ and ‘/dev/sdb1’
may be declared as follows:

     (mapped-device
       (source (list "/dev/sda1" "/dev/sdb1"))
       (target "/dev/md0")
       (type raid-device-mapping))

   The ‘/dev/md0’ device can then be used as the ‘device’ of a
‘file-system’ declaration (*note File Systems::).  Note that the RAID
level need not be given; it is chosen during the initial creation and
formatting of the RAID device and is determined automatically later.

   ---------- Footnotes ----------

   (1) Note that the GNU Hurd makes no difference between the concept of
a “mapped device” and that of a file system: both boil down to
_translating_ input/output operations made on a file to operations on
its backing store.  Thus, the Hurd implements mapped devices, like file
systems, using the generic “translator” mechanism (*note
(hurd)Translators::).


File: guix.info,  Node: User Accounts,  Next: Keyboard Layout,  Prev: Mapped Devices,  Up: System Configuration

8.5 User Accounts
=================

User accounts and groups are entirely managed through the
‘operating-system’ declaration.  They are specified with the
‘user-account’ and ‘user-group’ forms:

     (user-account
       (name "alice")
       (group "users")
       (supplementary-groups '("wheel"   ;allow use of sudo, etc.
                               "audio"   ;sound card
                               "video"   ;video devices such as webcams
                               "cdrom")) ;the good ol' CD-ROM
       (comment "Bob's sister")
       (home-directory "/home/alice"))

   When booting or upon completion of ‘guix system reconfigure’, the
system ensures that only the user accounts and groups specified in the
‘operating-system’ declaration exist, and with the specified properties.
Thus, account or group creations or modifications made by directly
invoking commands such as ‘useradd’ are lost upon reconfiguration or
reboot.  This ensures that the system remains exactly as declared.

 -- Data Type: user-account
     Objects of this type represent user accounts.  The following
     members may be specified:

     ‘name’
          The name of the user account.

     ‘group’
          This is the name (a string) or identifier (a number) of the
          user group this account belongs to.

     ‘supplementary-groups’ (default: ‘'()’)
          Optionally, this can be defined as a list of group names that
          this account belongs to.

     ‘uid’ (default: ‘#f’)
          This is the user ID for this account (a number), or ‘#f’.  In
          the latter case, a number is automatically chosen by the
          system when the account is created.

     ‘comment’ (default: ‘""’)
          A comment about the account, such as the account owner’s full
          name.

     ‘home-directory’
          This is the name of the home directory for the account.

     ‘create-home-directory?’ (default: ‘#t’)
          Indicates whether the home directory of this account should be
          created if it does not exist yet.

     ‘shell’ (default: Bash)
          This is a G-expression denoting the file name of a program to
          be used as the shell (*note G-Expressions::).

     ‘system?’ (default: ‘#f’)
          This Boolean value indicates whether the account is a “system”
          account.  System accounts are sometimes treated specially; for
          instance, graphical login managers do not list them.

     ‘password’ (default: ‘#f’)
          You would normally leave this field to ‘#f’, initialize user
          passwords as ‘root’ with the ‘passwd’ command, and then let
          users change it with ‘passwd’.  Passwords set with ‘passwd’
          are of course preserved across reboot and reconfiguration.

          If you _do_ want to set an initial password for an account,
          then this field must contain the encrypted password, as a
          string.  You can use the ‘crypt’ procedure for this purpose:

               (user-account
                 (name "charlie")
                 (group "users")

                 ;; Specify a SHA-512-hashed initial password.
                 (password (crypt "InitialPassword!" "$6$abc")))

               Note: The hash of this initial password will be available
               in a file in ‘/gnu/store’, readable by all the users, so
               this method must be used with care.

          *Note (libc)Passphrase Storage::, for more information on
          password encryption, and *note (guile)Encryption::, for
          information on Guile’s ‘crypt’ procedure.

   User group declarations are even simpler:

     (user-group (name "students"))

 -- Data Type: user-group
     This type is for, well, user groups.  There are just a few fields:

     ‘name’
          The name of the group.

     ‘id’ (default: ‘#f’)
          The group identifier (a number).  If ‘#f’, a new number is
          automatically allocated when the group is created.

     ‘system?’ (default: ‘#f’)
          This Boolean value indicates whether the group is a “system”
          group.  System groups have low numerical IDs.

     ‘password’ (default: ‘#f’)
          What, user groups can have a password?  Well, apparently yes.
          Unless ‘#f’, this field specifies the password of the group.

   For convenience, a variable lists all the basic user groups one may
expect:

 -- Scheme Variable: %base-groups
     This is the list of basic user groups that users and/or packages
     expect to be present on the system.  This includes groups such as
     “root”, “wheel”, and “users”, as well as groups used to control
     access to specific devices such as “audio”, “disk”, and “cdrom”.

 -- Scheme Variable: %base-user-accounts
     This is the list of basic system accounts that programs may expect
     to find on a GNU/Linux system, such as the “nobody” account.

     Note that the “root” account is not included here.  It is a
     special-case and is automatically added whether or not it is
     specified.


File: guix.info,  Node: Keyboard Layout,  Next: Locales,  Prev: User Accounts,  Up: System Configuration

8.6 Keyboard Layout
===================

To specify what each key of your keyboard does, you need to tell the
operating system what “keyboard layout” you want to use.  The default,
when nothing is specified, is the US English QWERTY layout for 105-key
PC keyboards.  However, German speakers will usually prefer the German
QWERTZ layout, French speakers will want the AZERTY layout, and so on;
hackers might prefer Dvorak or bépo, and they might even want to further
customize the effect of some of the keys.  This section explains how to
get that done.

   There are three components that will want to know about your keyboard
layout:

   • The _bootloader_ may want to know what keyboard layout you want to
     use (*note ‘keyboard-layout’: Bootloader Configuration.).  This is
     useful if you want, for instance, to make sure that you can type
     the passphrase of your encrypted root partition using the right
     layout.

   • The _operating system kernel_, Linux, will need that so that the
     console is properly configured (*note ‘keyboard-layout’:
     operating-system Reference.).

   • The _graphical display server_, usually Xorg, also has its own idea
     of the keyboard layout (*note ‘keyboard-layout’: X Window.).

   Guix allows you to configure all three separately but, fortunately,
it allows you to share the same keyboard layout for all three
components.

   Keyboard layouts are represented by records created by the
‘keyboard-layout’ procedure of ‘(gnu system keyboard)’.  Following the X
Keyboard extension (XKB), each layout has four attributes: a name (often
a language code such as “fi” for Finnish or “jp” for Japanese), an
optional variant name, an optional keyboard model name, and a possibly
empty list of additional options.  In most cases the layout name is all
you care about.  Here are a few example:

     ;; The German QWERTZ layout.  Here we assume a standard
     ;; "pc105" keyboard model.
     (keyboard-layout "de")

     ;; The bépo variant of the French layout.
     (keyboard-layout "fr" "bepo")

     ;; The Catalan layout.
     (keyboard-layout "es" "cat")

     ;; Arabic layout with "Alt-Shift" to switch to US layout.
     (keyboard-layout "ar,us" #:options '("grp:alt_shift_toggle"))

     ;; The Latin American Spanish layout.  In addition, the
     ;; "Caps Lock" key is used as an additional "Ctrl" key,
     ;; and the "Menu" key is used as a "Compose" key to enter
     ;; accented letters.
     (keyboard-layout "latam"
                      #:options '("ctrl:nocaps" "compose:menu"))

     ;; The Russian layout for a ThinkPad keyboard.
     (keyboard-layout "ru" #:model "thinkpad")

     ;; The "US international" layout, which is the US layout plus
     ;; dead keys to enter accented characters.  This is for an
     ;; Apple MacBook keyboard.
     (keyboard-layout "us" "intl" #:model "macbook78")

   See the ‘share/X11/xkb’ directory of the ‘xkeyboard-config’ package
for a complete list of supported layouts, variants, and models.

   Let’s say you want your system to use the Turkish keyboard layout
throughout your system—bootloader, console, and Xorg.  Here’s what your
system configuration would look like:

     ;; Using the Turkish layout for the bootloader, the console,
     ;; and for Xorg.

     (operating-system
       ;; ...
       (keyboard-layout (keyboard-layout "tr"))  ;for the console
       (bootloader (bootloader-configuration
                     (bootloader grub-efi-bootloader)
                     (target "/boot/efi")
                     (keyboard-layout keyboard-layout))) ;for GRUB
       (services (cons (set-xorg-configuration
                         (xorg-configuration             ;for Xorg
                           (keyboard-layout keyboard-layout)))
                       %desktop-services)))

   In the example above, for GRUB and for Xorg, we just refer to the
‘keyboard-layout’ field defined above, but we could just as well refer
to a different layout.  The ‘set-xorg-configuration’ procedure
communicates the desired Xorg configuration to the graphical log-in
manager, by default GDM.

   We’ve discussed how to specify the _default_ keyboard layout of your
system when it starts, but you can also adjust it at run time:

   • If you’re using GNOME, its settings panel has a “Region & Language”
     entry where you can select one or more keyboard layouts.

   • Under Xorg, the ‘setxkbmap’ command (from the same-named package)
     allows you to change the current layout.  For example, this is how
     you would change the layout to US Dvorak:

          setxkbmap us dvorak

   • The ‘loadkeys’ command changes the keyboard layout in effect in the
     Linux console.  However, note that ‘loadkeys’ does _not_ use the
     XKB keyboard layout categorization described above.  The command
     below loads the French bépo layout:

          loadkeys fr-bepo


File: guix.info,  Node: Locales,  Next: Services,  Prev: Keyboard Layout,  Up: System Configuration

8.7 Locales
===========

A “locale” defines cultural conventions for a particular language and
region of the world (*note (libc)Locales::).  Each locale has a name
that typically has the form ‘LANGUAGE_TERRITORY.CODESET’—e.g.,
‘fr_LU.utf8’ designates the locale for the French language, with
cultural conventions from Luxembourg, and using the UTF-8 encoding.

   Usually, you will want to specify the default locale for the machine
using the ‘locale’ field of the ‘operating-system’ declaration (*note
‘locale’: operating-system Reference.).

   The selected locale is automatically added to the “locale
definitions” known to the system if needed, with its codeset inferred
from its name—e.g., ‘bo_CN.utf8’ will be assumed to use the ‘UTF-8’
codeset.  Additional locale definitions can be specified in the
‘locale-definitions’ slot of ‘operating-system’—this is useful, for
instance, if the codeset could not be inferred from the locale name.
The default set of locale definitions includes some widely used locales,
but not all the available locales, in order to save space.

   For instance, to add the North Frisian locale for Germany, the value
of that field may be:

     (cons (locale-definition
             (name "fy_DE.utf8") (source "fy_DE"))
           %default-locale-definitions)

   Likewise, to save space, one might want ‘locale-definitions’ to list
only the locales that are actually used, as in:

     (list (locale-definition
             (name "ja_JP.eucjp") (source "ja_JP")
             (charset "EUC-JP")))

   The compiled locale definitions are available at
‘/run/current-system/locale/X.Y’, where ‘X.Y’ is the libc version, which
is the default location where the GNU libc provided by Guix looks for
locale data.  This can be overridden using the ‘LOCPATH’ environment
variable (*note ‘LOCPATH’ and locale packages: locales-and-locpath.).

   The ‘locale-definition’ form is provided by the ‘(gnu system locale)’
module.  Details are given below.

 -- Data Type: locale-definition
     This is the data type of a locale definition.

     ‘name’
          The name of the locale.  *Note (libc)Locale Names::, for more
          information on locale names.

     ‘source’
          The name of the source for that locale.  This is typically the
          ‘LANGUAGE_TERRITORY’ part of the locale name.

     ‘charset’ (default: ‘"UTF-8"’)
          The “character set” or “code set” for that locale, as defined
          by IANA (https://www.iana.org/assignments/character-sets).

 -- Scheme Variable: %default-locale-definitions
     A list of commonly used UTF-8 locales, used as the default value of
     the ‘locale-definitions’ field of ‘operating-system’ declarations.

     These locale definitions use the “normalized codeset” for the part
     that follows the dot in the name (*note normalized codeset:
     (libc)Using gettextized software.).  So for instance it has
     ‘uk_UA.utf8’ but _not_, say, ‘uk_UA.UTF-8’.

8.7.1 Locale Data Compatibility Considerations
----------------------------------------------

‘operating-system’ declarations provide a ‘locale-libcs’ field to
specify the GNU libc packages that are used to compile locale
declarations (*note operating-system Reference::).  “Why would I care?”,
you may ask.  Well, it turns out that the binary format of locale data
is occasionally incompatible from one libc version to another.

   For instance, a program linked against libc version 2.21 is unable to
read locale data produced with libc 2.22; worse, that program _aborts_
instead of simply ignoring the incompatible locale data(1).  Similarly,
a program linked against libc 2.22 can read most, but not all, of the
locale data from libc 2.21 (specifically, ‘LC_COLLATE’ data is
incompatible); thus calls to ‘setlocale’ may fail, but programs will not
abort.

   The “problem” with Guix is that users have a lot of freedom: They can
choose whether and when to upgrade software in their profiles, and might
be using a libc version different from the one the system administrator
used to build the system-wide locale data.

   Fortunately, unprivileged users can also install their own locale
data and define ‘GUIX_LOCPATH’ accordingly (*note ‘GUIX_LOCPATH’ and
locale packages: locales-and-locpath.).

   Still, it is best if the system-wide locale data at
‘/run/current-system/locale’ is built for all the libc versions actually
in use on the system, so that all the programs can access it—this is
especially crucial on a multi-user system.  To do that, the
administrator can specify several libc packages in the ‘locale-libcs’
field of ‘operating-system’:

     (use-package-modules base)

     (operating-system
       ;; ...
       (locale-libcs (list glibc-2.21 (canonical-package glibc))))

   This example would lead to a system containing locale definitions for
both libc 2.21 and the current version of libc in
‘/run/current-system/locale’.

   ---------- Footnotes ----------

   (1) Versions 2.23 and later of GNU libc will simply skip the
incompatible locale data, which is already an improvement.


File: guix.info,  Node: Services,  Next: Setuid Programs,  Prev: Locales,  Up: System Configuration

8.8 Services
============

An important part of preparing an ‘operating-system’ declaration is
listing “system services” and their configuration (*note Using the
Configuration System::).  System services are typically daemons launched
when the system boots, or other actions needed at that time—e.g.,
configuring network access.

   Guix has a broad definition of “service” (*note Service
Composition::), but many services are managed by the GNU Shepherd (*note
Shepherd Services::).  On a running system, the ‘herd’ command allows
you to list the available services, show their status, start and stop
them, or do other specific operations (*note (shepherd)Jump Start::).
For example:

     # herd status

   The above command, run as ‘root’, lists the currently defined
services.  The ‘herd doc’ command shows a synopsis of the given service
and its associated actions:

     # herd doc nscd
     Run libc's name service cache daemon (nscd).

     # herd doc nscd action invalidate
     invalidate: Invalidate the given cache--e.g., 'hosts' for host name lookups.

   The ‘start’, ‘stop’, and ‘restart’ sub-commands have the effect you
would expect.  For instance, the commands below stop the nscd service
and restart the Xorg display server:

     # herd stop nscd
     Service nscd has been stopped.
     # herd restart xorg-server
     Service xorg-server has been stopped.
     Service xorg-server has been started.

   The following sections document the available services, starting with
the core services, that may be used in an ‘operating-system’
declaration.

* Menu:

* Base Services::               Essential system services.
* Scheduled Job Execution::     The mcron service.
* Log Rotation::                The rottlog service.
* Networking Services::         Network setup, SSH daemon, etc.
* X Window::                    Graphical display.
* Printing Services::           Local and remote printer support.
* Desktop Services::            D-Bus and desktop services.
* Sound Services::              ALSA and Pulseaudio services.
* Database Services::           SQL databases, key-value stores, etc.
* Mail Services::               IMAP, POP3, SMTP, and all that.
* Messaging Services::          Messaging services.
* Telephony Services::          Telephony services.
* Monitoring Services::         Monitoring services.
* Kerberos Services::           Kerberos services.
* LDAP Services::               LDAP services.
* Web Services::                Web servers.
* Certificate Services::        TLS certificates via Let’s Encrypt.
* DNS Services::                DNS daemons.
* VPN Services::                VPN daemons.
* Network File System::         NFS related services.
* Continuous Integration::      The Cuirass service.
* Power Management Services::   Extending battery life.
* Audio Services::              The MPD.
* Virtualization Services::     Virtualization services.
* Version Control Services::    Providing remote access to Git repositories.
* Game Services::               Game servers.
* PAM Mount Service::           Service to mount volumes when logging in.
* Guix Services::               Services relating specifically to Guix.
* Linux Services::              Services tied to the Linux kernel.
* Hurd Services::               Services specific for a Hurd System.
* Miscellaneous Services::      Other services.


File: guix.info,  Node: Base Services,  Next: Scheduled Job Execution,  Up: Services

8.8.1 Base Services
-------------------

The ‘(gnu services base)’ module provides definitions for the basic
services that one expects from the system.  The services exported by
this module are listed below.

 -- Scheme Variable: %base-services
     This variable contains a list of basic services (*note Service
     Types and Services::, for more information on service objects) one
     would expect from the system: a login service (mingetty) on each
     tty, syslogd, the libc name service cache daemon (nscd), the udev
     device manager, and more.

     This is the default value of the ‘services’ field of
     ‘operating-system’ declarations.  Usually, when customizing a
     system, you will want to append services to ‘%base-services’, like
     this:

          (append (list (service avahi-service-type)
                        (service openssh-service-type))
                  %base-services)

 -- Scheme Variable: special-files-service-type
     This is the service that sets up “special files” such as ‘/bin/sh’;
     an instance of it is part of ‘%base-services’.

     The value associated with ‘special-files-service-type’ services
     must be a list of tuples where the first element is the “special
     file” and the second element is its target.  By default it is:

          `(("/bin/sh" ,(file-append bash "/bin/sh")))

     If you want to add, say, ‘/usr/bin/env’ to your system, you can
     change it to:

          `(("/bin/sh" ,(file-append bash "/bin/sh"))
            ("/usr/bin/env" ,(file-append coreutils "/bin/env")))

     Since this is part of ‘%base-services’, you can use
     ‘modify-services’ to customize the set of special files (*note
     ‘modify-services’: Service Reference.).  But the simple way to add
     a special file is via the ‘extra-special-file’ procedure (see
     below).

 -- Scheme Procedure: extra-special-file FILE TARGET
     Use TARGET as the “special file” FILE.

     For example, adding the following lines to the ‘services’ field of
     your operating system declaration leads to a ‘/usr/bin/env’
     symlink:

          (extra-special-file "/usr/bin/env"
                              (file-append coreutils "/bin/env"))

 -- Scheme Procedure: host-name-service NAME
     Return a service that sets the host name to NAME.

 -- Scheme Variable: console-font-service-type
     Install the given fonts on the specified ttys (fonts are per
     virtual console on the kernel Linux).  The value of this service is
     a list of tty/font pairs.  The font can be the name of a font
     provided by the ‘kbd’ package or any valid argument to ‘setfont’,
     as in this example:

          `(("tty1" . "LatGrkCyr-8x16")
            ("tty2" . ,(file-append
                          font-tamzen
                          "/share/kbd/consolefonts/TamzenForPowerline10x20.psf"))
            ("tty3" . ,(file-append
                          font-terminus
                          "/share/consolefonts/ter-132n"))) ; for HDPI

 -- Scheme Procedure: login-service CONFIG
     Return a service to run login according to CONFIG, a
     ‘<login-configuration>’ object, which specifies the message of the
     day, among other things.

 -- Data Type: login-configuration
     This is the data type representing the configuration of login.

     ‘motd’
          A file-like object containing the “message of the day”.

     ‘allow-empty-passwords?’ (default: ‘#t’)
          Allow empty passwords by default so that first-time users can
          log in when the ’root’ account has just been created.

 -- Scheme Procedure: mingetty-service CONFIG
     Return a service to run mingetty according to CONFIG, a
     ‘<mingetty-configuration>’ object, which specifies the tty to run,
     among other things.

 -- Data Type: mingetty-configuration
     This is the data type representing the configuration of Mingetty,
     which provides the default implementation of virtual console
     log-in.

     ‘tty’
          The name of the console this Mingetty runs on—e.g., ‘"tty1"’.

     ‘auto-login’ (default: ‘#f’)
          When true, this field must be a string denoting the user name
          under which the system automatically logs in.  When it is
          ‘#f’, a user name and password must be entered to log in.

     ‘login-program’ (default: ‘#f’)
          This must be either ‘#f’, in which case the default log-in
          program is used (‘login’ from the Shadow tool suite), or a
          gexp denoting the name of the log-in program.

     ‘login-pause?’ (default: ‘#f’)
          When set to ‘#t’ in conjunction with AUTO-LOGIN, the user will
          have to press a key before the log-in shell is launched.

     ‘mingetty’ (default: MINGETTY)
          The Mingetty package to use.

 -- Scheme Procedure: agetty-service CONFIG
     Return a service to run agetty according to CONFIG, an
     ‘<agetty-configuration>’ object, which specifies the tty to run,
     among other things.

 -- Data Type: agetty-configuration
     This is the data type representing the configuration of agetty,
     which implements virtual and serial console log-in.  See the
     ‘agetty(8)’ man page for more information.

     ‘tty’
          The name of the console this agetty runs on, as a string—e.g.,
          ‘"ttyS0"’.  This argument is optional, it will default to a
          reasonable default serial port used by the kernel Linux.

          For this, if there is a value for an option ‘agetty.tty’ in
          the kernel command line, agetty will extract the device name
          of the serial port from it and use that.

          If not and if there is a value for an option ‘console’ with a
          tty in the Linux command line, agetty will extract the device
          name of the serial port from it and use that.

          In both cases, agetty will leave the other serial device
          settings (baud rate etc.) alone—in the hope that Linux pinned
          them to the correct values.

     ‘baud-rate’ (default: ‘#f’)
          A string containing a comma-separated list of one or more baud
          rates, in descending order.

     ‘term’ (default: ‘#f’)
          A string containing the value used for the ‘TERM’ environment
          variable.

     ‘eight-bits?’ (default: ‘#f’)
          When ‘#t’, the tty is assumed to be 8-bit clean, and parity
          detection is disabled.

     ‘auto-login’ (default: ‘#f’)
          When passed a login name, as a string, the specified user will
          be logged in automatically without prompting for their login
          name or password.

     ‘no-reset?’ (default: ‘#f’)
          When ‘#t’, don’t reset terminal cflags (control modes).

     ‘host’ (default: ‘#f’)
          This accepts a string containing the “login_host”, which will
          be written into the ‘/var/run/utmpx’ file.

     ‘remote?’ (default: ‘#f’)
          When set to ‘#t’ in conjunction with HOST, this will add an
          ‘-r’ fakehost option to the command line of the login program
          specified in LOGIN-PROGRAM.

     ‘flow-control?’ (default: ‘#f’)
          When set to ‘#t’, enable hardware (RTS/CTS) flow control.

     ‘no-issue?’ (default: ‘#f’)
          When set to ‘#t’, the contents of the ‘/etc/issue’ file will
          not be displayed before presenting the login prompt.

     ‘init-string’ (default: ‘#f’)
          This accepts a string that will be sent to the tty or modem
          before sending anything else.  It can be used to initialize a
          modem.

     ‘no-clear?’ (default: ‘#f’)
          When set to ‘#t’, agetty will not clear the screen before
          showing the login prompt.

     ‘login-program’ (default: (file-append shadow "/bin/login"))
          This must be either a gexp denoting the name of a log-in
          program, or unset, in which case the default value is the
          ‘login’ from the Shadow tool suite.

     ‘local-line’ (default: ‘#f’)
          Control the CLOCAL line flag.  This accepts one of three
          symbols as arguments, ‘'auto’, ‘'always’, or ‘'never’.  If
          ‘#f’, the default value chosen by agetty is ‘'auto’.

     ‘extract-baud?’ (default: ‘#f’)
          When set to ‘#t’, instruct agetty to try to extract the baud
          rate from the status messages produced by certain types of
          modems.

     ‘skip-login?’ (default: ‘#f’)
          When set to ‘#t’, do not prompt the user for a login name.
          This can be used with LOGIN-PROGRAM field to use non-standard
          login systems.

     ‘no-newline?’ (default: ‘#f’)
          When set to ‘#t’, do not print a newline before printing the
          ‘/etc/issue’ file.

     ‘login-options’ (default: ‘#f’)
          This option accepts a string containing options that are
          passed to the login program.  When used with the
          LOGIN-PROGRAM, be aware that a malicious user could try to
          enter a login name containing embedded options that could be
          parsed by the login program.

     ‘login-pause’ (default: ‘#f’)
          When set to ‘#t’, wait for any key before showing the login
          prompt.  This can be used in conjunction with AUTO-LOGIN to
          save memory by lazily spawning shells.

     ‘chroot’ (default: ‘#f’)
          Change root to the specified directory.  This option accepts a
          directory path as a string.

     ‘hangup?’ (default: ‘#f’)
          Use the Linux system call ‘vhangup’ to do a virtual hangup of
          the specified terminal.

     ‘keep-baud?’ (default: ‘#f’)
          When set to ‘#t’, try to keep the existing baud rate.  The
          baud rates from BAUD-RATE are used when agetty receives a
          <BREAK> character.

     ‘timeout’ (default: ‘#f’)
          When set to an integer value, terminate if no user name could
          be read within TIMEOUT seconds.

     ‘detect-case?’ (default: ‘#f’)
          When set to ‘#t’, turn on support for detecting an
          uppercase-only terminal.  This setting will detect a login
          name containing only uppercase letters as indicating an
          uppercase-only terminal and turn on some upper-to-lower case
          conversions.  Note that this will not support Unicode
          characters.

     ‘wait-cr?’ (default: ‘#f’)
          When set to ‘#t’, wait for the user or modem to send a
          carriage-return or linefeed character before displaying
          ‘/etc/issue’ or login prompt.  This is typically used with the
          INIT-STRING option.

     ‘no-hints?’ (default: ‘#f’)
          When set to ‘#t’, do not print hints about Num, Caps, and
          Scroll locks.

     ‘no-hostname?’ (default: ‘#f’)
          By default, the hostname is printed.  When this option is set
          to ‘#t’, no hostname will be shown at all.

     ‘long-hostname?’ (default: ‘#f’)
          By default, the hostname is only printed until the first dot.
          When this option is set to ‘#t’, the fully qualified hostname
          by ‘gethostname’ or ‘getaddrinfo’ is shown.

     ‘erase-characters’ (default: ‘#f’)
          This option accepts a string of additional characters that
          should be interpreted as backspace when the user types their
          login name.

     ‘kill-characters’ (default: ‘#f’)
          This option accepts a string that should be interpreted to
          mean “ignore all previous characters” (also called a “kill”
          character) when the user types their login name.

     ‘chdir’ (default: ‘#f’)
          This option accepts, as a string, a directory path that will
          be changed to before login.

     ‘delay’ (default: ‘#f’)
          This options accepts, as an integer, the number of seconds to
          sleep before opening the tty and displaying the login prompt.

     ‘nice’ (default: ‘#f’)
          This option accepts, as an integer, the nice value with which
          to run the ‘login’ program.

     ‘extra-options’ (default: ‘'()’)
          This option provides an “escape hatch” for the user to provide
          arbitrary command-line arguments to ‘agetty’ as a list of
          strings.

 -- Scheme Procedure: kmscon-service-type CONFIG
     Return a service to run kmscon
     (https://www.freedesktop.org/wiki/Software/kmscon) according to
     CONFIG, a ‘<kmscon-configuration>’ object, which specifies the tty
     to run, among other things.

 -- Data Type: kmscon-configuration
     This is the data type representing the configuration of Kmscon,
     which implements virtual console log-in.

     ‘virtual-terminal’
          The name of the console this Kmscon runs on—e.g., ‘"tty1"’.

     ‘login-program’ (default: ‘#~(string-append #$shadow "/bin/login")’)
          A gexp denoting the name of the log-in program.  The default
          log-in program is ‘login’ from the Shadow tool suite.

     ‘login-arguments’ (default: ‘'("-p")’)
          A list of arguments to pass to ‘login’.

     ‘auto-login’ (default: ‘#f’)
          When passed a login name, as a string, the specified user will
          be logged in automatically without prompting for their login
          name or password.

     ‘hardware-acceleration?’ (default: #f)
          Whether to use hardware acceleration.

     ‘kmscon’ (default: KMSCON)
          The Kmscon package to use.

 -- Scheme Procedure: nscd-service [CONFIG] [#:glibc glibc]
          [#:name-services '()]
     Return a service that runs the libc name service cache daemon
     (nscd) with the given CONFIG—an ‘<nscd-configuration>’ object.
     *Note Name Service Switch::, for an example.

     For convenience, the Shepherd service for nscd provides the
     following actions:

     ‘invalidate’
          This invalidate the given cache.  For instance, running:

               herd invalidate nscd hosts

          invalidates the host name lookup cache of nscd.

     ‘statistics’
          Running ‘herd statistics nscd’ displays information about nscd
          usage and caches.

 -- Scheme Variable: %nscd-default-configuration
     This is the default ‘<nscd-configuration>’ value (see below) used
     by ‘nscd-service’.  It uses the caches defined by
     ‘%nscd-default-caches’; see below.

 -- Data Type: nscd-configuration
     This is the data type representing the name service cache daemon
     (nscd) configuration.

     ‘name-services’ (default: ‘'()’)
          List of packages denoting “name services” that must be visible
          to the nscd—e.g., ‘(list NSS-MDNS)’.

     ‘glibc’ (default: GLIBC)
          Package object denoting the GNU C Library providing the ‘nscd’
          command.

     ‘log-file’ (default: ‘"/var/log/nscd.log"’)
          Name of the nscd log file.  This is where debugging output
          goes when ‘debug-level’ is strictly positive.

     ‘debug-level’ (default: ‘0’)
          Integer denoting the debugging levels.  Higher numbers mean
          that more debugging output is logged.

     ‘caches’ (default: ‘%nscd-default-caches’)
          List of ‘<nscd-cache>’ objects denoting things to be cached;
          see below.

 -- Data Type: nscd-cache
     Data type representing a cache database of nscd and its parameters.

     ‘database’
          This is a symbol representing the name of the database to be
          cached.  Valid values are ‘passwd’, ‘group’, ‘hosts’, and
          ‘services’, which designate the corresponding NSS database
          (*note (libc)NSS Basics::).

     ‘positive-time-to-live’
     ‘negative-time-to-live’ (default: ‘20’)
          A number representing the number of seconds during which a
          positive or negative lookup result remains in cache.

     ‘check-files?’ (default: ‘#t’)
          Whether to check for updates of the files corresponding to
          DATABASE.

          For instance, when DATABASE is ‘hosts’, setting this flag
          instructs nscd to check for updates in ‘/etc/hosts’ and to
          take them into account.

     ‘persistent?’ (default: ‘#t’)
          Whether the cache should be stored persistently on disk.

     ‘shared?’ (default: ‘#t’)
          Whether the cache should be shared among users.

     ‘max-database-size’ (default: 32 MiB)
          Maximum size in bytes of the database cache.

 -- Scheme Variable: %nscd-default-caches
     List of ‘<nscd-cache>’ objects used by default by
     ‘nscd-configuration’ (see above).

     It enables persistent and aggressive caching of service and host
     name lookups.  The latter provides better host name lookup
     performance, resilience in the face of unreliable name servers, and
     also better privacy—often the result of host name lookups is in
     local cache, so external name servers do not even need to be
     queried.

 -- Data Type: syslog-configuration
     This data type represents the configuration of the syslog daemon.

     ‘syslogd’ (default: ‘#~(string-append #$inetutils "/libexec/syslogd")’)
          The syslog daemon to use.

     ‘config-file’ (default: ‘%default-syslog.conf’)
          The syslog configuration file to use.

 -- Scheme Procedure: syslog-service CONFIG
     Return a service that runs a syslog daemon according to CONFIG.

     *Note (inetutils)syslogd invocation::, for more information on the
     configuration file syntax.

 -- Scheme Variable: guix-service-type
     This is the type of the service that runs the build daemon,
     ‘guix-daemon’ (*note Invoking guix-daemon::).  Its value must be a
     ‘guix-configuration’ record as described below.

 -- Data Type: guix-configuration
     This data type represents the configuration of the Guix build
     daemon.  *Note Invoking guix-daemon::, for more information.

     ‘guix’ (default: GUIX)
          The Guix package to use.

     ‘build-group’ (default: ‘"guixbuild"’)
          Name of the group for build user accounts.

     ‘build-accounts’ (default: ‘10’)
          Number of build user accounts to create.

     ‘authorize-key?’ (default: ‘#t’)
          Whether to authorize the substitute keys listed in
          ‘authorized-keys’—by default that of ‘ci.guix.gnu.org’ (*note
          Substitutes::).

     ‘authorized-keys’ (default: ‘%default-authorized-guix-keys’)
          The list of authorized key files for archive imports, as a
          list of string-valued gexps (*note Invoking guix archive::).
          By default, it contains that of ‘ci.guix.gnu.org’ (*note
          Substitutes::).

     ‘use-substitutes?’ (default: ‘#t’)
          Whether to use substitutes.

     ‘substitute-urls’ (default: ‘%default-substitute-urls’)
          The list of URLs where to look for substitutes by default.

     ‘max-silent-time’ (default: ‘0’)
     ‘timeout’ (default: ‘0’)
          The number of seconds of silence and the number of seconds of
          activity, respectively, after which a build process times out.
          A value of zero disables the timeout.

     ‘log-compression’ (default: ‘'bzip2’)
          The type of compression used for build logs—one of ‘gzip’,
          ‘bzip2’, or ‘none’.

     ‘extra-options’ (default: ‘'()’)
          List of extra command-line options for ‘guix-daemon’.

     ‘log-file’ (default: ‘"/var/log/guix-daemon.log"’)
          File where ‘guix-daemon’’s standard output and standard error
          are written.

     ‘http-proxy’ (default: ‘#f’)
          The URL of the HTTP and HTTPS proxy used for downloading
          fixed-output derivations and substitutes.

          It is also possible to change the daemon’s proxy at run time
          through the ‘set-http-proxy’ action, which restarts it:

               herd set-http-proxy guix-daemon http://localhost:8118

          To clear the proxy settings, run:

               herd set-http-proxy guix-daemon

     ‘tmpdir’ (default: ‘#f’)
          A directory path where the ‘guix-daemon’ will perform builds.

 -- Scheme Procedure: udev-service [#:udev EUDEV #:rules ‘'()’]
     Run UDEV, which populates the ‘/dev’ directory dynamically.  udev
     rules can be provided as a list of files through the RULES
     variable.  The procedures ‘udev-rule’, ‘udev-rules-service’ and
     ‘file->udev-rule’ from ‘(gnu services base)’ simplify the creation
     of such rule files.

     The ‘herd rules udev’ command, as root, returns the name of the
     directory containing all the active udev rules.

 -- Scheme Procedure: udev-rule [FILE-NAME CONTENTS]
     Return a udev-rule file named FILE-NAME containing the rules
     defined by the CONTENTS literal.

     In the following example, a rule for a USB device is defined to be
     stored in the file ‘90-usb-thing.rules’.  The rule runs a script
     upon detecting a USB device with a given product identifier.

          (define %example-udev-rule
            (udev-rule
              "90-usb-thing.rules"
              (string-append "ACTION==\"add\", SUBSYSTEM==\"usb\", "
                             "ATTR{product}==\"Example\", "
                             "RUN+=\"/path/to/script\"")))

 -- Scheme Procedure: udev-rules-service [NAME RULES] [#:groups GROUPS]
     Return a service that extends ‘udev-service-type ’ with RULES and
     ‘account-service-type’ with GROUPS as system groups.  This works by
     creating a singleton service type ‘NAME-udev-rules’, of which the
     returned service is an instance.

     Here we show how it can be used to extend ‘udev-service-type’ with
     the previously defined rule ‘%example-udev-rule’.

          (operating-system
           ;; ...
           (services
             (cons (udev-rules-service 'usb-thing %example-udev-rule)
                   %desktop-services)))

 -- Scheme Procedure: file->udev-rule [FILE-NAME FILE]
     Return a udev file named FILE-NAME containing the rules defined
     within FILE, a file-like object.

     The following example showcases how we can use an existing rule
     file.

          (use-modules (guix download)     ;for url-fetch
                       (guix packages)     ;for origin
                       ...)

          (define %android-udev-rules
            (file->udev-rule
              "51-android-udev.rules"
              (let ((version "20170910"))
                (origin
                 (method url-fetch)
                 (uri (string-append "https://raw.githubusercontent.com/M0Rf30/"
                                     "android-udev-rules/" version "/51-android.rules"))
                 (sha256
                  (base32 "0lmmagpyb6xsq6zcr2w1cyx9qmjqmajkvrdbhjx32gqf1d9is003"))))))

   Additionally, Guix package definitions can be included in RULES in
order to extend the udev rules with the definitions found under their
‘lib/udev/rules.d’ sub-directory.  In lieu of the previous
FILE->UDEV-RULE example, we could have used the ANDROID-UDEV-RULES
package which exists in Guix in the ‘(gnu packages android)’ module.

   The following example shows how to use the ANDROID-UDEV-RULES package
so that the Android tool ‘adb’ can detect devices without root
privileges.  It also details how to create the ‘adbusers’ group, which
is required for the proper functioning of the rules defined within the
‘android-udev-rules’ package.  To create such a group, we must define it
both as part of the ‘supplementary-groups’ of our ‘user-account’
declaration, as well as in the GROUPS of the ‘udev-rules-service’
procedure.

     (use-modules (gnu packages android)  ;for android-udev-rules
                  (gnu system shadow)     ;for user-group
                  ...)

     (operating-system
       ;; ...
       (users (cons (user-account
                     ;; ...
                     (supplementary-groups
                      '("adbusers"   ;for adb
                        "wheel" "netdev" "audio" "video")))))
       ;; ...
       (services
         (cons (udev-rules-service 'android android-udev-rules
                                   #:groups '("adbusers"))
               %desktop-services)))

 -- Scheme Variable: urandom-seed-service-type
     Save some entropy in ‘%random-seed-file’ to seed ‘/dev/urandom’
     when rebooting.  It also tries to seed ‘/dev/urandom’ from
     ‘/dev/hwrng’ while booting, if ‘/dev/hwrng’ exists and is readable.

 -- Scheme Variable: %random-seed-file
     This is the name of the file where some random bytes are saved by
     URANDOM-SEED-SERVICE to seed ‘/dev/urandom’ when rebooting.  It
     defaults to ‘/var/lib/random-seed’.

 -- Scheme Variable: gpm-service-type
     This is the type of the service that runs GPM, the “general-purpose
     mouse daemon”, which provides mouse support to the Linux console.
     GPM allows users to use the mouse in the console, notably to
     select, copy, and paste text.

     The value for services of this type must be a ‘gpm-configuration’
     (see below).  This service is not part of ‘%base-services’.

 -- Data Type: gpm-configuration
     Data type representing the configuration of GPM.

     ‘options’ (default: ‘%default-gpm-options’)
          Command-line options passed to ‘gpm’.  The default set of
          options instruct ‘gpm’ to listen to mouse events on
          ‘/dev/input/mice’.  *Note (gpm)Command Line::, for more
          information.

     ‘gpm’ (default: ‘gpm’)
          The GPM package to use.

 -- Scheme Variable: guix-publish-service-type
     This is the service type for ‘guix publish’ (*note Invoking guix
     publish::).  Its value must be a ‘guix-publish-configuration’
     object, as described below.

     This assumes that ‘/etc/guix’ already contains a signing key pair
     as created by ‘guix archive --generate-key’ (*note Invoking guix
     archive::).  If that is not the case, the service will fail to
     start.

 -- Data Type: guix-publish-configuration
     Data type representing the configuration of the ‘guix publish’
     service.

     ‘guix’ (default: ‘guix’)
          The Guix package to use.

     ‘port’ (default: ‘80’)
          The TCP port to listen for connections.

     ‘host’ (default: ‘"localhost"’)
          The host (and thus, network interface) to listen to.  Use
          ‘"0.0.0.0"’ to listen on all the network interfaces.

     ‘compression’ (default: ‘'(("gzip" 3))’)
          This is a list of compression method/level tuple used when
          compressing substitutes.  For example, to compress all
          substitutes with _both_ lzip at level 7 and gzip at level 9,
          write:

               '(("lzip" 7) ("gzip" 9))

          Level 9 achieves the best compression ratio at the expense of
          increased CPU usage, whereas level 1 achieves fast
          compression.

          An empty list disables compression altogether.

     ‘nar-path’ (default: ‘"nar"’)
          The URL path at which “nars” can be fetched.  *Note
          ‘--nar-path’: Invoking guix publish, for details.

     ‘cache’ (default: ‘#f’)
          When it is ‘#f’, disable caching and instead generate archives
          on demand.  Otherwise, this should be the name of a
          directory—e.g., ‘"/var/cache/guix/publish"’—where ‘guix
          publish’ caches archives and meta-data ready to be sent.
          *Note ‘--cache’: Invoking guix publish, for more information
          on the tradeoffs involved.

     ‘workers’ (default: ‘#f’)
          When it is an integer, this is the number of worker threads
          used for caching; when ‘#f’, the number of processors is used.
          *Note ‘--workers’: Invoking guix publish, for more
          information.

     ‘ttl’ (default: ‘#f’)
          When it is an integer, this denotes the “time-to-live” in
          seconds of the published archives.  *Note ‘--ttl’: Invoking
          guix publish, for more information.

 -- Scheme Procedure: rngd-service [#:rng-tools RNG-TOOLS] [#:device
          "/dev/hwrng"]
     Return a service that runs the ‘rngd’ program from RNG-TOOLS to add
     DEVICE to the kernel’s entropy pool.  The service will fail if
     DEVICE does not exist.

 -- Scheme Procedure: pam-limits-service [#:limits ‘'()’]

     Return a service that installs a configuration file for the
     ‘pam_limits’ module
     (http://linux-pam.org/Linux-PAM-html/sag-pam_limits.html).  The
     procedure optionally takes a list of ‘pam-limits-entry’ values,
     which can be used to specify ‘ulimit’ limits and nice priority
     limits to user sessions.

     The following limits definition sets two hard and soft limits for
     all login sessions of users in the ‘realtime’ group:

          (pam-limits-service
           (list
            (pam-limits-entry "@realtime" 'both 'rtprio 99)
            (pam-limits-entry "@realtime" 'both 'memlock 'unlimited)))

     The first entry increases the maximum realtime priority for
     non-privileged processes; the second entry lifts any restriction of
     the maximum address space that can be locked in memory.  These
     settings are commonly used for real-time audio systems.


File: guix.info,  Node: Scheduled Job Execution,  Next: Log Rotation,  Prev: Base Services,  Up: Services

8.8.2 Scheduled Job Execution
-----------------------------

The ‘(gnu services mcron)’ module provides an interface to GNU mcron, a
daemon to run jobs at scheduled times (*note (mcron)Top::).  GNU mcron
is similar to the traditional Unix ‘cron’ daemon; the main difference is
that it is implemented in Guile Scheme, which provides a lot of
flexibility when specifying the scheduling of jobs and their actions.

   The example below defines an operating system that runs the
‘updatedb’ (*note (find)Invoking updatedb::) and the ‘guix gc’ commands
(*note Invoking guix gc::) daily, as well as the ‘mkid’ command on
behalf of an unprivileged user (*note (idutils)mkid invocation::).  It
uses gexps to introduce job definitions that are passed to mcron (*note
G-Expressions::).

     (use-modules (guix) (gnu) (gnu services mcron))
     (use-package-modules base idutils)

     (define updatedb-job
       ;; Run 'updatedb' at 3AM every day.  Here we write the
       ;; job's action as a Scheme procedure.
       #~(job '(next-hour '(3))
              (lambda ()
                (execl (string-append #$findutils "/bin/updatedb")
                       "updatedb"
                       "--prunepaths=/tmp /var/tmp /gnu/store"))))

     (define garbage-collector-job
       ;; Collect garbage 5 minutes after midnight every day.
       ;; The job's action is a shell command.
       #~(job "5 0 * * *"            ;Vixie cron syntax
              "guix gc -F 1G"))

     (define idutils-job
       ;; Update the index database as user "charlie" at 12:15PM
       ;; and 19:15PM.  This runs from the user's home directory.
       #~(job '(next-minute-from (next-hour '(12 19)) '(15))
              (string-append #$idutils "/bin/mkid src")
              #:user "charlie"))

     (operating-system
       ;; ...
       (services (cons (service mcron-service-type
                                (mcron-configuration
                                 (jobs (list garbage-collector-job
                                             updatedb-job
                                             idutils-job))))
                       %base-services)))

   For more complex jobs defined in Scheme where you need control over
the top level, for instance to introduce a ‘use-modules’ form, you can
move your code to a separate program using the ‘program-file’ procedure
of the ‘(guix gexp)’ module (*note G-Expressions::).  The example below
illustrates that.

     (define %battery-alert-job
       ;; Beep when the battery percentage falls below %MIN-LEVEL.
       #~(job
          '(next-minute (range 0 60 1))
          #$(program-file
             "battery-alert.scm"
             (with-imported-modules (source-module-closure
                                     '((guix build utils)))
               #~(begin
                   (define %min-level 20)
                   (use-modules (guix build utils)
                                (ice-9 popen)
                                (ice-9 regex)
                                (ice-9 textual-ports)
                                (srfi srfi-2))
                   (setenv "LC_ALL" "C")     ;ensure English output
                   (and-let* ((input-pipe (open-pipe*
                                           OPEN_READ
                                           #$(file-append acpi "/bin/acpi")))
                              (output (get-string-all input-pipe))
                              (m (string-match "Discharging, ([0-9]+)%" output))
                              (level (string->number (match:substring m 1)))
                              ((< level %min-level)))
                     (format #t "warning: Battery level is low (~a%)~%" level)
                     (invoke #$(file-append beep "/bin/beep") "-r5")))))))

   *Note mcron job specifications: (mcron)Guile Syntax, for more
information on mcron job specifications.  Below is the reference of the
mcron service.

   On a running system, you can use the ‘schedule’ action of the service
to visualize the mcron jobs that will be executed next:

     # herd schedule mcron

The example above lists the next five tasks that will be executed, but
you can also specify the number of tasks to display:

     # herd schedule mcron 10

 -- Scheme Variable: mcron-service-type
     This is the type of the ‘mcron’ service, whose value is an
     ‘mcron-configuration’ object.

     This service type can be the target of a service extension that
     provides it additional job specifications (*note Service
     Composition::).  In other words, it is possible to define services
     that provide additional mcron jobs to run.

 -- Data Type: mcron-configuration
     Data type representing the configuration of mcron.

     ‘mcron’ (default: MCRON)
          The mcron package to use.

     ‘jobs’
          This is a list of gexps (*note G-Expressions::), where each
          gexp corresponds to an mcron job specification (*note mcron
          job specifications: (mcron)Syntax.).


File: guix.info,  Node: Log Rotation,  Next: Networking Services,  Prev: Scheduled Job Execution,  Up: Services

8.8.3 Log Rotation
------------------

Log files such as those found in ‘/var/log’ tend to grow endlessly, so
it’s a good idea to “rotate” them once in a while—i.e., archive their
contents in separate files, possibly compressed.  The ‘(gnu services
admin)’ module provides an interface to GNU Rot[t]log, a log rotation
tool (*note (rottlog)Top::).

   This service is part of ‘%base-services’, and thus enabled by
default, with the default settings, for commonly encountered log files.
The example below shows how to extend it with an additional “rotation”,
should you need to do that (usually, services that produce log files
already take care of that):

     (use-modules (guix) (gnu))
     (use-service-modules admin)

     (define my-log-files
       ;; Log files that I want to rotate.
       '("/var/log/something.log" "/var/log/another.log"))

     (operating-system
       ;; ...
       (services (cons (simple-service 'rotate-my-stuff
                                       rottlog-service-type
                                       (list (log-rotation
                                              (frequency 'daily)
                                              (files my-log-files))))
                       %base-services)))

 -- Scheme Variable: rottlog-service-type
     This is the type of the Rottlog service, whose value is a
     ‘rottlog-configuration’ object.

     Other services can extend this one with new ‘log-rotation’ objects
     (see below), thereby augmenting the set of files to be rotated.

     This service type can define mcron jobs (*note Scheduled Job
     Execution::) to run the rottlog service.

 -- Data Type: rottlog-configuration
     Data type representing the configuration of rottlog.

     ‘rottlog’ (default: ‘rottlog’)
          The Rottlog package to use.

     ‘rc-file’ (default: ‘(file-append rottlog "/etc/rc")’)
          The Rottlog configuration file to use (*note
          (rottlog)Mandatory RC Variables::).

     ‘rotations’ (default: ‘%default-rotations’)
          A list of ‘log-rotation’ objects as defined below.

     ‘jobs’
          This is a list of gexps where each gexp corresponds to an
          mcron job specification (*note Scheduled Job Execution::).

 -- Data Type: log-rotation
     Data type representing the rotation of a group of log files.

     Taking an example from the Rottlog manual (*note (rottlog)Period
     Related File Examples::), a log rotation might be defined like
     this:

          (log-rotation
            (frequency 'daily)
            (files '("/var/log/apache/*"))
            (options '("storedir apache-archives"
                       "rotate 6"
                       "notifempty"
                       "nocompress")))

     The list of fields is as follows:

     ‘frequency’ (default: ‘'weekly’)
          The log rotation frequency, a symbol.

     ‘files’
          The list of files or file glob patterns to rotate.

     ‘options’ (default: ‘'()’)
          The list of rottlog options for this rotation (*note
          (rottlog)Configuration parameters::).

     ‘post-rotate’ (default: ‘#f’)
          Either ‘#f’ or a gexp to execute once the rotation has
          completed.

 -- Scheme Variable: %default-rotations
     Specifies weekly rotation of ‘%rotated-files’ and of
     ‘/var/log/guix-daemon.log’.

 -- Scheme Variable: %rotated-files
     The list of syslog-controlled files to be rotated.  By default it
     is: ‘'("/var/log/messages" "/var/log/secure" "/var/log/debug" \
     "/var/log/maillog")’.


File: guix.info,  Node: Networking Services,  Next: X Window,  Prev: Log Rotation,  Up: Services

8.8.4 Networking Services
-------------------------

The ‘(gnu services networking)’ module provides services to configure
the network interface.

 -- Scheme Variable: dhcp-client-service-type
     This is the type of services that run DHCP, a Dynamic Host
     Configuration Protocol (DHCP) client, on all the non-loopback
     network interfaces.  Its value is the DHCP client package to use,
     ‘isc-dhcp’ by default.

 -- Scheme Procedure: dhcpd-service-type
     This type defines a service that runs a DHCP daemon.  To create a
     service of this type, you must supply a ‘<dhcpd-configuration>’.
     For example:

          (service dhcpd-service-type
                   (dhcpd-configuration
                    (config-file (local-file "my-dhcpd.conf"))
                    (interfaces '("enp0s25"))))

 -- Data Type: dhcpd-configuration
     ‘package’ (default: ‘isc-dhcp’)
          The package that provides the DHCP daemon.  This package is
          expected to provide the daemon at ‘sbin/dhcpd’ relative to its
          output directory.  The default package is the ISC’s DHCP
          server (https://www.isc.org/products/DHCP).
     ‘config-file’ (default: ‘#f’)
          The configuration file to use.  This is required.  It will be
          passed to ‘dhcpd’ via its ‘-cf’ option.  This may be any
          “file-like” object (*note file-like objects: G-Expressions.).
          See ‘man dhcpd.conf’ for details on the configuration file
          syntax.
     ‘version’ (default: ‘"4"’)
          The DHCP version to use.  The ISC DHCP server supports the
          values “4”, “6”, and “4o6”.  These correspond to the ‘dhcpd’
          program options ‘-4’, ‘-6’, and ‘-4o6’.  See ‘man dhcpd’ for
          details.
     ‘run-directory’ (default: ‘"/run/dhcpd"’)
          The run directory to use.  At service activation time, this
          directory will be created if it does not exist.
     ‘pid-file’ (default: ‘"/run/dhcpd/dhcpd.pid"’)
          The PID file to use.  This corresponds to the ‘-pf’ option of
          ‘dhcpd’.  See ‘man dhcpd’ for details.
     ‘interfaces’ (default: ‘'()’)
          The names of the network interfaces on which dhcpd should
          listen for broadcasts.  If this list is not empty, then its
          elements (which must be strings) will be appended to the
          ‘dhcpd’ invocation when starting the daemon.  It may not be
          necessary to explicitly specify any interfaces here; see ‘man
          dhcpd’ for details.

 -- Scheme Variable: static-networking-service-type
     This is the type for statically-configured network interfaces.

 -- Scheme Procedure: static-networking-service INTERFACE IP [#:netmask
          #f] [#:gateway #f] [#:name-servers ‘'()’] [#:requirement
          ‘'(udev)’]
     Return a service that starts INTERFACE with address IP.  If NETMASK
     is true, use it as the network mask.  If GATEWAY is true, it must
     be a string specifying the default network gateway.  REQUIREMENT
     can be used to declare a dependency on another service before
     configuring the interface.

     This procedure can be called several times, one for each network
     interface of interest.  Behind the scenes what it does is extend
     ‘static-networking-service-type’ with additional network interfaces
     to handle.

     For example:

          (static-networking-service "eno1" "192.168.1.82"
                                     #:gateway "192.168.1.2"
                                     #:name-servers '("192.168.1.2"))

 -- Scheme Procedure: wicd-service [#:wicd WICD]
     Return a service that runs Wicd (https://launchpad.net/wicd), a
     network management daemon that aims to simplify wired and wireless
     networking.

     This service adds the WICD package to the global profile, providing
     several commands to interact with the daemon and configure
     networking: ‘wicd-client’, a graphical user interface, and the
     ‘wicd-cli’ and ‘wicd-curses’ user interfaces.

 -- Scheme Variable: modem-manager-service-type
     This is the service type for the ModemManager
     (https://wiki.gnome.org/Projects/ModemManager) service.  The value
     for this service type is a ‘modem-manager-configuration’ record.

     This service is part of ‘%desktop-services’ (*note Desktop
     Services::).

 -- Data Type: modem-manager-configuration
     Data type representing the configuration of ModemManager.

     ‘modem-manager’ (default: ‘modem-manager’)
          The ModemManager package to use.

 -- Scheme Variable: usb-modeswitch-service-type
     This is the service type for the USB_ModeSwitch
     (https://www.draisberghof.de/usb_modeswitch/) service.  The value
     for this service type is a ‘usb-modeswitch-configuration’ record.

     When plugged in, some USB modems (and other USB devices) initially
     present themselves as a read-only storage medium and not as a
     modem.  They need to be “modeswitched” before they are usable.  The
     USB_ModeSwitch service type installs udev rules to automatically
     modeswitch these devices when they are plugged in.

     This service is part of ‘%desktop-services’ (*note Desktop
     Services::).

 -- Data Type: usb-modeswitch-configuration
     Data type representing the configuration of USB_ModeSwitch.

     ‘usb-modeswitch’ (default: ‘usb-modeswitch’)
          The USB_ModeSwitch package providing the binaries for
          modeswitching.

     ‘usb-modeswitch-data’ (default: ‘usb-modeswitch-data’)
          The package providing the device data and udev rules file used
          by USB_ModeSwitch.

     ‘config-file’ (default: ‘#~(string-append #$usb-modeswitch:dispatcher "/etc/usb_modeswitch.conf")’)
          Which config file to use for the USB_ModeSwitch dispatcher.
          By default the config file shipped with USB_ModeSwitch is used
          which disables logging to ‘/var/log’ among other default
          settings.  If set to ‘#f’, no config file is used.

 -- Scheme Variable: network-manager-service-type
     This is the service type for the NetworkManager
     (https://wiki.gnome.org/Projects/NetworkManager) service.  The
     value for this service type is a ‘network-manager-configuration’
     record.

     This service is part of ‘%desktop-services’ (*note Desktop
     Services::).

 -- Data Type: network-manager-configuration
     Data type representing the configuration of NetworkManager.

     ‘network-manager’ (default: ‘network-manager’)
          The NetworkManager package to use.

     ‘dns’ (default: ‘"default"’)
          Processing mode for DNS, which affects how NetworkManager uses
          the ‘resolv.conf’ configuration file.

          ‘default’
               NetworkManager will update ‘resolv.conf’ to reflect the
               nameservers provided by currently active connections.

          ‘dnsmasq’
               NetworkManager will run ‘dnsmasq’ as a local caching
               nameserver, using a “conditional forwarding”
               configuration if you are connected to a VPN, and then
               update ‘resolv.conf’ to point to the local nameserver.

               With this setting, you can share your network connection.
               For example when you want to share your network
               connection to another laptop via an Ethernet cable, you
               can open ‘nm-connection-editor’ and configure the Wired
               connection’s method for IPv4 and IPv6 to be “Shared to
               other computers” and reestablish the connection (or
               reboot).

               You can also set up a “host-to-guest connection” to QEMU
               VMs (*note Installing Guix in a VM::).  With a
               host-to-guest connection, you can e.g. access a Web
               server running on the VM (*note Web Services::) from a
               Web browser on your host system, or connect to the VM via
               SSH (*note ‘openssh-service-type’: Networking Services.).
               To set up a host-to-guest connection, run this command
               once:

                    nmcli connection add type tun \
                     connection.interface-name tap0 \
                     tun.mode tap tun.owner $(id -u) \
                     ipv4.method shared \
                     ipv4.addresses 172.28.112.1/24

               Then each time you launch your QEMU VM (*note Running
               Guix in a VM::), pass ‘-nic
               tap,ifname=tap0,script=no,downscript=no’ to
               ‘qemu-system-...’.

          ‘none’
               NetworkManager will not modify ‘resolv.conf’.

     ‘vpn-plugins’ (default: ‘'()’)
          This is the list of available plugins for virtual private
          networks (VPNs).  An example of this is the
          ‘network-manager-openvpn’ package, which allows NetworkManager
          to manage VPNs via OpenVPN.

 -- Scheme Variable: connman-service-type
     This is the service type to run Connman (https://01.org/connman), a
     network connection manager.

     Its value must be an ‘connman-configuration’ record as in this
     example:

          (service connman-service-type
                   (connman-configuration
                     (disable-vpn? #t)))

     See below for details about ‘connman-configuration’.

 -- Data Type: connman-configuration
     Data Type representing the configuration of connman.

     ‘connman’ (default: CONNMAN)
          The connman package to use.

     ‘disable-vpn?’ (default: ‘#f’)
          When true, disable connman’s vpn plugin.

 -- Scheme Variable: wpa-supplicant-service-type
     This is the service type to run WPA supplicant
     (https://w1.fi/wpa_supplicant/), an authentication daemon required
     to authenticate against encrypted WiFi or ethernet networks.

 -- Data Type: wpa-supplicant-configuration
     Data type representing the configuration of WPA Supplicant.

     It takes the following parameters:

     ‘wpa-supplicant’ (default: ‘wpa-supplicant’)
          The WPA Supplicant package to use.

     ‘dbus?’ (default: ‘#t’)
          Whether to listen for requests on D-Bus.

     ‘pid-file’ (default: ‘"/var/run/wpa_supplicant.pid"’)
          Where to store the PID file.

     ‘interface’ (default: ‘#f’)
          If this is set, it must specify the name of a network
          interface that WPA supplicant will control.

     ‘config-file’ (default: ‘#f’)
          Optional configuration file to use.

     ‘extra-options’ (default: ‘'()’)
          List of additional command-line arguments to pass to the
          daemon.

 -- Scheme Variable: hostapd-service-type
     This is the service type to run the hostapd
     (https://w1.fi/hostapd/) daemon to set up WiFi (IEEE 802.11) access
     points and authentication servers.  Its associated value must be a
     ‘hostapd-configuration’ as shown below:

          ;; Use wlan1 to run the access point for "My Network".
          (service hostapd-service-type
                   (hostapd-configuration
                    (interface "wlan1")
                    (ssid "My Network")
                    (channel 12)))

 -- Data Type: hostapd-configuration
     This data type represents the configuration of the hostapd service,
     with the following fields:

     ‘package’ (default: ‘hostapd’)
          The hostapd package to use.

     ‘interface’ (default: ‘"wlan0"’)
          The network interface to run the WiFi access point.

     ‘ssid’
          The SSID (“service set identifier”), a string that identifies
          this network.

     ‘broadcast-ssid?’ (default: ‘#t’)
          Whether to broadcast this SSID.

     ‘channel’ (default: ‘1’)
          The WiFi channel to use.

     ‘driver’ (default: ‘"nl80211"’)
          The driver interface type.  ‘"nl80211"’ is used with all Linux
          mac80211 drivers.  Use ‘"none"’ if building hostapd as a
          standalone RADIUS server that does # not control any
          wireless/wired driver.

     ‘extra-settings’ (default: ‘""’)
          Extra settings to append as-is to the hostapd configuration
          file.  See
          <https://w1.fi/cgit/hostap/plain/hostapd/hostapd.conf> for the
          configuration file reference.

 -- Scheme Variable: simulated-wifi-service-type
     This is the type of a service to simulate WiFi networking, which
     can be useful in virtual machines for testing purposes.  The
     service loads the Linux kernel ‘mac80211_hwsim’ module
     (https://www.kernel.org/doc/html/latest/networking/mac80211_hwsim/mac80211_hwsim.html)
     and starts hostapd to create a pseudo WiFi network that can be seen
     on ‘wlan0’, by default.

     The service’s value is a ‘hostapd-configuration’ record.

 -- Scheme Variable: iptables-service-type
     This is the service type to set up an iptables configuration.
     iptables is a packet filtering framework supported by the Linux
     kernel.  This service supports configuring iptables for both IPv4
     and IPv6.  A simple example configuration rejecting all incoming
     connections except those to the ssh port 22 is shown below.

          (service iptables-service-type
                   (iptables-configuration
                    (ipv4-rules (plain-file "iptables.rules" "*filter
          :INPUT ACCEPT
          :FORWARD ACCEPT
          :OUTPUT ACCEPT
          -A INPUT -p tcp --dport 22 -j ACCEPT
          -A INPUT -j REJECT --reject-with icmp-port-unreachable
          COMMIT
          "))
                    (ipv6-rules (plain-file "ip6tables.rules" "*filter
          :INPUT ACCEPT
          :FORWARD ACCEPT
          :OUTPUT ACCEPT
          -A INPUT -p tcp --dport 22 -j ACCEPT
          -A INPUT -j REJECT --reject-with icmp6-port-unreachable
          COMMIT
          "))))

 -- Data Type: iptables-configuration
     The data type representing the configuration of iptables.

     ‘iptables’ (default: ‘iptables’)
          The iptables package that provides ‘iptables-restore’ and
          ‘ip6tables-restore’.
     ‘ipv4-rules’ (default: ‘%iptables-accept-all-rules’)
          The iptables rules to use.  It will be passed to
          ‘iptables-restore’.  This may be any “file-like” object (*note
          file-like objects: G-Expressions.).
     ‘ipv6-rules’ (default: ‘%iptables-accept-all-rules’)
          The ip6tables rules to use.  It will be passed to
          ‘ip6tables-restore’.  This may be any “file-like” object
          (*note file-like objects: G-Expressions.).

 -- Scheme Variable: nftables-service-type
     This is the service type to set up a nftables configuration.
     nftables is a netfilter project that aims to replace the existing
     iptables, ip6tables, arptables and ebtables framework.  It provides
     a new packet filtering framework, a new user-space utility ‘nft’,
     and a compatibility layer for iptables.  This service comes with a
     default ruleset ‘%default-nftables-ruleset’ that rejecting all
     incomming connections except those to the ssh port 22.  To use it,
     simply write:

          (service nftables-service-type)

 -- Data Type: nftables-configuration
     The data type representing the configuration of nftables.

     ‘package’ (default: ‘nftables’)
          The nftables package that provides ‘nft’.
     ‘ruleset’ (default: ‘%default-nftables-ruleset’)
          The nftables ruleset to use.  This may be any “file-like”
          object (*note file-like objects: G-Expressions.).

 -- Scheme Variable: ntp-service-type
     This is the type of the service running the Network Time Protocol
     (NTP) (https://www.ntp.org) daemon, ‘ntpd’.  The daemon will keep
     the system clock synchronized with that of the specified NTP
     servers.

     The value of this service is an ‘ntpd-configuration’ object, as
     described below.

 -- Data Type: ntp-configuration
     This is the data type for the NTP service configuration.

     ‘servers’ (default: ‘%ntp-servers’)
          This is the list of servers (‘<ntp-server>’ records) with
          which ‘ntpd’ will be synchronized.  See the ‘ntp-server’ data
          type definition below.

     ‘allow-large-adjustment?’ (default: ‘#t’)
          This determines whether ‘ntpd’ is allowed to make an initial
          adjustment of more than 1,000 seconds.

     ‘ntp’ (default: ‘ntp’)
          The NTP package to use.

 -- Scheme Variable: %ntp-servers
     List of host names used as the default NTP servers.  These are
     servers of the NTP Pool Project (https://www.ntppool.org/en/).

 -- Data Type: ntp-server
     The data type representing the configuration of a NTP server.

     ‘type’ (default: ‘'server’)
          The type of the NTP server, given as a symbol.  One of
          ‘'pool’, ‘'server’, ‘'peer’, ‘'broadcast’ or
          ‘'manycastclient’.

     ‘address’
          The address of the server, as a string.

     ‘options’
          NTPD options to use with that specific server, given as a list
          of option names and/or of option names and values tuples.  The
          following example define a server to use with the options
          ‘iburst’ and ‘prefer’, as well as ‘version’ 3 and a ‘maxpoll’
          time of 16 seconds.

               (ntp-server
                (type 'server)
                (address "some.ntp.server.org")
                (options `(iburst (version 3) (maxpoll 16) prefer))))

 -- Scheme Procedure: openntpd-service-type
     Run the ‘ntpd’, the Network Time Protocol (NTP) daemon, as
     implemented by OpenNTPD (http://www.openntpd.org).  The daemon will
     keep the system clock synchronized with that of the given servers.

          (service
           openntpd-service-type
           (openntpd-configuration
            (listen-on '("127.0.0.1" "::1"))
            (sensor '("udcf0 correction 70000"))
            (constraint-from '("www.gnu.org"))
            (constraints-from '("https://www.google.com/"))
            (allow-large-adjustment? #t)))


 -- Scheme Variable: %openntpd-servers
     This variable is a list of the server addresses defined in
     ‘%ntp-servers’.

 -- Data Type: openntpd-configuration
     ‘openntpd’ (default: ‘(file-append openntpd "/sbin/ntpd")’)
          The openntpd executable to use.
     ‘listen-on’ (default: ‘'("127.0.0.1" "::1")’)
          A list of local IP addresses or hostnames the ntpd daemon
          should listen on.
     ‘query-from’ (default: ‘'()’)
          A list of local IP address the ntpd daemon should use for
          outgoing queries.
     ‘sensor’ (default: ‘'()’)
          Specify a list of timedelta sensor devices ntpd should use.
          ‘ntpd’ will listen to each sensor that actually exists and
          ignore non-existent ones.  See upstream documentation
          (https://man.openbsd.org/ntpd.conf) for more information.
     ‘server’ (default: ‘'()’)
          Specify a list of IP addresses or hostnames of NTP servers to
          synchronize to.
     ‘servers’ (default: ‘%openntp-servers’)
          Specify a list of IP addresses or hostnames of NTP pools to
          synchronize to.
     ‘constraint-from’ (default: ‘'()’)
          ‘ntpd’ can be configured to query the ‘Date’ from trusted
          HTTPS servers via TLS. This time information is not used for
          precision but acts as an authenticated constraint, thereby
          reducing the impact of unauthenticated NTP man-in-the-middle
          attacks.  Specify a list of URLs, IP addresses or hostnames of
          HTTPS servers to provide a constraint.
     ‘constraints-from’ (default: ‘'()’)
          As with constraint from, specify a list of URLs, IP addresses
          or hostnames of HTTPS servers to provide a constraint.  Should
          the hostname resolve to multiple IP addresses, ‘ntpd’ will
          calculate a median constraint from all of them.
     ‘allow-large-adjustment?’ (default: ‘#f’)
          Determines if ‘ntpd’ is allowed to make an initial adjustment
          of more than 180 seconds.

 -- Scheme variable: inetd-service-type
     This service runs the ‘inetd’ (*note (inetutils)inetd invocation::)
     daemon.  ‘inetd’ listens for connections on internet sockets, and
     lazily starts the specified server program when a connection is
     made on one of these sockets.

     The value of this service is an ‘inetd-configuration’ object.  The
     following example configures the ‘inetd’ daemon to provide the
     built-in ‘echo’ service, as well as an smtp service which forwards
     smtp traffic over ssh to a server ‘smtp-server’ behind a gateway
     ‘hostname’:

          (service
           inetd-service-type
           (inetd-configuration
            (entries (list
                      (inetd-entry
                       (name "echo")
                       (socket-type 'stream)
                       (protocol "tcp")
                       (wait? #f)
                       (user "root"))
                      (inetd-entry
                       (node "127.0.0.1")
                       (name "smtp")
                       (socket-type 'stream)
                       (protocol "tcp")
                       (wait? #f)
                       (user "root")
                       (program (file-append openssh "/bin/ssh"))
                       (arguments
                        '("ssh" "-qT" "-i" "/path/to/ssh_key"
                          "-W" "smtp-server:25" "user@hostname")))))))

     See below for more details about ‘inetd-configuration’.

 -- Data Type: inetd-configuration
     Data type representing the configuration of ‘inetd’.

     ‘program’ (default: ‘(file-append inetutils "/libexec/inetd")’)
          The ‘inetd’ executable to use.

     ‘entries’ (default: ‘'()’)
          A list of ‘inetd’ service entries.  Each entry should be
          created by the ‘inetd-entry’ constructor.

 -- Data Type: inetd-entry
     Data type representing an entry in the ‘inetd’ configuration.  Each
     entry corresponds to a socket where ‘inetd’ will listen for
     requests.

     ‘node’ (default: ‘#f’)
          Optional string, a comma-separated list of local addresses
          ‘inetd’ should use when listening for this service.  *Note
          (inetutils)Configuration file:: for a complete description of
          all options.
     ‘name’
          A string, the name must correspond to an entry in
          ‘/etc/services’.
     ‘socket-type’
          One of ‘'stream’, ‘'dgram’, ‘'raw’, ‘'rdm’ or ‘'seqpacket’.
     ‘protocol’
          A string, must correspond to an entry in ‘/etc/protocols’.
     ‘wait?’ (default: ‘#t’)
          Whether ‘inetd’ should wait for the server to exit before
          listening to new service requests.
     ‘user’
          A string containing the user (and, optionally, group) name of
          the user as whom the server should run.  The group name can be
          specified in a suffix, separated by a colon or period, i.e.
          ‘"user"’, ‘"user:group"’ or ‘"user.group"’.
     ‘program’ (default: ‘"internal"’)
          The server program which will serve the requests, or
          ‘"internal"’ if ‘inetd’ should use a built-in service.
     ‘arguments’ (default: ‘'()’)
          A list strings or file-like objects, which are the server
          program’s arguments, starting with the zeroth argument, i.e.
          the name of the program itself.  For ‘inetd’’s internal
          services, this entry must be ‘'()’ or ‘'("internal")’.

     *Note (inetutils)Configuration file:: for a more detailed
     discussion of each configuration field.

 -- Scheme Variable: tor-service-type
     This is the type for a service that runs the Tor
     (https://torproject.org) anonymous networking daemon.  The service
     is configured using a ‘<tor-configuration>’ record.  By default,
     the Tor daemon runs as the ‘tor’ unprivileged user, which is a
     member of the ‘tor’ group.

 -- Data Type: tor-configuration
     ‘tor’ (default: ‘tor’)
          The package that provides the Tor daemon.  This package is
          expected to provide the daemon at ‘bin/tor’ relative to its
          output directory.  The default package is the Tor Project’s
          (https://www.torproject.org) implementation.

     ‘config-file’ (default: ‘(plain-file "empty" "")’)
          The configuration file to use.  It will be appended to a
          default configuration file, and the final configuration file
          will be passed to ‘tor’ via its ‘-f’ option.  This may be any
          “file-like” object (*note file-like objects: G-Expressions.).
          See ‘man tor’ for details on the configuration file syntax.

     ‘hidden-services’ (default: ‘'()’)
          The list of ‘<hidden-service>’ records to use.  For any hidden
          service you include in this list, appropriate configuration to
          enable the hidden service will be automatically added to the
          default configuration file.  You may conveniently create
          ‘<hidden-service>’ records using the ‘tor-hidden-service’
          procedure described below.

     ‘socks-socket-type’ (default: ‘'tcp’)
          The default socket type that Tor should use for its SOCKS
          socket.  This must be either ‘'tcp’ or ‘'unix’.  If it is
          ‘'tcp’, then by default Tor will listen on TCP port 9050 on
          the loopback interface (i.e., localhost).  If it is ‘'unix’,
          then Tor will listen on the UNIX domain socket
          ‘/var/run/tor/socks-sock’, which will be made writable by
          members of the ‘tor’ group.

          If you want to customize the SOCKS socket in more detail,
          leave ‘socks-socket-type’ at its default value of ‘'tcp’ and
          use ‘config-file’ to override the default by providing your
          own ‘SocksPort’ option.

 -- Scheme Procedure: tor-hidden-service NAME MAPPING
     Define a new Tor “hidden service” called NAME and implementing
     MAPPING.  MAPPING is a list of port/host tuples, such as:

           '((22 "127.0.0.1:22")
             (80 "127.0.0.1:8080"))

     In this example, port 22 of the hidden service is mapped to local
     port 22, and port 80 is mapped to local port 8080.

     This creates a ‘/var/lib/tor/hidden-services/NAME’ directory, where
     the ‘hostname’ file contains the ‘.onion’ host name for the hidden
     service.

     See the Tor project’s documentation
     (https://www.torproject.org/docs/tor-hidden-service.html.en) for
     more information.

   The ‘(gnu services rsync)’ module provides the following services:

   You might want an rsync daemon if you have files that you want
available so anyone (or just yourself) can download existing files or
upload new files.

 -- Scheme Variable: rsync-service-type
     This is the service type for the rsync (https://rsync.samba.org)
     daemon, The value for this service type is a ‘rsync-configuration’
     record as in this example:

          (service rsync-service-type)

     See below for details about ‘rsync-configuration’.

 -- Data Type: rsync-configuration
     Data type representing the configuration for ‘rsync-service’.

     ‘package’ (default: RSYNC)
          ‘rsync’ package to use.

     ‘port-number’ (default: ‘873’)
          TCP port on which ‘rsync’ listens for incoming connections.
          If port is less than ‘1024’ ‘rsync’ needs to be started as the
          ‘root’ user and group.

     ‘pid-file’ (default: ‘"/var/run/rsyncd/rsyncd.pid"’)
          Name of the file where ‘rsync’ writes its PID.

     ‘lock-file’ (default: ‘"/var/run/rsyncd/rsyncd.lock"’)
          Name of the file where ‘rsync’ writes its lock file.

     ‘log-file’ (default: ‘"/var/log/rsyncd.log"’)
          Name of the file where ‘rsync’ writes its log file.

     ‘use-chroot?’ (default: #T)
          Whether to use chroot for ‘rsync’ shared directory.

     ‘share-path’ (default: ‘/srv/rsync’)
          Location of the ‘rsync’ shared directory.

     ‘share-comment’ (default: ‘"Rsync share"’)
          Comment of the ‘rsync’ shared directory.

     ‘read-only?’ (default: #F)
          Read-write permissions to shared directory.

     ‘timeout’ (default: ‘300’)
          I/O timeout in seconds.

     ‘user’ (default: "ROOT")
          Owner of the ‘rsync’ process.

     ‘group’ (default: "ROOT")
          Group of the ‘rsync’ process.

     ‘uid’ (default: "RSYNCD")
          User name or user ID that file transfers to and from that
          module should take place as when the daemon was run as ‘root’.

     ‘gid’ (default: "RSYNCD")
          Group name or group ID that will be used when accessing the
          module.

   Furthermore, ‘(gnu services ssh)’ provides the following services.

 -- Scheme Procedure: lsh-service [#:host-key "/etc/lsh/host-key"]
          [#:daemonic? #t] [#:interfaces '()] [#:port-number 22]
          [#:allow-empty-passwords? #f] [#:root-login? #f]
          [#:syslog-output? #t] [#:x11-forwarding? #t]
          [#:tcp/ip-forwarding? #t] [#:password-authentication? #t]
          [#:public-key-authentication? #t] [#:initialize? #t]
     Run the ‘lshd’ program from LSH to listen on port PORT-NUMBER.
     HOST-KEY must designate a file containing the host key, and
     readable only by root.

     When DAEMONIC? is true, ‘lshd’ will detach from the controlling
     terminal and log its output to syslogd, unless one sets
     SYSLOG-OUTPUT? to false.  Obviously, it also makes lsh-service
     depend on existence of syslogd service.  When PID-FILE? is true,
     ‘lshd’ writes its PID to the file called PID-FILE.

     When INITIALIZE? is true, automatically create the seed and host
     key upon service activation if they do not exist yet.  This may
     take long and require interaction.

     When INITIALIZE? is false, it is up to the user to initialize the
     randomness generator (*note (lsh)lsh-make-seed::), and to create a
     key pair with the private key stored in file HOST-KEY (*note
     (lsh)lshd basics::).

     When INTERFACES is empty, lshd listens for connections on all the
     network interfaces; otherwise, INTERFACES must be a list of host
     names or addresses.

     ALLOW-EMPTY-PASSWORDS? specifies whether to accept log-ins with
     empty passwords, and ROOT-LOGIN? specifies whether to accept
     log-ins as root.

     The other options should be self-descriptive.

 -- Scheme Variable: openssh-service-type
     This is the type for the OpenSSH (http://www.openssh.org) secure
     shell daemon, ‘sshd’.  Its value must be an ‘openssh-configuration’
     record as in this example:

          (service openssh-service-type
                   (openssh-configuration
                     (x11-forwarding? #t)
                     (permit-root-login 'without-password)
                     (authorized-keys
                       `(("alice" ,(local-file "alice.pub"))
                         ("bob" ,(local-file "bob.pub"))))))

     See below for details about ‘openssh-configuration’.

     This service can be extended with extra authorized keys, as in this
     example:

          (service-extension openssh-service-type
                             (const `(("charlie"
                                       ,(local-file "charlie.pub")))))

 -- Data Type: openssh-configuration
     This is the configuration record for OpenSSH’s ‘sshd’.

     ‘pid-file’ (default: ‘"/var/run/sshd.pid"’)
          Name of the file where ‘sshd’ writes its PID.

     ‘port-number’ (default: ‘22’)
          TCP port on which ‘sshd’ listens for incoming connections.

     ‘permit-root-login’ (default: ‘#f’)
          This field determines whether and when to allow logins as
          root.  If ‘#f’, root logins are disallowed; if ‘#t’, they are
          allowed.  If it’s the symbol ‘'without-password’, then root
          logins are permitted but not with password-based
          authentication.

     ‘allow-empty-passwords?’ (default: ‘#f’)
          When true, users with empty passwords may log in.  When false,
          they may not.

     ‘password-authentication?’ (default: ‘#t’)
          When true, users may log in with their password.  When false,
          they have other authentication methods.

     ‘public-key-authentication?’ (default: ‘#t’)
          When true, users may log in using public key authentication.
          When false, users have to use other authentication method.

          Authorized public keys are stored in ‘~/.ssh/authorized_keys’.
          This is used only by protocol version 2.

     ‘x11-forwarding?’ (default: ‘#f’)
          When true, forwarding of X11 graphical client connections is
          enabled—in other words, ‘ssh’ options ‘-X’ and ‘-Y’ will work.

     ‘allow-agent-forwarding?’ (default: ‘#t’)
          Whether to allow agent forwarding.

     ‘allow-tcp-forwarding?’ (default: ‘#t’)
          Whether to allow TCP forwarding.

     ‘gateway-ports?’ (default: ‘#f’)
          Whether to allow gateway ports.

     ‘challenge-response-authentication?’ (default: ‘#f’)
          Specifies whether challenge response authentication is allowed
          (e.g. via PAM).

     ‘use-pam?’ (default: ‘#t’)
          Enables the Pluggable Authentication Module interface.  If set
          to ‘#t’, this will enable PAM authentication using
          ‘challenge-response-authentication?’ and
          ‘password-authentication?’, in addition to PAM account and
          session module processing for all authentication types.

          Because PAM challenge response authentication usually serves
          an equivalent role to password authentication, you should
          disable either ‘challenge-response-authentication?’ or
          ‘password-authentication?’.

     ‘print-last-log?’ (default: ‘#t’)
          Specifies whether ‘sshd’ should print the date and time of the
          last user login when a user logs in interactively.

     ‘subsystems’ (default: ‘'(("sftp" "internal-sftp"))’)
          Configures external subsystems (e.g. file transfer daemon).

          This is a list of two-element lists, each of which containing
          the subsystem name and a command (with optional arguments) to
          execute upon subsystem request.

          The command ‘internal-sftp’ implements an in-process SFTP
          server.  Alternatively, one can specify the ‘sftp-server’
          command:
               (service openssh-service-type
                        (openssh-configuration
                         (subsystems
                          `(("sftp" ,(file-append openssh "/libexec/sftp-server"))))))

     ‘accepted-environment’ (default: ‘'()’)
          List of strings describing which environment variables may be
          exported.

          Each string gets on its own line.  See the ‘AcceptEnv’ option
          in ‘man sshd_config’.

          This example allows ssh-clients to export the ‘COLORTERM’
          variable.  It is set by terminal emulators, which support
          colors.  You can use it in your shell’s resource file to
          enable colors for the prompt and commands if this variable is
          set.

               (service openssh-service-type
                        (openssh-configuration
                          (accepted-environment '("COLORTERM"))))

     ‘authorized-keys’ (default: ‘'()’)
          This is the list of authorized keys.  Each element of the list
          is a user name followed by one or more file-like objects that
          represent SSH public keys.  For example:

               (openssh-configuration
                 (authorized-keys
                   `(("rekado" ,(local-file "rekado.pub"))
                     ("chris" ,(local-file "chris.pub"))
                     ("root" ,(local-file "rekado.pub") ,(local-file "chris.pub")))))

          registers the specified public keys for user accounts
          ‘rekado’, ‘chris’, and ‘root’.

          Additional authorized keys can be specified via
          ‘service-extension’.

          Note that this does _not_ interfere with the use of
          ‘~/.ssh/authorized_keys’.

     ‘log-level’ (default: ‘'info’)
          This is a symbol specifying the logging level: ‘quiet’,
          ‘fatal’, ‘error’, ‘info’, ‘verbose’, ‘debug’, etc.  See the
          man page for ‘sshd_config’ for the full list of level names.

     ‘extra-content’ (default: ‘""’)
          This field can be used to append arbitrary text to the
          configuration file.  It is especially useful for elaborate
          configurations that cannot be expressed otherwise.  This
          configuration, for example, would generally disable root
          logins, but permit them from one specific IP address:

               (openssh-configuration
                 (extra-content "\
               Match Address 192.168.0.1
                 PermitRootLogin yes"))

 -- Scheme Procedure: dropbear-service [CONFIG]
     Run the Dropbear SSH daemon
     (https://matt.ucc.asn.au/dropbear/dropbear.html) with the given
     CONFIG, a ‘<dropbear-configuration>’ object.

     For example, to specify a Dropbear service listening on port 1234,
     add this call to the operating system’s ‘services’ field:

          (dropbear-service (dropbear-configuration
                              (port-number 1234)))

 -- Data Type: dropbear-configuration
     This data type represents the configuration of a Dropbear SSH
     daemon.

     ‘dropbear’ (default: DROPBEAR)
          The Dropbear package to use.

     ‘port-number’ (default: 22)
          The TCP port where the daemon waits for incoming connections.

     ‘syslog-output?’ (default: ‘#t’)
          Whether to enable syslog output.

     ‘pid-file’ (default: ‘"/var/run/dropbear.pid"’)
          File name of the daemon’s PID file.

     ‘root-login?’ (default: ‘#f’)
          Whether to allow ‘root’ logins.

     ‘allow-empty-passwords?’ (default: ‘#f’)
          Whether to allow empty passwords.

     ‘password-authentication?’ (default: ‘#t’)
          Whether to enable password-based authentication.

 -- Scheme Variable: autossh-service-type
     This is the type for the AutoSSH
     (https://www.harding.motd.ca/autossh) program that runs a copy of
     ‘ssh’ and monitors it, restarting it as necessary should it die or
     stop passing traffic.  AutoSSH can be run manually from the
     command-line by passing arguments to the binary ‘autossh’ from the
     package ‘autossh’, but it can also be run as a Guix service.  This
     latter use case is documented here.

     AutoSSH can be used to forward local traffic to a remote machine
     using an SSH tunnel, and it respects the ‘~/.ssh/config’ of the
     user it is run as.

     For example, to specify a service running autossh as the user
     ‘pino’ and forwarding all local connections to port ‘8081’ to
     ‘remote:8081’ using an SSH tunnel, add this call to the operating
     system’s ‘services’ field:

          (service autossh-service-type
                   (autossh-configuration
                    (user "pino")
                    (ssh-options (list "-T" "-N" "-L" "8081:localhost:8081" "remote.net"))))

 -- Data Type: autossh-configuration
     This data type represents the configuration of an AutoSSH service.

     ‘user’ (default ‘"autossh"’)
          The user as which the AutoSSH service is to be run.  This
          assumes that the specified user exists.

     ‘poll’ (default ‘600’)
          Specifies the connection poll time in seconds.

     ‘first-poll’ (default ‘#f’)
          Specifies how many seconds AutoSSH waits before the first
          connection test.  After this first test, polling is resumed at
          the pace defined in ‘poll’.  When set to ‘#f’, the first poll
          is not treated specially and will also use the connection poll
          specified in ‘poll’.

     ‘gate-time’ (default ‘30’)
          Specifies how many seconds an SSH connection must be active
          before it is considered successful.

     ‘log-level’ (default ‘1’)
          The log level, corresponding to the levels used by syslog—so
          ‘0’ is the most silent while ‘7’ is the chattiest.

     ‘max-start’ (default ‘#f’)
          The maximum number of times SSH may be (re)started before
          AutoSSH exits.  When set to ‘#f’, no maximum is configured and
          AutoSSH may restart indefinitely.

     ‘message’ (default ‘""’)
          The message to append to the echo message sent when testing
          connections.

     ‘port’ (default ‘"0"’)
          The ports used for monitoring the connection.  When set to
          ‘"0"’, monitoring is disabled.  When set to ‘"N"’ where N is a
          positive integer, ports N and N+1 are used for monitoring the
          connection, such that port N is the base monitoring port and
          ‘n+1’ is the echo port.  When set to ‘"N:M"’ where N and M are
          positive integers, the ports N and N+1 are used for monitoring
          the connection, such that port N is the base monitoring port
          and M is the echo port.

     ‘ssh-options’ (default ‘'()’)
          The list of command-line arguments to pass to ‘ssh’ when it is
          run.  Options ‘-f’ and ‘-M’ are reserved for AutoSSH and may
          cause undefined behaviour.

 -- Scheme Variable: %facebook-host-aliases
     This variable contains a string for use in ‘/etc/hosts’ (*note
     (libc)Host Names::).  Each line contains a entry that maps a known
     server name of the Facebook on-line service—e.g.,
     ‘www.facebook.com’—to the local host—‘127.0.0.1’ or its IPv6
     equivalent, ‘::1’.

     This variable is typically used in the ‘hosts-file’ field of an
     ‘operating-system’ declaration (*note ‘/etc/hosts’:
     operating-system Reference.):

          (use-modules (gnu) (guix))

          (operating-system
            (host-name "mymachine")
            ;; ...
            (hosts-file
              ;; Create a /etc/hosts file with aliases for "localhost"
              ;; and "mymachine", as well as for Facebook servers.
              (plain-file "hosts"
                          (string-append (local-host-aliases host-name)
                                         %facebook-host-aliases))))

     This mechanism can prevent programs running locally, such as Web
     browsers, from accessing Facebook.

   The ‘(gnu services avahi)’ provides the following definition.

 -- Scheme Variable: avahi-service-type
     This is the service that runs ‘avahi-daemon’, a system-wide
     mDNS/DNS-SD responder that allows for service discovery and
     “zero-configuration” host name lookups (see <https://avahi.org/>).
     Its value must be a ‘zero-configuration’ record—see below.

     This service extends the name service cache daemon (nscd) so that
     it can resolve ‘.local’ host names using nss-mdns
     (https://0pointer.de/lennart/projects/nss-mdns/).  *Note Name
     Service Switch::, for information on host name resolution.

     Additionally, add the AVAHI package to the system profile so that
     commands such as ‘avahi-browse’ are directly usable.

 -- Data Type: avahi-configuration
     Data type representation the configuration for Avahi.

     ‘host-name’ (default: ‘#f’)
          If different from ‘#f’, use that as the host name to publish
          for this machine; otherwise, use the machine’s actual host
          name.

     ‘publish?’ (default: ‘#t’)
          When true, allow host names and services to be published
          (broadcast) over the network.

     ‘publish-workstation?’ (default: ‘#t’)
          When true, ‘avahi-daemon’ publishes the machine’s host name
          and IP address via mDNS on the local network.  To view the
          host names published on your local network, you can run:

               avahi-browse _workstation._tcp

     ‘wide-area?’ (default: ‘#f’)
          When true, DNS-SD over unicast DNS is enabled.

     ‘ipv4?’ (default: ‘#t’)
     ‘ipv6?’ (default: ‘#t’)
          These fields determine whether to use IPv4/IPv6 sockets.

     ‘domains-to-browse’ (default: ‘'()’)
          This is a list of domains to browse.

 -- Scheme Variable: openvswitch-service-type
     This is the type of the Open vSwitch (https://www.openvswitch.org)
     service, whose value should be an ‘openvswitch-configuration’
     object.

 -- Data Type: openvswitch-configuration
     Data type representing the configuration of Open vSwitch, a
     multilayer virtual switch which is designed to enable massive
     network automation through programmatic extension.

     ‘package’ (default: OPENVSWITCH)
          Package object of the Open vSwitch.

 -- Scheme Variable: pagekite-service-type
     This is the service type for the PageKite (https://pagekite.net)
     service, a tunneling solution for making localhost servers publicly
     visible, even from behind restrictive firewalls or NAT without
     forwarded ports.  The value for this service type is a
     ‘pagekite-configuration’ record.

     Here’s an example exposing the local HTTP and SSH daemons:

          (service pagekite-service-type
                   (pagekite-configuration
                     (kites '("http:@kitename:localhost:80:@kitesecret"
                              "raw/22:@kitename:localhost:22:@kitesecret"))
                     (extra-file "/etc/pagekite.rc")))

 -- Data Type: pagekite-configuration
     Data type representing the configuration of PageKite.

     ‘package’ (default: PAGEKITE)
          Package object of PageKite.

     ‘kitename’ (default: ‘#f’)
          PageKite name for authenticating to the frontend server.

     ‘kitesecret’ (default: ‘#f’)
          Shared secret for authenticating to the frontend server.  You
          should probably put this inside ‘extra-file’ instead.

     ‘frontend’ (default: ‘#f’)
          Connect to the named PageKite frontend server instead of the
          pagekite.net service.

     ‘kites’ (default: ‘'("http:@kitename:localhost:80:@kitesecret")’)
          List of service kites to use.  Exposes HTTP on port 80 by
          default.  The format is ‘proto:kitename:host:port:secret’.

     ‘extra-file’ (default: ‘#f’)
          Extra configuration file to read, which you are expected to
          create manually.  Use this to add additional options and
          manage shared secrets out-of-band.


File: guix.info,  Node: X Window,  Next: Printing Services,  Prev: Networking Services,  Up: Services

8.8.5 X Window
--------------

Support for the X Window graphical display system—specifically Xorg—is
provided by the ‘(gnu services xorg)’ module.  Note that there is no
‘xorg-service’ procedure.  Instead, the X server is started by the
“login manager”, by default the GNOME Display Manager (GDM).

   GDM of course allows users to log in into window managers and desktop
environments other than GNOME; for those using GNOME, GDM is required
for features such as automatic screen locking.

   To use X11, you must install at least one “window manager”—for
example the ‘windowmaker’ or ‘openbox’ packages—preferably by adding it
to the ‘packages’ field of your operating system definition (*note
system-wide packages: operating-system Reference.).

 -- Scheme Variable: gdm-service-type
     This is the type for the GNOME Desktop Manager
     (https://wiki.gnome.org/Projects/GDM/) (GDM), a program that
     manages graphical display servers and handles graphical user
     logins.  Its value must be a ‘gdm-configuration’ (see below).

     GDM looks for “session types” described by the ‘.desktop’ files in
     ‘/run/current-system/profile/share/xsessions’ and allows users to
     choose a session from the log-in screen.  Packages such as ‘gnome’,
     ‘xfce’, and ‘i3’ provide ‘.desktop’ files; adding them to the
     system-wide set of packages automatically makes them available at
     the log-in screen.

     In addition, ‘~/.xsession’ files are honored.  When available,
     ‘~/.xsession’ must be an executable that starts a window manager
     and/or other X clients.

 -- Data Type: gdm-configuration
     ‘auto-login?’ (default: ‘#f’)
     ‘default-user’ (default: ‘#f’)
          When ‘auto-login?’ is false, GDM presents a log-in screen.

          When ‘auto-login?’ is true, GDM logs in directly as
          ‘default-user’.

     ‘debug?’ (default: ‘#f’)
          When true, GDM writes debug messages to its log.

     ‘gnome-shell-assets’ (default: ...)
          List of GNOME Shell assets needed by GDM: icon theme, fonts,
          etc.

     ‘xorg-configuration’ (default: ‘(xorg-configuration)’)
          Configuration of the Xorg graphical server.

     ‘xsession’ (default: ‘(xinitrc)’)
          Script to run before starting a X session.

     ‘dbus-daemon’ (default: ‘dbus-daemon-wrapper’)
          File name of the ‘dbus-daemon’ executable.

     ‘gdm’ (default: ‘gdm’)
          The GDM package to use.

 -- Scheme Variable: slim-service-type
     This is the type for the SLiM graphical login manager for X11.

     Like GDM, SLiM looks for session types described by ‘.desktop’
     files and allows users to choose a session from the log-in screen
     using ‘F1’.  It also honors ‘~/.xsession’ files.

     Unlike GDM, SLiM does not spawn the user session on a different VT
     after logging in, which means that you can only start one graphical
     session.  If you want to be able to run multiple graphical sessions
     at the same time you have to add multiple SLiM services to your
     system services.  The following example shows how to replace the
     default GDM service with two SLiM services on tty7 and tty8.

          (use-modules (gnu services)
                       (gnu services desktop)
                       (gnu services xorg)
                       (srfi srfi-1))  ;for 'remove'

          (operating-system
            ;; ...
            (services (cons* (service slim-service-type (slim-configuration
                                                         (display ":0")
                                                         (vt "vt7")))
                             (service slim-service-type (slim-configuration
                                                         (display ":1")
                                                         (vt "vt8")))
                             (remove (lambda (service)
                                       (eq? (service-kind service) gdm-service-type))
                                     %desktop-services))))

 -- Data Type: slim-configuration
     Data type representing the configuration of ‘slim-service-type’.

     ‘allow-empty-passwords?’ (default: ‘#t’)
          Whether to allow logins with empty passwords.

     ‘auto-login?’ (default: ‘#f’)
     ‘default-user’ (default: ‘""’)
          When ‘auto-login?’ is false, SLiM presents a log-in screen.

          When ‘auto-login?’ is true, SLiM logs in directly as
          ‘default-user’.

     ‘theme’ (default: ‘%default-slim-theme’)
     ‘theme-name’ (default: ‘%default-slim-theme-name’)
          The graphical theme to use and its name.

     ‘auto-login-session’ (default: ‘#f’)
          If true, this must be the name of the executable to start as
          the default session—e.g., ‘(file-append windowmaker
          "/bin/windowmaker")’.

          If false, a session described by one of the available
          ‘.desktop’ files in ‘/run/current-system/profile’ and
          ‘~/.guix-profile’ will be used.

               Note: You must install at least one window manager in the
               system profile or in your user profile.  Failing to do
               that, if ‘auto-login-session’ is false, you will be
               unable to log in.

     ‘xorg-configuration’ (default ‘(xorg-configuration)’)
          Configuration of the Xorg graphical server.

     ‘display’ (default ‘":0"’)
          The display on which to start the Xorg graphical server.

     ‘vt’ (default ‘"vt7"’)
          The VT on which to start the Xorg graphical server.

     ‘xauth’ (default: ‘xauth’)
          The XAuth package to use.

     ‘shepherd’ (default: ‘shepherd’)
          The Shepherd package used when invoking ‘halt’ and ‘reboot’.

     ‘sessreg’ (default: ‘sessreg’)
          The sessreg package used in order to register the session.

     ‘slim’ (default: ‘slim’)
          The SLiM package to use.

 -- Scheme Variable: %default-theme
 -- Scheme Variable: %default-theme-name
     The default SLiM theme and its name.

 -- Data Type: sddm-configuration
     This is the data type representing the SDDM service configuration.

     ‘display-server’ (default: "x11")
          Select display server to use for the greeter.  Valid values
          are ‘"x11"’ or ‘"wayland"’.

     ‘numlock’ (default: "on")
          Valid values are ‘"on"’, ‘"off"’ or ‘"none"’.

     ‘halt-command’ (default ‘#~(string-apppend #$shepherd "/sbin/halt")’)
          Command to run when halting.

     ‘reboot-command’ (default ‘#~(string-append #$shepherd "/sbin/reboot")’)
          Command to run when rebooting.

     ‘theme’ (default "maldives")
          Theme to use.  Default themes provided by SDDM are ‘"elarun"’,
          ‘"maldives"’ or ‘"maya"’.

     ‘themes-directory’ (default "/run/current-system/profile/share/sddm/themes")
          Directory to look for themes.

     ‘faces-directory’ (default "/run/current-system/profile/share/sddm/faces")
          Directory to look for faces.

     ‘default-path’ (default "/run/current-system/profile/bin")
          Default PATH to use.

     ‘minimum-uid’ (default: 1000)
          Minimum UID displayed in SDDM and allowed for log-in.

     ‘maximum-uid’ (default: 2000)
          Maximum UID to display in SDDM.

     ‘remember-last-user?’ (default #t)
          Remember last user.

     ‘remember-last-session?’ (default #t)
          Remember last session.

     ‘hide-users’ (default "")
          Usernames to hide from SDDM greeter.

     ‘hide-shells’ (default ‘#~(string-append #$shadow "/sbin/nologin")’)
          Users with shells listed will be hidden from the SDDM greeter.

     ‘session-command’ (default ‘#~(string-append #$sddm "/share/sddm/scripts/wayland-session")’)
          Script to run before starting a wayland session.

     ‘sessions-directory’ (default "/run/current-system/profile/share/wayland-sessions")
          Directory to look for desktop files starting wayland sessions.

     ‘xorg-configuration’ (default ‘(xorg-configuration)’)
          Configuration of the Xorg graphical server.

     ‘xauth-path’ (default ‘#~(string-append #$xauth "/bin/xauth")’)
          Path to xauth.

     ‘xephyr-path’ (default ‘#~(string-append #$xorg-server "/bin/Xephyr")’)
          Path to Xephyr.

     ‘xdisplay-start’ (default ‘#~(string-append #$sddm "/share/sddm/scripts/Xsetup")’)
          Script to run after starting xorg-server.

     ‘xdisplay-stop’ (default ‘#~(string-append #$sddm "/share/sddm/scripts/Xstop")’)
          Script to run before stopping xorg-server.

     ‘xsession-command’ (default: ‘xinitrc’)
          Script to run before starting a X session.

     ‘xsessions-directory’ (default: "/run/current-system/profile/share/xsessions")
          Directory to look for desktop files starting X sessions.

     ‘minimum-vt’ (default: 7)
          Minimum VT to use.

     ‘auto-login-user’ (default "")
          User to use for auto-login.

     ‘auto-login-session’ (default "")
          Desktop file to use for auto-login.

     ‘relogin?’ (default #f)
          Relogin after logout.

 -- Scheme Variable: sddm-service-type
     This is the type of the service to run the SDDM display manager
     (https://github.com/sddm/sddm).  Its value must be a
     ‘sddm-configuration’ record (see below).

     Here’s an example use:

          (service sddm-service-type
                   (sddm-configuration
                     (auto-login-user "alice")
                     (auto-login-session "xfce.desktop")))

 -- Data Type: sddm-configuration
     This data type represents the configuration of the SDDM login
     manager.  The available fields are:

     ‘sddm’ (default: ‘sddm’)
          The SDDM package to use.

     ‘display-server’ (default: ‘"x11"’)
          This must be either ‘"x11"’ or ‘"wayland"’.

     ‘auto-login-user’ (default: ‘""’)
          If non-empty, this is the user account under which to log in
          automatically.

     ‘auto-login-session’ (default: ‘""’)
          If non-empty, this is the ‘.desktop’ file name to use as the
          auto-login session.

 -- Data Type: xorg-configuration
     This data type represents the configuration of the Xorg graphical
     display server.  Note that there is not Xorg service; instead, the
     X server is started by a “display manager” such as GDM, SDDM, and
     SLiM. Thus, the configuration of these display managers aggregates
     an ‘xorg-configuration’ record.

     ‘modules’ (default: ‘%default-xorg-modules’)
          This is a list of “module packages” loaded by the Xorg
          server—e.g., ‘xf86-video-vesa’, ‘xf86-input-keyboard’, and so
          on.

     ‘fonts’ (default: ‘%default-xorg-fonts’)
          This is a list of font directories to add to the server’s
          “font path”.

     ‘drivers’ (default: ‘'()’)
          This must be either the empty list, in which case Xorg chooses
          a graphics driver automatically, or a list of driver names
          that will be tried in this order—e.g., ‘("modesetting"
          "vesa")’.

     ‘resolutions’ (default: ‘'()’)
          When ‘resolutions’ is the empty list, Xorg chooses an
          appropriate screen resolution.  Otherwise, it must be a list
          of resolutions—e.g., ‘((1024 768) (640 480))’.

     ‘keyboard-layout’ (default: ‘#f’)
          If this is ‘#f’, Xorg uses the default keyboard layout—usually
          US English (“qwerty”) for a 105-key PC keyboard.

          Otherwise this must be a ‘keyboard-layout’ object specifying
          the keyboard layout in use when Xorg is running.  *Note
          Keyboard Layout::, for more information on how to specify the
          keyboard layout.

     ‘extra-config’ (default: ‘'()’)
          This is a list of strings or objects appended to the
          configuration file.  It is used to pass extra text to be added
          verbatim to the configuration file.

     ‘server’ (default: ‘xorg-server’)
          This is the package providing the Xorg server.

     ‘server-arguments’ (default: ‘%default-xorg-server-arguments’)
          This is the list of command-line arguments to pass to the X
          server.  The default is ‘-nolisten tcp’.

 -- Scheme Procedure: set-xorg-configuration CONFIG
          [LOGIN-MANAGER-SERVICE-TYPE]
     Tell the log-in manager (of type LOGIN-MANAGER-SERVICE-TYPE) to use
     CONFIG, an ‘<xorg-configuration>’ record.

     Since the Xorg configuration is embedded in the log-in manager’s
     configuration—e.g., ‘gdm-configuration’—this procedure provides a
     shorthand to set the Xorg configuration.

 -- Scheme Procedure: xorg-start-command [CONFIG]
     Return a ‘startx’ script in which the modules, fonts, etc.
     specified in CONFIG, are available.  The result should be used in
     place of ‘startx’.

     Usually the X server is started by a login manager.

 -- Scheme Procedure: screen-locker-service PACKAGE [PROGRAM]
     Add PACKAGE, a package for a screen locker or screen saver whose
     command is PROGRAM, to the set of setuid programs and add a PAM
     entry for it.  For example:

          (screen-locker-service xlockmore "xlock")

     makes the good ol’ XlockMore usable.

