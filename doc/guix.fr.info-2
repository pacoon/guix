This is guix.fr.info, produced by makeinfo version 6.7 from
guix.fr.texi.

Copyright © 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020 Ludovic
Courtès
Copyright © 2013, 2014, 2016 Andreas Enge
Copyright © 2013 Nikita Karetnikov
Copyright © 2014, 2015, 2016 Alex Kost
Copyright © 2015, 2016 Mathieu Lirzin
Copyright © 2014 Pierre-Antoine Rault
Copyright © 2015 Taylan Ulrich Bayırlı/Kammer
Copyright © 2015, 2016, 2017, 2019, 2020 Leo Famulari
Copyright © 2015, 2016, 2017, 2018, 2019, 2020 Ricardo Wurmus
Copyright © 2016 Ben Woodcroft
Copyright © 2016, 2017, 2018 Chris Marusich
Copyright © 2016, 2017, 2018, 2019, 2020 Efraim Flashner
Copyright © 2016 John Darrington
Copyright © 2016, 2017 Nikita Gillmann
Copyright © 2016, 2017, 2018, 2019, 2020 Jan Nieuwenhuizen
Copyright © 2016, 2017, 2018, 2019, 2020 Julien Lepiller
Copyright © 2016 Alex ter Weele
Copyright © 2016, 2017, 2018, 2019 Christopher Baines
Copyright © 2017, 2018, 2019 Clément Lassieur
Copyright © 2017, 2018 Mathieu Othacehe
Copyright © 2017 Federico Beffa
Copyright © 2017, 2018 Carlo Zancanaro
Copyright © 2017 Thomas Danckaert
Copyright © 2017 humanitiesNerd
Copyright © 2017 Christopher Allan Webber
Copyright © 2017, 2018, 2019, 2020 Marius Bakke
Copyright © 2017, 2019, 2020 Hartmut Goebel
Copyright © 2017, 2019, 2020 Maxim Cournoyer
Copyright © 2017, 2018, 2019, 2020 Tobias Geerinckx-Rice
Copyright © 2017 George Clemmer
Copyright © 2017 Andy Wingo
Copyright © 2017, 2018, 2019 Arun Isaac
Copyright © 2017 nee
Copyright © 2018 Rutger Helling
Copyright © 2018 Oleg Pykhalov
Copyright © 2018 Mike Gerwitz
Copyright © 2018 Pierre-Antoine Rouby
Copyright © 2018, 2019 Gábor Boskovits
Copyright © 2018, 2019 Florian Pelz
Copyright © 2018 Laura Lazzati
Copyright © 2018 Alex Vong
Copyright © 2019 Josh Holland
Copyright © 2019, 2020 Diego Nicola Barbato
Copyright © 2019 Ivan Petkov
Copyright © 2019 Jakob L. Kreuze
Copyright © 2019 Kyle Andrews
Copyright © 2019 Alex Griffin
Copyright © 2019 Guillaume Le Vaillant
Copyright © 2020 Leo Prikler
Copyright © 2019, 2020 Simon Tournier
Copyright © 2020 Wiktor Żelazny
Copyright © 2020 Damien Cassou
Copyright © 2020 Jakub Kądziołka
Copyright © 2020 Jack Hill
Copyright © 2020 Naga Malleswari
Copyright © 2020 Brice Waegeneire
Copyright © 2020 R Veera Kumar
Copyright © 2020 Pierre Langlois
Copyright © 2020 pinoaffe

   Vous avez la permission de copier, distribuer ou modifier ce document
sous les termes de la Licence GNU Free Documentation, version 1.3 ou
toute version ultérieure publiée par la Free Software Foundation ; sans
section invariante, texte de couverture et sans texte de quatrième de
couverture. Une copie de la licence est incluse dans la section
intitulée « GNU Free Documentation License ».
INFO-DIR-SECTION Administration système
START-INFO-DIR-ENTRY
* Guix: (guix.fr).           Gérer les logiciels installés et la
                               configuration du système.
* guix package : (guix.fr)Invoquer guix package.  Installer, supprimer et
                                                      mettre à jour des
                                                      paquets.
* guix gc : (guix.fr)Invoquer guix gc.  Récupérer de l’espace disque
                                            inutilisé.
* guix pull : (guix.fr)Invoquer guix pull.  Mettre à jour la liste des
                                                paquets disponibles.
* guix system : (guix.fr)Invoquer guix system.  Gérer la configuration du
                                                    système d’exploitation.
* guix deploy: (guix)Invoking guix deploy.  Manage operating system
                                              configurations for remote hosts.
END-INFO-DIR-ENTRY

INFO-DIR-SECTION Développement logiciel
START-INFO-DIR-ENTRY
* guix environment : (guix.fr)Invoquer guix environment.  Construire des
                                                              environnements
                                                              de construction
                                                              avec Guix.
* guix build : (guix.fr)Invoquer guix build.  Construire des paquets.
* guix pack : (guix.fr) Invoquer guix pack.  Créer des lots binaires.
END-INFO-DIR-ENTRY


File: guix.fr.info,  Node: Le dépôt,  Next: Dérivations,  Prev: Systèmes de construction,  Up: Interface de programmation

6.4 Le dépôt
============

Conceptuellement, le “dépôt” est l’endroit où les dérivations qui ont
bien été construites sont stockées — par défaut, ‘/gnu/store’. Les
sous-répertoires dans le dépôt s’appellent des “éléments du dépôt” ou
parfois des “chemins du dépôt”. Le dépôt a une base de données associée
qui contient des informations comme les chemins du dépôt auxquels se
réfèrent chaque chemin du dépôt et la liste des éléments du dépôt
_valides_ — les résultats d’une construction réussie. Cette base de
données se trouve dans ‘LOCALSTATEDIR/guix/db’ où LOCALSTATEDIR est le
répertoire d’états spécifié via ‘--localstatedir’ à la configuration,
typiquement ‘/var’.

   C’est _toujours_ le démon qui accède au dépôt pour le compte de ses
clients (*note Invoquer guix-daemon::). Pour manipuler le dépôt, les
clients se connectent au démon par un socket Unix-domain, envoient une
requête dessus et lisent le résultat — ce sont des appels de procédures
distantes, ou RPC.

     Remarque : Les utilisateurs ne doivent _jamais_ modifier les
     fichiers dans ‘/gnu/store’ directement. Cela entraînerait des
     incohérences et casserait l’hypothèse d’immutabilité du modèle
     fonctionnel de Guix (*note Introduction::).

     *Note ‘guix gc --verify’: Invoquer guix gc, pour des informations
     sur la manière de vérifier l’intégrité du dépôt et d’essayer de
     réparer des modifications accidentelles.

   The ‘(guix store)’ module provides procedures to connect to the
daemon, and to perform RPCs. These are described below. By default,
‘open-connection’, and thus all the ‘guix’ commands, connect to the
local daemon or to the URI specified by the ‘GUIX_DAEMON_SOCKET’
environment variable.

 -- Variable d'environnement : GUIX_DAEMON_SOCKET
     Lorsqu’elle est initialisée, la valeur de cette variable devrait
     être un nom de fichier ou une URI qui désigne l’extrémité du démon.
     Lorsque c’est un nom de fichier, il dénote un socket Unix-domain où
     se connecter. En plus des noms de fichiers, les schémas d’URI
     supportés sont :

     ‘file’
     ‘unix’
          Pour les sockets Unix-domain.
          ‘file:///var/guix/daemon-socket/socket’ est équivalent à
          ‘/var/guix/daemon-socket/socket’.

     ‘guix’
          Ces URI dénotent des connexions par TCP/IP, sans chiffrement
          ni authentification de l’hôte distant. L’URI doit spécifier le
          nom d’hôte et éventuellement un numéro de port (par défaut
          44146) :

               guix://master.guix.example.org:1234

          Ce paramétrage est adapté aux réseaux locaux, comme dans le
          cas de grappes de serveurs, où seuls des noms de confiance
          peuvent se connecter au démon de construction sur
          ‘master.guix.example.org’.

          The ‘--listen’ option of ‘guix-daemon’ can be used to instruct
          it to listen for TCP connections (*note ‘--listen’: Invoquer
          guix-daemon.).

     ‘ssh’
          These URIs allow you to connect to a remote daemon over SSH.
          This feature requires Guile-SSH (*note Prérequis::) and a
          working ‘guile’ binary in ‘PATH’ on the destination machine.
          It supports public key and GSSAPI authentication. A typical
          URL might look like this:

               ssh://charlie@guix.example.org:22

          Comme pour ‘guix copy’, les fichiers de configuration du
          client OpenSSH sont respectés (*note Invoquer guix copy::).

     Des schémas d’URI supplémentaires pourraient être supportés dans le
     futur.

          Remarque : La capacité de se connecter à un démon de
          construction distant est considéré comme expérimental à la
          version 1.0.1.17089-7e269. Contactez-nous pour partager vos
          problèmes ou des suggestions que vous pourriez avoir (*note
          Contribuer::).

 -- Procédure Scheme : open-connection [URI] [#:reserve-space? #t]
     Se connecte au démon à travers le socket Unix-domain à URI (une
     chaîne de caractères). Lorsque RESERVE-SPACE? est vrai, cela
     demande de réserver un peu de place supplémentaire sur le système
     de fichiers pour que le ramasse-miette puisse opérer au cas où le
     disque serait plein. Renvoie un objet serveur.

     FILE defaults to ‘%default-socket-path’, which is the normal
     location given the options that were passed to ‘configure’.

 -- Procédure Scheme : close-connection SERVER
     Ferme la connexion au SERVEUR.

 -- Variable Scheme : current-build-output-port
     Cette variable est liée à un paramètre SRFI-39, qui se réfère au
     port où les journaux de construction et d’erreur envoyés par le
     démon devraient être écrits.

   Les procédures qui font des RPC prennent toutes un objet serveur
comme premier argument.

 -- Procédure Scheme : valid-path? SERVER PATH
     Return ‘#t’ when PATH designates a valid store item and ‘#f’
     otherwise (an invalid item may exist on disk but still be invalid,
     for instance because it is the result of an aborted or failed
     build).

     Une condition ‘&store-protocol-error’ est levée si PATH n’est pas
     préfixée par le répertoire du dépôt (‘/gnu/store’).

 -- Procédure Scheme : add-text-to-store SERVER NAME TEXT [REFERENCES]
     Ajoute TEXT dans le fichier NAME dans le dépôt et renvoie son
     chemin. REFERENCES est la liste des chemins du dépôt référencés par
     le chemin du dépôt qui en résulte.

 -- Scheme Procedure : build-derivations STORE DERIVATIONS [MODE] Build
          DERIVATIONS, a list of ‘<derivation>’ objects,
     ‘.drv’ file names, or derivation/output pairs, using the specified
     MODE—‘(build-mode normal)’ by default.

   Remarque que le module ‘(guix monads)’ fournit une monade ainsi que
des version monadiques des procédures précédentes, avec le but de rendre
plus facile de travailler avec le code qui accède au dépôt (*note La
monade du dépôt::).

   Cette section est actuellement incomplète.


File: guix.fr.info,  Node: Dérivations,  Next: La monade du dépôt,  Prev: Le dépôt,  Up: Interface de programmation

6.5 Dérivations
===============

Les actions de construction à bas-niveau et l’environnement dans lequel
elles sont effectuées sont représentés par des “dérivations”. Une
dérivation contient cet ensemble d’informations :

   • Les sorties de la dérivation — les dérivations produisent au moins
     un fichier ou répertoire dans le dépôt, mais peuvent en produire
     plus.

   • The inputs of the derivations—i.e., its build-time
     dependencies—which may be other derivations or plain files in the
     store (patches, build scripts, etc.).

   • Le type de système ciblé par la dérivation — p.ex. ‘x86_64-linux’.

   • Le nom de fichier d’un script de construction dans le dépôt avec
     les arguments à lui passer.

   • Une liste de variables d’environnement à définir.

   Derivations allow clients of the daemon to communicate build actions
to the store. They exist in two forms: as an in-memory representation,
both on the client- and daemon-side, and as files in the store whose
name end in ‘.drv’—these files are referred to as “derivation paths”.
Derivations paths can be passed to the ‘build-derivations’ procedure to
perform the build actions they prescribe (*note Le dépôt::).

   Des opérations comme le téléchargement de fichiers et la récupération
de sources gérés par un logiciel de contrôle de version pour lesquels le
hash du contenu est connu à l’avance sont modélisés par des “dérivations
à sortie fixe”. Contrairement aux dérivation habituelles, les sorties
d’une dérivation à sortie fixe sont indépendantes de ses entrées — p.ex.
un code source téléchargé produit le même résultat quelque soit la
méthode de téléchargement utilisée.

   Les sorties des dérivations — c.-à-d. les résultats de la
construction — ont un ensemble de “références”, comme le rapporte le RPC
‘references’ ou la commande ‘guix gc --references’ (*note Invoquer guix
gc::). Les références sont l’ensemble des dépendances à l’exécution des
résultats de la construction. Les références sont un sous-ensemble des
entrées de la dérivation ; ce sous-ensemble est automatiquement calculé
par le démon de construction en scannant tous les fichiers dans les
sorties.

   Le module ‘(guix derivations)’ fournit une représentation des
dérivations comme des objets Scheme, avec des procédures pour créer et
manipuler des dérivations. La primitive de plus bas-niveau pour créer
une dérivation est la procédure ‘derivation’ :

 -- Procédure Scheme : derivation STORE NAME BUILDER ARGS [#:outputs
          '("out")] [#:hash #f] [#:hash-algo #f] [#:recursive? #f]
          [#:inputs '()] [#:env-vars '()] [#:system (%current-system)]
          [#:references-graphs #f] [#:allowed-references #f]
          [#:disallowed-references #f] [#:leaked-env-vars #f]
          [#:local-build? #f] [#:substitutable? #t] [#:properties '()]
     Construit une dérivation avec les arguments donnés et renvoie
     l’objet ‘<derivation>’ obtenu.

     Lorsque HASH et HASH-ALGO sont donnés, une “dérivation à sortie
     fixe” est créée — c.-à-d. une dérivation dont le résultat est connu
     à l’avance, comme dans le cas du téléchargement d’un fichier. Si,
     en plus, RECURSIVE? est vrai, alors la sortie fixe peut être un
     fichier exécutable ou un répertoire et HASH doit être le hash d’une
     archive contenant la sortie.

     Lorsque REFERENCES-GRAPHS est vrai, il doit s’agir d’une liste de
     paires de noms de fichiers et de chemins du dépôt. Dans ce cas, le
     graphe des références de chaque chemin du dépôt est exporté dans
     l’environnement de construction dans le fichier correspondant, dans
     un simple format texte.

     Lorsque ALLOWED-REFERENCES est vrai, il doit s’agir d’une liste
     d’éléments du dépôt ou de sorties auxquelles la sortie de la
     dérivations peut faire référence. De même, DISALLOWED-REFERENCES,
     si vrai, doit être une liste de choses que la sortie ne doit _pas_
     référencer.

     Lorsque LEAKED-ENV-VARS est vrai, il doit s’agir d’une liste de
     chaînes de caractères qui désignent les variables d’environnements
     qui peuvent « fuiter » de l’environnement du démon dans
     l’environnement de construction. Ce n’est possible que pour les
     dérivations à sortie fixe — c.-à-d. lorsque HASH est vrai.
     L’utilisation principale est de permettre à des variables comme
     ‘http_proxy’ d’être passées aux dérivations qui téléchargent des
     fichiers.

     Lorsque LOCAL-BUILD? est vrai, déclare que la dérivation n’est pas
     un bon candidat pour le déchargement et devrait plutôt être
     construit localement (*note Réglages du délestage du démon::).
     C’est le cas des petites dérivations où le coût du transfert de
     données est plus important que les bénéfices.

     Lorsque que SUBSTITUTABLE? est faux, déclare que les substituts de
     la sortie de la dérivation ne devraient pas être utilisés (*note
     Substituts::). Cela est utile par exemple pour construire des
     paquets qui utilisent des détails du jeu d’instruction du CPU hôte.

     PROPERTIES doit être une liste d’association décrivant les «
     propriétés » de la dérivation. Elle est gardée telle-quelle, sans
     être interprétée, dans la dérivation.

Voici un exemple avec un script shell comme constructeur, en supposant
que STORE est une connexion ouverte au démon et BASH pointe vers un
exécutable Bash dans le dépôt :

     (use-modules (guix utils)
                  (guix store)
                  (guix derivations))

     (let ((builder   ; ajoute le script Bash au dépôt
             (add-text-to-store store "my-builder.sh"
                                "echo hello world > $out\n" '())))
       (derivation store "foo"
                   bash `("-e" ,builder)
                   #:inputs `((,bash) (,builder))
                   #:env-vars '(("HOME" . "/homeless"))))
     ⇒ #<derivation /gnu/store/...-foo.drv => /gnu/store/...-foo>

   Comme on pourrait s’en douter, cette primitive est difficile à
utiliser directement. Une meilleure approche est d’écrire les scripts de
construction en Scheme, bien sur ! Le mieux à faire pour cela est
d’écrire le code de construction comme une « G-expression » et de la
passer à ‘gexp->derivation’. Pour plus d’informations, *note
G-Expressions::.

   Il fut un temps où ‘gexp->derivation’ n’existait pas et où construire
une dérivation donc le code de construction était écrit en Scheme se
faisait avec ‘build-expression->derivation’, documenté plus bas. Cette
procédure est maintenant obsolète, remplacée par ‘gexp->derivation’ qui
est meilleure.

 -- Procédure Scheme : build-expression->derivation STORE NAME EXP
          [#:system (%current-system)] [#:inputs '()] [#:outputs
          '("out")] [#:hash #f] [#:hash-algo #f] [#:recursive? #f]
          [#:env-vars '()] [#:modules '()] [#:references-graphs #f]
          [#:allowed-references #f] [#:disallowed-references #f]
          [#:local-build? #f] [#:substitutable? #t] [#:guile-for-build
          #f]
     Renvoie une dérivation qui exécute l’expression Scheme EXP comme un
     constructeur pour la dérivation NAME. INPUTS doit être une liste de
     tuples ‘(name drv-path sub-drv)’ ; lorsque SUB-DRV est omis,
     ‘"out"’ est utilisé. MODULES est une liste de noms de modules Guile
     du chemin de recherche actuel qui seront copiés dans le dépôt,
     compilés et rendus disponibles dans le chemin de chargement pendant
     l’exécution de EXP — p. ex. ‘((guix build utils) (guix build
     gnu-build-system))’.

     EXP est évaluée dans une environnement où ‘%outputs’ est lié à une
     liste de paires de sortie/chemin, et où ‘%build-inputs’ est lié à
     une liste de paires de chaînes de caractères et de chemin de sortie
     construite à partir de INPUTS. Éventuellement, ENV-VARS est une
     liste de paires de chaînes de caractères spécifiant le nom et la
     valeur de variables d’environnement visibles pour le constructeur.
     Le constructeur termine en passant le résultat de EXP à ‘exit’ ;
     ainsi, lorsque EXP renvoie ‘#f’, la construction est considérée en
     échec.

     EXP est construite avec GUILE-FOR-BUILD (une dérivation). Lorsque
     GUILE-FOR-BUILD est omis où est ‘#f’, la valeur du fluide
     ‘%guile-for-build’ est utilisée à la place.

     Voir la procédure ‘derivation’ pour la signification de
     REFERENCES-GRAPH, ALLOWED-REFERENCES, DISALLOWED-REFERENCES,
     LOCAL-BUILD? et SUBSTITUTABLE?.

Voici un exemple de dérivation à sortie unique qui crée un répertoire
avec un fichier :

     (let ((builder '(let ((out (assoc-ref %outputs "out")))
                       (mkdir out)    ; create /gnu/store/...-goo
                       (call-with-output-file (string-append out "/test")
                         (lambda (p)
                           (display '(hello guix) p))))))
       (build-expression->derivation store "goo" builder))

     ⇒ #<derivation /gnu/store/...-goo.drv => ...>


File: guix.fr.info,  Node: La monade du dépôt,  Next: G-Expressions,  Prev: Dérivations,  Up: Interface de programmation

6.6 La monade du dépôt
======================

Les procédures qui travaillent sur le dépôt décrites dans les sections
précédentes prennent toutes une connexion ouverte au démon de
construction comme premier argument. Bien que le modèle sous-jacent soit
fonctionnel, elles ont soit des effets de bord, soit dépendent de l’état
actuel du dépôt.

   Le premier point est embêtant : on doit se balader avec la connexion
au démon dans toutes ces fonctions, ce qui rend impossible le fait de
composer des fonctions qui ne prennent pas ce paramètre avec des
fonctions qui le prennent. Le deuxième point est problématique : comme
les opérations sur le dépôt ont des effets de bord ou dépendent d’états
externes, elles doivent être enchaînés correctement.

   C’est là que le module ‘(guix monads)’ arrive à la rescousse. Ce
module fournit un cadre pour travailler avec des “monads”, en
particulier une monade très utile pour notre usage, la “monade du
dépôt”. Les monades sont des constructions qui permettent deux choses :
associer un « contexte » avec une valeur (dans notre cas, le contexte
est le dépôt) et construire une séquence de calculs (ici les calculs
comprennent des accès au dépôt). Les valeurs dans une monade — les
valeurs qui contiennent ce contexte supplémentaire — sont appelées des
“valeurs monadiques” ; les procédures qui renvoient ce genre de valeur
sont appelées des “procédures monadiques”.

   Considérez cette procédure « normale » :

     (define (sh-symlink store)
       ;; Renvoie une dérivation qui crée un lien symbolique vers l'exécutable « bash ».
       (let* ((drv (package-derivation store bash))
              (out (derivation->output-path drv))
              (sh  (string-append out "/bin/bash")))
         (build-expression->derivation store "sh"
                                       `(symlink ,sh %output))))

   En utilisant ‘(guix monads)’ et ‘(guix gexp)’, on peut la réécrire en
une fonction monadique :

     (define (sh-symlink)
       ;; Pareil, mais renvoie une valeur monadique.
       (mlet %store-monad ((drv (package->derivation bash)))
         (gexp->derivation "sh"
                           #~(symlink (string-append #$drv "/bin/bash")
                                      #$output))))

   Il y a plusieurs choses à remarquer avec cette deuxième version : le
paramètre ‘store’ est maintenant implicitement « enfilé » dans les
appels aux procédures monadiques ‘package->derivation’ et
‘gexp->derivation’, et la valeur monadique renvoyée par
‘package->derivation’ est “liée” avec ‘mlet’ plutôt qu’avec un simple
‘let’.

   Il se trouve que l’appel à ‘package->derivation’ peut même être omis
puisqu’il aura lieu implicitement, comme nous le verrons plus tard
(*note G-Expressions::) :

     (define (sh-symlink)
       (gexp->derivation "sh"
                         #~(symlink (string-append #$bash "/bin/bash")
                                    #$output)))

   L’appel à la procédure monadique ‘sh-symlink’ n’a aucun effet. Comme
on pourrait le dire, « on sort d’une monade comme de la monarchie : en
l’exécutant »(1). Donc, pour sortir de la monade et obtenir l’effet
escompté, on doit utiliser ‘run-with-store’.

     (run-with-store (open-connection) (sh-symlink))
     ⇒ /gnu/store/...-sh-symlink

   Remarquez que le module ‘(guix monad-repl)’ étend la console Guile
avec de nouvelles « méta-commandes » pour rendre plus facile la
manipulation de procédures monadiques : ‘run-in-store’ et
‘enter-store-monad’. La première est utilisée pour « lancer » une seule
valeur monadique à travers le dépôt :

     scheme@(guile-user)> ,run-in-store (package->derivation hello)
     $1 = #<derivation /gnu/store/...-hello-2.9.drv => ...>

   La deuxième entre dans une console récursive, où toutes les valeurs
de retour sont automatiquement lancées à travers le dépôt :

     scheme@(guile-user)> ,enter-store-monad
     store-monad@(guile-user) [1]> (package->derivation hello)
     $2 = #<derivation /gnu/store/...-hello-2.9.drv => ...>
     store-monad@(guile-user) [1]> (text-file "foo" "Hello!")
     $3 = "/gnu/store/...-foo"
     store-monad@(guile-user) [1]> ,q
     scheme@(guile-user)>

Remarquez qu’on ne peut pas renvoyer de valeur non monadique dans la
console ‘store-monad’.

   Les formes syntaxiques principales pour utiliser des monades en
général sont disponibles dans le module ‘(guix monads)’ et sont décrites
ci-dessous.

 -- Syntaxe Scheme : with-monad MONAD BODY ...
     Évalue n’importe quelle forme ‘>>=’ ou ‘return’ dans BODY comme une
     MONAD.

 -- Syntaxe Scheme : return VAL
     Renvoie une valeur monadique qui encapsule VAL.

 -- Syntaxe Scheme : >>= MVAL MPROC ...
     “Lie” une valeur monadique MVAL, en passant son « contenu » aux
     procédures monadiques MPROC...(2). Il peut y avoir une ou plusieurs
     ‘mproc’, comme dans cet exemple :

          (run-with-state
              (with-monad %state-monad
                (>>= (return 1)
                     (lambda (x) (return (+ 1 x)))
                     (lambda (x) (return (* 2 x)))))
            'some-state)

          ⇒ 4
          ⇒ some-state

 -- Syntaxe Scheme : mlet MONAD ((VAR MVAL) ...) BODY ...
 -- Syntaxe Scheme : mlet* MONAD ((VAR MVAL) ...) BODY ...
     Lie les variables VAR aux valeurs monadiques MVAL dans BODY, une
     séquence d’expressions. Comme avec l’opérateur de liaison, on peut
     réfléchir comme si on « ouvrait » la valeur non-monadique «
     contenue » dans MVAL et comme si on faisait en sorte que VAR se
     réfère à cette valeur pure, non-monadique, dans la portée de BODY.
     La forme (VAR -> VAL) lie VAR à la valeur « normale » VAL, comme
     ‘let’. L’opération de liaison a lieu en séquence de la gauche vers
     la droite. La dernière expression de BODY doit être une expression
     monadique et son résultat deviendra le résultat de ‘mlet’ ou
     ‘mlet*’ lorsque lancé dans la MONAD.

     ‘mlet*’ est à ‘mlet’ ce que ‘let*’ est à ‘let’ (*note (guile)Local
     Bindings::).

 -- Système Scheme : mbegin MONAD MEXP ...
     Lie MEXP et les expressions monadiques suivantes en séquence, et
     renvoie le résultat de la dernière expression. Chaque expression
     dans la séquence doit être une expression monadique.

     Cette procédure est similaire à ‘mlet’, sauf que les valeurs de
     retour des expressions monadiques sont ignorées. Dans ce sens, elle
     est analogue à ‘begin’, mais appliqué à des expressions monadiques.

 -- Système Scheme : mwhen CONDITION MEXP0 MEXP* ...
     Lorsque la CONDITION est vraie, évalue la séquence des expressions
     monadiques MEXP0..MEXP* comme dans un ‘mbegin’. Lorsque la
     CONDITION est fausse, renvoie ‘*unspecified*’ dans la monade
     actuelle. Chaque expression dans la séquence doit être une
     expression monadique.

 -- Système Scheme : munless CONDITION MEXP0 MEXP* ...
     Lorsque la CONDITION est fausse, évalue la séquence des expressions
     monadiques MEXP0..MEXP* comme dans un ‘mbegin’. Lorsque la
     CONDITION est vraie, renvoie ‘*unspecified*’ dans la monade
     actuelle. Chaque expression dans la séquence doit être une
     expression monadique.

   Le module ‘(guix monads)’ fournit la “monade d’état” qui permet à une
valeur supplémentaire — l’état — d’être enfilée à travers les appels de
procédures.

 -- Variable Scheme : %state-monad
     La monade d’état. les procédure dans la monade d’état peuvent
     accéder et modifier l’état qui est enfilé.

     Considérez l’exemple ci-dessous. La procédure ‘square’ renvoie une
     valeur dans la monade d’état. Elle renvoie le carré de son
     argument, mais incrémente aussi la valeur actuelle de l’état :

          (define (square x)
            (mlet %state-monad ((count (current-state)))
              (mbegin %state-monad
                (set-current-state (+ 1 count))
                (return (* x x)))))

          (run-with-state (sequence %state-monad (map square (iota 3))) 0)
          ⇒ (0 1 4)
          ⇒ 3

     When “run” through ‘%state-monad’, we obtain that additional state
     value, which is the number of ‘square’ calls.

 -- Procédure monadique : current-state
     Renvoie l’état actuel dans une valeur monadique.

 -- Procédure monadique : set-current-state VALUE
     Initialise l’état actuel à VALUE et renvoie l’état précédent dans
     une valeur monadique.

 -- Procédure monadique : state-push VALUE
     Pousse VALUE sur l’état actuel, qui est supposé être une liste, et
     renvoie l’état précédent dans une valeur monadique.

 -- Procédure monadique : state-pop
     Récupère (pop) une valeur dans l’état actuel et la renvoie comme
     une valeur monadique. L’état est supposé être une liste.

 -- Procédure Scheme : run-with-state MVAL [STATE]
     Lance la valeur monadique MVAL avec STATE comme valeur initiale.
     Renvoie deux valeurs : la valeur du résultat et l’état du résultat.

   L’interface principale avec la monade du dépôt, fournit par le module
‘(guix store)’, est la suivante.

 -- Variable Scheme : %store-monad
     The store monad—an alias for ‘%state-monad’.

     Values in the store monad encapsulate accesses to the store. When
     its effect is needed, a value of the store monad must be
     “evaluated” by passing it to the ‘run-with-store’ procedure (see
     below).

 -- Procédure Scheme : run-with-store STORE MVAL [#:guile-for-build]
          [#:system (%current-system)]
     Lance MVAL, une valeur monadique dans la monade du dépôt, dans
     STORE, une connexion ouvert au dépôt.

 -- Procédure monadique : text-file NAME TEXT [REFERENCES]
     Renvoie une valeur monadique correspondant au nom de fichier dans
     le dépôt du fichier contenant TEXT, une chaîne de caractères.
     REFERENCES est une liste d’éléments du dépôt auxquels le fichier
     texte en résultat se réfère ; c’est la liste vide par défaut.

 -- Procédure monadique : binary-file NAME DATA [REFERENCES]
     Renvoie une valeur monadique correspondant au nom de fichier absolu
     dans le dépôt du fichier contenant DATA, un vecteur d’octets.
     REFERENCES est une liste d’éléments du dépôt auxquels le fichier
     binaire en résultat se réfère ; c’est la liste vide par défaut.

 -- Procédure monadique : interned-file FILE [NAME] [#:recursive? #t]
          [#:select? (const #t)]
     Renvoie le nom de FILE une fois ajouté au dépôt. Utilise NAME comme
     nom dans le dépôt ou le nom de fichier de FILE si NAME est omis.

     Lorsque RECURSIVE? est vraie, le contenu de FILE est ajouté
     récursivement ; si FILE désigne un fichier simple et que RECURSIVE?
     est vrai, son contenu est ajouté et ses bits de permissions sont
     préservés.

     Lorsque RECURSIVE? est vraie, appelle ‘(SELECT? FILE STAT)’ pour
     chaque répertoire où FILE est le nom de fichier absolu de l’entrée
     et STAT est le résultat de ‘lstat’ ; à l’exception des entrées pour
     lesquelles SELECT? ne renvoie pas vrai.

     L’exemple ci-dessous ajoute un fichier au dépôt, sous deux noms
     différents :

          (run-with-store (open-connection)
            (mlet %store-monad ((a (interned-file "README"))
                                (b (interned-file "README" "LEGU-MIN")))
              (return (list a b))))

          ⇒ ("/gnu/store/rwm...-README" "/gnu/store/44i...-LEGU-MIN")

   Le module ‘(guix packages)’ exporte les procédures monadiques liées
aux paquets suivantes :

 -- Procédure monadique : package-file PACKAGE [FILE] [#:system
          (%current-system)] [#:target #f] [#:output "out"]
     Renvoie une valeur monadique qui contient le nom de fichier absolu
     de FILE dans le répertoire OUTPUT de PACKAGE. Lorsque FILE est
     omis, renvoie le nom du répertoire OUTPUT de PACKAGE. Lorsque
     TARGET est vrai, l’utilise comme un triplet de cible pour la
     compilation croisée.

     Note that this procedure does _not_ build PACKAGE. Thus, the result
     might or might not designate an existing file. We recommend not
     using this procedure unless you know what you are doing.

 -- Procédure monadique : package->derivation PACKAGE [SYSTEM]
 -- Procédure monadique : package->cross-derivation PACKAGE TARGET
          [SYSTEM]
     Version monadique de ‘package-derivation’ et
     ‘package-cross-derivation’ (*note Définition des paquets::).

   ---------- Footnotes ----------

   (1) NdT : il y a là un jeu de mot en anglais qui se base sur un
double sens de « run », qui peut se traduire par « exécuter » dans ce
contexte.

   (2) Cette opération est souvent appelée « bind », mais ce nom dénote
une procédure qui n’a rien à voir en Guile. Ainsi, nous empruntons ce
symbole quelque peu cryptique au langage Haskell


File: guix.fr.info,  Node: G-Expressions,  Next: Invoquer guix repl,  Prev: La monade du dépôt,  Up: Interface de programmation

6.7 G-Expressions
=================

On a donc des « dérivations » qui représentent une séquence d’actions de
construction à effectuer pour produire un élément du dépôt (*note
Dérivations::). Ces actions de construction sont effectuées lorsqu’on
demande au démon de construire effectivement les dérivations ; elles
sont lancées par le démon dans un conteneur (*note Invoquer
guix-daemon::).

   Ça ne devrait pas vous surprendre, mais nous aimons écrire ces
actions de construction en Scheme. Lorsqu’on fait ça, on fini avec deux
“strates” de code Scheme(1) : le « code hôte » — le code qui définit les
paquets, parle au démon, etc. — et le « code côté construction » — le
code qui effectue effectivement les actions de construction, comme créer
des répertoires, invoquer ‘make’, etc.

   Pour décrire une dérivation et ses actions de construction, on a
typiquement besoin d’intégrer le code de construction dans le code hôte.
Ça revient à manipuler le code de construction comme de la donnée, et
l’homoiconicité de Scheme — le code a une représentation directe en tant
que donnée — est très utile pour cela. Mais on a besoin de plus que le
mécanisme de ‘quasiquote’ en Scheme pour construire des expressions de
construction.

   Le module ‘(guix gexp)’ implémente les “G-expressions”, une forme de
S-expression adaptée aux expressions de construction. Les G-expression,
ou “gexps”, consistent en gros en trois formes syntaxiques : ‘gexp’,
‘ungexp’ et ‘ungexp-splicing’ (ou plus simplement : ‘#~’, ‘#$’ et
‘#$@’), qui sont comparable à ‘quasiquote’, ‘unquote’ et
‘unquote-splicing’ respectivement (*note ‘quasiquote’: (guile)Expression
Syntax.). Cependant il y a des différences majeures :

   • Les Gexps sont conçues pour être écrites dans un fichier et être
     lancées ou manipulées par d’autres processus.

   • Lorsqu’un objet de haut-niveau comme un paquet ou une dérivation
     est unquotée dans une gexp, le résultat est comme si le nom de
     fichier de son résultat avait été introduit.

   • Les gexps transportent des informations sur les paquets ou les
     dérivations auxquels elles se réfèrent, et ces dépendances sont
     automatiquement ajoutées comme des entrées du processus de
     construction qui les utilise.

   This mechanism is not limited to package and derivation objects:
“compilers” able to “lower” other high-level objects to derivations or
files in the store can be defined, such that these objects can also be
inserted into gexps. For example, a useful type of high-level objects
that can be inserted in a gexp is “file-like objects”, which make it
easy to add files to the store and to refer to them in derivations and
such (see ‘local-file’ and ‘plain-file’ below).

   Pour illustrer cette idée, voici un exemple de gexp :

     (define build-exp
       #~(begin
           (mkdir #$output)
           (chdir #$output)
           (symlink (string-append #$coreutils "/bin/ls")
                    "list-files")))

   Cette gexp peut être passée à ‘gexp->derivation’ ; on obtient une
dérivation qui construit une répertoire contenant exactement un lien
symbolique à ‘/gnu/store/...-coreutils-8.22/bin/ls’ :

     (gexp->derivation "the-thing" build-exp)

   Comme on pourrait s’y attendre, la chaîne
‘"/gnu/store/...-coreutils-8.22"’ est substituée à la place de la
référence au paquet COREUTILS dans le code de construction final, et
COREUTILS est automatiquement devenu une entrée de la dérivation. De
même, ‘#$output’ (équivalent à ‘(ungexp output)’) est remplacé par une
chaîne de caractères contenant le nom du répertoire de la sortie de la
dérivation.

   Dans le contexte d’une compilation croisée, il est utile de
distinguer entre des références à la construction _native_ d’un paquet —
qui peut être lancé par l’hôte — et des références à la construction
croisée d’un paquet. Pour cela, ‘#+’ joue le même rôle que ‘#$’, mais
référence une construction native d’un paquet :

     (gexp->derivation "vi"
        #~(begin
            (mkdir #$output)
            (mkdir (string-append #$output "/bin"))
            (system* (string-append #+coreutils "/bin/ln")
                     "-s"
                     (string-append #$emacs "/bin/emacs")
                     (string-append #$output "/bin/vi")))
        #:target "aarch64-linux-gnu")

Dans l’exemple ci-dessus, la construction native de COREUTILS est
utilisée, pour que ‘ln’ puisse effectivement être lancé sur l’hôte ;
mais ensuite la construction croisée d’EMACS est utilisée.

   Une autre fonctionnalité, ce sont les “modules importés” : parfois
vous voudriez pouvoir utiliser certains modules Guile de «
l’environnement hôte » dans la gexp, donc ces modules devraient être
importés dans « l’environnement de construction ». La forme
‘with-imported-modules’ vous permet d’exprimer ça :

     (let ((build (with-imported-modules '((guix build utils))
                    #~(begin
                        (use-modules (guix build utils))
                        (mkdir-p (string-append #$output "/bin"))))))
       (gexp->derivation "empty-dir"
                         #~(begin
                             #$build
                             (display "success!\n")
                             #t)))

Dans cet exemple, le module ‘(guix build utils)’ est automatiquement
récupéré dans l’environnement de construction isolé de notre gexp, pour
que ‘(use-modules (guix build utils))’ fonctionne comme on s’y
attendrait.

   Typiquement, vous voudriez que la _closure_ complète du module soit
importé — c.-à-d. le module lui-même et tous les modules dont il dépend
— plutôt que seulement le module ; sinon, une tentative de chargement du
module échouera à cause des modules dépendants manquants. La procédure
‘source-module-closure’ calcule la closure d’un module en cherchant dans
ses en-têtes sources, ce qui est pratique dans ce cas :

     (use-modules (guix modules))   ;pour 'source-module-closure'

     (with-imported-modules (source-module-closure
                              '((guix build utils)
                                (gnu build vm)))
       (gexp->derivation "something-with-vms"
                         #~(begin
                             (use-modules (guix build utils)
                                          (gnu build vm))
                             ...)))

   Dans la même idée, parfois vous pouvez souhaiter importer non
seulement des modules en Scheme pur, mais aussi des « extensions » comme
des liaisons Guile de bibliothèques C ou d’autres paquet « complets ».
Disons que vous voulez utiliser le paquet ‘guile-json’ du côté de la
construction, voici comme procéder :

     (use-modules (gnu packages guile))  ;pour 'guile-json'

     (with-extensions (list guile-json)
       (gexp->derivation "something-with-json"
                         #~(begin
                             (use-modules (json))
                             ...)))

   La forme syntaxique pour construire des gexps est résumée ci-dessous.

 -- Syntaxe Scheme : #~EXP
 -- Syntaxe Scheme : (gexp EXP)
     Renvoie une G-expression contenant EXP. EXP peut contenir une ou
     plusieurs de ces formes :

     ‘#$OBJ’
     ‘(ungexp OBJ)’
          Introduit une référence à OBJ. OBJ peut être d’un des types
          supportés, par exemple un paquet ou une dérivation, auquel cas
          la forme ‘ungexp’ est remplacée par le nom de fichier de sa
          sortie — p. ex. ‘"/gnu/store/...-coreutils-8.22’.

          Si BOJ est une liste, elle est traversée et les références aux
          objets supportés sont substitués de manière similaire.

          Si OBJ est une autre gexp, son contenu est inséré et ses
          dépendances sont ajoutées à celle de la gexp qui l’entoure.

          Si OBJ est un autre type d’objet, il est inséré tel quel.

     ‘#$OBJ:OUTPUT’
     ‘(ungexp OBJ OUTPUT)’
          Cette forme est similaire à la précédente, mais se réfère
          explicitement à la sortie OUTPUT de l’objet OBJ — c’est utile
          lorsque OBJ produit plusieurs sorties (*note Des paquets avec
          plusieurs résultats::).

     ‘#+OBJ’
     ‘#+OBJ:output’
     ‘(ungexp-native OBJ)’
     ‘(ungexp-native OBJ OUTPUT)’
          Comme ‘ungexp’, mais produit une référence à la construction
          _native_ de OBJ lorsqu’elle est utilisée dans une compilation
          croisée.

     ‘#$output[:OUTPUT]’
     ‘(ungexp output [OUTPUT])’
          Insère une référence à la sortie OUTPUT de la dérivation, ou à
          la sortie principale lorsque OUTPUT est omis.

          Cela ne fait du sens que pour les gexps passées à
          ‘gexp->derivation’.

     ‘#$@LST’
     ‘(ungexp-splicing LST)’
          Comme au dessus, mais recolle (splice) le contenu de LST dans
          la liste qui la contient.

     ‘#+@LST’
     ‘(ungexp-native-splicing LST)’
          Comme au dessus, mais se réfère à la construction native des
          objets listés dans LST.

     G-expressions created by ‘gexp’ or ‘#~’ are run-time objects of the
     ‘gexp?’ type (see below).

 -- Syntaxe Scheme : with-imported-modules MODULES BODY...
     Marque les gexps définies dans BODY... comme requérant MODULES dans
     leur environnement d’exécution.

     Chaque élément dans MODULE peut être le nom d’un module, comme
     ‘(guix build utils)’ ou le nom d’un module suivi d’une flèche,
     suivie d’un objet simili-fichier :

          `((guix build utils)
            (guix gcrypt)
            ((guix config) => ,(scheme-file "config.scm"
                                            #~(define-module ...))))

     Dans l’exemple au dessus, les deux premiers modules sont récupérés
     dans le chemin de recherche, et le dernier est créé à partir d’un
     objet simili-fichier.

     Cette forme a une portée _lexicale_ : elle a un effet sur les gexp
     directement définies dans BODY..., mais pas sur celles définies
     dans des procédures appelées par BODY....

 -- Syntaxe Scheme : with-extensions EXTENSIONS BODY...
     Marque les gexps définies dans BODY... comme requérant EXTENSIONS
     dans leur environnement de construction et d’exécution. EXTENSIONS
     est typiquement une liste d’objets paquets comme définis dans le
     module ‘(gnu packages guile)’.

     Concrètement, les paquets listés dans EXTENSIONS sont ajoutés au
     chemin de chargement lors de la compilation des modules importés
     dans BODY... ; ils sont aussi ajoutés au chemin de chargement de la
     gexp renvoyée par BODY....

 -- Procédure Scheme : gexp? OBJ
     Renvoie ‘#t’ si OBJ est une G-expression.

   G-expressions are meant to be written to disk, either as code
building some derivation, or as plain files in the store. The monadic
procedures below allow you to do that (*note La monade du dépôt::, for
more information about monads).

 -- Procédure monadique : gexp->derivation NAME EXP [#:system
          (%current-system)] [#:target #f] [#:graft? #t]  [#:hash #f]
     [#:hash-algo #f]  [#:recursive? #f] [#:env-vars ’()] [#:modules
     ’()]  [#:module-path ‘%load-path’]  [#:effective-version "2.2"]
      [#:references-graphs #f] [#:allowed-references #f]
      [#:disallowed-references #f]  [#:leaked-env-vars #f]
      [#:script-name (string-append NAME "-builder")]
      [#:deprecation-warnings #f]  [#:local-build? #f] [#:substitutable?
     #t]  [#:properties ’()] [#:guile-for-build #f] Return a derivation
     NAME that runs EXP (a gexp) with GUILE-FOR-BUILD (a derivation) on
     SYSTEM; EXP is stored in a file called SCRIPT-NAME. When TARGET is
     true, it is used as the cross-compilation target triplet for
     packages referred to by EXP.

     MODULES est devenu obsolète en faveur de ‘with-imported-modules’.
     Sa signification est de rendre MODULES disponibles dans le contexte
     d’évaluation de EXP ; MODULES est une liste de noms de modules
     Guile qui sont cherchés dans MODULE-PATH pour les copier dans le
     dépôt, les compiler et les rendre disponibles dans le chemin de
     chargement pendant l’exécution de EXP — p. ex. ‘((guix build utils)
     (guix build gnu-build-system))’.

     EFFECTIVE-VERSION détermine la chaîne à utiliser lors d’ajout
     d’extensions de EXP (voir ‘with-extensions’) au chemin de recherche
     — p. ex. ‘"2.2"’.

     GRAFT? détermine si les paquets référencés par EXP devraient être
     greffés si possible.

     Lorsque REFERENCES-GRAPHS est vrai, il doit s’agir d’une liste de
     tuples de la forme suivante :

          (FILE-NAME PACKAGE)
          (FILE-NAME PACKAGE OUTPUT)
          (FILE-NAME DERIVATION)
          (FILE-NAME DERIVATION OUTPUT)
          (FILE-NAME STORE-ITEM)

     La partie droite des éléments de REFERENCES-GRAPHS est
     automatiquement transformée en une entrée du processus de
     construction EXP. Dans l’environnement de construction, chaque
     FILE-NAME contient le graphe des références de l’élément
     correspondant, dans un format texte simple.

     ALLOWED-REFERENCES doit soit être ‘#f’, soit une liste de noms de
     sorties ou de paquets. Dans ce dernier cas, la liste dénote les
     éléments du dépôt auxquels le résultat a le droit de faire
     référence. Toute référence à un autre élément du dépôt conduira à
     une erreur à la construction. Comme pour DISALLOWED-REFERENCES, qui
     peut lister des éléments qui ne doivent pas être référencés par les
     sorties.

     DEPRECATION-WARNINGS détermine s’il faut afficher les avertissement
     d’obsolescence à la compilation de modules. Il peut valoir ‘#f’,
     ‘t’ ou ‘'detailed’.

     Les autres arguments sont les mêmes que pour ‘derivation’ (*note
     Dérivations::).

   Les procédures ‘local-file’, ‘plain-file’, ‘computed-file’,
‘program-file’ et ‘scheme-file’ ci-dessous renvoient des “objets
simili-fichiers”. C’est-à-dire, lorsqu’ils sont unquotés dans une
G-expression, ces objets donnent un fichier dans le dépôt. Considérez
cette G-expression :

     #~(system* #$(file-append glibc "/sbin/nscd") "-f"
                #$(local-file "/tmp/my-nscd.conf"))

   Ici, l’effet est « d’internaliser » ‘/tmp/my-nscd.conf’ en le copiant
dans le dépôt. Une fois étendu, par exemple via ‘gexp->derivation’, la
G-expression se réfère à cette copie dans ‘/gnu/store’ ; ainsi, modifier
ou supprimer le fichier dans ‘/tmp’ n’a aucun effet sur ce que fait la
G-expression. ‘plain-file’ peut être utilisé de la même manière ; elle
est seulement différente par le fait que le contenu du fichier est passé
directement par une chaîne de caractères.

 -- Procédure Scheme : local-file FILE [NAME] [#:recursive? #f]
          [#:select? (const #t)] Return an object representing local
     file FILE to add to the store; this object can be used in a gexp.
     If FILE is a literal string denoting a relative file name, it is
     looked up relative to the source file where it appears; if FILE is
     not a literal string, it is looked up relative to the current
     working directory at run time. FILE will be added to the store
     under NAME–by default the base name of FILE.

     Lorsque RECURSIVE? est vraie, le contenu de FILE est ajouté
     récursivement ; si FILE désigne un fichier simple et que RECURSIVE?
     est vrai, son contenu est ajouté et ses bits de permissions sont
     préservés.

     Lorsque RECURSIVE? est vraie, appelle ‘(SELECT? FILE STAT)’ pour
     chaque répertoire où FILE est le nom de fichier absolu de l’entrée
     et STAT est le résultat de ‘lstat’ ; à l’exception des entrées pour
     lesquelles SELECT? ne renvoie pas vrai.

     C’est la version déclarative de la procédure monadique
     ‘interned-file’ (*note ‘interned-file’: La monade du dépôt.).

 -- Procédure Scheme : plain-file NAME CONTENT
     Renvoie un objet représentant un fichier texte nommé NAME avec pour
     contenu CONTENT (une chaîne de caractères ou un vecteur d’octets) à
     ajouter un dépôt.

     C’est la version déclarative de ‘text-file’.

 -- Procédure Scheme : computed-file NAME GEXP [#:options
          '(#:local-build? #t)]
     Renvoie un objet représentant un élément du dépôt NAME, un fichier
     ou un répertoire calculé par GEXP. OPTIONS est une liste
     d’arguments supplémentaires à passer à ‘gexp->derivation’.

     C’est la version déclarative de ‘gexp->derivation’.

 -- Procédure monadique : gexp->script NAME EXP [#:guile
          (default-guile)] [#:module-path %load-path]  [#:system
     (%current-system)] [#:target #f] Return an executable script NAME
     that runs EXP using GUILE, with EXP’s imported modules in its
     search path. Look up EXP’s modules in MODULE-PATH.

     L’exemple ci-dessous construit un script qui invoque simplement la
     commande ‘ls’ :

          (use-modules (guix gexp) (gnu packages base))

          (gexp->script "list-files"
                        #~(execl #$(file-append coreutils "/bin/ls")
                                 "ls"))

     Lorsqu’elle est « lancée » à travers le dépôt (*note
     ‘run-with-store’: La monade du dépôt.), on obtient une dérivation
     qui produit une fichier exécutable ‘/gnu/store/...-list-files’ qui
     ressemble à :

          #!/gnu/store/...-guile-2.0.11/bin/guile -ds
          !#
          (execl "/gnu/store/...-coreutils-8.22"/bin/ls" "ls")

 -- Procédure Scheme : program-file NAME EXP [#:guile #f] [#:module-path
          %load-path]
     Renvoie un objet représentant un élément du dépôt NAME qui lance
     GEXP. GUILE est le paquet Guile à utiliser pour exécuter le script.
     Les modules importés par GEXP sont recherchés dans MODULE-PATH.

     C’est la version déclarative de ‘gexp->script’.

 -- Procédure monadique : gexp->file NAME EXP [#:set-load-path? #t]
          [#:module-path %load-path] [#:splice? #f] [#:guile
          (default-guile)]
     Renvoie une dérivation qui construit un fichier NAME contenant EXP.
     Lorsque SPLICE? est vrai, EXP est considéré comme une liste
     d’expressions qui seront splicée dans le fichier qui en résulte.

     Lorsque SET-LOAD-PATH? est vrai, émet du code dans le fichier de
     résultat pour initialiser ‘%load-path’ et ‘%load-compiled-path’
     pour honorer les modules importés de EXP. Les modules de EXP sont
     trouvés dans MODULE-PATH.

     Le fichier qui en résulte retient les références à toutes les
     dépendances de EXP ou un sous-ensemble.

 -- Scheme Procedure : scheme-file NAME EXP [#:splice? #f]
          [#:set-load-path? #t] Return an object representing the
     Scheme file NAME that contains EXP.

     C’est la version déclarative de ‘gexp->file’.

 -- Procédure monadique : text-file* NAME TEXT ...
     Renvoie une valeur monadique qui construit un ficher texte
     contenant TEXT. TEXT peut lister, en plus de chaînes de caractères,
     des objet de n’importe quel type qui peut être utilisé dans une
     gexp : des paquets, des dérivations, des fichiers objet locaux,
     etc. Le fichier du dépôt qui en résulte en retient toutes les
     références.

     Cette variante devrait être préférée à ‘text-file’ lorsque vous
     souhaitez créer des fichiers qui référencent le dépôt. Cela est le
     cas typiquement lorsque vous construisez un fichier de
     configuration qui contient des noms de fichiers du dépôt, comme
     ceci :

          (define (profile.sh)
            ;; Renvoie le nom d'un script shell dans le dépôt qui initialise
            ;; la variable d'environnement « PATH ».
            (text-file* "profile.sh"
                        "export PATH=" coreutils "/bin:"
                        grep "/bin:" sed "/bin\n"))

     Dans cet exemple, le fichier ‘/gnu/store/...-profile.sh’ qui en
     résulte référence COREUTILS, GREP et SED, ce qui les empêche d’être
     glanés tant que le script est accessible.

 -- Procédure Scheme : mixed-text-file NAME TEXT ...
     Renvoie un objet représentant le fichier du dépôt NAME contenant
     TEXT. TEXT est une séquence de chaînes de caractères et de fichiers
     simili-objets, comme dans :

          (mixed-text-file "profile"
                           "export PATH=" coreutils "/bin:" grep "/bin")

     C’est la version déclarative de ‘text-file*’.

 -- Procédure Scheme : file-union NAME FILES
     Renvoie un ‘<computed-file>’ qui construit un répertoire qui
     contient tous les fichiers de FILES. Chaque élément de FILES doit
     être une paire où le premier élément est le nom de fichier à
     utiliser dans le nouveau répertoire et le second élément est une
     gexp dénotant le fichier cible. Voici un exemple :

          (file-union "etc"
                      `(("hosts" ,(plain-file "hosts"
                                              "127.0.0.1 localhost"))
                        ("bashrc" ,(plain-file "bashrc"
                                               "alias ls='ls --color=auto'"))))

     Cela crée un répertoire ‘etc’ contenant ces deux fichiers.

 -- Procédure Scheme : directory-union NAME THINGS
     Renvoie un répertoire qui est l’union de THINGS, où THINGS est une
     liste d’objets simili-fichiers qui dénotent des répertoires. Par
     exemple :

          (directory-union "guile+emacs" (list guile emacs))

     crée un répertoire qui est l’union des paquets ‘guile’ et ‘emacs’.

 -- Procédure Scheme : file-append OBJ SUFFIX ...
     Renvoie un objet simili-fichier qui correspond à la concaténation
     de OBJ et SUFFIX où OBJ est un objet abaissable et chaque SUFFIX
     est une chaîne de caractères.

     Par exemple, considérez cette gexp :

          (gexp->script "run-uname"
                        #~(system* #$(file-append coreutils
                                                  "/bin/uname")))

     On peut obtenir le même effet avec :

          (gexp->script "run-uname"
                        #~(system* (string-append #$coreutils
                                                  "/bin/uname")))

     Il y a une différence cependant : dans le cas ‘file-append’, le
     script qui en résulte contient le nom de fichier absolu comme une
     chaîne de caractère alors que dans le deuxième cas, le script
     contient une expression ‘(string-append ...)’ pour construire le
     nom de fichier _à l’exécution_.

 -- Scheme Syntax : let-system SYSTEM BODY...
 -- Scheme Syntax : let-system (SYSTEM TARGET) BODY...
     Bind SYSTEM to the currently targeted system—e.g.,
     ‘"x86_64-linux"’—within BODY.

     In the second case, additionally bind TARGET to the current
     cross-compilation target—a GNU triplet such as
     ‘"arm-linux-gnueabihf"’—or ‘#f’ if we are not cross-compiling.

     ‘let-system’ is useful in the occasional case where the object
     spliced into the gexp depends on the target system, as in this
     example:

          #~(system*
             #+(let-system system
                 (cond ((string-prefix? "armhf-" system)
                        (file-append qemu "/bin/qemu-system-arm"))
                       ((string-prefix? "x86_64-" system)
                        (file-append qemu "/bin/qemu-system-x86_64"))
                       (else
                        (error "dunno!"))))
             "-net" "user" #$image)

 -- Scheme Syntax : with-parameters ((PARAMETER VALUE) ...) EXP
     This macro is similar to the ‘parameterize’ form for
     dynamically-bound “parameters” (*note (guile)Parameters::). The key
     difference is that it takes effect when the file-like object
     returned by EXP is lowered to a derivation or store item.

     A typical use of ‘with-parameters’ is to force the system in effect
     for a given object:

          (with-parameters ((%current-system "i686-linux"))
            coreutils)

     The example above returns an object that corresponds to the i686
     build of Coreutils, regardless of the current value of
     ‘%current-system’.

   Bien sûr, en plus de gexps inclues dans le code « hôte », certains
modules contiennent des outils de construction. Pour savoir facilement
qu’ils sont à utiliser dans la strate de construction, ces modules sont
gardés dans l’espace de nom ‘(guix build ...)’.

   En interne, les objets de haut-niveau sont “abaissés”, avec leur
compilateur, soit en des dérivations, soit en des objets du dépôt. Par
exemple, abaisser un paquet crée une dérivation, et abaisser un
‘plain-file’ crée un élément du dépôt. Cela est effectué par la
procédure monadique ‘lower-object’.

 -- Procédure monadique : lower-object OBJ [SYSTEM] [#:target #f] Return
          as a value in ‘%store-monad’ the derivation or
     store item corresponding to OBJ for SYSTEM, cross-compiling for
     TARGET if TARGET is true. OBJ must be an object that has an
     associated gexp compiler, such as a ‘<package>’.

   ---------- Footnotes ----------

   (1) Le terme “strate” dans ce contexte a été inventé par Manuel
Serrano et ses collaborateurs dans le contexte de leur travaux sur Hop.
Oleg Kiselyov, qui a écrit des essais perspicaces et du code sur le
sujet (http://okmij.org/ftp/meta-programming/#meta-scheme), utilise le
terme de « mise en scène » pour ce genre de génération de code.


File: guix.fr.info,  Node: Invoquer guix repl,  Prev: G-Expressions,  Up: Interface de programmation

6.8 Invoquer ‘guix repl’
========================

La commande ‘guix repl’ démarre un “boucle lecture-évaluation-affichage”
Guile pour la programmation interactive (*note (guile)Using Guile
Interactively::). Comparé au lancement de la commande ‘guile’, ‘guix
repl’ garanti que tous les modules Guix et toutes ses dépendances sont
disponibles dans le chemin de recherche. Vous pouvez l’utiliser de cette
manière :

     $ guix repl
     scheme@(guile-user)> ,use (gnu packages base)
     scheme@(guile-user)> coreutils
     $1 = #<package coreutils@8.29 gnu/packages/base.scm:327 3e28300>

   En plus, ‘guix repl’ implémente un protocole REPL simple lisible par
une machine à utiliser avec ‘(guix inferior)’, un dispositif pour
interagir avec des “inférieurs”, des processus séparés qui font tourner
une version potentiellement différente de Guix.

   Les options disponibles sont les suivante :

‘--type=TYPE’
‘-t TYPE’
     Démarrer un REPL du TYPE donné, qui peut être l’un de ces types :

     ‘guile’
          C’est la valeur par défaut. Elle démarre un REPL Guile
          standard fonctionnel.
     ‘machine’
          Démarre un REPL qui utilise le protocole lisible par machine.
          C’est le protocole que parle le module ‘(guix inferior)’.

‘--listen=EXTRÉMITÉ’
     Par défaut, ‘guix repl’ lit depuis l’entrée standard et écrit sur
     la sortie standard. Lorsque cette option est passée, il écoutera
     plutôt les connexions sur ENDPOINT. Voici un exemple d’options
     valides :

     ‘--listen=tcp:37146’
          Accepte les connexions sur localhost, sur le port 31.

     ‘--listen=unix:/tmp/socket’
          Accepte les connexions sur le socket Unix-domain
          ‘/tmp/socket’.

‘--load-path=RÉPERTOIRE’
‘-L RÉPERTOIRE’
     Ajoute RÉPERTOIRE au début du chemin de recherche de module de
     paquets (*note Modules de paquets::).

     This allows users to define their own packages and make them
     visible to the command-line tool.

‘-q’
     Inhibit loading of the ‘~/.guile’ file. By default, that
     configuration file is loaded when spawning a ‘guile’ REPL.


File: guix.fr.info,  Node: Utilitaires,  Next: Configuration système,  Prev: Interface de programmation,  Up: Top

7 Utilitaires
*************

Cette section décrit les utilitaires en ligne de commande de Guix.
certains sont surtout faits pour les personnes qui écrivent de nouvelles
définitions de paquets tandis que d’autres sont plus utiles pour une
utilisation générale. Ils complètent l’interface de programmation Scheme
de Guix d’une manière pratique.

* Menu:

* Invoquer guix build::      Construire des paquets depuis la ligne de
                               commande.
* Invoquer guix edit::       Modifier les définitions de paquets.
* Invoquer guix download::   Télécharger un fichier et afficher son hash.
* Invoquer guix hash::       Calculer le hash cryptographique d’un fichier.
* Invoquer guix import::     Importer des définitions de paquets.
* Invoquer guix refresh::    Mettre à jour les définitions de paquets.
* Invoquer guix lint::       Trouver des erreurs dans les définitions de
                               paquets.
* Invoquer guix size::       Profiler l’utilisation du disque.
* Invoquer guix graph::      Visualiser le graphe des paquets.
* Invoquer guix publish::    Partager des substituts.
* Invoquer guix challenge::  Défier les serveurs de substituts.
* Invoquer guix copy::       Copier vers et depuis un dépôt distant.
* Invoquer guix container::  Isolation de processus.
* Invoquer guix weather::    Mesurer la disponibilité des substituts.
* Invoquer guix processes::  Lister les processus clients.


File: guix.fr.info,  Node: Invoquer guix build,  Next: Invoquer guix edit,  Up: Utilitaires

7.1 Invoquer ‘guix build’
=========================

La commande ‘guix build’ construit des paquets ou des dérivations et
leurs dépendances et affiche les chemins du dépôt qui en résulte.
Remarquez qu’elle ne modifie pas le profil de l’utilisateur — c’est le
travail de la commande ‘guix package’ (*note Invoquer guix package::).
Ainsi, elle est surtout utile pour les personnes qui développent la
distribution.

   La syntaxe générale est :

     guix build OPTIONS PACKAGE-OR-DERIVATION...

   Par exemple, la commande suivante construit la dernière version
d’Emacs et de Guile, affiche leur journaux de construction et enfin
affiche les répertoires des résultats :

     guix build emacs guile

   De même, la commande suivante construit tous les paquets disponibles
:

     guix build --quiet --keep-going \
       `guix package -A | cut -f1,2 --output-delimiter=@`

   PACKAGE-OR-DERIVATION peut être soit le nom d’un paquet trouvé dans
la distribution logicielle comme ‘coreutils’, soit ‘coreutils@8.20’,
soit une dérivation comme ‘/gnu/store/...-coreutils-8.19.drv’. Dans le
premier cas, la commande cherchera un paquet avec le nom correspondant
(et éventuellement la version) dans les modules de la distribution GNU
(*note Modules de paquets::).

   Alternatively, the ‘--expression’ option may be used to specify a
Scheme expression that evaluates to a package; this is useful when
disambiguating among several same-named packages or package variants is
needed.

   Il peut y avoir aucune, une ou plusieurs OPTIONS. Les options
disponibles sont décrites dans les sous-sections ci-dessous.

* Menu:

* Options de construction communes::  Options de construction pour la
                                        plupart des commandes.
* Options de transformation de paquets::  Créer des variantes de paquets.
* Options de construction supplémentaires::  Options spécifiques à «
                                                guix build ».
* Débogage des échecs de construction::  L’empaquetage dans la vraie vie.


File: guix.fr.info,  Node: Options de construction communes,  Next: Options de transformation de paquets,  Up: Invoquer guix build

7.1.1 Options de construction communes
--------------------------------------

Un certain nombre d’options qui contrôlent le processus de construction
sont communes avec ‘guix build’ et les autres commandes qui peuvent
générer des constructions, comme ‘guix package’ ou ‘guix archive’. Voici
ces options :

‘--load-path=RÉPERTOIRE’
‘-L RÉPERTOIRE’
     Ajoute RÉPERTOIRE au début du chemin de recherche de module de
     paquets (*note Modules de paquets::).

     Cela permet à des utilisateurs de définir leur propres paquets et
     les rendre disponibles aux outils en ligne de commande.

‘--keep-failed’
‘-K’
     Garde l’arborescence de construction des constructions en échec.
     Ainsi, si une construction échoue, son arborescence de construction
     est préservée dans ‘/tmp’, dans un répertoire dont le nom est
     affiché à la fin du journal de construction. Cela est utile pour
     déboguer des échecs de construction. *Note Débogage des échecs de
     construction::, pour des astuces sur la manière de déboguer des
     problèmes de construction.

     This option implies ‘--no-offload’, and it has no effect when
     connecting to a remote daemon with a ‘guix://’ URI (*note the
     ‘GUIX_DAEMON_SOCKET’ variable: Le dépôt.).

‘--keep-going’
‘-k’
     Continue lorsque certaines dérivations échouent ; ne s’arrête que
     lorsque toutes les constructions ont soit réussies, soit échouées.

     Le comportement par défaut est de s’arrêter dès qu’une des
     dérivations spécifiées échoue.

‘--dry-run’
‘-n’
     Ne pas construire les dérivations.

‘--fallback’
     Lorsque la substitution d’un binaire pré-compilé échoue, construit
     les paquets localement à la place (*note Échec de substitution::).

‘--substitute-urls=URLS’
     Considère URLS comme une liste d’URL de sources de substituts
     séparés par des espaces, et remplace la liste par défaut d’URL de
     ‘guix-daemon’ (*note ‘guix-daemon’ URLs: daemon-substitute-urls.).

     Cela signifie que les substituts peuvent être téléchargés depuis
     URLS, tant qu’ils sont signés par une clef autorisée par
     l’administrateur système (*note Substituts::).

     Lorsque URLS est la chaîne vide, cela a pour effet de désactiver la
     substitution.

‘--no-substitutes’
     Ne pas utiliser de substitut pour les résultats de la construction.
     C’est-à-dire, toujours construire localement plutôt que de
     permettre le téléchargement de binaires pré-construits (*note
     Substituts::).

‘--no-grafts’
     Ne par « greffer » les paquets. En pratique, cela signifie que les
     mises à jour des paquets disponibles comme des greffes ne sont pas
     appliquées. *Note Mises à jour de sécurité::, pour plus
     d’information sur les greffes.

‘--rounds=N’
     Construit chaque dérivation N fois d’affilé, et renvoie une erreur
     si les constructions consécutives ne sont pas identiques bit-à-bit.

     Cela est une manière utile pour détecter des processus de
     construction non déterministes. Les processus de construction non
     déterministes sont problématiques car ils rendent pratiquement
     impossible la _vérification_ par les utilisateurs de l’authenticité
     de binaires tiers. *Note Invoquer guix challenge::, pour plus
     d’informations.

     Remarquez que, les résultats qui diffèrent ne sont pas gardés, donc
     vous devrez inspecter manuellement chaque erreur — p. ex. en
     gardant l’un des résultats avec ‘guix archive --export’ (*note
     Invoquer guix archive::), puis en reconstruisant, et enfin en
     comparant les deux résultats.

‘--no-offload’
     Do not use offload builds to other machines (*note Réglages du
     délestage du démon::). That is, always build things locally instead
     of offloading builds to remote machines.

‘--max-silent-time=SECONDES’
     Lorsque le processus de construction ou de substitution restent
     silencieux pendant plus de SECONDES, le terminer et rapporter une
     erreur de construction.

     By default, the daemon’s setting is honored (*note
     ‘--max-silent-time’: Invoquer guix-daemon.).

‘--timeout=SECONDES’
     De même, lorsque le processus de construction ou de substitution
     dure plus de SECONDES, le terminer et rapporter une erreur de
     construction.

     By default, the daemon’s setting is honored (*note ‘--timeout’:
     Invoquer guix-daemon.).

‘-v [NIVEAU]’
‘--verbosity=NIVEAU’
     Utiliser le NIVEAU de verbosité, en tant qu’entier. 0 signifie
     qu’aucune sortie n’est produite, 1 signifie une sortie silencieuse
     et 2 montre tous les journaux de construction sur la sortie
     d’erreur standard.

‘--cores=N’
‘-c N’
     Permet d’utiliser jusqu’à N cœurs du CPU pour la construction. La
     valeur spéciale ‘0’ signifie autant de cœurs que possible.

‘--max-jobs=N’
‘-M N’
     Allow at most N build jobs in parallel. *Note ‘--max-jobs’:
     Invoquer guix-daemon, for details about this option and the
     equivalent ‘guix-daemon’ option.

‘--debug=NIVEAU’
     Produire une sortie de débogage qui provient du démon de
     construction. NIVEAU doit être un entier entre 0 et 5 ; plus grand
     est ce nombre, plus verbeuse sera la sortie. Indiquer un niveau de
     4 ou plus peut être utile pour déboguer des problèmes
     d’installation avec le démon de construction.

   Sous le capot, ‘guix build’ est surtout un interface à la procédure
‘package-derivation’ du module ‘(guix packages)’, et à la procédure
‘build-derivations’ du module ‘(guix derivations)’.

   In addition to options explicitly passed on the command line, ‘guix
build’ and other ‘guix’ commands that support building honor the
‘GUIX_BUILD_OPTIONS’ environment variable.

 -- Variable d'environnement : GUIX_BUILD_OPTIONS
     Les utilisateurs peuvent définir cette variable à une liste
     d’options de la ligne de commande qui seront automatiquement
     utilisées par ‘guix build’ et les autres commandes ‘guix’ qui
     peuvent effectuer des constructions, comme dans l’exemple suivant :

          $ export GUIX_BUILD_OPTIONS="--no-substitutes -c 2 -L /foo/bar"

     Ces options sont analysées indépendamment, et le résultat est
     ajouté aux options de la ligne de commande analysées.


File: guix.fr.info,  Node: Options de transformation de paquets,  Next: Options de construction supplémentaires,  Prev: Options de construction communes,  Up: Invoquer guix build

7.1.2 Options de transformation de paquets
------------------------------------------

Un autre ensemble d’options de la ligne de commande supportés par ‘guix
build’ et aussi ‘guix package’ sont les “options de transformation de
paquets”. Ce sont des options qui rendent possible la définition de
“variantes de paquets” — par exemple, des paquets construit à partir de
sources différentes. C’est une manière simple de créer des paquets
personnalisés à la volée sans avoir à taper les définitions de variantes
de paquets (*note Définition des paquets::).

‘--with-source=SOURCE’
‘--with-source=PAQUET=SOURCE’
‘--with-source=PAQUET@VERSION=SOURCE’
     Utiles SOURCE comme la source de PAQUET, et VERSION comme son
     numéro de version. SOURCE doit être un nom de fichier ou une URL,
     comme pour ‘guix download’ (*note Invoquer guix download::).

     Lorsque PAQUET est omis, la commande utilisera le nom de paquet
     spécifié par la base de SOURCE — p. ex. si SOURCE est
     ‘/src/guix-2.0.10.tar.gz’, le paquet correspondant est ‘guile’.

     De même, lorsque VERSION est omis, la chaîne de version est inférée
     à partir de SOURCE ; dans l’exemple précédent, il s’agit de
     ‘2.0.10’.

     Cette option permet aux utilisateurs d’essayer des version des
     paquets différentes de celles fournies par la distribution.
     L’exemple ci-dessous télécharge ‘ed-1.7.tar.g’ depuis un miroir GNU
     et l’utilise comme source pour le paquet ‘ed’ :

          guix build ed --with-source=mirror://gnu/ed/ed-1.7.tar.gz

     As a developer, ‘--with-source’ makes it easy to test release
     candidates:

          guix build guile --with-source=../guile-2.0.9.219-e1bb7.tar.xz

     ... ou pour construire un dépôt de gestion de version dans un
     environnement vierge :

          $ git clone git://git.sv.gnu.org/guix.git
          $ guix build guix --with-source=guix@1.0=./guix

‘--with-input=PAQUET=REMPLAÇANT’
     Remplace la dépendance sur PAQUET par une dépendance à REMPLAÇANT.
     PAQUET doit être un nom de paquet et REMPLAÇANT doit être une
     spécification de paquet comme ‘guile’ ou ‘guile@1.8’.

     Par exemple, la commande suivante construit Guix, mais remplace sa
     dépendance à la version stable actuelle de Guile par une dépendance
     à une ancienne version de Guile, ‘guile@2.0’ :

          guix build --with-input=guile=guile@2.0 guix

     C’est un remplacement récursif profond. Donc dans cet exemple, à la
     fois ‘guix’ et ses dépendances ‘guile-json’ (qui dépend aussi de
     ‘guile’) sont reconstruits avec ‘guile@2.0’.

     Cette option est implémentée avec la procédure Scheme
     ‘package-input-rewriting’ (*note ‘package-input-rewriting’:
     Définition des paquets.).

‘--with-graft=PAQUET=REMPLAÇANT’
     This is similar to ‘--with-input’ but with an important difference:
     instead of rebuilding the whole dependency chain, REPLACEMENT is
     built and then “grafted” onto the binaries that were initially
     referring to PACKAGE. *Note Mises à jour de sécurité::, for more
     information on grafts.

     Par exemple, la commande ci-dessous greffe la version 3.5.4 de
     GnuTLS sur Wget et toutes ses dépendances, en remplaçant les
     références à la version actuelle de GnuTLS à laquelle ils se
     réfèrent actuellement :

          guix build --with-graft=gnutls=gnutls@3.5.4 wget

     Cela a l’avantage d’être bien plus rapide que de tout reconstruire.
     Mais il y a un piège : cela ne fonctionne que si PAQUET et
     REMPLAÇANT sont strictement compatibles — par exemple, s’ils
     fournissent une bibliothèque, l’interface binaire applicative (ABI)
     de ces bibliothèques doivent être compatibles. Si REMPLAÇANT est
     incompatible avec PAQUET, alors le paquet qui en résulte peut
     devenir inutilisable. À utilisez avec précaution !

‘--with-git-url=PAQUET=URL’
     Construire PAQUET depuis le dernier commit de la branche ‘master’
     du dépôt sur URL. Les sous-modules Git du dépôt sont récupérés,
     récursivement.

     Par exemple, la commande suivante construit la bibliothèque Python
     NumPy avec le dernier commit de la branche master de Python
     lui-même :

          guix build python-numpy \
            --with-git-url=python=https://github.com/python/cpython

     This option can also be combined with ‘--with-branch’ or
     ‘--with-commit’ (see below).

     Évidemment, comme cela utilise le dernier commit d’une branche
     donnée, le résultat d’une telle commande varie avec le temps.
     Néanmoins c’est une manière pratique pour reconstruire des piles
     logicielles entières avec le dernier commit d’un ou plusieurs
     paquets. C’est particulièrement pratique dans le contexte d’une
     intégration continue.

     Les clones sont gardés dans un cache dans ‘~/.cache/guix/checkouts’
     pour accélérer les accès consécutifs au même dépôt. Vous pourriez
     vouloir le nettoyer de temps en temps pour récupérer de l’espace
     disque.

‘--with-branch=PAQUET=BRANCHE’
     Build PACKAGE from the latest commit of BRANCH. If the ‘source’
     field of PACKAGE is an origin with the ‘git-fetch’ method (*note
     Référence des origines::) or a ‘git-checkout’ object, the
     repository URL is taken from that ‘source’. Otherwise you have to
     use ‘--with-git-url’ to specify the URL of the Git repository.

     Par exemple, la commande suivante construit ‘guile-sqlite3’ à
     partir du dernier commit de sa branche ‘master’, puis construit
     ‘guix’ (qui en dépend) et ‘cuirass’ (qui dépend de ‘guix’) avec
     cette construction spécifique de ‘guile-sqlite3’ :

          guix build --with-branch=guile-sqlite3=master cuirass

‘--with-commit=PAQUET=COMMIT’
     This is similar to ‘--with-branch’, except that it builds from
     COMMIT rather than the tip of a branch. COMMIT must be a valid Git
     commit SHA1 identifier or a tag.


File: guix.fr.info,  Node: Options de construction supplémentaires,  Next: Débogage des échecs de construction,  Prev: Options de transformation de paquets,  Up: Invoquer guix build

7.1.3 Options de construction supplémentaires
---------------------------------------------

Les options de la ligne de commande ci-dessous sont spécifiques à ‘guix
build’.

‘--quiet’
‘-q’
     Build quietly, without displaying the build log; this is equivalent
     to ‘--verbosity=0’. Upon completion, the build log is kept in
     ‘/var’ (or similar) and can always be retrieved using the
     ‘--log-file’ option.

‘--file=FICHIER’
‘-f FICHIER’
     Construit le paquet, la dérivation ou l’objet simili-fichier en
     lequel le code dans FILE s’évalue (*note file-like objects:
     G-Expressions.).

     Par exemple, FILE peut contenir une définition de paquet comme ceci
     (*note Définition des paquets::) :

          (use-modules (guix)
                       (guix build-system gnu)
                       (guix licenses))

          (package
            (name "hello")
            (version "2.10")
            (source (origin
                      (method url-fetch)
                      (uri (string-append "mirror://gnu/hello/hello-" version
                                          ".tar.gz"))
                      (sha256
                       (base32
                        "0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i"))))
            (build-system gnu-build-system)
            (synopsis "Hello, GNU world: An example GNU package")
            (description "Guess what GNU Hello prints!")
            (home-page "http://www.gnu.org/software/hello/")
            (license gpl3+))

     The FILE may also contain a JSON representation of one or more
     package definitions. Running ‘guix build -f’ on ‘hello.json’ with
     the following contents would result in building the packages
     ‘myhello’ and ‘greeter’:

          [
            {
              "name": "myhello",
              "version": "2.10",
              "source": "mirror://gnu/hello/hello-2.10.tar.gz",
              "build-system": "gnu",
              "arguments": {
                "tests?": false
              }
              "home-page": "https://www.gnu.org/software/hello/",
              "synopsis": "Hello, GNU world: An example GNU package",
              "description": "GNU Hello prints a greeting.",
              "license": "GPL-3.0+",
              "native-inputs": ["gettext"]
            },
            {
              "name": "greeter",
              "version": "1.0",
              "source": "https://example.com/greeter-1.0.tar.gz",
              "build-system": "gnu",
              "arguments": {
                "test-target": "foo",
                "parallel-build?": false,
              },
              "home-page": "https://example.com/",
              "synopsis": "Greeter using GNU Hello",
              "description": "This is a wrapper around GNU Hello.",
              "license": "GPL-3.0+",
              "inputs": ["myhello", "hello"]
            }
          ]

‘--manifest=MANIFEST’
‘-m MANIFEST’
     Build all packages listed in the given MANIFEST (*note
     ‘--manifest’: profile-manifest.).

‘--expression=EXPR’
‘-e EXPR’
     Construit le paquet ou la dérivation en lequel EXPR s’évalue.

     Par exemple, EXPR peut être ‘(@ (gnu packages guile) guile-1.8)’,
     qui désigne sans ambiguïté cette variante spécifique de la version
     1.8 de Guile.

     Autrement, EXP peut être une G-expression, auquel cas elle est
     utilisée comme un programme de construction passé à
     ‘gexp->derivation’ (*note G-Expressions::).

     Enfin, EXPR peut se référer à une procédure monadique à au moins un
     argument (*note La monade du dépôt::). La procédure doit renvoyer
     une dérivation comme une valeur monadique, qui est ensuite lancée à
     travers ‘run-with-store’.

‘--source’
‘-S’
     Construit les dérivation source des paquets, plutôt que des paquets
     eux-mêmes.

     Par exemple, ‘guix build -S gcc’ renvoie quelque chose comme
     ‘/gnu/store/...-gcc-4.7.2.tar.bz2’, qui est l’archive des sources
     de GCC.

     L’archive des sources renvoyée est le résultat de l’application des
     correctifs et des extraits de code éventuels spécifiés dans le
     champ ‘origin’ du paquet (*note Définition des paquets::).

     Note that ‘guix build -S’ compiles the sources only of the
     specified packages. They do not include the sources of statically
     linked dependencies and by themselves are insufficient for
     reproducing the packages.

‘--sources’
     Fetch and return the source of PACKAGE-OR-DERIVATION and all their
     dependencies, recursively. This is a handy way to obtain a local
     copy of all the source code needed to build PACKAGES, allowing you
     to eventually build them even without network access. It is an
     extension of the ‘--source’ option and can accept one of the
     following optional argument values:

     ‘package’
          This value causes the ‘--sources’ option to behave in the same
          way as the ‘--source’ option.

     ‘all’
          Construit les dérivations des sources de tous les paquets,
          dont les sources qui pourraient être listées dans ‘inputs’.
          C’est la valeur par défaut.

               $ guix build --sources tzdata
               The following derivations will be built:
                  /gnu/store/...-tzdata2015b.tar.gz.drv
                  /gnu/store/...-tzcode2015b.tar.gz.drv

     ‘transitive’
          Construire les dérivations des sources de tous les paquets,
          ainsi que toutes celles des entrées transitives des paquets.
          On peut par exemple utiliser cette option pour précharger les
          sources des paquets pour les construire plus tard hors ligne.

               $ guix build --sources=transitive tzdata
               The following derivations will be built:
                  /gnu/store/...-tzcode2015b.tar.gz.drv
                  /gnu/store/...-findutils-4.4.2.tar.xz.drv
                  /gnu/store/...-grep-2.21.tar.xz.drv
                  /gnu/store/...-coreutils-8.23.tar.xz.drv
                  /gnu/store/...-make-4.1.tar.xz.drv
                  /gnu/store/...-bash-4.3.tar.xz.drv
               ...

‘--system=SYSTÈME’
‘-s SYSTÈME’
     Essayer de construire pour SYSTEM — p. ex. ‘i686-linux’ — au lieu
     du type de système de l’hôte. La commande ‘guix build’ vous permet
     de répéter cette option plusieurs fois, auquel cas elle construit
     pour tous les systèmes spécifiés ; les autres commandes ignorent
     les options ‘-s’ supplémentaires.

          Remarque : The ‘--system’ flag is for _native_ compilation and
          must not be confused with cross-compilation. See ‘--target’
          below for information on cross-compilation.

     An example use of this is on Linux-based systems, which can emulate
     different personalities. For instance, passing
     ‘--system=i686-linux’ on an ‘x86_64-linux’ system or
     ‘--system=armhf-linux’ on an ‘aarch64-linux’ system allows you to
     build packages in a complete 32-bit environment.

          Remarque : La possibilité de construire pour un système
          ‘armhf-linux’ est activé sans condition sur les machines
          ‘aarch64-linux’, bien que certaines puces aarch64 n’en soient
          pas capables, comme les ThunderX.

     De même, lorsque l’émulation transparente avec QEMU et
     ‘binfnmt_misc’ est activée (*note ‘qemu-binfmt-service-type’:
     Services de virtualisation.), vous pouvez construire pour n’importe
     quel système pour lequel un gestionnaire QEMU ‘binfmt_misc’ est
     installé.

     Les constructions pour un autre système que celui de la machine que
     vous utilisez peuvent aussi être déchargées à une machine distante
     de la bonne architecture. *Note Réglages du délestage du démon::,
     pour plus d’information sur le déchargement.

‘--target=TRIPLET’
     Cross-build for TRIPLET, which must be a valid GNU triplet, such as
     ‘"aarch64-linux-gnu"’ (*note GNU configuration triplets:
     (autoconf)Specifying Target Triplets.).

‘--check’
     Reconstruit les PACKAGE-OR-DERIVATION, qui sont déjà disponibles
     dans le dépôt et lève une erreur si les résultats des constructions
     ne sont pas identiques bit-à-bit.

     Ce mécanisme vous permet de vérifier si les substituts précédemment
     installés sont authentiques (*note Substituts::) ou si le résultat
     de la construction d’un paquet est déterministe. *Note Invoquer
     guix challenge:: pour plus d’informations et pour les outils.

     Lorsqu’utilisé avec ‘--keep-failed’, la sortie différente est
     gardée dans le dépôt sous ‘/gnu/store/...-check’. Cela rend plus
     facile l’étude des différences entre les deux résultats.

‘--repair’
     Essaye de réparer les éléments du dépôt spécifiés, s’ils sont
     corrompus, en les téléchargeant ou en les construisant à nouveau.

     Cette opération n’est pas atomique et donc restreinte à
     l’utilisateur ‘root’

‘--derivations’
‘-d’
     Renvoie les chemins de dérivation, et non les chemins de sortie,
     des paquets donnés.

‘--root=FICHIER’
‘-r FICHIER’
     Fait de FICHIER un lien symbolique vers le résultat, et
     l’enregistre en tant que racine du ramasse-miettes.

     En conséquence, les résultats de cette invocation de ‘guix build’
     sont protégés du ramasse-miettes jusqu’à ce que FICHIER soit
     supprimé. Lorsque cette option est omise, les constructions sont
     susceptibles d’être glanées.

‘--log-file’
     Renvoie les noms des journaux de construction ou les URL des
     PACKAGE-OR-DERIVATION donnés ou lève une erreur si les journaux de
     construction sont absents.

     Cela fonctionne indépendamment de la manière dont les paquets ou
     les dérivations sont spécifiées. Par exemple, les invocations
     suivantes sont équivalentes :

          guix build --log-file `guix build -d guile`
          guix build --log-file `guix build guile`
          guix build --log-file guile
          guix build --log-file -e '(@ (gnu packages guile) guile-2.0)'

     If a log is unavailable locally, and unless ‘--no-substitutes’ is
     passed, the command looks for a corresponding log on one of the
     substitute servers (as specified with ‘--substitute-urls’).

     Donc par exemple, imaginons que vous souhaitiez voir le journal de
     construction de GDB sur MIPS, mais que vous n’avez qu’une machine
     ‘x86_64’ :

          $ guix build --log-file gdb -s aarch64-linux
          https://ci.guix.gnu.org/log/...-gdb-7.10

     Vous pouvez accéder librement à un vaste bibliothèque de journaux
     de construction !


File: guix.fr.info,  Node: Débogage des échecs de construction,  Prev: Options de construction supplémentaires,  Up: Invoquer guix build

7.1.4 Débogage des échecs de construction
-----------------------------------------

Lors de la définition d’un nouveau paquet (*note Définition des
paquets::), vous passerez probablement du temps à déboguer et modifier
la construction jusqu’à ce que ça marche. Pour cela, vous devez
effectuer les commandes de construction vous-même dans un environnement
le plus proche possible de celui qu’utilise le démon de construction.

   To that end, the first thing to do is to use the ‘--keep-failed’ or
‘-K’ option of ‘guix build’, which will keep the failed build tree in
‘/tmp’ or whatever directory you specified as ‘TMPDIR’ (*note
‘--keep-failed’: Invoquer guix build.).

   À partir de là, vous pouvez vous déplacer dans l’arborescence de
construction et sourcer le fichier ‘environment-variables’, qui contient
toutes les variables d’environnement qui étaient définies lorsque la
construction a échoué. Disons que vous déboguez un échec de construction
dans le paquet ‘foo’ ; une session typique ressemblerait à cela :

     $ guix build foo -K
     ... build fails
     $ cd /tmp/guix-build-foo.drv-0
     $ source ./environment-variables
     $ cd foo-1.2

   Maintenant, vous pouvez invoquer les commandes comme si vous étiez le
démon (presque) et corriger le processus de construction.

   Parfois il arrive que, par exemple, les tests d’un paquet réussissent
lorsque vous les lancez manuellement mais échouent quand ils sont lancés
par le démon. Cela peut arriver parce que le démon tourne dans un
conteneur où, contrairement à notre environnement au-dessus, l’accès
réseau est indisponible, ‘/bin/sh’ n’existe pas, etc. (*note Réglages de
l'environnement de construction::).

   Dans ce cas, vous pourriez avoir besoin de lancer le processus de
construction dans un conteneur similaire à celui que le démon crée :

     $ guix build -K foo
     ...
     $ cd /tmp/guix-build-foo.drv-0
     $ guix environment --no-grafts -C foo --ad-hoc strace gdb
     [env]# source ./environment-variables
     [env]# cd foo-1.2

   Here, ‘guix environment -C’ creates a container and spawns a new
shell in it (*note Invoquer guix environment::). The ‘--ad-hoc strace
gdb’ part adds the ‘strace’ and ‘gdb’ commands to the container, which
you may find handy while debugging. The ‘--no-grafts’ option makes sure
we get the exact same environment, with ungrafted packages (*note Mises
à jour de sécurité::, for more info on grafts).

   Pour obtenir un conteneur plus proche de ce qui serait utilisé par le
démon de construction, on peut enlever ‘/bin/sh’ :

     [env]# rm /bin/sh

   Ne vous inquiétez pas, c’est sans danger : tout cela se passe dans un
conteneur jetable créé par ‘guix environment’.

   La commande ‘strace’ n’est probablement pas dans le chemin de
recherche, mais on peut lancer :

     [env]# $GUIX_ENVIRONMENT/bin/strace -f -o log make check

   De cette manière, non seulement vous aurez reproduit les variables
d’environnement utilisées par le démon, mais vous lancerez aussi le
processus de construction dans un conteneur similaire à celui utilisé
par le démon.


File: guix.fr.info,  Node: Invoquer guix edit,  Next: Invoquer guix download,  Prev: Invoquer guix build,  Up: Utilitaires

7.2 Invoquer ‘guix edit’
========================

Tant de paquets, tant de fichiers source ! La commande ‘guix edit’
facilite la vie des utilisateurs et des empaqueteurs en plaçant leur
éditeur sur le fichier source qui contient la définition des paquets
spécifiés. Par exemple :

     guix edit gcc@4.9 vim

launches the program specified in the ‘VISUAL’ or in the ‘EDITOR’
environment variable to view the recipe of GCC 4.9.3 and that of Vim.

   If you are using a Guix Git checkout (*note Construire depuis Git::),
or have created your own packages on ‘GUIX_PACKAGE_PATH’ (*note Modules
de paquets::), you will be able to edit the package recipes. In other
cases, you will be able to examine the read-only recipes for packages
currently in the store.

   Instead of ‘GUIX_PACKAGE_PATH’, the command-line option
‘--load-path=DIRECTORY’ (or in short ‘-L DIRECTORY’) allows you to add
DIRECTORY to the front of the package module search path and so make
your own packages visible.


File: guix.fr.info,  Node: Invoquer guix download,  Next: Invoquer guix hash,  Prev: Invoquer guix edit,  Up: Utilitaires

7.3 Invoquer ‘guix download’
============================

Lorsqu’on écrit une définition de paquet, on a généralement besoin de
télécharger une archive des sources, calculer son hash SHA256 et écrire
ce hash dans la définition du paquet (*note Définition des paquets::).
L’outil ‘guix download’ aide à cette tâche : il télécharge un fichier à
l’URL donné, l’ajoute au dépôt et affiche à la fois son nom dans le
dépôt et son hash SHA56.

   Le fait que le fichier téléchargé soit ajouté au dépôt économise la
bande passante : quand on construit ensuite le paquet nouvellement
défini avec ‘guix build’, l’archive des sources n’a pas besoin d’être à
nouveau téléchargée puisqu’elle se trouve déjà dans le dépôt. C’est
aussi une manière pratique de garder des fichiers temporairement, qui
pourront ensuite être supprimés (*note Invoquer guix gc::).

   La commande ‘guix download’ supporte les mêmes URI que celles
utilisées dans les définitions de paquets. En particulier, elle supporte
les URI ‘mirror://’. Les URI ‘http’ (HTTP sur TLS) sont supportées _si_
les liaisons Guile de GnuTLS sont disponibles dans l’environnement de
l’utilisateur ; si elle ne sont pas disponibles, une erreur est
renvoyée. *Note how to install the GnuTLS bindings for Guile:
(gnutls-guile)Guile Preparations, pour plus d’informations.

   ‘guix download’ verifies HTTPS server certificates by loading the
certificates of X.509 authorities from the directory pointed to by the
‘SSL_CERT_DIR’ environment variable (*note Certificats X.509::), unless
‘--no-check-certificate’ is used.

   Les options suivantes sont disponibles :

‘--hash=ALGORITHM’
‘-H ALGORITHM’
     Compute a hash using the specified ALGORITHM. *Note Invoquer guix
     hash::, for more information.

‘--format=FMT’
‘-f FMT’
     Écrit le hash dans le format spécifié par FMT. Pour plus
     d’informations sur les valeurs valides pour FMT, *note Invoquer
     guix hash::.

‘--no-check-certificate’
     Ne pas valider les certificats HTTPS des serveurs.

     Lorsque vous utilisez cette option, vous n’avez _absolument aucune
     garanti_ que vous communiquez avec le serveur authentique
     responsable de l’URL donnée, ce qui vous rend vulnérable à des
     attaques de « l’homme du milieu ».

‘--output=FICHIER’
‘-o FICHIER’
     Enregistre le fichier téléchargé dans FICHIER plutôt que de
     l’ajouter au dépôt.


File: guix.fr.info,  Node: Invoquer guix hash,  Next: Invoquer guix import,  Prev: Invoquer guix download,  Up: Utilitaires

7.4 Invoquer ‘guix hash’
========================

La commande ‘guix hash’ calcul le hash SHA256 d’un fichier. C’est
surtout un outil pour simplifier la vie des contributeurs de la
distribution : il calcul le hash cryptographique d’un fichier, qui peut
être utilisé dans la définition d’un paquet (*note Définition des
paquets::).

   La syntaxe générale est :

     guix hash OPTION FICHIER

   Lorsque FICHIER est ‘-’ (un tiret), ‘guix hash’ calcul le hash des
données lues depuis l’entrée standard. ‘guix hash’ a les options
suivantes :

‘--hash=ALGORITHM’
‘-H ALGORITHM’
     Compute a hash using the specified ALGORITHM, ‘sha256’ by default.

     ALGORITHM must the name of a cryptographic hash algorithm supported
     by Libgcrypt via Guile-Gcrypt—e.g., ‘sha512’ or ‘sha3-256’ (*note
     (guile-gcrypt)Hash Functions::).

‘--format=FMT’
‘-f FMT’
     Écrit le hash dans le format spécifié par FMT.

     Supported formats: ‘base64’, ‘nix-base32’, ‘base32’, ‘base16’
     (‘hex’ and ‘hexadecimal’ can be used as well).

     Si l’option ‘--format’ n’est pas spécifiée, ‘guix hash’ affichera
     le hash en ‘nix-base32’. Cette représentation est utilisée dans les
     définitions des paquets.

‘--recursive’
‘-r’
     Calcule le hash sur FICHIER récursivement.

     Dans ce cas, le hash est calculé sur une archive contenant FICHIER,
     dont ses enfants si c’est un répertoire. Certaines métadonnées de
     FICHIER fait partie de l’archive ; par exemple lorsque FICHIER est
     un fichier normal, le hash est différent que le FICHIER soit
     exécutable ou non. Les métadonnées comme un horodatage n’ont aucun
     impact sur le hash (*note Invoquer guix archive::).

‘--exclude-vcs’
‘-x’
     When combined with ‘--recursive’, exclude version control system
     directories (‘.bzr’, ‘.git’, ‘.hg’, etc.).

     Par exemple, voici comment calculer le hash d’un dépôt Git, ce qui
     est utile avec la méthode ‘git-fetch’ (*note Référence des
     origines::) :

          $ git clone http://example.org/foo.git
          $ cd foo
          $ guix hash -rx .


File: guix.fr.info,  Node: Invoquer guix import,  Next: Invoquer guix refresh,  Prev: Invoquer guix hash,  Up: Utilitaires

7.5 Invoquer ‘guix import’
==========================

La commande ‘guix import’ est utile pour les gens qui voudraient ajouter
un paquet à la distribution avec aussi peu de travail que possible — une
demande légitime. La commande connaît quelques dépôts logiciels d’où
elle peut « importer » des métadonnées de paquets. Le résultat est une
définition de paquet, ou un modèle de définition, dans le format reconnu
par Guix (*note Définition des paquets::).

   La syntaxe générale est :

     guix import IMPORTER OPTIONS...

   IMPORTER specifies the source from which to import package metadata,
and OPTIONS specifies a package identifier and other options specific to
IMPORTER.

   Some of the importers rely on the ability to run the ‘gpgv’ command.
For these, GnuPG must be installed and in ‘$PATH’; run ‘guix install
gnupg’ if needed.

   Currently, the available “importers” are:

‘gnu’
     Importe des métadonnées d’un paquet GNU donné. Cela fournit un
     modèle pour la dernière version de ce paquet GNU, avec le hash de
     son archive, le synopsis et la description canonique.

     Les informations supplémentaires comme les dépendances du paquet et
     sa licence doivent être renseignées manuellement.

     Par exemple, la commande suivante renvoie une définition de paquets
     pour GNU Hello :

          guix import gnu hello

     Les options spécifiques sont :

     ‘--key-download=POLITIQUE’
          As for ‘guix refresh’, specify the policy to handle missing
          OpenPGP keys when verifying the package signature. *Note
          ‘--key-download’: Invoquer guix refresh.

‘pypi’
     Importe des métadonnées depuis l’index des paquets Python
     (https://pypi.python.org/). Les informations sont récupérées à
     partir de la description en JSON disponible sur ‘pypi.python.org’
     et inclus généralement toutes les informations utiles, dont les
     dépendances des paquets. Pour une efficacité maximale, il est
     recommandé d’installer l’utilitaire ‘unzip’, pour que l’importateur
     puisse dézipper les wheels Python et récupérer les informations
     contenues à l’intérieur.

     La commande ci-dessous importe les métadonnées du paquet Python
     ‘itsdangerous’ :

          guix import pypi itsdangerous

     ‘--recursive’
     ‘-r’
          Traverse le graphe des dépendances du paquet amont donné et
          génère les expressions de paquets de tous ceux qui ne sont pas
          déjà dans Guix.

‘gem’
     Importe des métadonnées de RubyGems (https://rubygems.org/). Les
     informations sont récupérées au format JSON disponible sur
     ‘rubygems.org’ et inclut les informations les plus utiles, comme
     les dépendances à l’exécution. Il y a des cependant quelques
     restrictions. Les métadonnées ne distinguent pas synopsis et
     description, donc la même chaîne est utilisée pour les deux champs.
     En plus, les détails des dépendances non Ruby requises pour
     construire des extensions natives sont indisponibles et laissé en
     exercice à l’empaqueteur.

     La commande ci-dessous importe les métadonnées pour le paquet Ruby
     ‘rails’ :

          guix import gem rails

     ‘--recursive’
     ‘-r’
          Traverse le graphe des dépendances du paquet amont donné et
          génère les expressions de paquets de tous ceux qui ne sont pas
          déjà dans Guix.

‘cpan’
     Importe des métadonnées de MetaCPAN (https://www.metacpan.org/).
     Les informations sont récupérées au format JSON disponible à
     travers l’API de MetaCPAN (https://fastapi.metacpan.org/) et inclus
     les informations les plus utiles, comme les dépendances des
     modules. L’information sur les licences doit être vérifiée avec
     attention. Si Perl est disponible dans le dépôt, alors l’utilitaire
     ‘corelist’ sera utiliser pour exclure les modules du cœur de la
     distribution Perl de la liste des dépendances.

     The command command below imports metadata for the Acme::Boolean
     Perl module:

          guix import cpan Acme::Boolean

‘cran’
     Importe des métadonnées de CRAN (https://cran.r-project.org/), le
     dépôt central de l’environnement statistique et graphique GNU R
     (https://r-project.org).

     Information is extracted from the ‘DESCRIPTION’ file of the
     package.

     The command command below imports metadata for the Cairo R package:

          guix import cran Cairo

     When ‘--recursive’ is added, the importer will traverse the
     dependency graph of the given upstream package recursively and
     generate package expressions for all those packages that are not
     yet in Guix.

     When ‘--archive=bioconductor’ is added, metadata is imported from
     Bioconductor (https://www.bioconductor.org/), a repository of R
     packages for for the analysis and comprehension of high-throughput
     genomic data in bioinformatics.

     Information is extracted from the ‘DESCRIPTION’ file contained in
     the package archive.

     The command below imports metadata for the GenomicRanges R package:

          guix import cran --archive=bioconductor GenomicRanges

     Finally, you can also import R packages that have not yet been
     published on CRAN or Bioconductor as long as they are in a git
     repository. Use ‘--archive=git’ followed by the URL of the git
     repository:

          guix import cran --archive=git https://github.com/immunogenomics/harmony

‘texlive’
     Importe les métadonnées de CTAN (https://www.ctan.org/), le réseau
     d’archive TeX complet pour les paquets TeX qui font partie de la
     distribution TeX Live (https://www.tug.org/texlive/).

     Les informations sur les paquets sont obtenues à travers l’API XML
     fournie par CTAN, tandis que le code source est téléchargé depuis
     le dépôt SVN du projet Tex Live. Cette méthode est utilisée parce
     que CTAN ne garde pas d’archives versionnées.

     La commande ci-dessous importe les métadonnées du paquet TeX
     ‘fontspec’ :

          guix import texlive fontspec

     When ‘--archive=DIRECTORY’ is added, the source code is downloaded
     not from the ‘latex’ sub-directory of the ‘texmf-dist/source’ tree
     in the TeX Live SVN repository, but from the specified sibling
     DIRECTORY under the same root.

     La commande ci-dessous importe les métadonnées du paquet ‘ifxetex’
     depuis CTAN en récupérant les sources depuis le répertoire
     ‘texmf/source/generic’ :

          guix import texlive --archive=generic ifxetex

‘json’
     Importe des métadonnées d’un fichier JSON local. Considérez
     l’exemple suivant d’une définition de paquet au format JSON :

          {
            "name": "hello",
            "version": "2.10",
            "source": "mirror://gnu/hello/hello-2.10.tar.gz",
            "build-system": "gnu",
            "home-page": "https://www.gnu.org/software/hello/",
            "synopsis": "Hello, GNU world: An example GNU package",
            "description": "GNU Hello prints a greeting.",
            "license": "GPL-3.0+",
            "native-inputs": ["gettext"]
          }

     Les noms des champs sont les mêmes que pour les enregistrements de
     ‘<package>’ (*Note Définition des paquets::). Les référence à
     d’autres paquets sont fournies comme des listes JSON de chaînes de
     spécifications de paquets comme ‘guile’ ou ‘guile@2.0’.

     L’importateur supporte aussi une définition plus explicite des
     sources avec les champs habituels pour les enregistrements
     ‘<origin>’ :

          {
            ...
            "source": {
              "method": "url-fetch",
              "uri": "mirror://gnu/hello/hello-2.10.tar.gz",
              "sha256": {
                "base32": "0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i"
              }
            }
            ...
          }

     La commande ci-dessous lit les métadonnées du fichier JSON
     ‘hello.json’ et renvoie une expression de paquet :

          guix import json hello.json

‘nix’
     Importe les métadonnées d’une copie locale des source de la
     distribution Nixpkgs (https://nixos.org/nixpkgs/)(1). Les
     définitions de paquets dans Nixpkgs sont habituellement écrites en
     un mélange entre le langage Nix et Bash. Cette commande n’importe
     que la structure de haut-niveau du paquet qui est écrite dans le
     langage Nix. Elle inclut normalement tous les champs de base de la
     définition d’un paquet.

     Lorsque vous importez un paquet GNU, le synopsis et la description
     sont replacés par la version canonique en amont.

     Normalement, vous devrez d’abord faire :

          export NIX_REMOTE=daemon

     pour que ‘nix-instantiate’ n’essaye pas d’ouvrir la base de données
     de Nix.

     Par exemple, la commande ci-dessous importe la définition du paquet
     de LibreOffice (plus précisément, elle importe la définition du
     paquet lié à l’attribut de plus haut-niveau ‘libreoffice’) :

          guix import nix ~/path/to/nixpkgs libreoffice

‘hackage’
     Importe les métadonnées de l’archive de paquets centrale de la
     communauté Haskell, Hackage (https://hackage.haskell.org/). Les
     informations sont récupérées depuis les fichiers Cabal et incluent
     toutes les informations utiles, dont les dépendances des paquets.

     Les options spécifiques sont :

     ‘--stdin’
     ‘-s’
          Lit un fichier Cabal depuis l’entrée standard.
     ‘--no-test-dependencies’
     ‘-t’
          N’inclut pas les dépendances requises uniquement par les
          suites de tests.
     ‘--cabal-environment=ALIST’
     ‘-e ALIST’
          ALIST est une alist Scheme qui définie l’environnement dans
          lequel les conditions de Cabal sont évaluées. Les clefs
          acceptées sont : ‘os’, ‘arch’, ‘impl’ et une représentation
          sous forme de chaîne de caractères du nom d’un drapeau. La
          valeur associée à un drapeau doit être le symbole ‘true’ ou
          ‘false’. La valeur associée aux autres clefs doivent se
          conformer avec la définition du format de fichiers Cabal. La
          valeur par défaut associée avec les clefs ‘os’, ‘arch’ et
          ‘impl’ sont respectivement ‘linux’, ‘x86_64’ et ‘ghc’.
     ‘--recursive’
     ‘-r’
          Traverse le graphe des dépendances du paquet amont donné et
          génère les expressions de paquets de tous ceux qui ne sont pas
          déjà dans Guix.

     The command below imports metadata for the latest version of the
     HTTP Haskell package without including test dependencies and
     specifying the value of the flag ‘network-uri’ as ‘false’:

          guix import hackage -t -e "'((\"network-uri\" . false))" HTTP

     Une version spécifique du paquet peut éventuellement être spécifiée
     en faisant suivre le nom du paquet par un arobase et un numéro de
     version comme dans l’exemple suivant :

          guix import hackage mtl@2.1.3.1

‘stackage’
     L’importateur ‘stackage’ est une enveloppe autour de l’importateur
     ‘hackage’. Il prend un nom de paquet, recherche la version incluse
     dans une version au support étendu (LTS) de Stackage
     (https://www.stackage.org) et utilise l’importateur ‘hackage’ pour
     récupérer les métadonnées. Remarquez que c’est à vous de choisir
     une version LTS compatible avec le compilateur GHC utilisé par
     Guix.

     Les options spécifiques sont :

     ‘--no-test-dependencies’
     ‘-t’
          N’inclut pas les dépendances requises uniquement par les
          suites de tests.
     ‘--lts-version=VERSION’
     ‘-l VERSION’
          VERSION est la version LTS désirée. Si elle est omise, la
          dernière version est utilisée.
     ‘--recursive’
     ‘-r’
          Traverse le graphe des dépendances du paquet amont donné et
          génère les expressions de paquets de tous ceux qui ne sont pas
          déjà dans Guix.

     The command below imports metadata for the HTTP Haskell package
     included in the LTS Stackage release version 7.18:

          guix import stackage --lts-version=7.18 HTTP

‘elpa’
     Importe les métadonnées du dépôt de paquets ELPA (Emacs Lisp
     Package Archive) (*note (emacs)Packages::).

     Les options spécifiques sont :

     ‘--archive=REPO’
     ‘-a REPO’
          REPO identifie le dépôt d’archive depuis lequel récupérer les
          informations. Actuellement les dépôts supportés et leurs
          identifiants sont :
             - GNU (https://elpa.gnu.org/packages), qu’on peut choisir
               avec l’identifiant ‘gnu’. C’est la valeur par défaut.

               Les paquets de ‘elpa.gnu.org’ avec l’une des clefs
               contenues dans le porte-clef GnuPG
               ‘share/emacs/25.1/etc/package-keyring.gpg’ (ou similaire)
               dans le paquet ‘emacs’ (*note ELPA package signatures:
               (emacs)Package Installation.).

             - MELPA-Stable (https://stable.melpa.org/packages), qu’on
               peut sélectionner avec l’identifiant ‘melpa-stable’.

             - MELPA (https://melpa.org/packages), qu’on peut
               sélectionner avec l’identifiant ‘melpa’.

     ‘--recursive’
     ‘-r’
          Traverse le graphe des dépendances du paquet amont donné et
          génère les expressions de paquets de tous ceux qui ne sont pas
          déjà dans Guix.

‘crate’
     Import metadata from the crates.io Rust package repository
     crates.io (https://crates.io), as in this example:

          guix import crate blake2-rfc

     The crate importer also allows you to specify a version string:

          guix import crate constant-time-eq@0.1.0

     Additional options include:

     ‘--recursive’
     ‘-r’
          Traverse le graphe des dépendances du paquet amont donné et
          génère les expressions de paquets de tous ceux qui ne sont pas
          déjà dans Guix.

‘opam’
     Importe les métadonnées du répertoire de paquets OPAM
     (https://opam.ocaml.org/) utilisé par la communauté OCaml.

   La structure du code de ‘guix import’ est modulaire. Il serait utile
d’avoir plus d’importateurs pour d’autres formats de paquets et votre
aide est la bienvenue sur ce sujet (*note Contribuer::).

   ---------- Footnotes ----------

   (1) Cela repose sur la commande ‘nix-instantiate’ de Nix
(https://nixos.org/nix/).


File: guix.fr.info,  Node: Invoquer guix refresh,  Next: Invoquer guix lint,  Prev: Invoquer guix import,  Up: Utilitaires

7.6 Invoquer ‘guix refresh’
===========================

La commande ‘guix refresh’ s’adresse avant tout aux personnes qui
développent la distribution logicielle GNU. Par défaut, elle rapporte
les paquets fournis par la distribution qui sont en retard par rapport
aux dernières versions disponibles en amont, comme ceci :

     $ guix refresh
     gnu/packages/gettext.scm:29:13: gettext serait mis à jour de 0.18.1.1 à 0.18.2.1
     gnu/packages/glib.scm:77:12: glib serait mis à jour de 2.34.3 à 2.37.0

   Alternatively, one can specify packages to consider, in which case a
warning is emitted for packages that lack an updater:

     $ guix refresh coreutils guile guile-ssh
     gnu/packages/ssh.scm:205:2 : avertissement : aucun gestionnaire de mise à jour pour guile-ssh
     gnu/packages/guile.scm:136:12 : guile serait mis à jour de 2.0.12 à 2.0.13

   ‘guix refresh’ navigue le dépôt amont de chaque paquet et détermine
le numéro de version le plus élevé parmi les versions publiées. La
commande sait comment mettre à jour certains types de paquets : les
paquets GNU, les paquets ELPA, etc. — voir la documentation pour
‘--type’ ci-dessous. Il y a beaucoup de paquet cependant pour lesquels
il manque une méthode pour déterminer si une nouvelle version est
disponible en amont. Cependant, le mécanisme est extensible, alors
n’hésitez pas à nous contacter pour ajouter une nouvelle méthode !

‘--recursive’
     Considère les paquets spécifiés et tous les paquets dont ils
     dépendent.

          $ guix refresh --recursive coreutils
          gnu/packages/acl.scm:35:2: warning: no updater for acl
          gnu/packages/m4.scm:30:12: info: 1.4.18 is already the latest version of m4
          gnu/packages/xml.scm:68:2: warning: no updater for expat
          gnu/packages/multiprecision.scm:40:12: info: 6.1.2 is already the latest version of gmp
          ...

   Parfois les noms en amont diffèrent du nom de paquet utilisé par Guix
et ‘guix refresh’ a besoin d’un peu d’aide. La plupart des gestionnaires
de mise à jour honorent la propriété ‘upstream-name’ dans les
définitions de paquets, ce qui peut être utilisé à cette fin :

     (define-public network-manager
       (package
         (name "network-manager")
         ;; ...
         (properties '((upstream-name . "NetworkManager")))))

   When passed ‘--update’, it modifies distribution source files to
update the version numbers and source tarball hashes of those package
recipes (*note Définition des paquets::). This is achieved by
downloading each package’s latest source tarball and its associated
OpenPGP signature, authenticating the downloaded tarball against its
signature using ‘gpgv’, and finally computing its hash—note that GnuPG
must be installed and in ‘$PATH’; run ‘guix install gnupg’ if needed.

   When the public key used to sign the tarball is missing from the
user’s keyring, an attempt is made to automatically retrieve it from a
public key server; when this is successful, the key is added to the
user’s keyring; otherwise, ‘guix refresh’ reports an error.

   Les options suivantes sont supportées :

‘--expression=EXPR’
‘-e EXPR’
     Considérer le paquet évalué par EXPR.

     C’est utile pour précisément se référer à un paquet, comme dans cet
     exemple :

          guix refresh -l -e '(@@ (gnu packages commencement) glibc-final)'

     This command lists the dependents of the “final” libc (essentially
     all the packages).

‘--update’
‘-u’
     Met à jour les fichiers source de la distribution (les recettes de
     paquets) en place. Cette option est généralement utilisée depuis
     une copie du dépôt git de Guix (*note Lancer Guix avant qu'il ne
     soit installé::) :

          $ ./pre-inst-env guix refresh -s non-core -u

     *Note Définition des paquets::, pour plus d’information sur les
     définitions des paquets.

‘--select=[SUBSET]’
‘-s SUBSET’
     Choisi tous les paquets dans SUBSET, entre ‘core’ et ‘non-core’.

     Le sous-ensemble ‘core’ se réfère à tous les paquets du cœur de la
     distribution — c.-à-d. les paquets qui sont utilisés pour
     construire « tout le reste ». Cela comprend GCC, libc, Binutils,
     Bash, etc. Habituellement, changer l’un de ces paquets dans la
     distribution implique de reconstruire tous les autres. Ainsi, ces
     mises à jour sont une nuisance pour les utilisateurs, en terme de
     temps de compilation et de bande passante utilisés pour effectuer
     la mise à jour.

     Le sous-ensemble ‘non-core’ se réfère au reste des paquets. C’est
     habituellement utile dans les cas où une mise à jour des paquets du
     cœur serait dérangeante.

‘--manifest=FICHIER’
‘-m FICHIER’
     Choisi tous les paquets du manifeste dans FILE. C’est utile pour
     vérifier qu’aucun des paquets du manifeste utilisateur ne peut être
     mis à jour.

‘--type=UPDATER’
‘-t UPDATER’
     Chois uniquement les paquets pris en charge par UPDATER
     (éventuellement une liste de gestionnaires de mise à jour séparés
     par des virgules). Actuellement, UPDATER peut être l’une des
     valeurs suivantes :

     ‘gnu’
          le gestionnaire de mise à jour pour les paquets GNU ;
     ‘gnome’
          le gestionnaire de mise à jour pour les paquets GNOME ;
     ‘kde’
          le gestionnaire de mise à jour pour les paquets KDE ;
     ‘xorg’
          le gestionnaire de mise à jour pour les paquets X.org ;
     ‘kernel.org’
          le gestionnaire de mise à jour pour les paquets hébergés sur
          kernel.org ;
     ‘elpa’
          le gestionnaire de mise à jour pour les paquets ELPA
          (https://elpa.gnu.org/) ;
     ‘cran’
          le gestionnaire de mise à jour pour les paquets CRAN
          (https://cran.r-project.org/) ;
     ‘bioconductor’
          le gestionnaire de mise à jour pour les paquets Bioconductor
          (https://www.bioconductor.org/) ;
     ‘cpan’
          le gestionnaire de mise à jour pour les paquets CPAN
          (https://www.cpan.org/) ;
     ‘pypi’
          le gestionnaire de mise à jour pour les paquets PyPI
          (https://pypi.python.org) ;
     ‘gem’
          le gestionnaire de mise à jour pour les paquets RubyGems
          (https://rubygems.org) ;
     ‘github’
          le gestionnaire de mise à jour pour les paquets GitHub
          (https://github.com) ;
     ‘hackage’
          le gestionnaire de mise à jour pour les paquets Hackage
          (https://hackage.haskell.org) ;
     ‘stackage’
          le gestionnaire de mise à jour pour les paquets Stackage
          (https://www.stackage.org) ;
     ‘crate’
          le gestionnaire de mise à jour pour les paquets Crates
          (https://crates.io) ;
     ‘launchpad’
          le gestionnaire de mise à jour pour les paquets Launchpad
          (https://launchpad.net)

     Par exemple, la commande suivante ne vérifie que les mises à jour
     des paquets Emacs hébergés sur ‘elpa.gnu.org’ et les paquets CRAN :

          $ guix refresh --type=elpa,cran
          gnu/packages/statistics.scm:819:13 : r-testthat serait mis à jour de 0.10.0 à 0.11.0
          gnu/packages/emacs.scm:856:13 : emacs-auctex serait mis à jour de 11.88.6 à 11.88.9

   En plus, on peut passer à ‘guix refresh’ un ou plusieurs noms de
paquets, comme dans cet exemple :

     $ ./pre-inst-env guix refresh -u emacs idutils gcc@4.8

The command above specifically updates the ‘emacs’ and ‘idutils’
packages. The ‘--select’ option would have no effect in this case.

   Pour déterminer s’il faut mettre à jour un paquet, il est parfois
pratique de savoir quels paquets seraient affectés par la mise à jour
pour pouvoir vérifier la compatibilité. Pour cela l’option suivante peut
être utilisée avec un ou plusieurs noms de paquets passés à ‘guix
refresh’ :

‘--list-updaters’
‘-L’
     List available updaters and exit (see ‘--type’ above).

     Pour chaque gestionnaire, affiche le pourcentage de paquets qu’il
     couvre ; à la fin, affiche le pourcentage de paquets couverts par
     tous les gestionnaires.

‘--list-dependent’
‘-l’
     Liste les paquets de plus haut-niveau qui devraient être
     reconstruits après la mise à jour d’un ou plusieurs paquets.

     *Note le type ‘reverse-package’ de ‘guix graph’: Invoquer guix
     graph, pour des informations sur la manière de visualiser la liste
     des paquets dépendant d’un autre.

   Be aware that the ‘--list-dependent’ option only _approximates_ the
rebuilds that would be required as a result of an upgrade. More rebuilds
might be required under some circumstances.

     $ guix refresh --list-dependent flex
     Building the following 120 packages would ensure 213 dependent packages are rebuilt:
     hop@2.4.0 geiser@0.4 notmuch@0.18 mu@0.9.9.5 cflow@1.4 idutils@4.6 ...

   La commande ci-dessus liste un ensemble de paquets qui peuvent être
construits pour vérifier la compatibilité d’une mise à jour de ‘flex’.

‘--list-transitive’
     Lister tous les paquets dont un paquet ou plus dépendent.

          $ guix refresh --list-transitive flex
          flex@2.6.4 depends on the following 25 packages: perl@5.28.0 help2man@1.47.6
          bison@3.0.5 indent@2.2.10 tar@1.30 gzip@1.9 bzip2@1.0.6 xz@5.2.4 file@5.33 ...

   La commande ci-dessus liste un ensemble de paquets qui, lorsqu’ils
sont modifiés, causent la reconstruction de ‘flex’.

   Les options suivante peuvent être utilisées pour personnaliser les
opérations avec GnuPG :

‘--gpg=COMMANDE’
     Utilise COMMANDE comme la commande de GnuPG 2.x. COMMANDE est
     recherchée dans ‘PATH’.

‘--keyring=FICHIER’
     Utilise FICHIER comme porte-clefs pour les clefs amont. FICHIER
     doit être dans le “format keybox”. Les fichiers Keybox ont
     d’habitude un nom qui fini par ‘.kbx’ et GNU Privacy Guard (GPG)
     peut manipuler ces fichiers (*note ‘kbxutil’: (gnupg)kbxutil, pour
     plus d’informations sur un outil pour manipuler des fichiers
     keybox).

     When this option is omitted, ‘guix refresh’ uses
     ‘~/.config/guix/upstream/trustedkeys.kbx’ as the keyring for
     upstream signing keys. OpenPGP signatures are checked against keys
     from this keyring; missing keys are downloaded to this keyring as
     well (see ‘--key-download’ below).

     Vous pouvez exporter les clefs de votre porte-clefs GPG par défaut
     dans un fichier keybox avec une commande telle que :

          gpg --export rms@gnu.org | kbxutil --import-openpgp >> mykeyring.kbx

     De même, vous pouvez récupérer des clefs dans un fichier keybox
     spécifique comme ceci :

          gpg --no-default-keyring --keyring mykeyring.kbx \
            --recv-keys 3CE464558A84FDC69DB40CFB090B11993D9AEBB5

     *note ‘--keyring’: (gnupg)GPG Configuration Options. pour plus
     d’informations sur l’option ‘--keyring’ de GPG.

‘--key-download=POLITIQUE’
     Gère les clefs OpenPGP manquantes d’après la POLITIQUE, qui peut
     être l’une des suivantes :

     ‘always’
          Toujours télécharger les clefs manquantes depuis un serveur de
          clefs et les ajouter au porte-clefs de l’utilisateur.

     ‘never’
          Ne jamais essayer de télécharger les clefs OpenPGP manquante.
          Quitter à la place.

     ‘interactive’
          Lorsqu’on rencontre un paquet signé par une clef OpenPGP
          inconnue, demander à l’utilisateur s’il souhaite la
          télécharger ou non. C’est le comportement par défaut.

‘--key-server=HOST’
     Utiliser HOST comme serveur de clefs OpenPGP lors de l’importe
     d’une clef publique.

‘--load-path=RÉPERTOIRE’
     Ajoute RÉPERTOIRE au début du chemin de recherche de module de
     paquets (*note Modules de paquets::).

     Cela permet à des utilisateurs de définir leur propres paquets et
     les rendre disponibles aux outils en ligne de commande.

   The ‘github’ updater uses the GitHub API
(https://developer.github.com/v3/) to query for new releases. When used
repeatedly e.g. when refreshing all packages, GitHub will eventually
refuse to answer any further API requests. By default 60 API requests
per hour are allowed, and a full refresh on all GitHub packages in Guix
requires more than this. Authentication with GitHub through the use of
an API token alleviates these limits. To use an API token, set the
environment variable ‘GUIX_GITHUB_TOKEN’ to a token procured from
<https://github.com/settings/tokens> or otherwise.


File: guix.fr.info,  Node: Invoquer guix lint,  Next: Invoquer guix size,  Prev: Invoquer guix refresh,  Up: Utilitaires

7.7 Invoquer ‘guix lint’
========================

The ‘guix lint’ command is meant to help package developers avoid common
errors and use a consistent style. It runs a number of checks on a given
set of packages in order to find common mistakes in their definitions.
Available “checkers” include (see ‘--list-checkers’ for a complete
list):

‘synopsis’
‘description’
     Vérifie certaines règles typographiques et stylistiques dans les
     descriptions et les synopsis.

‘inputs-should-be-native’
     Identifie les entrées qui devraient sans doute plutôt être des
     entrées natives.

‘source’
‘home-page’
‘mirror-url’
‘github-url’
‘source-file-name’
     Sonde les URL ‘home-page’ et ‘source’ et rapporte celles qui sont
     invalides. Suggère une URL en ‘mirror://’ lorsque c’est possible.
     Si l’URL de ‘source’ redirige vers une URL GitHub, recommande
     d’utiliser l’URL GitHub. Vérifie que le nom du fichier source a un
     sens, p. ex. qu’il ne s’agisse pas juste d’un numéro de version ou
     « git-checkout », sans avoir déclaré un ‘file-name’ (*note
     Référence des origines::).

‘source-unstable-tarball’
     Analyse l’URL ‘source’ pour déterminer si une archive de GitHub est
     autogénérée ou s’il s’agit d’une archive de publication.
     Malheureusement les archives autogénérées de GitHub sont parfois
     régénérées.

‘archival’
     Checks whether the package’s source code is archived at Software
     Heritage (https://www.softwareheritage.org).

     When the source code that is not archived comes from a
     version-control system (VCS)—e.g., it’s obtained with ‘git-fetch’,
     send Software Heritage a “save” request so that it eventually
     archives it. This ensures that the source will remain available in
     the long term, and that Guix can fall back to Software Heritage
     should the source code disappear from its original host. The status
     of recent “save” requests can be viewed on-line
     (https://archive.softwareheritage.org/save/#requests).

     When source code is a tarball obtained with ‘url-fetch’, simply
     print a message when it is not archived. As of this writing,
     Software Heritage does not allow requests to save arbitrary
     tarballs; we are working on ways to ensure that non-VCS source code
     is also archived.

     Software Heritage limits the request rate per IP address
     (https://archive.softwareheritage.org/api/#rate-limiting). When the
     limit is reached, ‘guix lint’ prints a message and the ‘archival’
     checker stops doing anything until that limit has been reset.

‘cve’
     Report known vulnerabilities found in the Common Vulnerabilities
     and Exposures (CVE) databases of the current and past year
     published by the US NIST (https://nvd.nist.gov/vuln/data-feeds).

     Pour voir les informations sur une vulnérabilité en particulier,
     visitez les pages :

        • 
          ‘https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-ANNÉE-ABCD’
        • 
          ‘https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-ANNÉE-ABCD’

     où ‘CVE-ANNÉE-ABCD’ est l’identifiant CVE — p. ex. ‘CVE-2015-7554’.

     Package developers can specify in package recipes the Common
     Platform Enumeration (CPE) (https://nvd.nist.gov/products/cpe) name
     and version of the package when they differ from the name or
     version that Guix uses, as in this example:

          (package
            (name "grub")
            ;; ...
            ;; CPE calls this package "grub2".
            (properties '((cpe-name . "grub2")
                          (cpe-version . "2.3"))))

     Certaines entrées dans la base de données CVE ne spécifient pas la
     version du paquet auquel elles s’appliquent et lui restera donc
     attachée pour toujours. Les développeur·euse·s qui trouvent des
     alertes CVE et ont vérifié qu’elles peuvent être ignorées peuvent
     les déclarer comme dans cet exemple :

          (package
            (name "t1lib")
            ;; ...
            ;; Ces CVE ne s'appliquent plus et peuvent être ignorée sans problème.
            (properties `((lint-hidden-cve . ("CVE-2011-0433"
                                              "CVE-2011-1553"
                                              "CVE-2011-1554"
                                              "CVE-2011-5244")))))

‘formatting’
     Avertit de problèmes de formatage du code source évidents : des
     espaces en fin de ligne, des tabulations, etc.

   La syntaxe générale est :

     guix lint OPTIONS PACKAGE...

   Si aucun paquet n’est donné par la ligne de commande, tous les
paquets seront vérifiés. Les OPTIONS peuvent contenir aucune ou plus des
options suivantes :

‘--list-checkers’
‘-l’
     Liste et décrit tous les vérificateurs disponibles qui seront
     lancés sur les paquets puis quitte.

‘--checkers’
‘-c’
     Only enable the checkers specified in a comma-separated list using
     the names returned by ‘--list-checkers’.

‘--load-path=RÉPERTOIRE’
‘-L RÉPERTOIRE’
     Ajoute RÉPERTOIRE au début du chemin de recherche de module de
     paquets (*note Modules de paquets::).

     Cela permet à des utilisateurs de définir leur propres paquets et
     les rendre disponibles aux outils en ligne de commande.


File: guix.fr.info,  Node: Invoquer guix size,  Next: Invoquer guix graph,  Prev: Invoquer guix lint,  Up: Utilitaires

7.8 Invoquer ‘guix size’
========================

La commande ‘guix size’ aide à dresser un profil de l’utilisation de
l’espace disque par les paquets. Il est facile de négliger l’impact
d’une dépendance supplémentaire ajoutée à un paquet, ou l’impact de
l’utilisation d’une sortie unique pour un paquet qui pourrait être
facilement séparé (*note Des paquets avec plusieurs résultats::). Ce
sont ces problèmes que ‘guix size’ peut typiquement mettre en valeur.

   On peut passer un ou plusieurs spécifications de paquets à la
commande, comme ‘gcc@4.8’ ou ‘guile:debug’, ou un nom de fichier dans le
dépôt. Regardez cet exemple :

     $ guix size coreutils
     store item                               total    self
     /gnu/store/...-gcc-5.5.0-lib           60.4    30.1  38.1%
     /gnu/store/...-glibc-2.27              30.3    28.8  36.6%
     /gnu/store/...-coreutils-8.28          78.9    15.0  19.0%
     /gnu/store/...-gmp-6.1.2               63.1     2.7   3.4%
     /gnu/store/...-bash-static-4.4.12       1.5     1.5   1.9%
     /gnu/store/...-acl-2.2.52              61.1     0.4   0.5%
     /gnu/store/...-attr-2.4.47             60.6     0.2   0.3%
     /gnu/store/...-libcap-2.25             60.5     0.2   0.2%
     total: 78.9 MiB

   Les éléments du dépôt listés ici constituent la “clôture transitive”
de Coreutils — c.-à-d. Coreutils et toutes ses dépendances,
récursivement — comme ce qui serait renvoyé par :

     $ guix gc -R /gnu/store/...-coreutils-8.23

   Ici, la sortie possède trois colonnes à côté de chaque élément du
dépôt. La première colonne, nommée « total », montre la taille en
mébioctet (Mio) de la clôture de l’élément du dépôt — c’est-à-dire sa
propre taille plus la taille de ses dépendances. La colonne suivante,
nommée « lui-même », montre la taille de l’élément lui-même. La dernière
colonne montre le ration de la taille de l’élément lui-même par rapport
à celle de tous les éléments montrés.

   Dans cet exemple, on voit que la clôture de Coreutils pèse 79 Mio,
dont la plupart est dû à la libc et aux bibliothèques à l’exécution de
GCC (ce n’est pas un problème en soit que la libc et les bibliothèques
de GCC représentent une grande part de la clôture parce qu’elles sont
toujours disponibles sur le système de toute façon).

   Lorsque les paquets passés à ‘guix size’ sont disponibles dans le
dépôt(1), ‘guix size’ demande au démon de déterminer ses dépendances, et
mesure sa taille dans le dépôt, comme avec ‘du -ms --apparent-size’
(*note (coreutils)du invocation::).

   Lorsque les paquets donnés ne sont _pas_ dans le dépôt, ‘guix size’
rapporte les informations en se basant sur les substituts disponibles
(*note Substituts::). Cela permet de profiler l’utilisation du disque
des éléments du dépôt même s’ils ne sont pas sur le disque, mais
disponibles à distance.

   Vous pouvez aussi spécifier plusieurs noms de paquets :

     $ guix size coreutils grep sed bash
     store item                               total    self
     /gnu/store/...-coreutils-8.24          77.8    13.8  13.4%
     /gnu/store/...-grep-2.22               73.1     0.8   0.8%
     /gnu/store/...-bash-4.3.42             72.3     4.7   4.6%
     /gnu/store/...-readline-6.3            67.6     1.2   1.2%
     ...
     total: 102.3 MiB

Dans cet exemple on voit que la combinaison des quatre paquets prend
102.3 Mio en tout, ce qui est bien moins que la somme des clôtures
puisqu’ils ont beaucoup de dépendances en commun.

   When looking at the profile returned by ‘guix size’, you may find
yourself wondering why a given package shows up in the profile at all.
To understand it, you can use ‘guix graph --path -t references’ to
display the shortest path between the two packages (*note Invoquer guix
graph::).

   Les options disponibles sont :

‘--substitute-urls=URLS’
     Utilise les informations de substituts de URLS. *Note the same
     option for ‘guix build’: client-substitute-urls.

‘--sort=CLEF’
     Trie les lignes en fonction de la CLEF, l’une des options suivantes
     :

     ‘self’
          la taille de chaque élément (par défaut) ;
     ‘closure’
          la taille totale de la clôture de l’élément.

‘--map-file=FICHIER’
     Écrit un schéma de l’utilisation du disque au format PNG dans
     FICHIER.

     Pour l’exemple au-dessus, le schéma ressemble à ceci :

 [image src="images/coreutils-size-map.png" alt="schéma de l'utilisation du disque de
Coreutils produit par guix size" ]

     Cette option requiert l’installation de Guile-Charting
     (https://wingolog.org/software/guile-charting/) et qu’il soit
     visible dans le chemin de recherche des modules Guile. Lorsque ce
     n’est pas le cas, ‘guix size’ plante en essayant de le charger.

‘--system=SYSTÈME’
‘-s SYSTÈME’
     Considère les paquets pour SYSTÈME — p. ex. ‘x86_64-linux’.

‘--load-path=RÉPERTOIRE’
‘-L RÉPERTOIRE’
     Ajoute RÉPERTOIRE au début du chemin de recherche de module de
     paquets (*note Modules de paquets::).

     Cela permet à des utilisateurs de définir leur propres paquets et
     les rendre disponibles aux outils en ligne de commande.

   ---------- Footnotes ----------

   (1) Plus précisément, ‘guix size’ cherche les variantes _non
greffées_ des paquets donnés, tels qu’ils sont renvoyés par ‘guix build
PAQUET --no-graft’. *Note Mises à jour de sécurité:: pour des
informations sur les greffes


File: guix.fr.info,  Node: Invoquer guix graph,  Next: Invoquer guix publish,  Prev: Invoquer guix size,  Up: Utilitaires

7.9 Invoque ‘guix graph’
========================

Packages and their dependencies form a “graph”, specifically a directed
acyclic graph (DAG). It can quickly become difficult to have a mental
model of the package DAG, so the ‘guix graph’ command provides a visual
representation of the DAG. By default, ‘guix graph’ emits a DAG
representation in the input format of Graphviz
(https://www.graphviz.org/), so its output can be passed directly to the
‘dot’ command of Graphviz. It can also emit an HTML page with embedded
JavaScript code to display a “chord diagram” in a Web browser, using the
d3.js (https://d3js.org/) library, or emit Cypher queries to construct a
graph in a graph database supporting the openCypher
(https://www.opencypher.org/) query language. With ‘--path’, it simply
displays the shortest path between two packages. The general syntax is:

     guix graph OPTIONS PAQUET...

   Par exemple, la commande suivante génère un fichier PDF représentant
le DAG du paquet pour GNU Core Utilities, qui montre ses dépendances à
la compilation :

     guix graph coreutils | dot -Tpdf > dag.pdf

   La sortie ressemble à ceci :

[Graphe de dépendance de GNU Coreutils]
   Joli petit graphe, non ?

   You may find it more pleasant to navigate the graph interactively
with ‘xdot’ (from the ‘xdot’ package):

     guix graph coreutils | xdot -

   Mais il y a plus qu’un seul graphe ! Celui au-dessus est concis :
c’est le graphe des objets paquets, en omettant les entrées implicites
comme GCC, libc, grep, etc. Il est souvent utile d’avoir ces graphes
concis, mais parfois on veut voir plus de détails. ‘guix graph’ supporte
plusieurs types de graphes, qui vous permettent de choisir le niveau de
détails :

‘package’
     C’est le type par défaut utilisé dans l’exemple plus haut. Il
     montre le DAG des objets paquets, sans les dépendances implicites.
     C’est concis, mais omet pas mal de détails.

‘reverse-package’
     Cela montre le DAG _inversé_ des paquets. Par exemple :

          guix graph --type=reverse-package ocaml

     ... yields the graph of packages that _explicitly_ depend on OCaml
     (if you are also interested in cases where OCaml is an implicit
     dependency, see ‘reverse-bag’ below).

     Remarquez que pour les paquets du cœur de la distribution, cela
     crée des graphes énormes. Si vous voulez seulement voir le nombre
     de paquets qui dépendent d’un paquet donnés, utilisez ‘guix refresh
     --list-dependent’ (*note ‘--list-dependent’: Invoquer guix
     refresh.).

‘bag-emerged’
     C’est le DAG du paquet, _avec_ les entrées implicites.

     Par exemple, la commande suivante :

          guix graph --type=bag-emerged coreutils

     … montre ce graphe plus gros :

[Graphe des dépendances détaillé de
GNU Coreutils]
     En bas du graphe, on voit toutes les entrées implicites de
     GNU-BUILD-SYSTEM (*note ‘gnu-build-system’: Systèmes de
     construction.).

     Maintenant, remarquez que les dépendances de ces entrées implicites
     — c’est-à-dire les “dépendances de bootstrap” (*note
     Bootstrapping::) — ne sont pas affichées, pour rester concis.

‘bag’
     Comme ‘bag-emerged’ mais cette fois inclus toutes les dépendances
     de bootstrap.

‘bag-with-origins’
     Comme ‘bag’, mais montre aussi les origines et leurs dépendances.

‘reverse-bag’
     Cela montre le DAG _inverse_ des paquets. Contrairement à
     ‘reverse-package’, il montre aussi les dépendance implicites. Par
     exemple :

          guix graph -t reverse-bag dune

     … crée le graphe des tous les paquets qui dépendent de Dune,
     directement ou indirectement. Comme Dune est une dépendance
     _implicite_ de nombreux paquets via ‘dune-build-system’, cela
     montre un plus grand nombre de paquets, alors que ‘reverse-package’
     en montrerait très peu, voir aucun.

‘dérivation’
     C’est la représentation lu plus détaillée : elle montre le DAG des
     dérivations (*note Dérivations::) et des éléments du dépôt. Comparé
     à la représentation ci-dessus, beaucoup plus de nœuds sont
     visibles, dont les scripts de construction, les correctifs, les
     modules Guile, etc.

     Pour ce type de graphe, il est aussi possible de passer un nom de
     fichier ‘.drv’ à la place d’un nom de paquet, comme dans :

          guix graph -t derivation `guix system build -d my-config.scm`

‘module’
     C’est le graphe des “modules de paquets” (*note Modules de
     paquets::). Par exemple, la commande suivante montre le graphe des
     modules de paquets qui définissent le paquet ‘guile’ :

          guix graph -t module guile | xdot -

   Tous les types ci-dessus correspondent aux _dépendances à la
construction_. Le type de graphe suivant représente les _dépendances à
l’exécution_ :

‘references’
     C’est le graphe des “references” d’une sortie d’un paquet, telles
     que renvoyées par ‘guix gc --references’ (*note Invoquer guix
     gc::).

     Si la sortie du paquet donnée n’est pas disponible dans le dépôt,
     ‘guix graph’ essayera d’obtenir les informations sur les
     dépendances à travers les substituts.

     Vous pouvez aussi passer un nom de fichier du dépôt plutôt qu’un
     nom de paquet. Par exemple, la commande ci-dessous produit le
     graphe des références de votre profile (qui peut être gros !) :

          guix graph -t references `readlink -f ~/.guix-profile`

‘referrers’
     C’est le graphe des “référents” d’un élément du dépôt, tels que
     renvoyés par ‘guix gc --referrers’ (*note Invoquer guix gc::).

     Cela repose exclusivement sur les informations de votre dépôt. Par
     exemple, supposons que Inkscape est actuellement disponible dans 10
     profils sur votre machine ; ‘guix graph -t referrers inkscape’
     montrera le graphe dont la racine est Inkscape avec 10 profils qui
     y sont liés.

     Cela peut aider à déterminer ce qui empêche un élément du dépôt
     d’être glané.

   Often, the graph of the package you are interested in does not fit on
your screen, and anyway all you want to know is _why_ that package
actually depends on some seemingly unrelated package. The ‘--path’
option instructs ‘guix graph’ to display the shortest path between two
packages (or derivations, or store items, etc.):

     $ guix graph --path emacs libunistring
     emacs@26.3
     mailutils@3.9
     libunistring@0.9.10
     $ guix graph --path -t derivation emacs libunistring
     /gnu/store/...-emacs-26.3.drv
     /gnu/store/...-mailutils-3.9.drv
     /gnu/store/...-libunistring-0.9.10.drv
     $ guix graph --path -t references emacs libunistring
     /gnu/store/...-emacs-26.3
     /gnu/store/...-libidn2-2.2.0
     /gnu/store/...-libunistring-0.9.10

   Les options disponibles sont les suivante :

‘--type=TYPE’
‘-t TYPE’
     Produit un graphe en sortie de type TYPE où TYPE doit être l’un des
     types au-dessus.

‘--list-types’
     Liste les types de graphes supportés.

‘--backend=MOTEUR’
‘-b MOTEUR’
     Produit un graphe avec le MOTEUR choisi.

‘--list-backends’
     Liste les moteurs de graphes supportés.

     Actuellement les moteurs disponibles sont Graphviz et d3.js.

‘--path’
     Display the shortest path between two nodes of the type specified
     by ‘--type’. The example below shows the shortest path between
     ‘libreoffice’ and ‘llvm’ according to the references of
     ‘libreoffice’:

          $ guix graph --path -t references libreoffice llvm
          /gnu/store/...-libreoffice-6.4.2.2
          /gnu/store/...-libepoxy-1.5.4
          /gnu/store/...-mesa-19.3.4
          /gnu/store/...-llvm-9.0.1

‘--expression=EXPR’
‘-e EXPR’
     Considérer le paquet évalué par EXPR.

     C’est utile pour précisément se référer à un paquet, comme dans cet
     exemple :

          guix graph -e '(@@ (gnu packages commencement) gnu-make-final)'

‘--system=SYSTÈME’
‘-s SYSTÈME’
     Affiche le graphe pour SYSTÈME — p. ex. ‘i686-linux’.

     Le graphe de dépendance des paquets est la plupart du temps
     indépendant de l’architecture, mais il y a quelques parties qui
     dépendent de l’architecture que cette option vous permet de
     visualiser.

‘--load-path=RÉPERTOIRE’
‘-L RÉPERTOIRE’
     Ajoute RÉPERTOIRE au début du chemin de recherche de module de
     paquets (*note Modules de paquets::).

     Cela permet à des utilisateurs de définir leur propres paquets et
     les rendre disponibles aux outils en ligne de commande.

   On top of that, ‘guix graph’ supports all the usual package
transformation options (*note Options de transformation de paquets::).
This makes it easy to view the effect of a graph-rewriting
transformation such as ‘--with-input’. For example, the command below
outputs the graph of ‘git’ once ‘openssl’ has been replaced by
‘libressl’ everywhere in the graph:

     guix graph git --with-input=openssl=libressl

   So many possibilities, so much fun!


File: guix.fr.info,  Node: Invoquer guix publish,  Next: Invoquer guix challenge,  Prev: Invoquer guix graph,  Up: Utilitaires

7.10 Invoquer ‘guix publish’
============================

Le but de ‘guix publish’ est de vous permettre de partager facilement
votre dépôt avec d’autres personnes qui peuvent ensuite l’utiliser comme
serveur de substituts (*note Substituts::).

   When ‘guix publish’ runs, it spawns an HTTP server which allows
anyone with network access to obtain substitutes from it. This means
that any machine running Guix can also act as if it were a build farm,
since the HTTP interface is compatible with Cuirass, the software behind
the ‘ci.guix.gnu.org’ build farm.

   For security, each substitute is signed, allowing recipients to check
their authenticity and integrity (*note Substituts::). Because ‘guix
publish’ uses the signing key of the system, which is only readable by
the system administrator, it must be started as root; the ‘--user’
option makes it drop root privileges early on.

   La pair de clefs pour les signatures doit être générée avant de
lancer ‘guix publish’, avec ‘guix archive --generate-key’ (*note
Invoquer guix archive::).

   La syntaxe générale est :

     guix publish OPTIONS...

   Lancer ‘guix publish’ sans arguments supplémentaires lancera un
serveur HTTP sur le port 8080 :

     guix publish

   Une fois qu’un serveur de publication a été autorisé (*note Invoquer
guix archive::), le démon peut télécharger des substituts à partir de
lui :

     guix-daemon --substitute-urls=http://example.org:8080

   Par défaut, ‘guix publish’ compresse les archives à la volée quand il
les sert. Ce mode « à la volée » est pratique puisqu’il ne demande
aucune configuration et est disponible immédiatement. Cependant,
lorsqu’il s’agit de servir beaucoup de clients, nous recommandons
d’utiliser l’option ‘--cache’, qui active le cache des archives avant de
les envoyer aux clients — voir les détails plus bas. La commande ‘guix
weather’ fournit un manière pratique de vérifier ce qu’un serveur
fournit (*note Invoquer guix weather::).

   En bonus, ‘guix publish’ sert aussi un miroir adressé par le contenu
des fichiers source référencées dans les enregistrements ‘origin’ (*note
Référence des origines::). Par exemple, en supposant que ‘guix publish’
tourne sur ‘example.org’, l’URL suivante renverra le fichier brut
‘hello-2.10.tar.gz’ avec le hash SHA256 donné (représenté sous le format
‘nix-base32’, *note Invoquer guix hash::) :

     http://example.org/file/hello-2.10.tar.gz/sha256/0ssi1...ndq1i

   Évidemment, ces URL ne fonctionnent que pour des fichiers dans le
dépôt ; dans les autres cas, elles renvoie une erreur 404 (« Introuvable
»).

   Les journaux de construction sont disponibles à partir des URL ‘/log’
comme ceci :

     http://example.org/log/gwspk...-guile-2.2.3

When ‘guix-daemon’ is configured to save compressed build logs, as is
the case by default (*note Invoquer guix-daemon::), ‘/log’ URLs return
the compressed log as-is, with an appropriate ‘Content-Type’ and/or
‘Content-Encoding’ header. We recommend running ‘guix-daemon’ with
‘--log-compression=gzip’ since Web browsers can automatically decompress
it, which is not the case with Bzip2 compression.

   Les options suivantes sont disponibles :

‘--port=PORT’
‘-p PORT’
     Écoute les requêtes HTTP sur le PORT

‘--listen=HÔTE’
     Écoute sur l’interface réseau de HÔTE. Par défaut, la commande
     accepte les connexions de n’importe quelle interface.

‘--user=UTILISATEUR’
‘-u UTILISATEUR’
     Charge les privilèges de UTILISATEUR le plus vite possible —
     c.-à-d. une fois que la socket du serveur est ouverte et que la
     clef de signature a été lue.

‘--compression[=METHOD[:LEVEL]]’
‘-C [METHOD[:LEVEL]]’
     Compress data using the given METHOD and LEVEL. METHOD is one of
     ‘lzip’ and ‘gzip’; when METHOD is omitted, ‘gzip’ is used.

     When LEVEL is zero, disable compression. The range 1 to 9
     corresponds to different compression levels: 1 is the fastest, and
     9 is the best (CPU-intensive). The default is 3.

     Usually, ‘lzip’ compresses noticeably better than ‘gzip’ for a
     small increase in CPU usage; see benchmarks on the lzip Web page
     (https://nongnu.org/lzip/lzip_benchmark.html).

     À moins que ‘--cache’ ne soit utilisé, la compression se fait à la
     volée et les flux compressés ne sont pas cachés. Ainsi, pour
     réduire la charge sur la machine qui fait tourner ‘guix publish’,
     c’est une bonne idée de choisir un niveau de compression faible, de
     lancer ‘guix publish’ derrière un serveur de cache ou d’utiliser
     ‘--cache’. Utilise ‘--cache’ a l’avantage qu’il permet à ‘guix
     publish’ d’ajouter l’en-tête HTTP ‘Content-Length’ à sa réponse.

     This option can be repeated, in which case every substitute gets
     compressed using all the selected methods, and all of them are
     advertised. This is useful when users may not support all the
     compression methods: they can select the one they support.

‘--cache=RÉPERTOIRE’
‘-c RÉPERTOIRE’
     Cache les archives et les métadonnées (les URL ‘.narinfo’) dans
     RÉPERTOIRE et ne sert que les archives dans ce cache.

     Lorsque cette option est omise, les archives et les métadonnées
     sont crées à la volée. Cela réduit la bande passante disponible,
     surtout quand la compression est activée puisqu’elle pourrait être
     limitée par le CPU. Un autre inconvénient au mode par défaut est
     que la taille des archives n’est pas connue à l’avance, donc ‘guix
     publish’ n’ajoute pas l’en-tête ‘Content-Length’ à ses réponses, ce
     qui empêche les clients de savoir la quantité de données à
     télécharger.

     À l’inverse, lorsque ‘--cache’ est utilisée, la première requête
     pour un élément du dépôt (via une URL ‘.narinfo’) renvoie une
     erreur 404 et déclenche la création de l’archive — en calculant son
     ‘.narinfo’ et en compressant l’archive au besoin. Une fois
     l’archive cachée dans RÉPERTOIRE, les requêtes suivantes
     réussissent et sont servies directement depuis le cache, ce qui
     garanti que les clients ont la meilleure bande passante possible.

     Le processus de création est effectué par des threads de travail.
     Par défaut, un thread par cœur du CPU est créé, mais cela peut être
     personnalisé. Voir ‘--workers’ plus bas.

     Lorsque l’option ‘--ttl’ est utilisée, les entrées cachées sont
     automatiquement supprimées lorsqu’elles expirent.

‘--workers=N’
     Lorsque ‘--cache’ est utilisée, demande l’allocation de N thread de
     travail pour créer les archives.

‘--ttl=TTL’
     Produit des en-têtes HTTP ‘Cache-Control’ qui expriment une durée
     de vie (TTL) de TTL. TTL peut dénoter une durée : ‘5d’ signifie 5
     jours, ‘1m’ signifie un mois, etc.

     Cela permet au Guix de l’utilisateur de garder les informations en
     cache pendant TTL. Cependant, remarquez que ‘guix publish’ ne
     garanti pas lui-même que les éléments du dépôt qu’il fournit seront
     toujours disponible pendant la durée TTL.

     En plus, lorsque ‘--cache’ est utilisée, les entrées cachées qui
     n’ont pas été demandé depuis TTL et n’ont pas d’élément
     correspondant dans le dépôt peuvent être supprimées.

‘--nar-path=CHEMIN’
     Utilise CHEMIN comme préfixe des URL de fichier « nar » (*note
     normalized archives: Invoquer guix archive.).

     Par défaut, les nars sont présents à l’URL comme
     ‘/nar/gzip/...-coreutils-8.25’. Cette option vous permet de changer
     la partie ‘/nar’ en CHEMIN.

‘--public-key=FICHIER’
‘--private-key=FICHIER’
     Utilise les FICHIERs spécifiques comme pair de clefs utilisées pour
     signer les éléments avant de les publier.

     Les fichiers doivent correspondre à la même pair de clefs (la clef
     privée est utilisée pour signer et la clef publique est seulement
     ajouté aux métadonnées de la signature). Ils doivent contenir les
     clefs dans le format s-expression canonique produit par ‘guix
     archive --generate-key’ (*note Invoquer guix archive::). Par
     défaut, ‘/etc/guix/signing-key.pub’ et ‘/etc/guix/signing-key.sec’
     sont utilisés.

‘--repl[=PORT]’
‘-r [PORT]’
     Crée un serveur REPL Guile (*note (guile)REPL Servers::) sur PPORT
     (37146 par défaut). C’est surtout utile pour déboguer un serveur
     ‘guix publish’ qui tourne.

   Activer ‘guix publish’ sur un système Guix est vraiment une seule
ligne : instanciez simplement un service ‘guix-publish-service-type’
dans le champs ‘services’ de votre déclaration ‘operating-system’ (*note
‘guix-publish-service-type’: guix-publish-service-type.).

   If you are instead running Guix on a “foreign distro”, follow these
instructions:

   • Si votre distro hôte utilise le système d’init systemd :

          # ln -s ~root/.guix-profile/lib/systemd/system/guix-publish.service \
                  /etc/systemd/system/
          # systemctl start guix-publish && systemctl enable guix-publish

   • Si votre distribution hôte utilise le système d’initialisation
     Upstart :

          # ln -s ~root/.guix-profile/lib/upstart/system/guix-publish.conf /etc/init/
          # start guix-publish

   • Sinon, procédez de manière similaire avec votre système d’init de
     votre distro.


File: guix.fr.info,  Node: Invoquer guix challenge,  Next: Invoquer guix copy,  Prev: Invoquer guix publish,  Up: Utilitaires

7.11 Invoquer ‘guix challenge’
==============================

Est-ce que les binaires fournis par ce serveur correspondent réellement
au code source qu’il dit avoir construit ? Est-ce que le processus de
construction d’un paquet est déterministe ? Ce sont les question
auxquelles la commande ‘guix challenge’ essaye de répondre.

   La première question est évidemment importante : avant d’utiliser un
serveur de substituts (*note Substituts::), il vaut mieux _vérifier_
qu’il fournit les bons binaires et donc le _défier_. La deuxième est ce
qui permet la première : si les constructions des paquets sont
déterministes alors des constructions indépendantes du paquet devraient
donner le même résultat, bit à bit ; si un serveur fournit un binaire
différent de celui obtenu localement, il peut être soit corrompu, soit
malveillant.

   On sait que le hash qui apparaît dans ‘/gnu/store’ est le hash de
toutes les entrées du processus qui construit le fichier ou le
répertoire — les compilateurs, les bibliothèques, les scripts de
construction, etc. (*note Introduction::). En supposant que les
processus de construction sont déterministes, un nom de fichier dans le
dépôt devrait correspondre exactement à une sortie de construction.
‘guix challenge’ vérifie si il y a bien effectivement une seule
correspondance en comparant les sorties de plusieurs constructions
indépendantes d’un élément du dépôt donné.

   La sortie de la commande ressemble à :

     $ guix challenge --substitute-urls="https://ci.guix.gnu.org https://guix.example.org"
     updating list of substitutes from 'https://ci.guix.gnu.org'... 100.0%
     updating list of substitutes from 'https://guix.example.org'... 100.0%
     /gnu/store/...-openssl-1.0.2d contents differ:
       local hash: 0725l22r5jnzazaacncwsvp9kgf42266ayyp814v7djxs7nk963q
       https://ci.guix.gnu.org/nar/...-openssl-1.0.2d: 0725l22r5jnzazaacncwsvp9kgf42266ayyp814v7djxs7nk963q
       https://guix.example.org/nar/...-openssl-1.0.2d: 1zy4fmaaqcnjrzzajkdn3f5gmjk754b43qkq47llbyak9z0qjyim
       differing files:
         /lib/libcrypto.so.1.1
         /lib/libssl.so.1.1

     /gnu/store/...-git-2.5.0 contents differ:
       local hash: 00p3bmryhjxrhpn2gxs2fy0a15lnip05l97205pgbk5ra395hyha
       https://ci.guix.gnu.org/nar/...-git-2.5.0: 069nb85bv4d4a6slrwjdy8v1cn4cwspm3kdbmyb81d6zckj3nq9f
       https://guix.example.org/nar/...-git-2.5.0: 0mdqa9w1p6cmli6976v4wi0sw9r4p5prkj7lzfd1877wk11c9c73
       differing file:
         /libexec/git-core/git-fsck

     /gnu/store/...-pius-2.1.1 contents differ:
       local hash: 0k4v3m9z1zp8xzzizb7d8kjj72f9172xv078sq4wl73vnq9ig3ax
       https://ci.guix.gnu.org/nar/...-pius-2.1.1: 0k4v3m9z1zp8xzzizb7d8kjj72f9172xv078sq4wl73vnq9ig3ax
       https://guix.example.org/nar/...-pius-2.1.1: 1cy25x1a4fzq5rk0pmvc8xhwyffnqz95h2bpvqsz2mpvlbccy0gs
       differing file:
         /share/man/man1/pius.1.gz

     ...

     6,406 éléments du dépôt ont été analysés :
       - 4,749 (74.1%) étaient identiques
       - 525 (8.2%) étaient différents
       - 1,132 (17.7%) étaient impossibles à évaluer

Dans cet exemple, ‘guix challenge’ scanne d’abord le dépôt pour
déterminer l’ensemble des dérivations construites localement — en
opposition aux éléments qui ont été téléchargées depuis un serveur de
substituts — puis demande leur avis à tous les serveurs de substituts.
Il rapporte ensuite les éléments du dépôt pour lesquels les serveurs ont
obtenu un résultat différent de la construction locale.

   Dans l’exemple, ‘guix.example.org’ obtient toujours une réponse
différente. Inversement, ‘ci.guix.gnu.org’ est d’accord avec les
constructions locale, sauf dans le cas de Git. Cela peut indiquer que le
processus de construction de Git est non-déterministe, ce qui signifie
que sa sortie diffère en fonction de divers choses que Guix ne contrôle
pas parfaitement, malgré l’isolation des constructions (*note
Fonctionnalités::). Les sources les plus communes de non-déterminisme
comprennent l’ajout d’horodatage dans les résultats des constructions,
l’inclusion de nombres aléatoires et des listes de fichiers ordonnés par
numéro d’inœud. Voir <https://reproducible-builds.org/docs/>, pour plus
d’informations.

   To find out what is wrong with this Git binary, the easiest approach
is to run:

     guix challenge git \
       --diff=diffoscope \
       --substitute-urls="https://ci.guix.gnu.org https://guix.example.org"

   This automatically invokes ‘diffoscope’, which displays detailed
information about files that differ.

   Alternatively, we can do something along these lines (*note Invoquer
guix archive::):

     $ wget -q -O - https://ci.guix.gnu.org/nar/lzip/...-git-2.5.0 \
        | lzip -d | guix archive -x /tmp/git
     $ diff -ur --no-dereference /gnu/store/...-git.2.5.0 /tmp/git

   Cette commande montre les différences entre les fichiers qui
résultent de la construction locale et des fichiers qui résultent de la
construction sur ‘ci.guix.gnu.org’ (*note Comparing and Merging Files:
(diffutils)Overview.). La commande ‘diff’ fonctionne bien avec des
fichiers texte. Lorsque des fichiers binaires diffèrent cependant,
Diffoscope (https://diffoscope.org/) est une meilleure option. C’est un
outil qui aide à visualiser les différences entre toute sorte de
fichiers.

   Une fois que vous avez fait ce travail, vous pourrez dire si les
différences sont dues au non-déterminisme du processus de construction
ou à la malhonnêteté du serveur. Nous avons fait beaucoup d’effort pour
éliminer les sources de non-déterminisme dans les paquets pour rendre
plus facile la vérification des substituts, mais bien sûr, c’est un
processus qui n’implique pas que Guix, mais une grande partie de la
communauté des logiciels libres. Pendant ce temps, ‘guix challenge’ est
un outil pour aider à corriger le problème.

   Si vous écrivez un paquet pour Guix, nous vous encourageons à
vérifier si ‘ci.guix.gnu.org’ et d’autres serveurs de substituts
obtiennent le même résultat que vous avec :

     $ guix challenge PAQUET

où PAQUET est une spécification de paquet comme ‘guile@2.0’ ou
‘glibc:debug’.

   La syntaxe générale est :

     guix challenge OPTIONS [PAQUETS...]

   When a difference is found between the hash of a locally-built item
and that of a server-provided substitute, or among substitutes provided
by different servers, the command displays it as in the example above
and its exit code is 2 (other non-zero exit codes denote other kinds of
errors).

   L’option qui compte est :

‘--substitute-urls=URLS’
     Considère URLS comme la liste des URL des sources de substituts
     séparés par des espaces avec lesquels comparer les paquets locaux.

‘--diff=MODE’
     Upon mismatches, show differences according to MODE, one of:

     ‘simple’ (the default)
          Show the list of files that differ.

     ‘diffoscope’
     COMMAND
          Invoke Diffoscope (https://diffoscope.org/), passing it two
          directories whose contents do not match.

          When COMMAND is an absolute file name, run COMMAND instead of
          Diffoscope.

     ‘none’
          Do not show further details about the differences.

     Thus, unless ‘--diff=none’ is passed, ‘guix challenge’ downloads
     the store items from the given substitute servers so that it can
     compare them.

‘--verbose’
‘-v’
     Montre des détails sur les correspondances (contenu identique) en
     plus des informations sur différences.


File: guix.fr.info,  Node: Invoquer guix copy,  Next: Invoquer guix container,  Prev: Invoquer guix challenge,  Up: Utilitaires

7.12 Invoquer ‘guix copy’
=========================

La commande ‘guix copy’ copie des éléments du dépôt d’une machine vers
le dépôt d’une autre machine à travers une connexion SSH(1). Par
exemple, la commande suivante copie le paquet ‘coreutils’, le profil
utilisateur et toutes leurs dépendances sur HÔTE, en tant qu’utilisateur
UTILISATEUR :

     guix copy --to=UTILISATEUR@HÔTE \
               coreutils `readlink -f ~/.guix-profile`

   Si certains éléments à copier sont déjà présents sur HÔTE, ils ne
sont pas envoyés.

   La commande ci-dessous récupère ‘libreoffice’ et ‘gimp’ depuis HÔTE,
en supposant qu’ils y sont présents :

     guix copy --from=HÔTE libreoffice gimp

   La connexion SSH est établie avec le client Guile-SSH, qui set
compatible avec OpenSSH : il honore ‘~/.ssh/known_hosts’ et
‘~/.ssh/config’ et utilise l’agent SSH pour l’authentification.

   La clef utilisée pour signer les éléments qui sont envoyés doit être
acceptée par la machine distante. De même, la clef utilisée pour la
machine distante depuis laquelle vous récupérez des éléments doit être
dans ‘/etc/guix/acl’ pour qu’ils soient acceptés par votre propre démon.
*Note Invoquer guix archive::, pour plus d’informations sur
l’authentification des éléments du dépôt.

   La syntaxe générale est :

     guix copy [--to=SPEC|--from=SPEC] ITEMS...

   Vous devez toujours spécifier l’une des options suivantes :

‘--to=SPEC’
‘--from=SPEC’
     Spécifie l’hôte où envoyer ou d’où recevoir les éléments. SPEC doit
     être une spécification SSH comme ‘example.org’,
     ‘charlie@example.org’ ou ‘charlie@example.org:2222’.

   L’option ITEMS peut être des noms de paquets, comme ‘gimp’ ou des
éléments du dépôt comme ‘/gnu/store/...-idutils-4.6’.

   Lorsque vous spécifiez le nom d’un paquet à envoyer, il est d’abord
construit au besoin, sauf si l’option ‘--dry-run’ est spécifiée. Les
options de construction communes sont supportées (*note Options de
construction communes::).

   ---------- Footnotes ----------

   (1) Cette commande n’est disponible que si Guile-SSH est trouvé.
*Note Prérequis::, pour des détails


File: guix.fr.info,  Node: Invoquer guix container,  Next: Invoquer guix weather,  Prev: Invoquer guix copy,  Up: Utilitaires

7.13 Invoquer ‘guix container’
==============================

     Remarque : À la version 1.0.1.17089-7e269, cet outil est toujours
     expérimental. L’interface est sujette à changement radicaux dans le
     futur.

   Le but de ‘guix container’ est de manipuler des processus qui
tournent dans un environnement séparé, connus sous le nom de « conteneur
», typiquement créés par les commandes ‘guix environment’ (*note
Invoquer guix environment::) et ‘guix system container’ (*note Invoquer
guix system::).

   La syntaxe générale est :

     guix container ACTION OPTIONS...

   ACTION spécifie les opérations à effectuer avec un conteneur, et
OPTIONS spécifie les arguments spécifiques au contexte pour l’action.

   Les actions suivantes sont disponibles :

‘exec’
     Exécute une commande dans le contexte d’un conteneur lancé.

     La syntaxe est :

          guix container exec PID PROGRAMME ARGUMENTS...

     PID spécifie le PID du conteneur lancé. PROGRAMME spécifie le nom
     du fichier exécutable dans le système de fichiers racine du
     conteneur. ARGUMENTS sont les options supplémentaires à passer à
     PROGRAMME.

     La commande suivante lance un shell de connexion interactif dans un
     conteneur Guix System, démarré par ‘guix system container’ et dont
     le PID est 9001 :

          guix container exec 9001 /run/current-system/profile/bin/bash --login

     Remarquez que PID ne peut pas être le processus parent d’un
     conteneur. Ce doit être le PID 1 du conteneur ou l’un de ses
     processus fils.


File: guix.fr.info,  Node: Invoquer guix weather,  Next: Invoquer guix processes,  Prev: Invoquer guix container,  Up: Utilitaires

7.14 Invoquer ‘guix weather’
============================

Vous pouvez parfois grogner lorsque les substituts ne sont pas
disponibles et que vous devez construire les paquets vous-même (*note
Substituts::). La commande ‘guix weather’ rapporte la disponibilité des
substituts sur les serveurs spécifiés pour que vous sachiez si vous
allez raller aujourd’hui. Cela peut parfois être une information utile
pour les utilisateurs, mais elle est surtout utile pour les personnes
qui font tourner ‘guix publish’ (*note Invoquer guix publish::).

   Voici un exemple :

     $ guix weather --substitute-urls=https://guix.example.org
     calcul de 5,872 dérivations de paquets pour x86_64-linux…
     recherche de 6,128 éléments du dépôt sur https://guix.example.org…
     mise à jour de la liste des substituts depuis 'https://guix.example.org'... 100.0%
     https://guix.example.org
       43.4% substituts disponibles (2,658 sur 6,128)
       7,032.5 Mo de fichiers nar (compressés)
       19,824.2 Mo sur le disque (décompressés)
       0.030 secondes par requêtes (182.9 secondes au total)
       33.5 requêtes par seconde

       9.8% (342 sur 3,470) des éléments manquants sont dans la queue
       867 constructions dans la queue
           x86_64-linux : 518 (59.7%)
           i686-linux : 221 (25.5%)
           aarch64-linux : 128 (14.8%)
       vitesse de construction : 23.41 constructions par heure
           x86_64-linux : 11.16 constructions par heure
           i686-linux : 6.03 constructions par heure
           aarch64-linux : 6.41 constructions par heure

   Comme vous pouvez le voir, elle rapporte le pourcentage des paquets
pour lesquels des substituts sont disponibles sur le serveur —
indépendamment du fait que les substituts soient activés, et
indépendamment du fait que la clef de signature du serveur soit
autorisée. Elle rapporte aussi la taille des archives compressées («
nars ») fournies par le serveur, la taille des éléments du dépôt
correspondant dans le dépôt (en supposant que la déduplication soit
désactivée) et la vitesse du serveur. La deuxième partie donne des
statistiques sur l’intégration continue (CI), si le serveur le supporte.
En plus, avec l’option ‘--coverage’, ‘guix weather’ peut lister les
substituts de paquets « importants » qui font défaut sur le serveur
(voir plus bas).

   Pour cela, ‘guix weather’ récupère par HTTP(S) les métadonnées
(“narinfos” de tous les éléments du dépôts pertinents. Comme ‘guix
challenge’, il ignore les signatures de ces substituts, ce qui n’est pas
dangereux puisque la commande ne fait que récupérer des statistiques et
n’installe pas ces substituts.

   La syntaxe générale est :

     guix weather OPTIONS... [PACKAGES...]

   When PACKAGES is omitted, ‘guix weather’ checks the availability of
substitutes for _all_ the packages, or for those specified with
‘--manifest’; otherwise it only considers the specified packages. It is
also possible to query specific system types with ‘--system’. ‘guix
weather’ exits with a non-zero code when the fraction of available
substitutes is below 100%.

   The available options are listed below.

‘--substitute-urls=URLS’
     URLS est la liste des URL des serveurs de substituts séparés par
     des espaces. Lorsque cette option n’est pas renseignée, l’ensemble
     des serveurs de substituts par défaut est utilisé.

‘--system=SYSTÈME’
‘-s SYSTÈME’
     Effectue des requêtes pour les substituts SYSTÈME — p. ex.
     ‘aarch64-linux’. Cette option peut être répétée, auquel cas ‘guix
     weather’ demandera les substituts de plusieurs types de systèmes.

‘--manifest=FICHIER’
     Plutôt que de demander des substituts pour tous les paquets,
     demande uniquement les paquets spécifiés dans FICHIER. FICHIER doit
     contenir un “manifeste” comme avec l’option ‘-m’ de ‘guix package’
     (*note Invoquer guix package::).

     This option can be repeated several times, in which case the
     manifests are concatenated.

‘--coverage[=COUNT]’
‘-c [COUNT]’
     Rapporte la couverture des substituts pour les paquets : liste les
     paquets avec au moins COUNT autres paquets qui en dépendent (zéro
     par défaut) pour lesquels il n’y a pas de substitut. Les paquets
     qui en dépendent ne sont pas listés : si B dépend de A et que A n’a
     pas de substitut, seul A est listé, même si B n’a habituellement
     pas de substitut non plus. Le résultat ressemble à cela :

          $ guix weather --substitute-urls=https://ci.guix.gnu.org -c 10
          calcul de 8 983 dérivations de paquets pour x86_64-linux…
          recherche de 9 343 éléments du dépôt sur https://ci.guix.gnu.org…
          mise à jour des substituts depuis « https://ci.guix.gnu.org »… 100,0 %
          https://ci.guix.gnu.org
            64.7 % des substituts sont disponibles (6,047 sur 9,343)
          ...
          2502 paquets ne sont pas sur « https://ci.guix.gnu.org » pour « x86_64-linux », parmi lesquels :
              58  kcoreaddons@5.49.0      /gnu/store/...-kcoreaddons-5.49.0
              46  qgpgme@1.11.1           /gnu/store/...-qgpgme-1.11.1
              37  perl-http-cookiejar@0.008  /gnu/store/...-perl-http-cookiejar-0.008
              ...

     Ce que montre cet exemple est que ‘kcoreaddons’ et probablement les
     58 paquets qui en dépendent n’ont pas de substituts sur
     ‘ci.guix.fr.info’ ; de même pour ‘qgpgme’ et les 46 paquets qui en
     dépendent.

     Si vous êtes un développeur de Guix, ou si vous prenez soin de
     cette ferme de construction, vous voudrez sans doute inspecter plus
     finement ces paquets : ils peuvent simplement avoir échoué à la
     construction.

‘--display-missing’
     Display the list of store items for which substitutes are missing.


File: guix.fr.info,  Node: Invoquer guix processes,  Prev: Invoquer guix weather,  Up: Utilitaires

7.15 Invoquer ‘guix processes’
==============================

La commande ‘guix processes’ peut être utile pour les développeur·euse·s
ou les personnes qui administrent des systèmes, surtout sur des machines
multi-utilisateur·rice et sur les fermes de construction : elle liste
les sessions actuelles (les connexions au démon), ainsi que des
informations sur les processus en question(1). Voici un exemple des
informations qu’elle renvoie :

     $ sudo guix processes
     SessionPID: 19002
     ClientPID: 19090
     ClientCommand: guix environment --ad-hoc python

     SessionPID: 19402
     ClientPID: 19367
     ClientCommand: guix publish -u guix-publish -p 3000 -C 9 ...

     SessionPID: 19444
     ClientPID: 19419
     ClientCommand: cuirass --cache-directory /var/cache/cuirass ...
     LockHeld: /gnu/store/...-perl-ipc-cmd-0.96.lock
     LockHeld: /gnu/store/...-python-six-bootstrap-1.11.0.lock
     LockHeld: /gnu/store/...-libjpeg-turbo-2.0.0.lock
     ChildProcess: 20495: guix offload x86_64-linux 7200 1 28800
     ChildProcess: 27733: guix offload x86_64-linux 7200 1 28800
     ChildProcess: 27793: guix offload x86_64-linux 7200 1 28800

   Dans cet exemple, on voit que ‘guix-daemon’ a trois clients directs :
‘guix environment’, ‘guix publish’ et l’outil d’intégration continue
Cuirass ; leur identifiant de processus (PID) est donné par le champ
‘ClientPID’. Le champ ‘SessionPID’ fournit le PID du sous-processus
‘guix-daemon’ de cette session particulière.

   The ‘LockHeld’ fields show which store items are currently locked by
this session, which corresponds to store items being built or
substituted (the ‘LockHeld’ field is not displayed when ‘guix processes’
is not running as root). Last, by looking at the ‘ChildProcess’ field,
we understand that these three builds are being offloaded (*note
Réglages du délestage du démon::).

   La sortie est dans le format Recutils pour qu’on puisse utiliser la
commande ‘recsel’ pour sélectionner les sessions qui nous intéressent
(*note (recutils)Selection Expressions::). Par exemple, la commande
montre la ligne de commande et le PID du client qui effectue la
construction d’un paquet Perl :

     $ sudo guix processes | \
         recsel -p ClientPID,ClientCommand -e 'LockHeld ~ "perl"'
     ClientPID: 19419
     ClientCommand: cuirass --cache-directory /var/cache/cuirass ...

   ---------- Footnotes ----------

   (1) Les sessions distantes, lorsque ‘guix-daemon’ est démarré avec
‘--listen’ en spécifiant un point d’entrée TCP, ne sont _pas_ listées.


File: guix.fr.info,  Node: Configuration système,  Next: Documentation,  Prev: Utilitaires,  Up: Top

8 Configuration système
***********************

Guix System utilise un mécanisme de configuration du système cohérent.
On veut dire par là que tous les aspects de la configuration globale du
système — comme la disponibilité des services système, la configuration
des fuseaux horaires, des paramètres linguistiques et des comptes
utilisateurs — sont déclarés à un seul endroit. Une telle “configuration
système” peut être “instanciée”, c’est-à-dire entrer en vigueur.

   L’un des avantages de placer toute la configuration du système sous
le contrôle de Guix est de permettre les mises à jour transactionnelles
du système ce qui rend possible le fait de revenir en arrière à une
instanciation précédent du système, si quelque chose se passait mal avec
le nouveau (*note Fonctionnalités::). Un autre avantage est de rendre
facile la réplication de la même configuration sur plusieurs machines
différentes ou à différents moments dans le temps, sans avoir à recourir
à des outils d’administrations supplémentaires au-dessus des outils du
système.

   Cette section décrit ce mécanisme. Tout d’abord nous nous concentrons
sur le point de vue de l’administrateur système en expliquant comment le
système est configuré et instancié. Ensuite nous montrons comment ce
mécanisme peut être étendu, par exemple pour supporter de nouveaux
services systèmes.

* Menu:

* Utiliser le système de configuration::  Personnaliser votre système
                                             GNU.
* Référence de système d'exploitation::  Détail sur la déclaration de
                                              système d’exploitation.
* Systèmes de fichiers::    Configurer les montages de systèmes de
                               fichiers.
* Périphériques mappés::  Gestion des périphériques de bloc.
* Comptes utilisateurs::     Spécifier des comptes utilisateurs.
* Disposition du clavier::   La manière dont le système interprète les
                               touches du clavier.
* Régionalisation::         Paramétrer la langue et les conventions
                               culturelles.
* Services::                 Spécifier les services du système.
* Programmes setuid::        Programmes tournant avec les privilèges root.
* Certificats X.509::        Authentifier les serveurs HTTPS.
* Name Service Switch::      Configurer le « name service switch » de la
                               libc.
* Disque de RAM initial::    Démarrage de Linux-Libre.
* Configuration du chargeur d'amorçage::  Configurer le chargeur
                                             d’amorçage.
* Invoquer guix system::     Instantier une configuration du système.
* Invoking guix deploy::     Deploying a system configuration to a remote
                               host.
* Lancer Guix dans une VM::  Comment lancer Guix dans une machine virtuelle.
* Définir des services::    Ajouter de nouvelles définitions de services.


File: guix.fr.info,  Node: Utiliser le système de configuration,  Next: Référence de système d'exploitation,  Up: Configuration système

8.1 Utiliser le système de configuration
========================================

Le système d’exploitation est configuré en fournissant une déclaration
‘operating-system’ dans un fichier qui peut être passé à la command
‘guix system’ (*note Invoquer guix system::). Une configuration simple,
avec les services systèmes par défaut, le noyau Linux-Libre par défaut,
un disque de RAM initial et un chargeur d’amorçage ressemble à ceci :

     ;; This is an operating system configuration template
     ;; for a "bare bones" setup, with no X11 display server.

     (use-modules (gnu))
     (use-service-modules networking ssh)
     (use-package-modules screen)

     (operating-system
       (host-name "komputilo")
       (timezone "Europe/Berlin")
       (locale "en_US.utf8")

       ;; Boot in "legacy" BIOS mode, assuming /dev/sdX is the
       ;; target hard disk, and "my-root" is the label of the target
       ;; root file system.
       (bootloader (bootloader-configuration
                     (bootloader grub-bootloader)
                     (target "/dev/sdX")))
       (file-systems (cons (file-system
                             (device (file-system-label "my-root"))
                             (mount-point "/")
                             (type "ext4"))
                           %base-file-systems))

       ;; This is where user accounts are specified.  The "root"
       ;; account is implicit, and is initially created with the
       ;; empty password.
       (users (cons (user-account
                     (name "alice")
                     (comment "Bob's sister")
                     (group "users")

                     ;; Adding the account to the "wheel" group
                     ;; makes it a sudoer.  Adding it to "audio"
                     ;; and "video" allows the user to play sound
                     ;; and access the webcam.
                     (supplementary-groups '("wheel"
                                             "audio" "video")))
                    %base-user-accounts))

       ;; Globally-installed packages.
       (packages (cons screen %base-packages))

       ;; Add services to the baseline: a DHCP client and
       ;; an SSH server.
       (services (append (list (service dhcp-client-service-type)
                               (service openssh-service-type
                                        (openssh-configuration
                                         (port-number 2222))))
                         %base-services)))

   Cet exemple devrait se comprendre de lui-même. Certains champs
définis ci-dessus, comme ‘host-name’ et ‘bootloader’ sont obligatoires.
D’autres comme ‘packages’ et ‘services’ peuvent être omis auquel cas ils
ont une valeur par défaut.

   Ci-dessous nous discutons des effets de certains des champs les plus
importants (*note Référence de système d'exploitation::, pour des
détails sur tous les champs disponibles) et comment “instancier” le
système d’exploitation avec ‘guix system’.

Bootloader
----------

Le champ ‘bootloader’ décrit la méthode qui sera utilisée pour démarrer
votre système. Les machines basées sur les processeurs Intel peuvent
démarrer dans l’ancien mode BIOS, comme dans l’exemple au-dessus.
Cependant, les machines plus récentes s’appuient sur l’UEFI (“Unified
Extensible Firmware Interface”) pour démarrer. Dans ce cas, le champ
‘bootloader’ devrait contenir quelque chose comme cela :

     (bootloader-configuration
       (bootloader grub-efi-bootloader)
       (target "/boot/efi"))

   *Note Configuration du chargeur d'amorçage::, pour plus
d’informations sur les options de configuration disponibles.

Paquets visibles sur tout le système
------------------------------------

The ‘packages’ field lists packages that will be globally visible on the
system, for all user accounts—i.e., in every user’s ‘PATH’ environment
variable—in addition to the per-user profiles (*note Invoquer guix
package::). The ‘%base-packages’ variable provides all the tools one
would expect for basic user and administrator tasks—including the GNU
Core Utilities, the GNU Networking Utilities, the GNU Zile lightweight
text editor, ‘find’, ‘grep’, etc. The example above adds GNU Screen to
those, taken from the ‘(gnu packages screen)’ module (*note Modules de
paquets::). The ‘(list package output)’ syntax can be used to add a
specific output of a package:

     (use-modules (gnu packages))
     (use-modules (gnu packages dns))

     (operating-system
       ;; ...
       (packages (cons (list bind "utils")
                       %base-packages)))

   Se référer aux paquets par le nom de leur variable, comme ‘bind’
ci-dessus, a l’avantage d’être sans ambiguïté ; cela permet aussi de se
rendre rapidement compte de coquilles quand on a des « variables non
liées ». L’inconvénient est qu’on a besoin de savoir dans quel module
est défini le paquet, et de modifier la ligne ‘use-package-modules’ en
conséquence. Pour éviter cela, on peut utiliser la procédure
‘specification->package’ du module ‘(gnu packages)’, qui renvoie le
meilleur paquet pour un nom donné ou un nom et une version :

     (use-modules (gnu packages))

     (operating-system
       ;; ...
       (packages (append (map specification->package
                              '("tcpdump" "htop" "gnupg@2.0"))
                         %base-packages)))

Services systèmes
-----------------

Le champ ‘services’ liste les “services système” à rendre disponible
lorsque le système démarre (*note Services::). La déclaration
‘operating-system’ au-dessus spécifie que, en plus des services de base,
on veut que le démon ssh OpenSSH écoute sur le port 2222 (*note
‘openssh-service-type’: Services réseau.). Sous le capot,
‘openssh-service-type’ s’arrange pour que ‘sshd’ soit lancé avec les
bonnes options de la ligne de commande, éventuellement en générant des
fichiers de configuration (*note Définir des services::).

   Parfois, plutôt que d’utiliser les services de base tels-quels, on
peut vouloir les personnaliser. Pour cela, utilisez ‘modify-services’
(*note ‘modify-services’: Référence de service.) pour modifier la liste.

   For example, suppose you want to modify ‘guix-daemon’ and Mingetty
(the console log-in) in the ‘%base-services’ list (*note
‘%base-services’: Services de base.). To do that, you can write the
following in your operating system declaration:

     (define %my-services
       ;; Ma propre liste de services.
       (modify-services %base-services
         (guix-service-type config =>
                            (guix-configuration
                             (inherit config)
                             (use-substitutes? #f)
                             (extra-options '("--gc-keep-derivations"))))
         (mingetty-service-type config =>
                                (mingetty-configuration
                                 (inherit config)))))
     (operating-system
       ;; ...
       (services %my-services))

   This changes the configuration—i.e., the service parameters—of the
‘guix-service-type’ instance, and that of all the
‘mingetty-service-type’ instances in the ‘%base-services’ list. Observe
how this is accomplished: first, we arrange for the original
configuration to be bound to the identifier ‘config’ in the BODY, and
then we write the BODY so that it evaluates to the desired
configuration. In particular, notice how we use ‘inherit’ to create a
new configuration which has the same values as the old configuration,
but with a few modifications.

   La configuration pour une utilisation de « bureau » typique, avec une
partition racine chiffrée, le serveur d’affichage X11, GNOME et Xfce
(les utilisateurs peuvent choisir l’environnement de bureau sur l’écran
de connexion en appuyant sur ‘F1’), la gestion du réseau, la gestion de
l’énergie, et bien plus, ressemblerait à ceci :

     ;; This is an operating system configuration template
     ;; for a "desktop" setup with GNOME and Xfce where the
     ;; root partition is encrypted with LUKS.

     (use-modules (gnu) (gnu system nss))
     (use-service-modules desktop xorg)
     (use-package-modules certs gnome)

     (operating-system
       (host-name "antelope")
       (timezone "Europe/Paris")
       (locale "en_US.utf8")

       ;; Choose US English keyboard layout.  The "altgr-intl"
       ;; variant provides dead keys for accented characters.
       (keyboard-layout (keyboard-layout "us" "altgr-intl"))

       ;; Use the UEFI variant of GRUB with the EFI System
       ;; Partition mounted on /boot/efi.
       (bootloader (bootloader-configuration
                     (bootloader grub-efi-bootloader)
                     (target "/boot/efi")
                     (keyboard-layout keyboard-layout)))

       ;; Specify a mapped device for the encrypted root partition.
       ;; The UUID is that returned by 'cryptsetup luksUUID'.
       (mapped-devices
        (list (mapped-device
               (source (uuid "12345678-1234-1234-1234-123456789abc"))
               (target "my-root")
               (type luks-device-mapping))))

       (file-systems (append
                      (list (file-system
                              (device (file-system-label "my-root"))
                              (mount-point "/")
                              (type "ext4")
                              (dependencies mapped-devices))
                            (file-system
                              (device (uuid "1234-ABCD" 'fat))
                              (mount-point "/boot/efi")
                              (type "vfat")))
                      %base-file-systems))

       (users (cons (user-account
                     (name "bob")
                     (comment "Alice's brother")
                     (group "users")
                     (supplementary-groups '("wheel" "netdev"
                                             "audio" "video")))
                    %base-user-accounts))

       ;; This is where we specify system-wide packages.
       (packages (append (list
                          ;; for HTTPS access
                          nss-certs
                          ;; for user mounts
                          gvfs)
                         %base-packages))

       ;; Add GNOME and Xfce---we can choose at the log-in screen
       ;; by clicking the gear.  Use the "desktop" services, which
       ;; include the X11 log-in service, networking with
       ;; NetworkManager, and more.
       (services (append (list (service gnome-desktop-service-type)
                               (service xfce-desktop-service-type)
                               (set-xorg-configuration
                                (xorg-configuration
                                 (keyboard-layout keyboard-layout))))
                         %desktop-services))

       ;; Allow resolution of '.local' host names with mDNS.
       (name-service-switch %mdns-host-lookup-nss))

   Un système graphique avec un choix de gestionnaires de fenêtres
légers plutôt que des environnement de bureaux complets ressemblerait à
cela :

     ;; This is an operating system configuration template
     ;; for a "desktop" setup without full-blown desktop
     ;; environments.

     (use-modules (gnu) (gnu system nss))
     (use-service-modules desktop)
     (use-package-modules bootloaders certs ratpoison suckless wm)
     (use-package-modules bootloaders certs ratpoison suckless wm xorg)

     (operating-system
       (host-name "antelope")
       (timezone "Europe/Paris")
       (locale "en_US.utf8")

       ;; Use the UEFI variant of GRUB with the EFI System
       ;; Partition mounted on /boot/efi.
       (bootloader (bootloader-configuration
                     (bootloader grub-efi-bootloader)
                     (target "/boot/efi")))

       ;; Assume the target root file system is labelled "my-root",
       ;; and the EFI System Partition has UUID 1234-ABCD.
       (file-systems (append
                      (list (file-system
                              (device (file-system-label "my-root"))
                              (mount-point "/")
                              (type "ext4"))
                            (file-system
                              (device (uuid "1234-ABCD" 'fat))
                              (mount-point "/boot/efi")
                              (type "vfat")))
                      %base-file-systems))

       (users (cons (user-account
                     (name "alice")
                     (comment "Bob's sister")
                     (group "users")
                     (supplementary-groups '("wheel" "netdev"
                                             "audio" "video")))
                    %base-user-accounts))

       ;; Add a bunch of window managers; we can choose one at
       ;; the log-in screen with F1.
       (packages (append (list
                          ;; window managers
                          ratpoison i3-wm i3status dmenu
                          ;; terminal emulator
                          xterm
                          ;; for HTTPS access
                          nss-certs)
                         %base-packages))

       ;; Use the "desktop" services, which include the X11
       ;; log-in service, networking with NetworkManager, and more.
       (services %desktop-services)

       ;; Allow resolution of '.local' host names with mDNS.
       (name-service-switch %mdns-host-lookup-nss))

   Cet exemple se réfère au système de fichier ‘/boot/efi’ par son UUID,
‘1234-ABCD’. Remplacez cet UUID par le bon UUID de votre système,
renvoyé par la commande ‘blkid’.

   *Note Services de bureaux::, for the exact list of services provided
by ‘%desktop-services’. *Note Certificats X.509::, for background
information about the ‘nss-certs’ package that is used here.

   Again, ‘%desktop-services’ is just a list of service objects. If you
want to remove services from there, you can do so using the procedures
for list filtering (*note (guile)SRFI-1 Filtering and Partitioning::).
For instance, the following expression returns a list that contains all
the services in ‘%desktop-services’ minus the Avahi service:

     (remove (lambda (service)
               (eq? (service-kind service) avahi-service-type))
             %desktop-services)

Instancier le système
---------------------

En supposant que la déclaration ‘operating-system’ est stockée dans le
fichier ‘my-system-config.scm’, la commande ‘guix system reconfigure
my-system-config.scm’ instancie cette configuration et en fait l’entrée
par défaut dans GRUB (*note Invoquer guix system::).

   Pour changer la configuration du système, on met normalement à jour
ce fichier et on relance ‘guix system reconfigure’. On ne devrait jamais
avoir à modifier de fichiers dans ‘/etc’ ou à lancer des commandes qui
modifient l’état du système comme ‘useradd’ ou ‘grub-install’. En fait,
vous devez les éviter parce que non seulement ça annulerait vos
garanties, mais ça empêcherait aussi de revenir à des versions
précédents du système, si vous en avez besoin.

   En parlant de revenir en arrière, à chaque fois que vous lancez ‘guix
system reconfigure’, une nouvelle “génération” du système est crée —
sans modifier ou supprimer les générations précédentes. Les anciennes
générations du système ont une entrée dans le menu du chargeur
d’amorçage, ce qui vous permet de démarrer dessus au cas où quelque
chose se serait mal passé avec la dernière génération. C’est rassurant,
non ? La commande ‘guix system list-generations’ liste les générations
du système disponibles sur le disque. Il est possible de revenir à une
ancienne génération via les commandes ‘guix system roll-back’ et ‘guix
system switch-generation’.

   Bien que la commande ‘guix system reconfigure’ ne modifiera pas les
générations précédentes, vous devez faire attention lorsque votre
génération actuelle n’est pas la dernière (p. ex. après avoir invoqué
‘guix system roll-back’), puisque l’opération pourrait remplacer une
génération suivante (*note Invoquer guix system::).

L’interface de programmation
----------------------------

Au niveau Scheme, la grosse déclaration ‘operating-system’ est
instanciée avec la procédure monadique suivante (*note La monade du
dépôt::) :

 -- Procédure monadique : operating-system-derivation os
     Renvoie une dérivation qui construit OS, un objet
     ‘operating-system’ (*note Dérivations::).

     La sortie de la dérivation est un répertoire qui se réfère à tous
     les paquets et d’autres fichiers supports requis pour instancier
     OS.

   Cette procédure est fournie par le module ‘(gnu system)’. Avec ‘(gnu
services)’ (*note Services::), ce module contient les entrailles du
système Guix. Ouvrez-le un jour !


File: guix.fr.info,  Node: Référence de système d'exploitation,  Next: Systèmes de fichiers,  Prev: Utiliser le système de configuration,  Up: Configuration système

8.2 Référence de ‘operating-system’
===================================

Cette section résume toutes les options disponibles dans les
déclarations ‘operating-system’ (*note Utiliser le système de
configuration::).

 -- Type de données : operating-system
     C’est le type de données représentant une configuration d’un
     système d’exploitation. On veut dire par là toute la configuration
     globale du système, mais pas la configuration par utilisateur
     (*note Utiliser le système de configuration::).

     ‘kernel’ (default: ‘linux-libre’)
          The package object of the operating system kernel to use(1).

     ‘hurd’ (default: ‘#f’)
          The hurd to be started by the kernel. This is required to
          build an experimental vm-image for the Hurd and requires using
          ‘kernel’ GNU mach as well as other specific operating system
          overrides.

     ‘kernel-loadable-modules’ (default: ’())
          A list of objects (usually packages) to collect loadable
          kernel modules from–e.g. ‘(list ddcci-driver-linux)’.

     ‘kernel-arguments’ (default: ‘%default-kernel-arguments’)
          Liste de chaînes ou de gexps représentant des arguments
          supplémentaires à passer sur la ligne de commande du noyau —
          p. ex. ‘("console=ttyS0")’.

     ‘bootloader’
          L’objet de configuration du chargeur d’amorçage. *Note
          Configuration du chargeur d'amorçage::.

     ‘label’
          C’est l’étiquette (une chaîne de caractères) comme elle
          apparaît dans l’entrée du menu du chargeur d’amorçage.
          L’étiquette par défaut inclus le nom du noyau et sa version.

     ‘keyboard-layout’ (par défaut : ‘#f’)
          Ce champ spécifie la disposition du clavier à utiliser dans la
          console. Il peut être soit ‘#f’, auquel cas la disposition par
          défaut est utilisée (habituellement anglais américain), ou un
          enregistrement ‘<keyboard-layout>’.

          Cette disposition du clavier est effective dès que le noyau
          démarre. Par exemple, c’est la disposition du clavier
          effective lorsque vous saisissez la phrase de passe de votre
          système de fichier racine sur une partition utilisant
          ‘luks-device-mapping’ (*note Périphériques mappés::).

               Remarque : Cela ne spécifie _pas_ la disposition clavier
               utilisée par le chargeur d’amorçage, ni celle utilisée
               par le serveur d’affichage graphique. *Note Configuration
               du chargeur d'amorçage::, pour plus d’information sur la
               manière de spécifier la disposition du clavier pour le
               chargeur d’amorçage. *Note Système de fenêtrage X::, pour
               plus d’informations sur la manière de spécifier la
               disposition du clavier utilisée par le système de
               fenêtrage X.

     ‘initrd-modules’ (par défaut : ‘%base-initrd-modules’)
          La liste des modules du noyau linux requis dans l’image disque
          de RAM initiale. *Note Disque de RAM initial::.

     ‘initrd’ (par défaut : ‘base-initrd’)
          Une procédure qui renvoie un disque de RAM initial pour le
          noyau Linux. Ce champ est fournit pour pouvoir personnaliser
          son système à bas-niveau et n’est que rarement utile dans le
          cas général. *Note Disque de RAM initial::.

     ‘firmware’ (default: ‘%base-firmware’)
          Liste les paquets de microgiciels chargeables pour le noyau de
          système d’exploitation.

          La valeur par défaut contient les microgiciels requis pour les
          périphériques WiFi Atheros et Broadcom (modules ‘ath9k’ et
          ‘b43-open’ de Linux-libre, respectivement). *Note
          Considérations matérielles::, pour plus d’info sur les
          périphériques supportés.

     ‘host-name’
          Le nom d’hôte.

     ‘hosts-file’
          Un objet simili-fichier (*note file-like objects:
          G-Expressions.) à utiliser comme ‘/etc/hosts’ (*note
          (libc)Host Names::). La valeur par défaut est un fichier avec
          des entrées pour ‘localhost’ et HOST-NAME.

     ‘mapped-devices’ (par défaut : ‘'()’)
          Une liste de périphériques mappés. *Note Périphériques
          mappés::.

     ‘file-systems’
          Une liste de systèmes de fichiers. *Note Systèmes de
          fichiers::.

     ‘swap-devices’ (par défaut : ‘'()’)
          Une liste de chaînes identifiant les périphériques ou les
          fichiers utilisé pour « l’espace d’échange » (*note
          (libc)Memory Concepts::). Par exemple, ‘'("/dev/sda3")’ ou
          ‘'("/swapfile")’. Il est possible de spécifier un fichier
          d’échange sur un périphérique mappé, tant que le périphérique
          nécessaire et le système de fichiers sont aussi spécifiés.
          *Note Périphériques mappés:: et *note Systèmes de fichiers::.

     ‘users’ (par défaut : ‘%base-user-accounts’)
     ‘groups’ (default: ‘%base-groups’)
          Liste les comptes utilisateurs et les groupes. *Note Comptes
          utilisateurs::.

          Si la liste ‘users’ n’a pas de compte lié à l’UID 0, un compte
          « root » avec l’UID 0 est automatiquement ajouté.

     ‘skeletons’ (par défaut : ‘(default-skeletons)’)
          Une liste de couples composés d’un nom de fichier cible et
          d’un objet simili-fichier (*note file-like objects:
          G-Expressions.). Ce sont les fichiers squelettes qui seront
          ajoutés au répertoire personnel des comptes utilisateurs
          nouvellement créés.

          Par exemple, un valeur valide ressemblerait à cela :

               `((".bashrc" ,(plain-file "bashrc" "echo Hello\n"))
                 (".guile" ,(plain-file "guile"
                                        "(use-modules (ice-9 readline))
                                         (activate-readline)")))

     ‘issue’ (default: ‘%default-issue’)
          Une chaîne qui dénote le contenu du fichier ‘/etc/issue’ qui
          est affiché lorsqu’un utilisateur se connecte sur la console.

     ‘packages’ (default: ‘%base-packages’)
          L’ensemble des paquets installés dans le profil global, qui
          est accessible à partir de ‘/run/current-system/profile’.

          L’ensemble par défaut contient les utilitaires de base et
          c’est une bonne pratique d’installer les utilitaires non
          essentiels dans les profils utilisateurs (*note Invoquer guix
          package::).

     ‘timezone’
          Une chaîne identifiant un fuseau horaire — p. ex.
          ‘"Europe/Paris"’.

          Vous pouvez lancer la commande ‘tzselect’ pour trouver le
          fuseau horaire correspondant à votre région. Si vous
          choisissez un nom de fuseau horaire invalide, ‘guix system’
          échouera.

     ‘locale’ (par défaut : ‘"en_US.utf8"’)
          Le nom du paramètre régional par défaut (*note (libc)Locale
          Names::). *Note Régionalisation::, pour plus d’informations.

     ‘locale-definitions’ (default: ‘%default-locale-definitions’)
          La liste des définitions de locales à compiler et qui
          devraient être utilisées à l’exécution. *Note
          Régionalisation::.

     ‘locale-libcs’ (par défaut : ‘(list GLIBC)’)
          La liste des paquets GNU libc dont les données des paramètres
          linguistiques sont utilisées pour construire les définitions
          des paramètres linguistiques. *Note Régionalisation::, pour
          des considérations sur la compatibilité qui justifient cette
          option.

     ‘name-service-switch’ (default: ‘%default-nss’)
          La configuration de NSS de la libc (name service switch) — un
          objet ‘<name-service-switch>’. *Note Name Service Switch::,
          pour des détails.

     ‘services’ (default: ‘%base-services’)
          Une liste d’objets services qui dénotent les services du
          système. *Note Services::.

     ‘essential-services’ (par défaut : …)
          La liste des « services essentiels » — c.-à-d. les services
          comme des instance de ‘system-service-type’ et
          ‘host-name-service-type’ (*note Référence de service::), qui
          sont dérivés de la définition du système d’exploitation
          lui-même. En tant qu’utilisateur vous ne devriez _jamais_
          toucher à ce champ.

     ‘pam-services’ (par défaut : ‘(base-pam-services)’)
          Services PAM (“pluggable authentication module”) Linux.

     ‘setuid-programs’ (default: ‘%setuid-programs’)
          Liste de G-expressions qui s’évaluent en chaînes de caractères
          qui dénotent les programmes setuid. *Note Programmes setuid::.

     ‘sudoers-file’ (default: ‘%sudoers-specification’)
          Le contenu du fichier ‘/etc/sudoers’ comme un objet
          simili-fichier (*note ‘local-file’ et ‘plain-file’:
          G-Expressions.).

          Ce fichier spécifier quels utilisateurs peuvent utiliser la
          commande ‘sudo’, ce qu’ils ont le droit de faire, et quels
          privilèges ils peuvent gagner. La valeur par défaut est que
          seul ‘root’ et les membres du groupe ‘wheel’ peuvent utiliser
          ‘sudo’.

      -- Type de données : this-operating-system
          Lorsqu’il est utilisée dans la _portée lexicale_ de la
          définition d’un du système d’exploitation, cet identifiant est
          résolu comme étant le système d’exploitation définit.

          L’exemple ci-dessous montre le référencement au système
          d’exploitation définit dans la définition du champ ‘label’ :

               (use-modules (gnu) (guix))

               (operating-system
                 ;; ...
                 (label (package-full-name
                         (operating-system-kernel this-operating-system))))

          C’est une erreur que de se référer à ‘this-operating-system’
          en dehors de la définition d’un système d’exploitation.

   ---------- Footnotes ----------

   (1) Currently only the Linux-libre kernel is fully supported. Using
GNU mach in combination with a ‘hurd’ is experimental and only available
when building a vm-image.


File: guix.fr.info,  Node: Systèmes de fichiers,  Next: Périphériques mappés,  Prev: Référence de système d'exploitation,  Up: Configuration système

8.3 Systèmes de fichiers
========================

La liste des systèmes de fichiers à monter est spécifiée dans le champ
‘file-systems’ de la déclaration de système d’exploitation (*note
Utiliser le système de configuration::). Chaque système de fichier est
déclaré avec la forme ‘file-system’, comme ceci :

     (file-system
       (mount-point "/home")
       (device "/dev/sda3")
       (type "ext4"))

   Comme d’habitude, certains de ces champs sont obligatoire — comme le
montre l’exemple au-dessus — alors que d’autres peuvent être omis. Ils
sont décrits plus bas.

 -- Type de données : file-system
     Les objets de ce type représentent des systèmes de fichiers à
     monter. Ils contiennent les membres suivants :

     ‘type’
          C’est une chaîne de caractères spécifiant le type du système
          de fichier — p. ex. ‘"ext4"’.

     ‘mount-point’
          Désigne l’emplacement où le système de fichier sera monté.

     ‘device’
          Ce champ nomme le système de fichier « source ». il peut être
          l’une de ces trois choses : une étiquette de système de
          fichiers, un UUID de système de fichier ou le nom d’un nœud
          dans ‘/dev’. Les étiquettes et les UUID offrent une manière de
          se référer à des systèmes de fichiers sans avoir à coder en
          dur le nom de périphérique(1).

          Les étiquettes de systèmes de fichiers sont crées avec la
          procédure ‘file-system-label’, les UUID avec ‘uuid’ et les
          nœuds de ‘/dev’ sont de simples chaînes de caractères. Voici
          un exemple d’un système de fichiers référencé par son
          étiquette, donnée par la commande ‘e2label’ :

               (file-system
                 (mount-point "/home")
                 (type "ext4")
                 (device (file-system-label "my-home")))

          Les UUID sont convertis à partir de leur représentation en
          chaîne de caractères (montrée par la command ‘tune2fs -l’) en
          utilisant la forme ‘uuid’(2), comme ceci :

               (file-system
                 (mount-point "/home")
                 (type "ext4")
                 (device (uuid "4dab5feb-d176-45de-b287-9b0a6e4c01cb")))

          Lorsque la source d’un système de fichiers est un périphérique
          mappé (*note Périphériques mappés::), sont champ ‘device’
          _doit_ se référer au nom du périphérique mappé — p. ex.
          ‘"/dev/mapper/root-partition"’. Cela est requis pour que le
          système sache que monter ce système de fichier dépend de la
          présence du périphérique mappé correspondant.

     ‘flags’ (par défaut : ‘'()’)
          This is a list of symbols denoting mount flags. Recognized
          flags include ‘read-only’, ‘bind-mount’, ‘no-dev’ (disallow
          access to special files), ‘no-suid’ (ignore setuid and setgid
          bits), ‘no-atime’ (do not update file access times),
          ‘strict-atime’ (update file access time), ‘lazy-time’ (only
          update time on the in-memory version of the file inode), and
          ‘no-exec’ (disallow program execution). *Note
          (libc)Mount-Unmount-Remount::, for more information on these
          flags.

     ‘options’ (par défaut : ‘#f’)
          This is either ‘#f’, or a string denoting mount options passed
          to the file system driver. *Note
          (libc)Mount-Unmount-Remount::, for details and run ‘man 8
          mount’ for options for various file systems. Note that the
          ‘file-system-options->alist’ and ‘alist->file-system-options’
          procedures from ‘(gnu system file-systems)’ can be used to
          convert file system options given as an association list to
          the string representation, and vice-versa.

     ‘mount?’ (par défaut : ‘#t’)
          Cette valeur indique s’il faut monter automatiquement le
          système de fichier au démarrage du système. Lorsque la valeur
          est ‘#f’, le système de fichier reçoit une entrée dans
          ‘/etc/fstab’ (lue par la commande ‘mount’) mais n’est pas
          monté automatiquement.

     ‘needed-for-boot?’ (par défaut : ‘#f’)
          Cette valeur booléenne indique si le système de fichier est
          nécessaire au démarrage. Si c’est vrai alors le système de
          fichier est monté au chargement du disque de RAM initial.
          C’est toujours le cas par exemple du système de fichiers
          racine.

     ‘check?’ (par défaut : ‘#t’)
          Cette valeur booléenne indique si le système de fichier doit
          être vérifié avant de le monter.

     ‘create-mount-point?’ (par défaut : ‘#f’)
          Lorsque cette valeur est vraie, le point de montage est créé
          s’il n’existe pas déjà.

     ‘dependencies’ (par défaut : ‘'()’)
          C’est une liste d’objets ‘<file-system>’ ou ‘<mapped-device>’
          qui représentent les systèmes de fichiers qui doivent être
          montés ou les périphériques mappés qui doivent être ouverts
          avant (et monté ou fermés après) celui-ci.

          Par exemple, considérons une hiérarchie de montage :
          ‘/sys/fs/cgroup’ est une dépendance de ‘/sys/fs/cgroup/cpu’ et
          ‘/sys/fs/cgroup/memory’.

          Un autre exemple est un système de fichier qui dépend d’un
          périphérique mappé, par exemple pour une partition chiffrée
          (*note Périphériques mappés::).

   Le module ‘(gnu system file-systems)’ exporte les variables utiles
suivantes.

 -- Variable Scheme : %base-file-systems
     These are essential file systems that are required on normal
     systems, such as ‘%pseudo-terminal-file-system’ and
     ‘%immutable-store’ (see below). Operating system declarations
     should always contain at least these.

 -- Variable Scheme : %pseudo-terminal-file-system
     C’est le système de fichier monté sur ‘/dev/pts’. Il supporte les
     “pseudo-terminaux” créés via ‘openpty’ et les fonctions similaires
     (*note (libc)Pseudo-Terminals::). Les pseudo-terminaux sont
     utilisés par les émulateurs de terminaux comme ‘xterm’.

 -- Variable Scheme : %shared-memory-file-system
     Ce système de fichier est monté dans ‘/dev/shm’ et est utilisé pour
     le partage de mémoire entre processus (*note ‘shm_open’:
     (libc)Memory-mapped I/O.).

 -- Variable Scheme : %immutable-store
     Ce système de fichiers effectue un « montage lié » en lecture-seule
     de ‘/gnu/store’, ce qui en fait un répertoire en lecture-seule pour
     tous les utilisateurs dont ‘root’. Cela évite que des logiciels qui
     tournent en ‘root’ ou des administrateurs systèmes ne modifient
     accidentellement le dépôt.

     Le démon lui-même est toujours capable d’écrire dans le dépôt : il
     est remonté en lecture-écriture dans son propre « espace de nom ».

 -- Variable Scheme : %binary-format-file-system
     Le système de fichiers ‘binfmt_misc’, qui permet de gérer n’importe
     quel type de fichiers exécutables à déléguer en espace utilisateur.
     Cela demande que le module du noyau ‘binfmt.ko’ soit chargé.

 -- Variable Scheme : %fuse-control-file-system
     Le système de fichiers ‘fusectl’, qui permet à des utilisateurs non
     privilégiés de monter et de démonter des systèmes de fichiers FUSE
     en espace utilisateur. Cela requiert que le module du noyau
     ‘fuse.ko’ soit chargé.

* Menu:

* Btrfs file system::

   ---------- Footnotes ----------

   (1) Remarquez que, s’il est tentant d’utiliser ‘/dev/disk/by-uuid’ et
autres chemins similaires pour obtenir le même résultat, ce n’est pas
recommandé : ces nœuds de périphériques spéciaux sont créés par le démon
udev et peuvent ne pas être disponibles au moment de monter le
périphérique.

   (2) La forme ‘uuid’ s’attend à des UUID sur 16 octets définis dans la
RFC 4122 (https://tools.ietf.org/html/rfc4122). C’est la forme des UUID
utilisées par la famille de systèmes de fichiers ext2 et d’autres, mais
ce n’est pas le même type d’UUID que ceux qui se trouvent sur les
systèmes de fichiers FAT par exemple


File: guix.fr.info,  Node: Btrfs file system,  Up: Systèmes de fichiers

8.3.1 Btrfs file system
-----------------------

The Btrfs has special features, such as subvolumes, that merit being
explained in more details. The following section attempts to cover basic
as well as complex uses of a Btrfs file system with the Guix System.

   In its simplest usage, a Btrfs file system can be described, for
example, by:

     (file-system
       (mount-point "/home")
       (type "btrfs")
       (device (file-system-label "my-home")))

   The example below is more complex, as it makes use of a Btrfs
subvolume, named ‘rootfs’. The parent Btrfs file system is labeled
‘my-btrfs-pool’, and is located on an encrypted device (hence the
dependency on ‘mapped-devices’):

     (file-system
       (device (file-system-label "my-btrfs-pool"))
       (mount-point "/")
       (type "btrfs")
       (options "subvol=rootfs")
       (dependencies mapped-devices))

   Some bootloaders, for example GRUB, only mount a Btrfs partition at
its top level during the early boot, and rely on their configuration to
refer to the correct subvolume path within that top level. The
bootloaders operating in this way typically produce their configuration
on a running system where the Btrfs partitions are already mounted and
where the subvolume information is readily available. As an example,
‘grub-mkconfig’, the configuration generator command shipped with GRUB,
reads ‘/proc/self/mountinfo’ to determine the top-level path of a
subvolume.

   The Guix System produces a bootloader configuration using the
operating system configuration as its sole input; it is therefore
necessary to extract the subvolume name on which ‘/gnu/store’ lives (if
any) from that operating system configuration. To better illustrate,
consider a subvolume named ’rootfs’ which contains the root file system
data. In such situation, the GRUB bootloader would only see the top
level of the root Btrfs partition, e.g.:

     /                   (top level)
     ├── rootfs          (subvolume directory)
         ├── gnu         (normal directory)
             ├── store   (normal directory)
     [...]

   Thus, the subvolume name must be prepended to the ‘/gnu/store’ path
of the kernel, initrd binaries and any other files referred to in the
GRUB configuration that must be found during the early boot.

   The next example shows a nested hierarchy of subvolumes and
directories:

     /                   (top level)
     ├── rootfs          (subvolume)
         ├── gnu         (normal directory)
             ├── store   (subvolume)
     [...]

   This scenario would work without mounting the ’store’ subvolume.
Mounting ’rootfs’ is sufficient, since the subvolume name matches its
intended mount point in the file system hierarchy. Alternatively, the
’store’ subvolume could be referred to by setting the ‘subvol’ option to
either ‘/rootfs/gnu/store’ or ‘rootfs/gnu/store’.

   Finally, a more contrived example of nested subvolumes:

     /                           (top level)
     ├── root-snapshots          (subvolume)
         ├── root-current        (subvolume)
             ├── guix-store      (subvolume)
     [...]

   Here, the ’guix-store’ subvolume doesn’t match its intended mount
point, so it is necessary to mount it. The subvolume must be fully
specified, by passing its file name to the ‘subvol’ option. To
illustrate, the ’guix-store’ subvolume could be mounted on ‘/gnu/store’
by using a file system declaration such as:

     (file-system
       (device (file-system-label "btrfs-pool-1"))
       (mount-point "/gnu/store")
       (type "btrfs")
       (options "subvol=root-snapshots/root-current/guix-store,\
     compress-force=zstd,space_cache=v2"))


File: guix.fr.info,  Node: Périphériques mappés,  Next: Comptes utilisateurs,  Prev: Systèmes de fichiers,  Up: Configuration système

8.4 Périphériques mappés
========================

Le noyau Linux a une notion de “mappage de périphériques” : un
périphérique bloc, comme une partition sur un disque dur, peut être
“mappé” sur un autre périphérique, typiquement dans ‘/dev/mapper’, avec
des calculs supplémentaires sur les données qui naviguent entre les
deux(1). Un exemple typique est le mappage de périphériques chiffrés :
toutes les écritures sont sur le périphérique mappé sont chiffrées,
toutes les lectures déchiffrées, de manière transparente. Guix étend
cette notion en considérant que tout périphérique ou ensemble de
périphériques qui sont “transformés” d’une certaine manière créent un
nouveau périphérique ; par exemple, les périphériques RAID sont obtenus
en “assemblant” plusieurs autres périphériques, comme des disque ou des
partitions, en un nouveau périphérique en tant qu’unique partition. Un
autre exemple, qui n’est pas encore disponible, sont les volumes
logiques LVM.

   Les périphériques mappés sont déclarés avec la forme ‘mapped-device’,
définie comme suit ; par exemple, voir ci-dessous.

 -- Type de données : mapped-device
     Les objets de ce type représentent des mappages de périphériques
     qui seront effectués au démarrage du système.

     ‘source’
          C’est soit une chaîne qui spécifie le nom d’un périphérique
          bloc à mapper, comme ‘"/dev/sda3"’, soit une liste de
          plusieurs périphériques à assembler pour en créer un nouveau.

     ‘target’
          Cette chaîne spécifie le nom du périphérique mappé qui en
          résulte. Pour les mappeurs noyaux comme les périphériques
          chiffrés de type ‘luks-device-mapping’, spécifier
          ‘"ma-partition"’ crée le périphérique
          ‘"/dev/mapper/ma-partition"’. Pour les périphériques RAID de
          type ‘raid-device-mapping’, il faut donner le nom complet
          comme ‘"/dev/md0"’.

     ‘type’
          Ce doit être un objets ‘mapped-device-kind’, qui spécifie
          comment SOURCE est mappés sur TARGET.

 -- Variable Scheme : luks-device-mapping
     Cela définie les périphériques blocs chiffrés en LUKS avec
     ‘cryptsetup’ du paquet du même nom. Elle s’appuie sur le module du
     noyau Linux ‘dm-crypt’.

 -- Variable Scheme : raid-device-mapping
     Cela définie un périphérique RAID qui est assemblé avec la commande
     ‘mdadm’ du paquet du même nom. Elle nécessite un module noyau Linux
     approprié pour le niveau RAID chargé, comme ‘raid456’ pour RAID-4,
     RAID-5 et RAID-6 ou ‘raid10’ pour RAID-10.

   L’exemple suivant spécifie un mappage de ‘/dev/sda3’ vers
‘/dev/mapper/home’ avec LUKS — Linux Unified Key Setup
(https://gitlab.com/cryptsetup/cryptsetup), un mécanisme standard pour
chiffrer les disques. Le périphérique ‘/dev/mapper/home’ peut ensuite
être utilisé comme ‘device’ d’une déclaration ‘file-system’ (*note
Systèmes de fichiers::).

     (mapped-device
       (source "/dev/sda3")
       (target "home")
       (type luks-device-mapping))

   Autrement, pour devenir indépendant du numéro de périphérique, on
peut obtenir l’UUID LUKS (“l’identifiant unique”) du périphérique source
avec une commande comme :

     cryptsetup luksUUID /dev/sda3

   et l’utiliser ainsi :

     (mapped-device
       (source (uuid "cb67fc72-0d54-4c88-9d4b-b225f30b0f44"))
       (target "home")
       (type luks-device-mapping))

   Il est aussi désirable de chiffrer l’espace d’échange, puisque
l’espace d’échange peut contenir des données sensibles. Une manière de
faire cela est d’utiliser un fichier d’échange dans un système de
fichiers sur un périphérique mappé avec un chiffrement LUKS. De cette
manière, le fichier d’échange est chiffré parce que tout le périphérique
est chiffré. *Note Disk Partitioning: Préparer l'installation, pour un
exemple.

   Un périphérique RAID formé des partitions ‘/dev/sda1’ et ‘/dev/sdb1’
peut être déclaré ainsi :

     (mapped-device
       (source (list "/dev/sda1" "/dev/sdb1"))
       (target "/dev/md0")
       (type raid-device-mapping))

   Le périphérique ‘/dev/md0’ peut ensuite être utilisé comme ‘device’
d’une déclaration ‘file-system’ (*note Systèmes de fichiers::).
Remarquez que le niveau de RAID n’a pas besoin d’être donné ; il est
choisi pendant la création initiale du périphérique RAID et est ensuite
déterminé automatiquement.

   ---------- Footnotes ----------

   (1) Remarquez que le Hurd ne fait pas de différence entre le concept
de « périphérique mappé » et celle d’un système de fichiers : les deux
correspondent à la _traduction_ des opérations d’entrée-sortie faites
sur un fichier en des opérations sur ce qui le contient. Ainsi, le Hurd
implémente les périphériques mappés, comme les systèmes de fichiers,
avec le mécanisme des “traducteurs” générique (*note
(hurd)Translators::).


File: guix.fr.info,  Node: Comptes utilisateurs,  Next: Disposition du clavier,  Prev: Périphériques mappés,  Up: Configuration système

8.5 Comptes utilisateurs
========================

Les comptes utilisateurs et les groupes sont gérés entièrement par la
déclaration ‘operating-system’. Ils sont spécifiés avec les formes
‘user-account’ et ‘user-group’ :

     (user-account
       (name "alice")
       (group "users")
       (supplementary-groups '("wheel"   ;permet d'utiliser sudo, etc.
                               "audio"   ;carte son
                               "video"   ;périphériques réseaux comme les webcams
                               "cdrom")) ;le bon vieux CD-ROM
       (comment "Bob's sister")
       (home-directory "/home/alice"))

   Lors du démarrage ou à la fin de ‘guix system reconfigure’, le
système s’assure que seuls les comptes utilisateurs et les groupes
spécifiés dans la déclaration ‘operating-system’ existent, et avec les
propriétés spécifiées. Ainsi, les modifications ou les créations de
comptes ou de groupes effectuées directement en invoquant des commandes
comme ‘useradd’ sont perdue à la reconfiguration ou au redémarrage. Cela
permet de s’assurer que le système reste exactement tel que déclaré.

 -- Type de données : user-account
     Les objets de se type représentent les comptes utilisateurs. Les
     membres suivants peuvent être spécifiés :

     ‘name’
          Le nom du compte utilisateur.

     ‘group’
          C’est le nom (une chaîne) ou un identifiant (un nombre) du
          groupe utilisateur auquel ce compte appartient.

     ‘supplementary-groups’ (par défaut : ‘'()’)
          Éventuellement, cela peut être définie comme une liste de noms
          de groupes auxquels ce compte appartient.

     ‘uid’ (par défaut : ‘#f’)
          C’est l’ID utilisateur de ce compte (un nombre) ou ‘#f’. Dans
          ce dernier cas, le nombre est choisi automatiquement par le
          système à la création du compte.

     ‘comment’ (par défaut : ‘""’)
          Un commentaire à propos du compte, comme le nom complet de
          l’utilisateur.

     ‘home-directory’
          C’est le nom du répertoire personnel du compte.

     ‘create-home-directory?’ (par défaut : ‘#t’)
          Indique si le répertoire personnel du compte devrait être créé
          s’il n’existe pas déjà.

     ‘shell’ (par défaut : Bash)
          C’est une G-expression qui dénote un nom de fichier d’un
          programme utilisé comme shell (*note G-Expressions::).

     ‘system?’ (par défaut : ‘#f’)
          C’est une valeur booléenne qui indique si le compte est un
          compte « système ». Les comptes systèmes sont parfois traités
          à part ; par exemple, les gestionnaires de connexion
          graphiques ne les liste pas.

     ‘password’ (par défaut : ‘#f’)
          Vous laisseriez normalement ce champ à ‘#f’ et initialiseriez
          les mots de passe utilisateurs en tant que ‘root’ avec la
          commande ‘passwd’, puis laisseriez l’utilisateur le changer
          avec ‘passwd’. Les mots de passes définis avec ‘passwd’ sont
          bien sûr préservés après redémarrage et reconfiguration.

          Si vous voulez _vraiment_ définir un mot de passe pour un
          compte, alors ce champ doit contenir le mot de passe chiffré,
          comme une chaîne de caractère. Vous pouvez utiliser la
          procédure ‘crypt’ pour cela :

               (user-account
                 (name "charlie")
                 (group "users")

                 ;; Spécifie un mot de passe initial hashé avec sha512.
                 (password (crypt "InitialPassword!" "$6$abc")))

               Remarque : Le hash de ce mot de passe initial sera
               disponible dans un fichier dans ‘/gnu/store’, lisible par
               tous les utilisateurs, donc cette méthode est à utiliser
               avec soin.

          *Note (libc)Passphrase Storage::, pour plus d’information sur
          le chiffrement des mots de passe et *note (guile)Encryption::,
          pour des informations sur la procédure ‘crypt’ de Guile.

   Les déclarations de groupes sont encore plus simple :

     (user-group (name "students"))

 -- Type de données : user-group
     C’est le type pour, hé bien, les comptes utilisateurs. Il n’y a que
     quelques champs :

     ‘name’
          Le nom du groupe.

     ‘id’ (par défaut : ‘#f’)
          L’identifiant du groupe (un nombre). S’il est ‘#f’, un nouveau
          nombre est alloué automatiquement lorsque le groupe est créé.

     ‘system?’ (par défaut : ‘#f’)
          Cette valeur booléenne indique si le groupe est un groupe «
          système ». les groupes systèmes ont un numéro d’ID bas.

     ‘password’ (par défaut : ‘#f’)
          Quoi, les groupes utilisateurs peuvent avoir des mots de passe
          ? On dirait bien. À moins que la valeur ne soit ‘#f’, ce champ
          spécifie le mot de passe du groupe.

   Par simplicité, une variable liste les groupes utilisateurs de base
auxquels on pourrait s’attendre :

 -- Variable Scheme : %base-groups
     C’est la liste des groupes utilisateur de base que les utilisateurs
     et les paquets s’attendent à trouver sur le système. Cela comprend
     des groupes comme « root », « wheel » et « users », ainsi que des
     groupes utilisés pour contrôler l’accès à certains périphériques,
     comme « audio », « disk » et « cdrom ».

 -- Variable Scheme : %base-user-accounts
     C’est la liste des compte du système de base que les programmes
     peuvent s’attendre à trouver sur un système GNU/Linux, comme le
     compte « nobody ».

     Remarquez que le compte « root » n’est pas défini ici. C’est un cas
     particulier et il est automatiquement ajouté qu’il soit spécifié ou
     non.


File: guix.fr.info,  Node: Disposition du clavier,  Next: Régionalisation,  Prev: Comptes utilisateurs,  Up: Configuration système

8.6 Disposition du clavier
==========================

Pour spécifier ce que fait chaque touche de votre clavier, vous devez
dire au système d’exploitation quel “disposition du clavier” vous voulez
utiliser. Par défaut, lorsque rien n’est spécifié, la disposition QWERTY
pour l’anglais américain pour les claviers 105 touches est utilisée.
Cependant, les germanophones préfèrent généralement la disposition
QWERTZ, les francophones la disposition AZERTY etc. ; les hackers
peuvent préférer Dvorak ou bépo, et peuvent même vouloir personnaliser
plus en détails l’effet de certaines touches. Cette section explique
comment faire cela.

   Il y a trois composants qui devront connaître votre disposition du
clavier :

   • Le _chargeur d’amorçage_ peut avoir besoin de connaître la
     disposition clavier que vous voulez utiliser (*note
     ‘keyboard-layout’: Configuration du chargeur d'amorçage.). C’est
     utile si vous voulez par exemple vous assurer que vous pouvez
     saisir la phrase de passe de votre partition racine chiffrée avec
     la bonne disposition.

   • Le _noyau du système d’exploitation_, Linux, en aura besoin pour
     configurer correctement la console (*note ‘keyboard-layout’:
     Référence de système d'exploitation.).

   • Le _serveur d’affichage graphique_, habituellement Xorg, a aussi sa
     propre idée sur la disposition du clavier à utiliser (*note
     ‘keyboard-layout’: Système de fenêtrage X.).

   Guix vous permet de configurer les trois séparément mais,
heureusement, il vous permet de partager la même disposition du clavier
pour chacun des trois composants.

   Les dispositions de clavier sont représentées par des enregistrements
créés par la procédure ‘keyboard-layout’ de ‘(gnu system keyboard)’. En
suivant l’extension clavier de X (XKB), chaque disposition a trois
attributs : un nom (souvent un code de langue comme « fi » pour le
finnois ou « jp » pour le japonais), un nom de variante facultatif, un
nom de modèle de clavier facultatif et une liste éventuellement vide
d’options supplémentaires. Dans la plupart des cas, vous n’aurez besoin
que du nom de la disposition. Voici quelques exemples :

     ;; La disposition QWERTZ allemande.  Ici on suppose que vous utilisez un clavier
     ;; type « pc105 » standard.
     (keyboard-layout "de")

     ;; La variante bépo de la disposition française.
     (keyboard-layout "fr" "bepo")

     ;; La disposition catalane.
     (keyboard-layout "es" "cat")

     ;; Arabic layout with "Alt-Shift" to switch to US layout.
     (keyboard-layout "ar,us" #:options '("grp:alt_shift_toggle"))

     ;; La disposition espagnole américaine.  En plus, la touche
     ;; « Verr. Maj. » est utilisée comme touche « Ctrl » supplémentaire,
     ;; et la touche « Menu » est utilisée comme touche « Compose » pour
     ;; saisir des lettres accentuées.
     (keyboard-layout "latam"
                      #:options '("ctrl:nocaps" "compose:menu"))

     ;; La disposition russe pour un clavier de ThinkPad.
     (keyboard-layout "ru" #:model "thinkpad")

     ;; La disposition « US internationale », qui est comme la disposition US plus
     ;; des touches mortes pour saisir des caractères accentués.  Cet exemple est pour
     ;; un clavier de MacBook Apple.
     (keyboard-layout "us" "intl" #:model "macbook78")

   Voir le répertoire ‘share/X11/xkb’ du paquet ‘xkeyboard-config’ pour
une liste complète des disposition, des variantes et des modèles pris en
charge.

   Disons que vous voulez que votre système utilise la disposition
turque sur tout le système — du chargeur d’amorçage à Xorg en passant
par la console. Voici ce que votre configuration du système contiendrait
:

     ;; Utiliser la disposition turque pour le chargeur d'amorçage,
     ;; la console et Xorg.
     (operating-system
       ;; ...
       (keyboard-layout (keyboard-layout "tr"))  ;pour la console
       (bootloader (bootloader-configuration
                     (bootloader grub-efi-bootloader)
                     (target "/boot/efi")
                     (keyboard-layout keyboard-layout))) ;pour GRUB
       (services (cons (set-xorg-configuration
                         (xorg-configuration             ;pour Xorg
                           (keyboard-layout keyboard-layout)))
                       %desktop-services)))

   Dans l’exemple ci-dessus, pour GRUB et pour Xorg, nous nous référons
simplement au champ ‘keyboard-layout’ au dessus, mais on pourrait aussi
bien se référer à une autre disposition. La procédure
‘set-xorg-configuration’ communique la configuration Xorg désirée au
gestionnaire de connexion, par défaut GDM.

   Nous avons discuté de la manière de spécifier la disposition du
clavier _par défaut_ lorsque votre système démarre, mais vous pouvez
aussi l’ajuster à l’exécution :

   • Si vous utilisez GNOME, son panneau de configuration contient une
     entrée « Région & Langues » où vous pouvez choisir une ou plusieurs
     dispositions du clavier.

   • Sous Xorg, la commande ‘sexkbmap’ (du paquet du même nom) vous
     permet de changer la disposition actuelle. Par exemple, voilà
     comment changer la disposition pour un Dvorak américain :

          setxkbmap us dvorak

   • La commande ‘loadkey’ change la disposition du clavier dans la
     console Linux. Cependant, remarque que ‘loadkeys’ n’utilise _pas_
     la catégorisation des dispositions XKB décrite plus haut. La
     commande suivante charge la disposition bépo française :

          loadkeys fr-bepo


File: guix.fr.info,  Node: Régionalisation,  Next: Services,  Prev: Disposition du clavier,  Up: Configuration système

8.7 Régionalisation
===================

Un “paramètre linguistique” définie les conventions culturelles d’une
langue et d’une région particulières (*note (libc)Régionalisation::).
Chaque paramètre linguistique a un nom de la forme
‘LANGUE_TERRITOIRE.JEUDECARACTÈRES’ — p. ex. ‘fr_LU.utf8’ désigne le
paramètre linguistique pour le français, avec les conventions
culturelles du Luxembourg, en utilisant l’encodage UTF-8.

   Normalement, vous voudrez spécifier les paramètres linguistiques par
défaut pour la machine en utilisant le champ ‘locale’ de la déclaration
‘operating-system’ (*note ‘locale’: Référence de système
d'exploitation.).

   Les paramètres régionaux choisis sont automatiquement ajoutés aux
définitions des “paramètres régionaux” connues par le système au besoin,
avec le jeu de caractères inféré à partir de son nom, p. ex.
‘bo_CN.utf8’ supposera qu’il faut utiliser le jeu de caractères ‘UTF-8’.
Des définitions supplémentaires peuvent être spécifiées dans le champ
‘locale-definitions’ de ‘operating-system’ — c’est utile par exemple si
le jeu de caractères n’a pas été inféré à partir du nom. L’ensemble par
défaut de définitions comprend certains paramètres linguistiques parmi
les plus utilisés, mais pas toutes les variantes disponibles, pour
gagner de la place.

   Par exemple, pour ajouter les paramètres pour le frison septentrional
en Allemagne, la valeur de ce champ serait :

     (cons (locale-definition
             (name "fy_DE.utf8") (source "fy_DE"))
           %default-locale-definitions)

   De me, pour gagner de la place, on peut vouloir lister dans
‘locale-definitions’ seulement les paramètres qui sont vraiment
utilisés, comme dans :

     (list (locale-definition
             (name "ja_JP.eucjp") (source "ja_JP")
             (charset "EUC-JP")))

   The compiled locale definitions are available at
‘/run/current-system/locale/X.Y’, where ‘X.Y’ is the libc version, which
is the default location where the GNU libc provided by Guix looks for
locale data. This can be overridden using the ‘LOCPATH’ environment
variable (*note ‘LOCPATH’ and locale packages: locales-and-locpath.).

   La forme ‘locale-definition’ est fournie par le module ‘(gnu system
locale)’. Des détails sont disponibles plus bas.

 -- Type de données : locale-definition
     C’est le type de données d’une définition de paramètres
     linguistiques.

     ‘name’
          Le nom du paramètre linguistique. *Note (libc)Locale Names::,
          pour en savoir plus sur les noms de paramètres linguistiques.

     ‘source’
          Le nom de la source pour ce paramètre linguistique. C’est
          typiquement la partie ‘LANGUE_TERRITOIRE’ du nom du paramètre.

     ‘charset’ (par défaut : ‘"UTF-8"’)
          Le « jeu de caractères » d’un paramètre linguistique, défini
          par l’IANA (https://www.iana.org/assignments/character-sets).

 -- Variable Scheme : %default-locale-definitions
     Une liste des paramètres linguistiques UTF-8 couramment utilisés,
     utilisée comme valeur par défaut pour le champ ‘locale-definitions’
     des déclarations ‘operating-system’.

     Ces définitions de paramètres linguistiques utilisent le “jeu de
     caractère normalisé” pour la partie qui suit le point dans le nom
     (*note normalized codeset: (libc)Using gettextized software.). Donc
     par exemple il y a ‘uk_UA.utf8’ mais _pas_, disons, ‘uk_UA.UTF-8’.

8.7.1 Considérations sur la compatibilité des données linguistiques
-------------------------------------------------------------------

Les déclaration ‘operating-system’ fournissent un champ ‘locale-libcs’
pour spécifier les paquets GNU libc à utiliser pour compiler les
déclarations de paramètres linguistiques (*note Référence de système
d'exploitation::). « Pourquoi je devrais m’en soucier ? », vous
demandez-vous sûrement. Hé bien il se trouve que le format binaire des
données linguistique est parfois incompatible d’une version de la libc à
une autre.

   For instance, a program linked against libc version 2.21 is unable to
read locale data produced with libc 2.22; worse, that program _aborts_
instead of simply ignoring the incompatible locale data(1). Similarly, a
program linked against libc 2.22 can read most, but not all, of the
locale data from libc 2.21 (specifically, ‘LC_COLLATE’ data is
incompatible); thus calls to ‘setlocale’ may fail, but programs will not
abort.

   Le « problème » avec Guix c’est que les utilisateurs ont beaucoup de
liberté : ils peuvent choisir s’ils veulent et quand ils veulent mettre
à jour les logiciels de leur profil, et peuvent utiliser une version
différente de la libc de celle que l’administrateur système utilise pour
construire les données linguistiques du système global.

   Fortunately, unprivileged users can also install their own locale
data and define ‘GUIX_LOCPATH’ accordingly (*note ‘GUIX_LOCPATH’ and
locale packages: locales-and-locpath.).

   Cependant, c’est encore mieux si les données linguistiques du système
dans ‘/run/current-system/locale’ étaient construites avec les versions
de la libc utilisées sur le système, pour que tous les programmes
puissent y accéder — c’est surtout crucial sur un système
multi-utilisateurs. Pour cela, l’administrateur peut spécifier plusieurs
paquets de la libc dans le champ ‘locale-libcs’ de ‘operating-system’ :

     (use-package-modules base)

     (operating-system
       ;; ...
       (locale-libcs (list glibc-2.21 (canonical-package glibc))))

   Cet exemple créera un système contenant les définitions des
paramètres linguistiques pour la libc 2.21 et pour la version actuelle
de la libc dans ‘/run/current-system/locale’.

   ---------- Footnotes ----------

   (1) Versions 2.23 and later of GNU libc will simply skip the
incompatible locale data, which is already an improvement.


File: guix.fr.info,  Node: Services,  Next: Programmes setuid,  Prev: Régionalisation,  Up: Configuration système

8.8 Services
============

Une part importante de la préparation d’une déclaration
‘operating-system’ est la liste des “services systèmes” et de leur
configuration (*note Utiliser le système de configuration::). Les
services systèmes sont typiquement des démons lancés au démarrage ou
d’autres actions requises à ce moment-là — p. ex. configurer les accès
réseaux.

   Guix a une définition large de « service » (*note Composition de
services::), mais beaucoup de services sont gérés par le GNU Shepherd
(*note Services Shepherd::). Sur un système lancé, la commande ‘herd’
vous permet de lister les services disponibles, montrer leur statut, les
démarrer et les arrêter, ou faire d’autres opérations spécifiques (*note
(shepherd)Jump Start::). Par exemple :

     # herd status

   La commande ci-dessus, lancée en ‘root’, liste les services
actuellement définis. La commande ‘herd doc’ montre un synopsis du
service donné et ses actions associées :

     # herd doc nscd
     Run libc's name service cache daemon (nscd).

     # herd doc nscd action invalidate
     invalidate: Invalidate the given cache--e.g., 'hosts' for host name lookups.

   Les sous-commandes ‘start’, ‘stop’ et ‘restart’ ont l’effet auquel on
s’attend. Par exemple, les commande suivantes stoppent le service nscd
et redémarrent le serveur d’affichage Xorg :

     # herd stop nscd
     Service nscd has been stopped.
     # herd restart xorg-server
     Service xorg-server has been stopped.
     Service xorg-server has been started.

   Les sections suivantes documentent les services disponibles, en
commençant par les services de base qui peuvent être utilisés avec une
déclaration ‘operating-system’.

* Menu:

* Services de base::         Services systèmes essentiels.
* Exécution de tâches planifiées::  Le service mcron.
* Rotation des journaux::    Le service rottlog.
* Services réseau::         Paramètres réseau, démon SSH, etc.
* Système de fenêtrage X::  Affichage graphique.
* Services d'impression::    Support pour les imprimantes locales et
                               distantes.
* Services de bureaux::      D-Bus et les services de bureaux.
* Services de son::          Services ALSA et Pulseaudio.
* Services de bases de données::  Bases SQL, clefs-valeurs, etc.
* Services de courriels::    IMAP, POP3, SMTP, et tout ça.
* Services de messagerie::   Services de messagerie.
* Services de téléphonie::  Services de téléphonie.
* Services de surveillance::  Services de surveillance.
* Services Kerberos::        Services Kerberos.
* Services LDAP::            services LDAP
* Services web::             Services web.
* Services de certificats::  Certificats TLS via Let’s Encrypt.
* Services DNS::             Démons DNS.
* Services VPN::             Démons VPN.
* Système de fichiers en réseau::  Services liés à NFS.
* Intégration continue::    Le service Cuirass.
* Services de gestion de l'énergie::  Augmenter la durée de vie de la
                                         batterie.
* Services audio::           MPD.
* Services de virtualisation::  Services de virtualisation.
* Services de contrôle de version::  Fournit des accès distants à des
                                        dépôts Git.
* Services de jeu::          Serveurs de jeu.
* PAM Mount Service::        Service to mount volumes when logging in.
* Guix Services::            Services relating specifically to Guix.
* Linux Services::           Services tied to the Linux kernel.
* Hurd Services::            Services specific for a Hurd System.
* Services divers::          D’autres services.


File: guix.fr.info,  Node: Services de base,  Next: Exécution de tâches planifiées,  Up: Services

8.8.1 Services de base
----------------------

Le module ‘(gnu services base)’ fournit des définitions de services pour
les services de base qu’on peut attendre du système. Les services
exportés par ce module sort listés ci-dessous.

 -- Variable Scheme : %base-services
     Cette variable contient une liste de services de base (*note Types
     service et services::, pour plus d’informations sur les objets
     service) qu’on peut attendre du système : un service de connexion
     (mingetty) sur chaque tty, syslogd, le démon de cache de noms de la
     libc (nscd), le gestionnaire de périphériques udev, et plus.

     This is the default value of the ‘services’ field of
     ‘operating-system’ declarations. Usually, when customizing a
     system, you will want to append services to ‘%base-services’, like
     this:

          (append (list (service avahi-service-type)
                        (service openssh-service-type))
                  %base-services)

 -- Variable Scheme : special-files-service-type
     C’est le service qui met en place des « fichiers spéciaux » comme
     ‘/bin/sh’ ; une instance de ce service fait partie de
     ‘%base-services’.

     La valeur associée avec les services ‘special-files-service-type’
     doit être une liste de couples dont le premier élément est le «
     fichier spécial » et le deuxième sa cible. Par défaut il s’agit de
     :

          `(("/bin/sh" ,(file-append bash "/bin/sh")))

     Si vous voulez ajouter, disons, ‘/usr/bin/env’ à votre système,
     vous pouvez changer cela en :

          `(("/bin/sh" ,(file-append bash "/bin/sh"))
            ("/usr/bin/env" ,(file-append coreutils "/bin/env")))

     Since this is part of ‘%base-services’, you can use
     ‘modify-services’ to customize the set of special files (*note
     ‘modify-services’: Référence de service.). But the simple way to
     add a special file is via the ‘extra-special-file’ procedure (see
     below).

 -- Procédure Scheme : extra-special-file FILE TARGET
     Utilise TARGET comme « fichier spécial » FILE.

     Par exemple, ajouter l’une des lignes suivantes au champ ‘services’
     de votre déclaration de système d’exploitation crée un lien
     symbolique ‘/usr/bin/env’ :

          (extra-special-file "/usr/bin/env"
                              (file-append coreutils "/bin/env"))

 -- Procédure Scheme : host-name-service NAME
     Renvoie un service qui paramètre le nom d’hôte à NAME.

 -- Scheme Variable : console-font-service-type
     Install the given fonts on the specified ttys (fonts are per
     virtual console on the kernel Linux). The value of this service is
     a list of tty/font pairs. The font can be the name of a font
     provided by the ‘kbd’ package or any valid argument to ‘setfont’,
     as in this example:

          `(("tty1" . "LatGrkCyr-8x16")
            ("tty2" . ,(file-append
                          font-tamzen
                          "/share/kbd/consolefonts/TamzenForPowerline10x20.psf"))
            ("tty3" . ,(file-append
                          font-terminus
                          "/share/consolefonts/ter-132n"))) ; for HDPI

 -- Procédure Scheme : login-service CONFIG
     Renvoie un service pour lancer login en suivant CONFIG, un objet
     ‘<login-configuration>’ qui spécifie le message du jour, entre
     autres choses.

 -- Type de données : login-configuration
     Le type de données qui représente la configuration de login.

     ‘motd’
          Un objet simili-fichier contenant le « message du jour ».

     ‘allow-empty-passwords?’ (par défaut : ‘#t’)
          Permet les mots de passes vides par défaut pour que les
          utilisateurs puissent se connecter au compte « root » la
          première fois après sa création.

 -- Procédure Scheme : mingetty-service CONFIG
     Renvoie un service qui lance mingetty en suivant CONFIG, un objet
     ‘<mingetty-configuration>’, qui spécifie le tty à lancer entre
     autres choses.

 -- Type de données : mingetty-configuration
     C’est le type de données représentant la configuration de Mingetty,
     qui fournit l’implémentation par défaut de l’écran de connexion des
     consoles virtuelles.

     ‘tty’
          Le nom de la console sur laquelle tourne ce Mingetty, p. ex.
          ‘"tty1"’.

     ‘auto-login’ (par défaut : ‘#f’)
          Lorsque la valeur est vraie, ce champ doit être une chaîne de
          caractère dénotant le nom d’utilisateur pour lequel le système
          se connecte automatiquement. Lorsque la valeur est ‘#f’, il
          faut entrer un nom d’utilisateur et un mot de passe pour se
          connecter.

     ‘login-program’ (par défaut : ‘#f’)
          Ce doit être soit ‘#f’, auquel cas le programme de connexion
          par défaut est utilisé (‘login’ de la suite d’outils Shadow),
          soit une gexp dénotant le nom d’un programme de connexion.

     ‘login-pause?’ (par défaut : ‘#f’)
          Lorsque la valeur est ‘#t’ en plus de AUTO-LOGIN,
          l’utilisateur devrai appuyer sur une touche avant que le shell
          de connexion ne soit lancé.

     ‘mingetty’ (par défaut : MINGETTY)
          Le paquet Mingetty à utiliser.

 -- Procédure Scheme : agetty-service CONFIG
     Renvoie un service pour lancer agetty en suivant CONFIG, un objet
     ‘<agetty-configuration>’, qui spécifie le tty à lancer, entre
     autres choses.

 -- Type de données : agetty-configuration
     Ce type de données représente la configuration de agetty, qui
     implémente l’écran de connexion des consoles virtuelles et series.
     Voir la page de manuel de ‘agetty(8)’ pour plus d’informations.

     ‘tty’
          The name of the console this agetty runs on, as a string—e.g.,
          ‘"ttyS0"’. This argument is optional, it will default to a
          reasonable default serial port used by the kernel Linux.

          Pour cela, s’il y a une valeur pour une option ‘agetty.tty’
          sur la ligne de commande du noyau, agetty extraira le nom du
          périphérique du port série à partir de cette option.

          Sinon et s’il y a une valeur pour une option ‘console’ avec un
          tty sur la ligne de commande du noyau Linux, agetty extraira
          le nom du périphérique du port série et l’utilisera.

          Dans les deux cas, agetty laissera les autres paramètres du
          périphérique série (baud, etc.) sans y toucher — dans l’espoir
          que Linux leur a assigné les bonnes valeurs.

     ‘baud-rate’ (par défaut : ‘#f’)
          Une chaîne qui contient une liste d’un ou plusieurs taux de
          baud séparés par des virgules, en ordre décroissant.

     ‘term’ (par défaut : ‘#f’)
          A string containing the value used for the ‘TERM’ environment
          variable.

     ‘eight-bits?’ (par défaut : ‘#f’)
          Lorsque la valeur est ‘#t’, le tty est supposé être propre
          pour les caractères 8-bit et la détection de parité est
          désactivée.

     ‘auto-login’ (par défaut : ‘#f’)
          Lorsqu’un nom de connexion est passé comme une chaîne de
          caractères, l’utilisateur spécifié sera automatiquement
          connecté sans demande du nom d’utilisateur ni du mot de passe.

     ‘no-reset?’ (par défaut : ‘#f’)
          Lorsque la valeur est ‘#t’, ne vide pas les cflags du terminal
          (modes de contrôle).

     ‘host’ (par défaut : ‘#f’)
          This accepts a string containing the “login_host”, which will
          be written into the ‘/var/run/utmpx’ file.

     ‘remote?’ (par défaut : ‘#f’)
          Lorsque la valeur est ‘#t’ en plus de HOST, cette option
          ajoutera une option fakehost ‘-r’ à la ligne de commande du
          programme de connexion spécifié dans LOGIN-PROGRAM.

     ‘flow-control?’ (par défaut : ‘#f’)
          Lorsque la valeur est ‘#t’, active le contrôle de flux
          matériel (RTS/CTS).

     ‘no-issue?’ (par défaut : ‘#f’)
          Lorsque la valeur est ‘#t’, le contenu du fichier ‘/etc/issue’
          ne sera pas affiché avant de présenter l’écran de connexion.

     ‘init-string’ (par défaut : ‘#f’)
          Cette option accepte une chaîne de caractères qui sera envoyée
          au tty ou au modem avant toute autre chose. Elle peut être
          utilisée pour initialiser un modem.

     ‘no-clear?’ (par défaut : ‘#f’)
          Lorsque la valeur est ‘#t’, agetty ne nettoiera pas l’écran
          avant de montrer l’écran de connexion.

     ‘login-program’ (par défaut : (file-append shadow "/bin/login"))
          Cette option doit être soit une gexp dénotant le nom d’un
          programme de connexion, soit non définie, auquel cas la valeur
          par défaut est la commande ‘login’ de la suite d’outils
          Shadow.

     ‘local-line’ (par défaut : ‘#f’)
          Contrôle le drapeau CLOCAL. Cette option accepte l’un des
          trois symboles comme argument, ‘'auto’, ‘'always’ ou ‘'never’.
          Si la valeur est ‘#f’, la valeur par défaut choisie par agetty
          est ‘'auto’.

     ‘extract-baud?’ (par défaut : ‘#f’)
          Lorsque la valeur est ‘#t’, dit à agetty d’essayer d’extraire
          la taux de baud depuis les messages de statut produits par
          certains modems.

     ‘skip-login?’ (par défaut : ‘#f’)
          Lorsque la valeur est ‘#t’, ne demande par de nom
          d’utilisateur. Elle peut être utilisée avec le champ
          LOGIN-PROGRAM pour utiliser des systèmes de connexion non
          standards.

     ‘no-newline?’ (par défaut : ‘#f’)
          Lorsque la valeur est ‘#t’, n’affiche pas de retour à la ligne
          avant d’afficher le fichier ‘/etc/issue’.

     ‘login-options’ (par défaut : ‘#f’)
          Cette option accepte une chaîne de caractères contenant des
          options passées au programme login. Lorsqu’utilisé avec
          LOGIN-PROGRAM, soyez conscient qu’un utilisateur malicieux
          pourrait essayer de rentrer un nom d’utilisateur contenant des
          options incluses qui pourraient être analysées par le
          programme de connexion.

     ‘login-pause’ (par défaut : ‘#f’)
          Lorsque la valeur est ‘#t’, attend qu’une touche soit appuyée
          avant de montrer l’écran de connexion. Cela peut être utilisé
          avec AUTO-LOGIN pour sauvegarder de la mémoire en lançant les
          shells de manière fainéante.

     ‘chroot’ (par défaut : ‘#f’)
          Change de racine dans le répertoire donné. Cette option
          accepte un chemin en tant que chaîne de caractères.

     ‘hangup?’ (par défaut : ‘#f’)
          Utilise l’appel système Linux ‘vhangup’ pour raccrocher
          virtuellement le terminal spécifié.

     ‘keep-baud?’ (par défaut : ‘#f’)
          Lorsque la valeur est ‘#t’, essaye de garder le taux de baud
          existant. Les taux de baud de BAUD-RATE sont utilisés lorsque
          agetty reçoit un caractères <BREAK>.

     ‘timeout’ (par défaut : ‘#f’)
          Lorsque la valeur est un nombre entier, termine la session si
          aucun nom d’utilisateur n’a pu être lu après TIMEOUT secondes.

     ‘detect-case?’ (par défaut : ‘#f’)
          Lorsque la valeur est ‘#t’, active le support pour la
          détection des terminaux en majuscule uniquement. Ce paramètre
          détectera qu’un nom d’utilisateur qui ne contient que des
          majuscules indique un terminal en majuscule et effectuera des
          conversion de majuscule en minuscule. Remarquez que cela ne
          fonctionne pas avec les caractères unicode.

     ‘wait-cr?’ (par défaut : ‘#f’)
          Lorsque la valeur est ‘#t’, attend que l’utilisateur ou le
          modem envoie un retour chariot ou un saut de ligne avant
          d’afficher ‘/etc/issue’ ou l’écran de connexion. Cela est
          typiquement utilisé avec l’option INIT-STRING.

     ‘no-hints?’ (par défaut : ‘#f’)
          Lorsque la valeur est ‘#t’, n’affiche par les astuces à propos
          des verrouillages numériques, majuscule et défilement.

     ‘no-hostname?’ (par défaut : ‘#f’)
          Par défaut, le nom d’hôte est affiché. Lorsque la valeur est
          ‘#t’, aucun nom d’hôte ne sera affiché.

     ‘long-hostname?’ (par défaut : ‘#f’)
          Par défaut, le nom d’hôte n’est affiché qu’après le premier
          point. Lorsque la valeur est ‘#t’, le nom d’hôte pleinement
          qualifié renvoyé par ‘gethostname’ ou ‘getaddrinfo’ sera
          affiché.

     ‘erase-characters’ (par défaut : ‘#f’)
          Cette option accepte une chaîne de caractères de caractères
          supplémentaires qui devraient être interprétés comme des
          effacements lorsque l’utilisateur les tape dans leur nom
          d’utilisateur.

     ‘kill-characters’ (par défaut : ‘#f’)
          This option accepts a string that should be interpreted to
          mean “ignore all previous characters” (also called a “kill”
          character) when the user types their login name.

     ‘chdir’ (par défaut : ‘#f’)
          Cette option accepte, en tant que chaîne de caractères, un
          chemin vers un répertoire dans lequel se trouvera la commande
          avant la connexion.

     ‘delay’ (par défaut : ‘#f’)
          Cette option accepte, en tant qu’entier, le nombre de secondes
          à attendre avant d’ouvrir le tty et afficher l’écran de
          connexion.

     ‘nice’ (par défaut : ‘#f’)
          Cette option accepte, en tant qu’entier, la valeur « nice »
          avec laquelle le programme ‘login’ tourne.

     ‘extra-options’ (par défaut : ‘'()’)
          This option provides an “escape hatch” for the user to provide
          arbitrary command-line arguments to ‘agetty’ as a list of
          strings.

 -- Procédure Scheme : kmscon-service-type CONFIG
     Renvoie un service qui lance kmscon
     (https://www.freedesktop.org/wiki/Software/kmscon) d’après CONFIG,
     un objet ‘<kmscon-configuration>’, qui spécifie le tty sur lequel
     tourner, entre autres choses.

 -- Type de données : kmscon-configuration
     C’est le type de données représentant la configuration de Kscon,
     qui implémente l’écran de chargement de la console virtuelle.

     ‘virtual-terminal’
          Le nom de la console sur laquelle Kmscon tourne, p. ex.
          ‘"tty1"’.

     ‘login-program’ (par défaut : ‘#~(string-append #$shadow "/bin/login")’)
          Une gexp qui dénote le nom d’un programme de connexion. le
          programme de connexion par défaut est ‘login’ de la suite
          d’outils Shadow.

     ‘login-arguments’ (par défaut : ‘'("-p")’)
          Une liste d’arguments à passer à ‘login’.

     ‘auto-login’ (par défaut : ‘#f’)
          Lorsqu’un nom de connexion est passé comme une chaîne de
          caractères, l’utilisateur spécifié sera automatiquement
          connecté sans demande du nom d’utilisateur ni du mot de passe.

     ‘hardware-acceleration?’ (par défaut : #f)
          S’il faut utiliser l’accélération matérielle.

     ‘kmscon’ (par défaut : KMSCON)
          Le paquet Kmscon à utiliser.

 -- Procédure Scheme : nscd-service [CONFIG] [#:glibc glibc]
          [#:name-services '()]
     Renvoie un service qui lance le démon de cache de services de noms
     de la libc (nscd) avec la CONFIG donnée — un objet
     ‘<nscd-configuration>’. *Note Name Service Switch::, pour un
     exemple.

     Parce que c’est pratique, le service du Shepherd pour nscd fournit
     les actions suivantes :

     ‘invalidate’
          Cela invalide le cache donné. Par exemple, en laçant :

               herd invalidate nscd hosts

          on invalide le cache de noms d’hôtes de nscd.

     ‘statistiques’
          Lancer ‘herd statistics nscd’ affiche des informations sur
          l’utilisation de nscd et des caches.

 -- Variable Scheme : %nscd-default-configuration
     This is the default ‘<nscd-configuration>’ value (see below) used
     by ‘nscd-service’. It uses the caches defined by
     ‘%nscd-default-caches’; see below.

 -- Type de données : nscd-configuration
     C’est le type de données qui représente la configuration du démon
     de cache de services de noms (nscd).

     ‘name-services’ (par défaut : ‘'()’)
          Liste des paquets dénotant des “services de noms” qui doivent
          être visible pour nscd, p. ex. ‘(list NSS-MDNS)’.

     ‘glibc’ (par défaut : GLIBC)
          Objet de paquet qui dénote la Bibliothèque C de GNU qui
          fournit la commande ‘nscd’.

     ‘log-file’ (par défaut : ‘"/var/log/nscd.log"’)
          Nom du fichier journal de nscd. C’est là que les sorties de
          débogage sont envoyée lorsque ‘debug-level’ est strictement
          positif.

     ‘debug-level’ (par défaut : ‘0’)
          Entier qui dénote le niveau de débogage. Les entiers les plus
          grands signifient plus de sortie de débogage.

     ‘caches’ (default: ‘%nscd-default-caches’)
          Liste d’objets ‘<nscd-cache>’ qui dénotent des choses à mettre
          en cache ; voir plus bas.

 -- Type de données : nscd-cache
     Type de données représentant une base de données de cache de nscd
     et ses paramètres.

     ‘database’
          C’est un symbole qui représente le nom de la base de donnée à
          mettre en cache. Les valeurs valide sont ‘passwd’, ‘group’,
          ‘hosts’ et ‘services’ qui désignent les bases de données NSS
          correspondantes (*note (libc)NSS Basics::).

     ‘positive-time-to-live’
     ‘negative-time-to-live’ (par défaut : ‘20’)
          Un entier qui représente le nombre de secondes pendant
          lesquelles un résultat positif ou négatif reste en cache.

     ‘check-files?’ (par défaut : ‘#t’)
          Indique s’il faut vérifier des mises à jours dans les fichiers
          correspondant à DATABASE.

          Par exemple, lorsque DATABASE est ‘hosts’, ce drapeau indique
          à nscd de vérifier s’il y a des mises à jour de ‘/etc/hosts’
          et de les prendre en compte.

     ‘persistent?’ (par défaut : ‘#t’)
          Indique si le cache devrait être stocké de manière persistante
          sur le disque.

     ‘shared?’ (par défaut : ‘#t’)
          Indique si le cache devrait être partagé entre les
          utilisateurs.

     ‘max-database-size’ (par défaut : 32 MiB)
          Taille maximale en octets de la base de données en cache.

 -- Variable Scheme : %nscd-default-caches
     Liste d’objets ‘<nscd-cache>’ utilisés par défaut par
     ‘nscd-configuration’ (voir plus haut).

     Elle active la mise en cache persistante et agressive des
     recherches de services et de noms d’hôtes. Ces derniers fournissent
     une recherche de noms d’hôtes plus performante, résiliente face à
     des serveurs de noms peu fiables et une protection de votre vie
     privée plus efficace — souvent le résultat des recherches de noms
     d’hôtes sont dans le cache local, donc les serveurs de nom externes
     n’ont même pas besoin d’être questionnés.

 -- Type de données : syslog-configuration
     Ce type de données représente la configuration du démon syslog.

     ‘syslogd’ (par défaut : ‘#~(string-append #$inetutils "/libexec/syslogd")’)
          Le démon syslog à utiliser.

     ‘config-file’ (par défaut : ‘%default-syslog.conf’)
          Le fichier de configuration de syslog à utiliser.

 -- Procédure Scheme : syslog-service CONFIG
     Renvoie un service qui lance un démon syslog en suivant CONFIG.

     *Note (inetutils)syslogd invocation::, pour plus d’informations sur
     la syntaxe du fichier de configuration.

 -- Variable Scheme : guix-service-type
     C’est le type de service qui lance le démon de construction,
     ‘guix-daemon’ (*note Invoquer guix-daemon::). Sa valeur doit être
     un enregistrement ‘guix-configuration’ décrit plus bas.

 -- Type de données : guix-configuration
     Ce type de données représente la configuration du démon de
     construction de Guix. *Note Invoquer guix-daemon:: pour plus
     d’informations.

     ‘guix’ (par défaut : GUIX)
          Le paquet Guix à utiliser.

     ‘build-group’ (par défaut : ‘"guixbuild"’)
          Nom du groupe des comptes utilisateurs de construction.

     ‘build-accounts’ (par défaut : ‘10’)
          Nombre de comptes utilisateurs de construction à créer.

     ‘authorize-key?’ (par défaut : ‘#t’)
          Indique s’il faut autoriser ou non les clefs de substituts
          listées dans ‘authorize-keys’ — par défaut celle de
          ‘ci.guix.gnu.org’ (*note Substituts::).

     ‘authorized-keys’ (default: ‘%default-authorized-guix-keys’)
          La liste des fichiers de clefs autorisées pour les imports
          d’archives, en tant que liste de gexps sous forme de chaînes
          (*note Invoquer guix archive::). Par défaut, elle contient
          celle de ‘ci.guix.gnu.org’ (*note Substituts::).

     ‘use-substitutes?’ (par défaut : ‘#t’)
          S’il faut utiliser les substituts.

     ‘substitute-urls’ (default: ‘%default-substitute-urls’)
          La liste des URL où trouver des substituts par défaut.

     ‘max-silent-time’ (par défaut : ‘0’)
     ‘timeout’ (par défaut : ‘0’)
          Le nombre de secondes de silence et le nombre de secondes
          d’inactivité, respectivement, après lesquelles un processus de
          construction son délai d’attente. Une valeur de zéro désactive
          le délai d’attente.

     ‘log-compression’ (par défaut : ‘'bzip2’)
          Le type de compression utilisé par les journaux de
          construction — parmi ‘gzip’, ‘bzip2’ et ‘none’.

     ‘extra-options’ (par défaut : ‘'()’)
          Liste d’options supplémentaires de la ligne de commande pour
          ‘guix-daemon’.

     ‘log-file’ (par défaut : ‘"/var/log/guix-daemon.log"’)
          Le fichier où les sorties standard et d’erreur de
          ‘guix-daemon’ sont écrites.

     ‘http-proxy’ (par défaut : ‘#f’)
          The URL of the HTTP and HTTPS proxy used for downloading
          fixed-output derivations and substitutes.

          It is also possible to change the daemon’s proxy at run time
          through the ‘set-http-proxy’ action, which restarts it:

               herd set-http-proxy guix-daemon http://localhost:8118

          To clear the proxy settings, run:

               herd set-http-proxy guix-daemon

     ‘tmpdir’ (par défaut : ‘#f’)
          Un répertoire où ‘guix-daemon’ effectuera ses constructions.

 -- Procédure Scheme : udev-service [#:udev EUDEV #:rules ‘'()’]
     Run UDEV, which populates the ‘/dev’ directory dynamically. udev
     rules can be provided as a list of files through the RULES
     variable. The procedures ‘udev-rule’, ‘udev-rules-service’ and
     ‘file->udev-rule’ from ‘(gnu services base)’ simplify the creation
     of such rule files.

     La commande ‘herd rules udev’, en tant que root, renvoie le nom du
     répertoire contenant toutes les règles udev actives.

 -- Procédure Scheme : udev-rule [FILE-NAME CONTENTS]
     Renvoie un fichier de règle udev nommé FILE-NAME contenant les
     règles définie par le littéral CONTENTS.

     Dans l’exemple suivant, on définie une règle pour un périphérique
     USB qui sera stockée dans le fichier ‘90-usb-thing.rules’. La règle
     lance un script à la détection du périphérique USB avec
     l’identifiant de produit donné.

          (define %example-udev-rule
            (udev-rule
              "90-usb-thing.rules"
              (string-append "ACTION==\"add\", SUBSYSTEM==\"usb\", "
                             "ATTR{product}==\"Example\", "
                             "RUN+=\"/path/to/script\"")))

 -- Scheme Procedure : udev-rules-service [NAME RULES] [#:groups GROUPS]
          Return a service that extends
     ‘udev-service-type ’ with RULES and ‘account-service-type’ with
     GROUPS as system groups. This works by creating a singleton service
     type ‘NAME-udev-rules’, of which the returned service is an
     instance.

     Here we show how it can be used to extend ‘udev-service-type’ with
     the previously defined rule ‘%example-udev-rule’.

          (operating-system
           ;; ...
           (services
             (cons (udev-rules-service 'usb-thing %example-udev-rule)
                   %desktop-services)))

 -- Procédure Scheme : file->udev-rule [FILE-NAME FILE]
     Renvoie un fichier udev nommé FILE-NAME contenant les règles
     définies dans FILE, un objet simili-fichier.

     L’exemple suivant montre comment utiliser un fichier de règles
     existant.

          (use-modules (guix download)     ;for url-fetch
                       (guix packages)     ;for origin
                       ...)

          (define %android-udev-rules
            (file->udev-rule
              "51-android-udev.rules"
              (let ((version "20170910"))
                (origin
                 (method url-fetch)
                 (uri (string-append "https://raw.githubusercontent.com/M0Rf30/"
                                     "android-udev-rules/" version "/51-android.rules"))
                 (sha256
                  (base32 "0lmmagpyb6xsq6zcr2w1cyx9qmjqmajkvrdbhjx32gqf1d9is003"))))))

   En plus, les définitions des paquets de Guix peuvent être inclus dans
RULES pour étendre les règles avec les définitions trouvées dans leur
sous-répertoire ‘lib/udev/rules.d’. Au lieu de l’exemple FILE->UDEV-RULE
précédent, on aurait pu utiliser le paquet ANDROID-UDEV-RULES qui existe
dans le module ‘(gnu packages android)’.

   The following example shows how to use the ANDROID-UDEV-RULES package
so that the Android tool ‘adb’ can detect devices without root
privileges. It also details how to create the ‘adbusers’ group, which is
required for the proper functioning of the rules defined within the
‘android-udev-rules’ package. To create such a group, we must define it
both as part of the ‘supplementary-groups’ of our ‘user-account’
declaration, as well as in the GROUPS of the ‘udev-rules-service’
procedure.

     (use-modules (gnu packages android)  ;for android-udev-rules
                  (gnu system shadow)     ;for user-group
                  ...)

     (operating-system
       ;; ...
       (users (cons (user-account
                     ;; ...
                     (supplementary-groups
                      '("adbusers"   ;for adb
                        "wheel" "netdev" "audio" "video")))))
       ;; ...
       (services
         (cons (udev-rules-service 'android android-udev-rules
                                   #:groups '("adbusers"))
               %desktop-services)))

 -- Variable Scheme : urandom-seed-service-type
     Save some entropy in ‘%random-seed-file’ to seed ‘/dev/urandom’
     when rebooting. It also tries to seed ‘/dev/urandom’ from
     ‘/dev/hwrng’ while booting, if ‘/dev/hwrng’ exists and is readable.

 -- Variable Scheme : %random-seed-file
     C’est le nom du fichier où des octets aléatoires sont sauvegardés
     par URANDOM-SEED-SERVICE pour démarrer ‘/dev/urandom’ au
     redémarrage. Sa valeur par défaut est ‘/var/lib/random-seed’.

 -- Variable Scheme : gpm-service-type
     C’est le type du service qui lance GPM, le “démon de souris à but
     général”, qui fournit le support de la souris sur la console Linux.
     GPM permet aux utilisateurs d’utiliser la souris dans la console,
     entre autres pour sélectionner, copier et coller du texte.

     The value for services of this type must be a ‘gpm-configuration’
     (see below). This service is not part of ‘%base-services’.

 -- Type de données : gpm-configuration
     Type de données représentant la configuration de GPM.

     ‘options’ (par défaut : ‘%default-gpm-options’)
          Les options de la ligne de commande à passer à ‘gpm’.
          L’ensemble des options par défaut dit à ‘gpm’ d’écouter les
          événements de la souris dans ‘/dev/input/mice’. *Note
          (gpm)Command Line::, pour plus d’informations.

     ‘gpm’ (par défaut : ‘gpm’)
          Le paquet GPM à utiliser.

 -- Variable Scheme : guix-publish-service-type
     This is the service type for ‘guix publish’ (*note Invoquer guix
     publish::). Its value must be a ‘guix-publish-configuration’
     object, as described below.

     Ce service suppose que ‘/etc/guix’ contient déjà une paire de clefs
     créée par ‘guix archive --generate-key’ (*note Invoquer guix
     archive::). Si ce n’est pas le cas, le service ne démarrera pas.

 -- Type de données : guix-publish-configuration
     Le type de données représentant la configuration du service ‘guix
     publish’.

     ‘guix’ (par défaut : ‘guix’)
          Le paquet Guix à utiliser.

     ‘port’ (par défaut : ‘80’)
          Le port TCP sur lequel écouter les connexions.

     ‘host’ (par défaut : ‘"localhost"’)
          L’hôte (et donc, l’interface réseau) sur lequel écouter.
          Utilisez ‘"0.0.0.0"’ pour écouter sur toutes les interfaces
          réseaux.

     ‘compression’ (default: ‘'(("gzip" 3))’)
          This is a list of compression method/level tuple used when
          compressing substitutes. For example, to compress all
          substitutes with _both_ lzip at level 7 and gzip at level 9,
          write:

               '(("lzip" 7) ("gzip" 9))

          Level 9 achieves the best compression ratio at the expense of
          increased CPU usage, whereas level 1 achieves fast
          compression.

          An empty list disables compression altogether.

     ‘nar-path’ (par défaut : ‘"nar"’)
          The URL path at which “nars” can be fetched. *Note
          ‘--nar-path’: Invoquer guix publish, for details.

     ‘cache’ (par défaut : ‘#f’)
          Lorsque la valeur est ‘#f’, désactive le cache et génère les
          archives à la demande. Sinon, cela devrait être le nom d’un
          répertoire — p. ex. ‘"/var/cache/guix/publish"’ — où ‘guix
          publish’ gère le cache des archives et des métadonnées prêtes
          à être envoyées. *Note ‘--cache’: Invoquer guix publish, pour
          plus d’informations sur les compromis impliqués.

     ‘workers’ (par défaut : ‘#f’)
          Lorsque la valeur est un entier, c’est le nombre de threads de
          travail utilisés pour le cache ; lorsque la valeur est ‘#f’,
          le nombre de processeurs est utilisé. *Note ‘--workers’:
          Invoquer guix publish, pour plus d’informations.

     ‘ttl’ (par défaut : ‘#f’)
          Lorsque la valeur est un entier, il dénote la “durée de vie”
          en secondes des archives publiées. *Note ‘--ttl’: Invoquer
          guix publish, pour plus d’informations.

 -- Procédure Scheme : rngd-service [#:rng-tools RNG-TOOLS] [#:device
          "/dev/hwrng"]
     Renvoie un service qui lance le programme ‘rngd’ de RNG-TOOLS pour
     ajouter DEVICE à la réserve d’entropie du noyau. Le service
     échouera si DEVICE n’existe pas.

 -- Procédure Scheme : pam-limits-service [#:limits ‘'()’]

     Renvoie un service qui installe un fichier de configuration pour le
     module ‘pam_limits’
     (http://linux-pam.org/Linux-PAM-html/sag-pam_limits.html). La
     procédure prend éventuellement une liste de valeurs
     ‘pam-limits-entry’ qui peuvent être utilisées pour spécifier les
     limites ‘ulimit’ et les priorités des sessions utilisateurs.

     La définition de limites suivante défini deux limites matérielles
     et logicielles pour toutes les sessions connectées des utilisateurs
     du groupe ‘realtime’ :

          (pam-limits-service
           (list
            (pam-limits-entry "@realtime" 'both 'rtprio 99)
            (pam-limits-entry "@realtime" 'both 'memlock 'unlimited)))

     La première entrée augment la priorité en temps réel maximale des
     processus non privilégiés ; la deuxième entrée abandonne les
     restrictions sur l’espace d’adressage maximal qui peut être
     verrouillé en mémoire. Ces paramètres sont souvent utilisés sur les
     systèmes audio temps-réel.


File: guix.fr.info,  Node: Exécution de tâches planifiées,  Next: Rotation des journaux,  Prev: Services de base,  Up: Services

8.8.2 Exécution de tâches planifiées
------------------------------------

Le module ‘(gnu services mcron)’ fournit une interface pour GNU mcron,
un démon qui lance des tâches planifiées (*note (mcron)Top::). GNU mcron
est similaire au démon Unix traditionnel ‘cron’ ; la principale
différence est qu’il est implémenté en Guile Scheme, qui fournit
beaucoup de flexibilité lors de la spécification de la planification des
tâches et de leurs actions.

   L’exemple en dessous définit un système d’exploitation qui lance les
commandes ‘updatebd’ (*note (find)Invoking updatedb::) et ‘guix gc’
(*note Invoquer guix gc::) tous les jours, ainsi que la commande ‘mkid’
en tant qu’utilisateur non privilégié (*note (idutils)mkid
invocation::). Il utilise des gexps pour introduire des définitions de
tâches qui sont passées à mcron (*note G-Expressions::).

     (use-modules (guix) (gnu) (gnu services mcron))
     (use-package-modules base idutils)

     (define updatedb-job
       ;; Lance « updatedb » à 3h du matin chaque jour.  Ici nous spécifions
       ;; l'action de la tâche comme une procédure Scheme.
       #~(job '(next-hour '(3))
              (lambda ()
                (execl (string-append #$findutils "/bin/updatedb")
                       "updatedb"
                       "--prunepaths=/tmp /var/tmp /gnu/store"))))

     (define garbage-collector-job
       ;; Lance le ramasse-miettes tous les jours à minuit cinq.
       ;; L'action de la tâche est une commande shell.
       #~(job "5 0 * * *"            ;Vixie cron syntax
              "guix gc -F 1G"))

     (define idutils-job
       ;; Met à jour la base de données d'index en tant que « charlie » à 12h15
       ;; et 19h15.  La commande est lancée depuis le répertoire personnel de l'utilisateur.
       #~(job '(next-minute-from (next-hour '(12 19)) '(15))
              (string-append #$idutils "/bin/mkid src")
              #:user "charlie"))

     (operating-system
       ;; ...
       (services (cons (service mcron-service-type
                                (mcron-configuration
                                 (jobs (list garbage-collector-job
                                             updatedb-job
                                             idutils-job))))
                       %base-services)))

   For more complex jobs defined in Scheme where you need control over
the top level, for instance to introduce a ‘use-modules’ form, you can
move your code to a separate program using the ‘program-file’ procedure
of the ‘(guix gexp)’ module (*note G-Expressions::). The example below
illustrates that.

     (define %battery-alert-job
       ;; Beep when the battery percentage falls below %MIN-LEVEL.
       #~(job
          '(next-minute (range 0 60 1))
          #$(program-file
             "battery-alert.scm"
             (with-imported-modules (source-module-closure
                                     '((guix build utils)))
               #~(begin
                   (define %min-level 20)
                   (use-modules (guix build utils)
                                (ice-9 popen)
                                (ice-9 regex)
                                (ice-9 textual-ports)
                                (srfi srfi-2))
                   (setenv "LC_ALL" "C")     ;ensure English output
                   (and-let* ((input-pipe (open-pipe*
                                           OPEN_READ
                                           #$(file-append acpi "/bin/acpi")))
                              (output (get-string-all input-pipe))
                              (m (string-match "Discharging, ([0-9]+)%" output))
                              (level (string->number (match:substring m 1)))
                              ((< level %min-level)))
                     (format #t "warning: Battery level is low (~a%)~%" level)
                     (invoke #$(file-append beep "/bin/beep") "-r5")))))))

   *Note mcron job specifications: (mcron)Guile Syntax, pour plus
d’informations sur les spécifications des tâche de mcron. Ci-dessous est
la référence du service mcron.

   Sur un système lancé, vous pouvez utiliser l’action ‘schedule’ du
service pour visualiser les travaux mcron qui seront exécutés ensuite :

     # herd schedule mcron

Cet exemple ci-dessus montre les cinq tâches qui seront exécutés, mais
vous pouvez spécifier le nombre de tâches à afficher :

     # herd schedule mcron 10

 -- Variable Scheme : mcron-service-type
     C’est le type du service ‘mcron’, dont la valeur est un objet
     ‘mcron-configuration’

     Ce type de service peut être la cible d’une extension de service
     qui lui fournit des spécifications de tâches supplémentaires (*note
     Composition de services::). En d’autres termes, il est possible de
     définir des services qui fournissent des tâches mcron à lancer.

 -- Type de données : mcron-configuration
     Type données qui représente la configuration de mcron.

     ‘mcron’ (par défaut : MCRON)
          Le paquet mcron à utiliser.

     ‘jobs’
          C’est la liste des gexps (*note G-Expressions::), où chaque
          gexp correspond à une spécification de tâche de mcron (*note
          mcron job specifications: (mcron)Syntax.).


File: guix.fr.info,  Node: Rotation des journaux,  Next: Services réseau,  Prev: Exécution de tâches planifiées,  Up: Services

8.8.3 Rotation des journaux
---------------------------

Les fichiers journaux comme ceux qui se trouvent dans ‘/var/log’ ont
tendance à grandir sans fin, donc c’est une bonne idée de le “faire
tourner” de temps à autres — c.-à-d. archiver leur contenu dans des
fichiers séparés, potentiellement compressés. Le module ‘(gnu services
admin)’ fournit une interface pour GNU Rot[t]log, un outil de rotation
de journaux (*note (rottlog)Top::).

   This service is part of ‘%base-services’, and thus enabled by
default, with the default settings, for commonly encountered log files.
The example below shows how to extend it with an additional “rotation”,
should you need to do that (usually, services that produce log files
already take care of that):

     (use-modules (guix) (gnu))
     (use-service-modules admin)

     (define my-log-files
       ;; Log files that I want to rotate.
       '("/var/log/something.log" "/var/log/another.log"))

     (operating-system
       ;; ...
       (services (cons (simple-service 'rotate-my-stuff
                                       rottlog-service-type
                                       (list (log-rotation
                                              (frequency 'daily)
                                              (files my-log-files))))
                       %base-services)))

 -- Variable Scheme : rottlog-service-type
     C’est le type du service Rotlog, dont la valeur est un objet
     ‘rottlog-configuration’.

     D’autres services peuvent étendre celui-ci avec de nouveaux objets
     ‘log-rotation’ (voir plus bas), en augmentant ainsi l’ensemble des
     fichiers à faire tourner.

     Ce type de service peut définir des taches (*note Exécution de
     tâches planifiées::) pour lancer le service rottlog.

 -- Type de données : rottlog-configuration
     Type de données représentant la configuration de rottlog.

     ‘rottlog’ (par défaut : ‘rottlog’)
          Le paquet Rottlog à utiliser.

     ‘rc-file’ (par défaut : ‘(file-append rottlog "/etc/rc")’)
          Le fichier de configuration Rottlog à utiliser (*note
          (rottlog)Mandatory RC Variables::).

     ‘rotations’ (par défaut : ‘%default-rotations’)
          Une liste d’objets ‘log-rotation’ définis plus bas.

     ‘jobs’
          C’est une liste de gexps où chaque gexp correspond à une
          spécification de tache de mcron (*note Exécution de tâches
          planifiées::).

 -- Type de données : log-rotation
     Type de données représentant la rotation d’un groupe de fichiers
     journaux.

     En reprenant un exemple du manuel de Rottlog (*note (rottlog)Period
     Related File Examples::), on peut définir la rotation d’un journal
     de cette manière :

          (log-rotation
            (frequency 'daily)
            (files '("/var/log/apache/*"))
            (options '("storedir apache-archives"
                       "rotate 6"
                       "notifempty"
                       "nocompress")))

     La liste des champs est la suivante :

     ‘frequency’ (par défaut : ‘'weekly’)
          La fréquence de rotation, un symbole.

     ‘files’
          La liste des fichiers ou des motifs de noms de fichiers à
          faire tourner.

     ‘options’ (par défaut : ‘'()’)
          La liste des options de rottlog pour cette rotation (*note
          (rottlog)Configuration parameters::).

     ‘post-rotate’ (par défaut : ‘#f’)
          Soit ‘#f’, soit une gexp à exécuter une fois la rotation
          terminée.

 -- Variable Scheme : %default-rotations
     Specifies weekly rotation of ‘%rotated-files’ and of
     ‘/var/log/guix-daemon.log’.

 -- Variable Scheme : %rotated-files
     The list of syslog-controlled files to be rotated. By default it
     is: ‘'("/var/log/messages" "/var/log/secure" "/var/log/debug" \
     "/var/log/maillog")’.

