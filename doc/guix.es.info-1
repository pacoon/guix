This is guix.es.info, produced by makeinfo version 6.7 from
guix.es.texi.

Copyright © 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020 Ludovic
Courtès
Copyright © 2013, 2014, 2016 Andreas Enge
Copyright © 2013 Nikita Karetnikov
Copyright © 2014, 2015, 2016 Alex Kost
Copyright © 2015, 2016 Mathieu Lirzin
Copyright © 2014 Pierre-Antoine Rault
Copyright © 2015 Taylan Ulrich Bayırlı/Kammer
Copyright © 2015, 2016, 2017, 2019, 2020 Leo Famulari
Copyright © 2015, 2016, 2017, 2018, 2019, 2020 Ricardo Wurmus
Copyright © 2016 Ben Woodcroft
Copyright © 2016, 2017, 2018 Chris Marusich
Copyright © 2016, 2017, 2018, 2019, 2020 Efraim Flashner
Copyright © 2016 John Darrington
Copyright © 2016, 2017 Nikita Gillmann
Copyright © 2016, 2017, 2018, 2019, 2020 Jan Nieuwenhuizen
Copyright © 2016, 2017, 2018, 2019, 2020 Julien Lepiller
Copyright © 2016 Alex ter Weele
Copyright © 2016, 2017, 2018, 2019 Christopher Baines
Copyright © 2017, 2018, 2019 Clément Lassieur
Copyright © 2017, 2018 Mathieu Othacehe
Copyright © 2017 Federico Beffa
Copyright © 2017, 2018 Carlo Zancanaro
Copyright © 2017 Thomas Danckaert
Copyright © 2017 humanitiesNerd
Copyright © 2017 Christopher Allan Webber
Copyright © 2017, 2018, 2019, 2020 Marius Bakke
Copyright © 2017, 2019, 2020 Hartmut Goebel
Copyright © 2017, 2019, 2020 Maxim Cournoyer
Copyright © 2017, 2018, 2019, 2020 Tobias Geerinckx-Rice
Copyright © 2017 George Clemmer
Copyright © 2017 Andy Wingo
Copyright © 2017, 2018, 2019 Arun Isaac
Copyright © 2017 nee
Copyright © 2018 Rutger Helling
Copyright © 2018 Oleg Pykhalov
Copyright © 2018 Mike Gerwitz
Copyright © 2018 Pierre-Antoine Rouby
Copyright © 2018, 2019 Gábor Boskovits
Copyright © 2018, 2019 Florian Pelz
Copyright © 2018 Laura Lazzati
Copyright © 2018 Alex Vong
Copyright © 2019 Josh Holland
Copyright © 2019, 2020 Diego Nicola Barbato
Copyright © 2019 Ivan Petkov
Copyright © 2019 Jakob L. Kreuze
Copyright © 2019 Kyle Andrews
Copyright © 2019 Alex Griffin
Copyright © 2019 Guillaume Le Vaillant
Copyright © 2020 Leo Prikler
Copyright © 2019, 2020 Simon Tournier
Copyright © 2020 Wiktor Żelazny
Copyright © 2020 Damien Cassou
Copyright © 2020 Jakub Kądziołka
Copyright © 2020 Jack Hill
Copyright © 2020 Naga Malleswari
Copyright © 2020 Brice Waegeneire
Copyright © 2020 R Veera Kumar
Copyright © 2020 Pierre Langlois
Copyright © 2020 pinoaffe

   Se garantiza el permiso de copia, distribución y/o modificación de
este documento bajo los términos de la licencia de documentación libre
de GNU (GNU Free Documentation License), versión 1.3 o cualquier versión
posterior publicada por la Free Software Foundation; sin secciones
invariantes, sin textos de cubierta delantera ni trasera. Una copia de
la licencia está incluida en la sección titulada “GNU Free Documentation
License”.
INFO-DIR-SECTION Administración del sistema
START-INFO-DIR-ENTRY
* Guix: (guix.es).           Gestión del software instalado y la
                               configuración del sistema.
* guix package: (guix.es)Invocación de guix package.  Instalación, borrado
                                                         y actualización de
                                                         paquetes.
* guix gc: (guix.es)Invocación de guix gc.  Recuperar espacio de disco sin
                                               usar.
* guix pull: (guix.es)Invocación de guix pull.  Actualización de la lista
                                                   disponible de paquetes.
* guix system: (guix.es)Invocación de guix system.  Gestión de la
                                                       configuración del
                                                       sistema operativo.
* guix deploy: (guix.es)Invocación de guix deploy.  Gestión de
                                                       configuraciones de
                                                       sistemas operativos en
                                                       máquinas remotas.
END-INFO-DIR-ENTRY

INFO-DIR-SECTION Desarrollo de software
START-INFO-DIR-ENTRY
* guix environment: (guix.es)Invocación de guix environment.  Construcción
                                                                 de entornos
                                                                 de desarrollo
                                                                 con Guix.
* guix build: (guix.es)Invocación de guix build.  Construcción de
                                                     paquetes.
* guix pack: (guix.es)Invocación de guix pack.  Creación de empaquetados
                                                   binarios.
END-INFO-DIR-ENTRY


File: guix.es.info,  Node: Top,  Next: Introducción,  Up: (dir)

GNU Guix
********

Este documento describe GNU Guix versión 1.0.1.17089-7e269, una
herramienta funcional de gestión de paquetes escrita para el sistema
GNU.

   Este manual también está disponible en chino simplificado (*note
(guix.zh_CN)Top::), francés (*note (guix.fr)Top::), alemán (*note
(guix.de)Top::), ruso (*note (guix.ru)Top::) y la versión original en
inglés (*note (guix)Top::). Si desea traducirlo en su lengua nativa,
considere unirse al Translation Project
(https://translationproject.org/domain/guix-manual.html).

   Este manual se está traducido prácticamente al completo al
castellano, pero es posible que se ocasionalmente algún fragmento sin
traducir aquí y allá, debido a modificaciones al texto original en
inglés del manual. Si encuentra fallos en esta traducción, o simplemente
quiere colaborar en su evolución y mejora, le rogamos que nos contacte a
través de la información de contacto del equipo de traducción
(https://translationproject.org/team/es.html).

* Menu:

* Introducción::            ¿Qué es esto de Guix?
* Instalación::             Instalar Guix.
* Instalación del sistema::  Instalar el sistema operativo completo.
* Gestión de paquetes::     Instalación de paquetes, actualización, etc.
* Desarrollo::               Desarrollo de software asistido por Guix.
* Interfaz programática::   Uso de Guix en Scheme.
* Utilidades::               Órdenes de gestión de paquetes.
* Configuración del sistema::  Configurar el sistema operativo.
* Documentación::           Navegar por los manuales de usuaria del
                               software.
* Instalación de ficheros de depuración::  Alimentación del depurador.
* Actualizaciones de seguridad::  Desplegar correcciones de seguridad
                                    rápidamente.
* Lanzamiento inicial::      GNU/Linux construido de cero.
* Transportar::              Adaptación para otra plataforma o núcleo.
* Contribuir::               ¡Se necesita su ayuda!

* Reconocimientos::          ¡Gracias!
* Licencia de documentación libre GNU::  La licencia de este manual.
* Índice de conceptos::     Conceptos.
* Índice programático::    Tipos de datos, funciones y variables.

 — La lista detallada de nodos —



Introducción



* Gestión de software con Guix::  Qué es especial.
* Distribución GNU::        Los paquetes y herramientas.

Instalación



* Instalación binaria::     ¡Poner Guix en funcionamiento en nada de
                               tiempo!
* Requisitos::               Software necesario para construir y ejecutar
                               Guix.
* Ejecución de la batería de pruebas::  Probar Guix.
* Preparación del daemon::  Preparar el entorno del daemon de
                               construcción.
* Invocación de guix-daemon::  Ejecutar el daemon de construcción.
* Configuración de la aplicación::  Configuración específica de la
                                        aplicación.

Preparación del daemon



* Configuración del entorno de construcción::  Preparar el entorno aislado
                                                   de construcción.
* Configuración de delegación del daemon::  Delegar construcciones a
                                                máquinas remotas.
* Soporte de SELinux::       Uso de una política SELinux para el daemon.

Instalación del sistema



* Limitaciones::             Qué puede esperar.
* Consideraciones sobre el hardware::  Hardware soportado.
* Instalación desde memoria USB y DVD::  Preparar el medio de instalación.
* Preparación para la instalación::  Red, particionado, etc.
* Instalación gráfica guiada::  Instalación gráfica fácil.
* Instalación manual::      Instalación manual para artistas del teclado.
* Tras la instalación del sistema::  Cuando la instalación ha finalizado
                                        satisfactoriamente.
* Instalación de Guix en una máquina virtual::  El patio de recreo del
                                                    sistema Guix.
* Construcción de la imagen de instalación::  Cómo esto llega a ser.

Instalación manual



* Distribución de teclado y red y particionado::  Configuración inicial.
* Procedimiento de instalación::  Instalación.

Gestión de paquetes



* Características::         Cómo Guix dará brillo a su vida.
* Invocación de guix package::  Instalación de paquetes, borrado, etc.
* Sustituciones::            Descargar binarios pre-construidos.
* Paquetes con múltiples salidas::  Un único paquete de fuentes,
                                       múltiples salidas.
* Invocación de guix gc::   Ejecutar el recolector de basura.
* Invocación de guix pull::  Obtener la última versión de Guix y la
                                distribución.
* Canales::                  Personalizar el recolector de basura.
* Invocación de guix time-machine::  Ejecutar una versión antigua de Guix.
* Inferiores::               Interactuar con otra revisión de Guix.
* Invocación de guix describe::  Muestra información acerca de su
                                    revisión de Guix.
* Invocación de guix archive::  Exportar e importar ficheros del almacén.

Sustituciones



* Servidor oficial de sustituciones.::  Una fuente particular de
                                          sustituciones.
* Autorización de servidores de sustituciones::  Cómo activar o desactivar
                                                    las sustituciones.
* Verificación de sustituciones::  Cómo verifica las sustituciones Guix.
* Configuración de la pasarela.::  Cómo obtener sustituciones a través de
                                      una pasarela.
* Fallos en las sustituciones::  Qué pasa cuando una sustitución falla.
* Sobre la confianza en binarios::  ¿Cómo puede confiar en esa masa amorfa
                                      de datos binarios?

Desarrollo



* Invocación de guix environment::  Configurar entornos de desarrollo.
* Invocación de guix pack::  Creación de empaquetados de software.
* La cadena de herramientas de GCC::  Working with languages supported by
                                        GCC.

Interfaz programática



* Módulos de paquetes::     Paquetes bajo el punto de vista del
                               programador.
* Definición de paquetes::  Definir nuevos paquetes.
* Sistemas de construcción::  Especificar como se construyen los paquetes.
* El almacén::              Manipular el almacén de paquetes.
* Derivaciones::             Interfaz de bajo nivel de las derivaciones de
                               los paquetes.
* La mónada del almacén::  Interfaz puramente funcional del almacén.
* Expresiones-G::            Manipular expresiones de construcción.
* Invocación de guix repl::  Enredar con Guix interactivamente.

Definición de paquetes



* Referencia de package::    El tipo de datos de los paquetes.
* Referencia de origin::     El tipo de datos de orígenes.

Utilidades



* Invocación de guix build::  Construir paquetes desde la línea de
                                 órdenes.
* Invocación de guix edit::  Editar las definiciones de paquetes.
* Invocación de guix download::  Descargar un fichero e imprimir su hash.
* Invocación de guix hash::  Calcular el hash criptográfico de un fichero.
* Invocación de guix import::  Importar definiciones de paquetes.
* Invocación de guix refresh::  Actualizar definiciones de paquetes.
* Invocación de guix lint::  Encontrar errores en definiciones de paquetes.
* Invocación de guix size::  Perfilar el uso del disco.
* Invocación de guix graph::  Visualizar el grafo de paquetes.
* Invocación de guix publish::  Compartir sustituciones.
* Invocación de guix challenge::  Poner a prueba servidores de
                                     sustituciones.
* Invocación de guix copy::  Copiar a y desde un almacén remoto.
* Invocación de guix container::  Aislamiento de procesos.
* Invocación de guix weather::  Comprobar la disponibilidad de
                                   sustituciones.
* Invocación de guix processes::  Enumerar los procesos cliente.

Invocación de ‘guix build’



* Opciones comunes de construcción::  Opciones de construcción para la
                                         mayoría de órdenes.
* Opciones de transformación de paquetes::  Crear variantes de paquetes.
* Opciones de construcción adicionales::  Opciones específicas de ’guix
                                             build’.
* Depuración de fallos de construcción::  Experiencia de empaquetamiento
                                              en la vida real.

Configuración del sistema



* Uso de la configuración del sistema::  Personalizar su sistema GNU.
* Referencia de operating-system::  Detalle de las declaraciones de sistema
                                      operativo.
* Sistemas de ficheros::     Configurar el montaje de sistemas de ficheros.
* Dispositivos traducidos::  Procesamiento adicional de dispositivos de
                               bloques.
* Cuentas de usuaria::       Especificar las cuentas de usuaria.
* Distribución de teclado::  Cómo interpreta el sistema las pulsaciones
                                del teclado.
* Localizaciones::           Configuración de idioma y convenciones
                               culturales.
* Servicios::                Especificar los servicios del sistema.
* Programas con setuid::     Programas que se ejecutan con privilegios de
                               root.
* Certificados X.509::       Verificar servidores HTTPS.
* Selector de servicios de nombres::  Configurar el selector de servicios de
                                        nombres de libc.
* Disco en RAM inicial::     Arranque de Linux-Libre.
* Configuración del gestor de arranque::  Configurar el gestor de arranque.
* Invocación de guix system::  Instanciar una configuración del sistema.
* Invocación de guix deploy::  Despliegue de una configuración del sistema
                                  en una máquina remota.
* Ejecutar Guix en una máquina virtual::  Cómo ejecutar el sistema Guix en
                                             una máquina virtual.
* Definición de servicios::  Añadir nuevas definiciones de servicios.

Servicios



* Servicios base::           Servicios esenciales del sistema.
* Ejecución de tareas programadas::  El servicio mcron.
* Rotación del registro de mensajes::  El servicio rottlog.
* Servicios de red::         Configuración de red, daemon SSH, etc.
* Sistema X Window::         Interfaz gráfica.
* Servicios de impresión::  Soporte de impresoras locales y remotas.
* Servicios de escritorio::  D-Bus y servicios de escritorio.
* Servicios de sonido::      Servicios de ALSA y Pulseaudio.
* Servicios de bases de datos::  Bases de datos SQL, almacenes de
                                   clave-valor, etc.
* Servicios de correo::      IMAP, POP3, SMTP y todo eso.
* Servicios de mensajería::  Servicios de mensajería.
* Servicios de telefonía::  Servicios de telefonía.
* Servicios de monitorización::  Servicios de monitorización.
* Servicios Kerberos::       Servicios Kerberos.
* Servicios Web::            Servidores Web.
* Servicios de certificados::  Certificados TLS via Let’s Encrypt.
* Servicios DNS::            Daemon de DNS.
* Servicios VPN::            Daemon de VPN.
* Sistema de ficheros en red::  Servicios relacionados con NFS.
* Integración continua::    El servicio Cuirass.
* Servicios de gestión de energía::  Extender la vida de la batería.
* Servicios de audio::       El MPD.
* Servicios de virtualización::  Servicios de virtualización.
* Servicios de control de versiones::  Proporcionar acceso remoto a
                                         repositorios Git.
* Servicios de juegos::      Servidores de juegos.
* Servicio PAM Mount::       Servicio de montado de volúmenes en el ingreso
                               al sistema.
* Servicios de Guix::        Servicios relacionados específicamente con
                               Guix.
* Servicios de Linux::       Servicios asociados al núcleo Linux.
* Hurd Services::            Services specific to a Hurd System.
* Servicios misceláneos::   Otros servicios.

Definición de servicios



* Composición de servicios::  El modelo para la composición de servicios.
* Tipos de servicios y servicios::  Tipos y servicios
* Referencia de servicios::  Referencia de la API.
* Servicios de Shepherd::    Un tipo de servicio particular.



File: guix.es.info,  Node: Introducción,  Next: Instalación,  Prev: Top,  Up: Top

1 Introducción
**************

GNU Guix(1) es una herramienta de gestión de paquetes y una distribución
del sistema GNU. Guix facilita a usuarias sin privilegios la
instalación, actualización o borrado de paquetes de software, la vuelta
a un conjunto de paquetes previo atómicamente, la construcción de
paquetes desde las fuentes, y ayuda de forma general en la creación y
mantenimiento de entornos software.

   Puede instalar GNU Guix sobre un sistema GNU/Linux existente, donde
complementará las herramientas disponibles sin interferencias (*note
Instalación::), o puede usarse como un sistema operativo en sí mismo, el
“sistema Guix”(2). *Note Distribución GNU::.

* Menu:

* Gestión de software con Guix::  Qué es especial.
* Distribución GNU::        Los paquetes y herramientas.

   ---------- Footnotes ----------

   (1) “Guix” se pronuncia tal y como se escribe en castellano, “ɡiːks”
en el alfabeto fonético internacional (IPA).

   (2) Solíamos referirnos al sistema Guix como “Distribución de sistema
Guix” o “GuixSD”. Ahora consideramos que tiene más sentido agrupar todo
bajo la etiqueta “Guix” ya que, después de todo, el sistema Guix está
inmediatamente disponible a través de la orden ‘guix system’, ¡incluso
cuando usa una distribución distinta por debajo!


File: guix.es.info,  Node: Gestión de software con Guix,  Next: Distribución GNU,  Up: Introducción

1.1 Gestión de software con Guix
================================

Guix proporciona una interfaz de gestión de paquetes de línea de ordenes
(*note Gestión de paquetes::), un conjunto de utilidades de línea de
órdenes (*note Utilidades::), así como interfaces programáticas Scheme
(*note Interfaz programática::). Su “daemon de construcción” es
responsable de la construcción de paquetes en delegación de las usuarias
(*note Preparación del daemon::) y de la descarga de binarios
preconstruidos de fuentes autorizadas (*note Sustituciones::)

   Guix incluye definiciones de paquetes para muchos paquetes GNU y
no-GNU, todos los cuales respetan la libertad de computación de la
usuaria (https://www.gnu.org/philosophy/free-sw.html). Es _extensible_:
las usuarias pueden escribir sus propias definiciones de paquetes (*note
Definición de paquetes::) y hacerlas disponibles como módulos
independientes de paquetes (*note Módulos de paquetes::). También es
_personalizable_: las usuarias pueden _derivar_ definiciones de paquetes
especializadas de las existentes, inclusive desde la línea de órdenes
(*note Opciones de transformación de paquetes::).

   En su implementación, Guix utiliza la disciplina de “gestión de
paquetes funcional” en la que Nix fue pionero (*note Reconocimientos::).
En Guix, el proceso de construcción e instalación es visto como una
_función_, en el sentido matemático. Dicha función toma entradas, como
los guiones de construcción, un compilador, unas bibliotecas y devuelve
el paquete instalado. Como función pura, su resultado únicamente depende
de sus entradas—por ejemplo, no puede hacer referencia a software o
guiones que no fuesen pasados explícitamente como entrada. Una función
de construcción siempre produce el mismo resultado cuando se le
proporciona un conjunto de entradas dado. No puede modificar el entorno
del sistema que la ejecuta de ninguna forma; por ejemplo, no puede
crear, modificar o borrar archivos fuera de sus directorios de
construcción e instalación. Esto se consigue ejecutando los procesos de
construcción en entornos aislados (o “contenedores”), donde únicamente
sus entradas explícitas son visibles.

   El resultado de las funciones de construcción de paquetes es
“almacenado en la caché” en el sistema de ficheros, en un directorio
especial llamado “el almacén” (*note El almacén::). Cada paquete se
instala en un directorio propio en el almacén—por defecto, bajo
‘/gnu/store’. El nombre del directorio contiene el hash de todas las
entradas usadas para construir el paquete; por tanto, cambiar una
entrada resulta en un nombre de directorio distinto.

   Esta aproximación es el cimiento de las avanzadas características de
Guix: capacidad para la actualización transaccional y vuelta-atrás de
paquetes, instalación en el ámbito de la usuaria y recolección de basura
de paquetes (*note Características::).


File: guix.es.info,  Node: Distribución GNU,  Prev: Gestión de software con Guix,  Up: Introducción

1.2 Distribución GNU
====================

Guix viene con una distribución del sistema GNU consistente en su
totalidad de software libre(1). La distribución puede instalarse
independientemente (*note Instalación del sistema::), pero también es
posible instalar Guix como un gestor de paquetes sobre un sistema
GNU/Linux existente (*note Instalación::). Para distinguir entre las dos
opciones, nos referimos a la distribución independiente como el
sistema Guix.

   La distribución proporciona paquetes principales de GNU como GNU
libc, GCC y Binutils, así como muchas aplicaciones GNU y no-GNU. La
lista completa de paquetes disponibles se puede explorar en línea
(https://www.gnu.org/software/guix/packages) o ejecutando ‘guix package’
(*note Invocación de guix package::):

     guix package --list-available

   Nuestro objetivo es proporcionar una distribución práctica con 100%
software libre basada en Linux y otras variantes de GNU, con un enfoque
en la promoción y la alta integración de componentes GNU, y un énfasis
en programas y herramientas que ayuden a las usuarias a ejercitar esa
libertad.

   Actualmente hay paquetes disponibles para las siguientes plataformas:

‘x86_64-linux’
     arquitectura ‘x86_64’ de Intel/AMD, núcleo Linux-Libre;

‘i686-linux’
     arquitectura de 32-bits Intel (IA32), núcleo Linux-Libre;

‘armhf-linux’
     arquitectura ARMv7-A con coma flotante hardware, Thumb-2 y NEON,
     usando la interfaz binaria de aplicaciones (ABI) EABI con coma
     flotante hardware, y el núcleo Linux-Libre.

‘aarch64-linux’
     procesadores ARMv8-A de 64 bits little-endian, con el núcleo
     Linux-Libre.

‘mips64el-linux (deprecated)’
     little-endian 64-bit MIPS processors, specifically the Loongson
     series, n32 ABI, and Linux-Libre kernel. This configuration is no
     longer fully supported; in particular, there is no ongoing work to
     ensure that this architecture still works. Should someone decide
     they wish to revive this architecture then the code is still
     available.

   Con el sistema Guix, _declara_ todos los aspectos de la configuración
del sistema y Guix se hace cargo de instanciar la configuración de
manera transaccional, reproducible y sin estado global (*note
Configuración del sistema::). El sistema Guix usa el núcleo Linux-libre,
el sistema de inicialización Shepherd (*note (shepherd)Introducción::),
las conocidas utilidades y herramientas de compilación GNU, así como el
entorno gráfico o servicios del sistema de su elección.

   El sistema Guix está disponible en todas las plataformas previas
excepto ‘mips64el-linux’.

Para información sobre el transporte a otras arquitecturas o núcleos,
*note Transportar::.

   La construcción de esta distribución es un esfuerzo cooperativo, ¡y
esta invitada a unirse! *Note Contribuir::, para información sobre cómo
puede ayudar.

   ---------- Footnotes ----------

   (1) El término “libre” aquí se refiere a la libertad proporcionada a
las usuarias de dicho software
(https://www.gnu.org/philosophy/free-sw.html).


File: guix.es.info,  Node: Instalación,  Next: Instalación del sistema,  Prev: Introducción,  Up: Top

2 Instalación
*************

     Nota: Recomendamos el uso de este guión de shell de instalación
     (https://git.savannah.gnu.org/cgit/guix.git/plain/etc/guix-install.sh)
     para instalar Guix sobre un sistema GNU/Linux en ejecución, de aquí
     en adelante referido como una “distribución distinta”.(1) El guión
     automatiza la descarga, instalación y configuración inicial de
     Guix. Debe ejecutarse como la usuaria de administración root.

   Cuando está instalado sobre una distribución distinta, GNU Guix
complementa las herramientas disponibles sin interferencias. Sus datos
radican exclusivamente en dos directorios, normalmente ‘/gnu/store’ y
‘/var/guix’; otros ficheros en su sistema, como ‘/etc’, permanecen
intactos.

   Una vez instalado, Guix puede ser actualizado ejecutando ‘guix pull’
(*note Invocación de guix pull::.

   Si prefiere realizar los pasos de instalación manualmente o desea
personalizarlos, puede encontrar útiles las siguientes instrucciones.
Describen los requisitos de software de Guix, así como su instalación
manual y la preparación para su uso.

* Menu:

* Instalación binaria::     ¡Poner Guix en funcionamiento en nada de
                               tiempo!
* Requisitos::               Software necesario para construir y ejecutar
                               Guix.
* Ejecución de la batería de pruebas::  Probar Guix.
* Preparación del daemon::  Preparar el entorno del daemon de
                               construcción.
* Invocación de guix-daemon::  Ejecutar el daemon de construcción.
* Configuración de la aplicación::  Configuración específica de la
                                        aplicación.
* Actualizar Guix::          Actualizar Guix y su daemon de construcción.

   ---------- Footnotes ----------

   (1) Esta sección está dedicada a la instalación del gestor de
paquetes, que puede realizarse sobre un sistema GNU/Linux ya en
ejecución. Si, en vez de eso, desea instalar el sistema operativo GNU
completo, *note Instalación del sistema::.


File: guix.es.info,  Node: Instalación binaria,  Next: Requisitos,  Up: Instalación

2.1 Instalación binaria
=======================

Esta sección describe cómo instalar Guix en un sistema arbitrario desde
un archivador autocontenido que proporciona los binarios para Guix y
todas sus dependencias. Esto es normalmente más rápido que una
instalación desde las fuentes, la cual es descrita en las siguientes
secciones. El único requisito es tener GNU tar y Xz.

     Nota: We recommend the use of this shell installer script
     (https://git.savannah.gnu.org/cgit/guix.git/plain/etc/guix-install.sh).
     The script automates the download, installation, and initial
     configuration steps described below. It should be run as the root
     user. As root, you can thus run this:

          cd /tmp
          wget https://git.savannah.gnu.org/cgit/guix.git/plain/etc/guix-install.sh
          chmod +x guix-install.sh
          ./guix-install.sh

   La instalación consiste más o menos en los siguientes pasos:

  1. Download the binary tarball from
     ‘https://ftp.gnu.org/gnu/guix/guix-binary-1.0.1.17089-7e269.x86_64-linux.tar.xz’,
     where ‘x86_64-linux’ can be replaced with ‘i686-linux’ for an
     ‘i686’ (32-bits) machine already running the kernel Linux, and so
     on (*note Distribución GNU::).

     Asegúrese de descargar el fichero ‘.sig’ asociado y de verificar la
     autenticidad del archivador con él, más o menos así:

          $ wget https://ftp.gnu.org/gnu/guix/guix-binary-1.0.1.17089-7e269.x86_64-linux.tar.xz.sig
          $ gpg --verify guix-binary-1.0.1.17089-7e269.x86_64-linux.tar.xz.sig

     Si la orden falla porque no dispone de la clave pública necesaria,
     entonces ejecute esta otra orden para importarla:

          $ wget https://sv.gnu.org/people/viewgpg.php?user_id=15145 \
                -qO - | gpg --import -

     y vuelva a ejecutar la orden ‘gpg --verify’.

     Tenga en cuenta que un aviso del tipo “Esta clave no esta
     certificada con una firma de confianza” es normal.

  2. Ahora necesita convertirse en la usuaria ‘root’. Dependiendo de su
     distribución, puede que tenga que ejecutar ‘su -’ o ‘sudo -i’. Como
     ‘root’, ejecute:

          # cd /tmp
          # tar --warning=no-timestamp -xf \
               /path/to/guix-binary-1.0.1.17089-7e269.x86_64-linux.tar.xz
          # mv var/guix /var/ && mv gnu /

     This creates ‘/gnu/store’ (*note El almacén::) and ‘/var/guix’. The
     latter contains a ready-to-use profile for ‘root’ (see next step).

     _No_ extraiga el archivador en un sistema Guix ya funcionando ya
     que sobreescribiría sus propios ficheros esenciales.

     The ‘--warning=no-timestamp’ option makes sure GNU tar does not
     emit warnings about “implausibly old time stamps” (such warnings
     were triggered by GNU tar 1.26 and older; recent versions are
     fine). They stem from the fact that all the files in the archive
     have their modification time set to zero (which means January 1st,
     1970). This is done on purpose to make sure the archive content is
     independent of its creation time, thus making it reproducible.

  3. Ponga disponible el perfil en ‘~root/.config/guix/current’, que es
     donde ‘guix pull’ instalará las actualizaciones (*note Invocación
     de guix pull::):

          # mkdir -p ~root/.config/guix
          # ln -sf /var/guix/profiles/per-user/root/current-guix \
                   ~root/.config/guix/current

     Source ‘etc/profile’ to augment ‘PATH’ and other relevant
     environment variables:

          # GUIX_PROFILE="`echo ~root`/.config/guix/current" ; \
            source $GUIX_PROFILE/etc/profile

  4. Cree el grupo y las cuentas de usuaria para las usuarias de
     construcción como se explica a continuación (*note Configuración
     del entorno de construcción::).

  5. Ejecute el daemon, y configure su inicio automático durante el
     arranque.

     Si su distribución anfitriona usa el sistema de inicio systemd,
     puede hacerlo con las siguientes órdenes:

          # cp ~root/.config/guix/current/lib/systemd/system/gnu-store.mount \
               ~root/.config/guix/current/lib/systemd/system/guix-daemon.service \
               /etc/systemd/system/
          # systemctl enable --now gnu-store.mount guix-daemon

     Si su distribución anfitriona usa el sistema de inicio Upstart:

          # initctl reload-configuration
          # cp ~root/.config/guix/current/lib/upstart/system/guix-daemon.conf \
               /etc/init/
          # start guix-daemon

     En otro caso, todavía puede iniciar el daemon manualmente con:

          # ~root/.config/guix/current/bin/guix-daemon \
                 --build-users-group=guixbuild

  6. Haga accesible la orden ‘guix’ a otras usuarias de la máquina, por
     ejemplo con:

          # mkdir -p /usr/local/bin
          # cd /usr/local/bin
          # ln -s /var/guix/profiles/per-user/root/current-guix/bin/guix

     Es también una buena idea poner disponible la versión Info de este
     manual ahí:

          # mkdir -p /usr/local/share/info
          # cd /usr/local/share/info
          # for i in /var/guix/profiles/per-user/root/current-guix/share/info/* ;
            do ln -s $i ; done

     That way, assuming ‘/usr/local/share/info’ is in the search path,
     running ‘info guix’ will open this manual (*note (texinfo)Other
     Info Directories::, for more details on changing the Info search
     path).

  7. Para usar sustituciones de ‘ci.guix.gnu.org’ o uno de sus espejos
     (*note Sustituciones::), debe autorizarlas:

          # guix archive --authorize < \
               ~root/.config/guix/current/share/guix/ci.guix.gnu.org.pub

  8. Cada usuaria puede necesitar dar algunos pasos adicionales para
     preparar su entorno de Guix para el uso diario, *note Configuración
     de la aplicación::.

   Voilà, ¡la instalación está completa!

   Puede confirmar que Guix está funcionando instalando un paquete de
ejemplo en su perfil de root:

     # guix install hello

   El archivador de la instalación binaria puede ser (re)producido y
verificado simplemente ejecutando la siguiente orden en el árbol de
fuentes de Guix:

     make guix-binary.SISTEMA.tar.xz

... que a su vez ejecuta:

     guix pack -s SISTEMA --localstatedir \
       --profile-name=current-guix guix

   *Note Invocación de guix pack::, para más información sobre esta útil
herramienta.


File: guix.es.info,  Node: Requisitos,  Next: Ejecución de la batería de pruebas,  Prev: Instalación binaria,  Up: Instalación

2.2 Requisitos
==============

Esta sección enumera los requisitos para construir Guix desde las
fuentes. El procedimiento de construcción de Guix es el mismo que el de
otro software GNU, y no está cubierto aquí. Por favor, eche un vistazo a
los ficheros ‘README’ y ‘INSTALL’ en el árbol de fuentes de Guix para
obtener detalles adicionales.

   GNU Guix está disponible para descarga desde su página web en
<http://www.gnu.org/software/guix/>.

   GNU Guix depende de los siguientes paquetes:

   • GNU Guile (https://gnu.org/software/guile/), versión 3.0.x o 2.2.x;
   • Guile-Gcrypt (https://notabug.org/cwebber/guile-gcrypt), versión
     0.1.0 o posterior;
   • GnuTLS (https://gnutls.org/), específicamente su API para Guile
     (*note how to install the GnuTLS bindings for Guile:
     (gnutls-guile)Guile Preparations.);
   • Guile-SQLite3 (https://notabug.org/guile-sqlite3/guile-sqlite3),
     versión 0.1.0 o posterior;
   • Guile-Git (https://gitlab.com/guile-git/guile-git), de agosto de
     2017 o posterior;
   • Guile-JSON (https://savannah.nongnu.org/projects/guile-json/) 3.x;
   • zlib (https://zlib.net);
   • GNU Make (https://www.gnu.org/software/make/).

   Las siguientes dependencias son opcionales:

   • La delegación de construcciones (*note Configuración de delegación
     del daemon::) y ‘guix copy’ (*note Invocación de guix copy::)
     dependen de Guile-SSH
     (https://github.com/artyom-poptsov/guile-ssh), versión 0.12.0 o
     posterior.

   • Cuando lzlib (https://www.nongnu.org/lzip/lzlib.html) está
     disponible, se pueden usar sustituciones con lzlib y ‘guix publish’
     puede comprimir las sustituciones con lzlib.

   • Cuando libbz2 (http://www.bzip.org) está disponible, ‘guix daemon’
     puede usarla para comprimir los registros de construcción.

   Unless ‘--disable-daemon’ was passed to ‘configure’, the following
packages are also needed:

   • GNU libgcrypt (https://gnupg.org/);
   • SQLite 3 (https://sqlite.org);
   • g++ de GCC (https://gcc.gnu.org) con soporte para el estándar C++11

   When configuring Guix on a system that already has a Guix
installation, be sure to specify the same state directory as the
existing installation using the ‘--localstatedir’ option of the
‘configure’ script (*note ‘localstatedir’: (standards)Directory
Variables.). Usually, this LOCALSTATEDIR option is set to the value
‘/var’. The ‘configure’ script protects against unintended
misconfiguration of LOCALSTATEDIR so you do not inadvertently corrupt
your store (*note El almacén::).


File: guix.es.info,  Node: Ejecución de la batería de pruebas,  Next: Preparación del daemon,  Prev: Requisitos,  Up: Instalación

2.3 Ejecución de la batería de pruebas
======================================

Después de una ejecución exitosa de ‘configure’ y ‘make’, es una buena
idea ejecutar la batería de pruebas. Puede ayudar a encontrar problemas
con la configuración o el entorno, o errores en el mismo Guix—e informar
de fallos en las pruebas es realmente una buena forma de ayudar a
mejorar el software. Para ejecutar la batería de pruebas, teclee:

     make check

   Los casos de prueba pueden ejecutarse en paralelo: puede usar la
opción ‘-j’ de GNU make para acelerar las cosas. La primera ejecución
puede tomar algunos minutos en una máquina reciente; las siguientes
ejecuciones serán más rápidas puesto que el almacén creado para las
pruebas ya tendrá varias cosas en la caché.

   También es posible ejecutar un subconjunto de las pruebas definiendo
la variable de makefile ‘TESTS’ como en el ejemplo:

     make check TESTS="tests/store.scm tests/cpio.scm"

   Por defecto, los resultados de las pruebas se muestran a nivel de
fichero. Para ver los detalles de cada caso de prueba individual, es
posible definir la variable de makefile ‘SCM_LOG_DRIVER_FLAGS’ como en
el ejemplo:

     make check TESTS="tests/base64.scm" SCM_LOG_DRIVER_FLAGS="--brief=no"

   En caso de fallo, le rogamos que envíe un correo a <bug-guix@gnu.org>
y adjunte el fichero ‘test-suite.log’. Por favor, especifique la versión
de Guix usada así como los números de versión de las dependencias (*note
Requisitos::) en su mensaje.

   Guix también viene como una batería de pruebas del sistema completo
que prueban instancias completas del sistema Guix. Se puede ejecutar
únicamente en sistemas donde Guix ya está instalado, usando:

     make check-system

o, de nuevo, definiendo ‘TESTS’ para seleccionar un subconjunto de las
pruebas a ejecutar:

     make check-system TESTS="basic mcron"

   Estas pruebas de sistema están definidas en los módulos ‘(gnu tests
...)’. Funcionan ejecutando el sistema operativo con una instrumentación
ligera en una máquina virtual (VM). Pueden ser computacionalmente
intensivas o bastante baratas, dependiendo de si hay sustituciones
disponibles para sus dependencias (*note Sustituciones::). Algunas
requieren mucho espacio de almacenamiento para alojar las imágenes de la
máquina virtual.

   De nuevo, en caso de fallos en las pruebas, le rogamos que envíe a
<bug-guix@gnu.org> todos los detalles.


File: guix.es.info,  Node: Preparación del daemon,  Next: Invocación de guix-daemon,  Prev: Ejecución de la batería de pruebas,  Up: Instalación

2.4 Preparación del daemon
==========================

Operaciones como la construcción de un paquete o la ejecución del
recolector de basura son realizadas por un proceso especializado, el
“daemon de construcción”, en delegación de sus clientes. Únicamente el
daemon puede acceder al almacén y su base de datos asociada. Por tanto,
cualquier operación que manipula el almacén se realiza a través del
daemon. Por ejemplo, las herramientas de línea de órdenes como ‘guix
package’ y ‘guix build’ se comunican con el daemon (via llamadas a
procedimientos remotos) para indicarle qué hacer.

   Las siguientes secciones explican cómo preparar el entorno del daemon
de construcción. Véase también *note Sustituciones::, para información
sobre cómo permitir al daemon descargar binarios pre-construidos.

* Menu:

* Configuración del entorno de construcción::  Preparar el entorno aislado
                                                   de construcción.
* Configuración de delegación del daemon::  Delegar construcciones a
                                                máquinas remotas.
* Soporte de SELinux::       Uso de una política SELinux para el daemon.


File: guix.es.info,  Node: Configuración del entorno de construcción,  Next: Configuración de delegación del daemon,  Up: Preparación del daemon

2.4.1 Configuración del entorno de construcción
-----------------------------------------------

En una configuración multiusuaria estándar, Guix y su daemon—el programa
‘guix-daemon’—son instalados por la administradora del sistema;
‘/gnu/store’ pertenece a ‘root’ y ‘guix-daemon’ se ejecuta como ‘root’.
Usuarias sin privilegios pueden usar las herramientas de Guix para
construir paquetes o acceder al almacén de otro modo, y el daemon lo
hará en delegación suya, asegurando que el almacén permanece en un
estado consistente, y permitiendo compartir entre usuarias los paquetes
construidos.

   Mientras que ‘guix-daemon’ se ejecuta como ‘root’, puede que no desee
que los procesos de construcción de paquetes se ejecuten como ‘root’
también, por razones de seguridad obvias. Para evitarlo, una reserva
especial de “usuarias de construcción” debe ser creada para ser usada
por los procesos de construcción iniciados por el daemon. Estas usuarias
de construcción no necesitan tener un shell ni un directorio home:
simplemente serán usadas cuando el daemon se deshaga de los privilegios
de ‘root’ en los procesos de construcción. Tener varias de dichas
usuarias permite al daemon lanzar distintos procesos de construcción
bajo UID separados, lo que garantiza que no interferirán entre ellos—una
característica esencial ya que las construcciones se caracterizan como
funciones puras (*note Introducción::).

   En un sistema GNU/Linux, una reserva de usuarias de construcción
puede ser creada así (usando la sintaxis de Bash y las órdenes de
‘shadow’):

     # groupadd --system guixbuild
     # for i in `seq -w 1 10`;
       do
         useradd -g guixbuild -G guixbuild                      \
                 -d /var/empty -s `which nologin`               \
                 -c "Usuaria de construcción Guix $i" --system  \
                 guixbuilder$i;
       done

El número de usuarias de construcción determina cuantos trabajos de
construcción se pueden ejecutar en paralelo, especificado por la opción
‘--max-jobs’ (*note ‘--max-jobs’: Invocación de guix-daemon.). Para usar
‘guix system vm’ y las órdenes relacionadas, puede necesitar añadir las
usuarias de construcción al grupo ‘kvm’ para que puedan acceder a
‘/dev/kvm’, usando ‘-G guixbuild,kvm’ en vez de ‘-G guixbuild’ (*note
Invocación de guix system::).

   El programa ‘guix-daemon’ puede ser ejecutado entonces como ‘root’
con la siguiente orden(1):

     # guix-daemon --build-users-group=guixbuild

De este modo, el daemon inicia los procesos de construcción en un
“chroot”, bajo una de las usuarias ‘guixbuilder’. En GNU/Linux, por
defecto, el entorno “chroot” contiene únicamente:

   • un directorio ‘/dev’ mínimo, creado en su mayor parte
     independientemente del ‘/dev’ del sistema anfitrión(2);

   • el directorio ‘/proc’; únicamente muestra los procesos del
     contenedor ya que se usa un espacio de nombres de PID separado;

   • ‘/etc/passwd’ con una entrada para la usuaria actual y una entrada
     para la usuaria ‘nobody’;

   • ‘/etc/groups’ con una entrada para el grupo de la usuaria;

   • ‘/etc/hosts’ con una entrada que asocia ‘localhost’ a ‘127.0.0.1’;

   • un directorio ‘/tmp’ con permisos de escritura.

   You can influence the directory where the daemon stores build trees
via the ‘TMPDIR’ environment variable. However, the build tree within
the chroot is always called ‘/tmp/guix-build-NAME.drv-0’, where NAME is
the derivation name—e.g., ‘coreutils-8.24’. This way, the value of
‘TMPDIR’ does not leak inside build environments, which avoids
discrepancies in cases where build processes capture the name of their
build tree.

   The daemon also honors the ‘http_proxy’ and ‘https_proxy’ environment
variables for HTTP and HTTPS downloads it performs, be it for
fixed-output derivations (*note Derivaciones::) or for substitutes
(*note Sustituciones::).

   If you are installing Guix as an unprivileged user, it is still
possible to run ‘guix-daemon’ provided you pass ‘--disable-chroot’.
However, build processes will not be isolated from one another, and not
from the rest of the system. Thus, build processes may interfere with
each other, and may access programs, libraries, and other files
available on the system—making it much harder to view them as _pure_
functions.

   ---------- Footnotes ----------

   (1) Si su máquina usa el sistema de inicio systemd, copiando el
fichero ‘PREFIX/lib/systemd/system/guix-daemon.service’ en
‘/etc/systemd/system’ asegurará que ‘guix-daemon’ se arranca
automáticamente. De igual modo, si su máquina usa el sistema de inicio
Upstart, copie el fichero ‘PREFIX/lib/upstart/system/guix-daemon.conf’
en ‘/etc/init’.

   (2) “En su mayor parte” porque, mientras el conjunto de ficheros que
aparecen en ‘/dev’ es fijo, la mayor parte de estos ficheros solo pueden
ser creados si el sistema anfitrión los tiene.


File: guix.es.info,  Node: Configuración de delegación del daemon,  Next: Soporte de SELinux,  Prev: Configuración del entorno de construcción,  Up: Preparación del daemon

2.4.2 Uso de la facilidad de descarga de trabajo
------------------------------------------------

Cuando así se desee, el daemon de construcción puede “delegar”
construcciones de derivación a otras máquinas ejecutando Guix, usando el
“procedimiento de extensión de construcción” ‘offload’(1). Cuando dicha
característica es activada, una lista de máquinas de construcción
especificadas por la usuaria es leída de ‘/etc/guix/machines.scm’; cada
vez que se solicita una construcción, por ejemplo via ‘guix build’, el
daemon intenta delegarla a una de las máquinas que satisfaga las
condiciones de la derivación, en particular su tipo de sistema—por
ejemplo, ‘x86_64-linux’. Los prerrequisitos restantes para la
construcción son copiados por SSH a la máquina objetivo, la cual procede
con la construcción; con un resultado satisfactorio la(s) salida(s) de
la construcción son copiadas de vuelta a la máquina inicial.

   El fichero ‘/etc/guix/machines.scm’ normalmente tiene un contenido de
este estilo:

     (list (build-machine
             (name "ochentayseis.example.org")
             (system "x86_64-linux")
             (host-key "ssh-ed25519 AAAAC3Nza...")
             (user "rober")
             (speed 2.))     ;¡increíblemente rápida!

           (build-machine
             (name "armeight.example.org")
             (system "aarch64-linux")
             (host-key "ssh-rsa AAAAB3Nza...")
             (user "alice")
             (private-key
              (string-append (getenv "HOME")
                             "/.ssh/identity-for-guix"))))

In the example above we specify a list of two build machines, one for
the ‘x86_64’ architecture and one for the ‘aarch64’ architecture.

   De hecho, este fichero es—¡sin sorpresa ninguna!—un fichero Scheme
que se evalúa cuando el procedimiento de extensión ‘offload’ se inicia.
El valor que devuelve debe ser una lista de objetos ‘build-machine’.
Mientras que este ejemplo muestra una lista fija de máquinas de
construcción, una puede imaginarse, digamos, el uso de DNS-SD para
devolver una lista de máquinas de construcción potenciales descubierta
en la red local (*note Guile-Avahi: (guile-avahi)Introducción.). El tipo
de datos ‘build-machine’ se detalla a continuación.

 -- Tipo de datos: build-machine
     Este tipo de datos representa las máquinas de construcción a las
     cuales el daemon puede delegar construcciones. Los campos
     importantes son:

     ‘name’
          El nombre de red de la máquina remota.

     ‘system’
          El sistema de la máquina remota—por ejemplo, ‘"x86_64-linux"’.

     ‘user’
          La cuenta de usuaria usada para la conexión a la máquina
          remota por SSH. Tenga en cuenta que el par de claves SSH _no_
          debe estar protegido por contraseña, para permitir ingresos al
          sistema no interactivos.

     ‘host-key’
          Este campo debe contener la “clave pública de la máquina” de
          SSH en formato OpenSSH. Es usado para autentificar la máquina
          cuando nos conectamos a ella. Es una cadena larga más o menos
          así:

               ssh-ed25519 AAAAC3NzaC...mde+UhL recordatorio@example.org

          Si la máquina está ejecutando el daemon OpenSSH, ‘sshd’, la
          clave pública de la máquina puede encontrarse en un fichero
          como ‘/etc/ssh/ssh_host_ed25519_key.pub’.

          Si la máquina está ejecutando el daemon SSH GNU lsh, ‘lshd’,
          la clave de la máquina está en ‘/etc/lsh/host-key.pub’ o un
          fichero similar. Puede convertirse a formato OpenSSH usando
          ‘lsh-export-key’ (*note (lsh)Converting keys::):

               $ lsh-export-key --openssh < /etc/lsh/host-key.pub
               ssh-rsa AAAAB3NzaC1yc2EAAAAEOp8FoQAAAQEAs1eB46LV...

     Ciertos número de campos opcionales pueden ser especificados:

     ‘port’ (predeterminado: ‘22’)
          Número de puerto del servidor SSH en la máquina.

     ‘private-key’ (predeterminada: ‘~root/.ssh/id_rsa’)
          El fichero de clave privada SSH usado para conectarse a la
          máquina, en formato OpenSSH. Esta clave no debe estar
          protegida con una contraseña.

          Tenga en cuenta que el valor predeterminado es la clave
          privada _de la cuenta de root_. Asegúrese de que existe si usa
          el valor predeterminado.

     ‘compression’ (predeterminado: ‘"zlib@openssh.com,zlib"’)
     ‘compression-level’ (predeterminado: ‘3’)
          Los métodos de compresión y nivel de compresión a nivel SSH
          solicitados.

          Tenga en cuenta que la delegación de carga depende de la
          compresión SSH para reducir el ancho de banda usado cuando se
          transfieren ficheros hacia y desde máquinas de construcción.

     ‘daemon-socket’ (predeterminado: ‘"/var/guix/daemon-socket/socket"’)
          Nombre de fichero del socket de dominio Unix en el que
          ‘guix-daemon’ escucha en esa máquina.

     ‘parallel-builds’ (predeterminadas: ‘1’)
          El número de construcciones que pueden ejecutarse en paralelo
          en la máquina.

     ‘speed’ (predeterminado: ‘1.0’)
          Un “factor de velocidad relativa”. El planificador de
          delegaciones tenderá a preferir máquinas con un factor de
          velocidad mayor.

     ‘features’ (predeterminadas: ‘'()’)
          Una lista de cadenas denotando las características específicas
          permitidas por la máquina. Un ejemplo es ‘"kvm"’ para máquinas
          que tienen los módulos KVM de Linux y las correspondientes
          características hardware. Las derivaciones pueden solicitar
          las características por nombre, y entonces se planificarán en
          las máquinas adecuadas.

   El ejecutable ‘guix’ debe estar en la ruta de búsqueda de las
máquinas de construcción. Puede comprobar si es el caso ejecutando:

     ssh build-machine guix repl --version

   Hay una última cosa por hacer una vez ‘machines.scm’ está en su
lugar. Como se ha explicado anteriormente, cuando se delega, los
ficheros se transfieren en ambas direcciones entre los almacenes de las
máquinas. Para que esto funcione, primero debe generar un par de claves
en cada máquina para permitir al daemon exportar los archivos firmados
de ficheros en el almacén (*note Invocación de guix archive::):

     # guix archive --generate-key

Cada máquina de construcción debe autorizar a la clave de la máquina
maestra para que acepte elementos del almacén que reciba de la maestra:

     # guix archive --authorize < clave-publica-maestra.txt

Del mismo podo, la máquina maestra debe autorizar la clave de cada
máquina de construcción.

   Todo este lío con claves está ahí para expresar las mutuas relaciones
de confianza entre pares de la máquina maestra y las máquinas de
construcción. Concretamente, cuando la maestra recibe ficheros de una
máquina de construcción (y vice versa), su daemon de construcción puede
asegurarse de que son genuinos, no han sido modificados, y que están
firmados por una clave autorizada.

   Para comprobar si su configuración es operacional, ejecute esta orden
en el nodo maestro:

     # guix offload test

   Esto intentará conectar con cada una de las máquinas de construcción
especificadas en ‘/etc/guix/machines.scm’, comprobará que GUile y los
módulos Guix están disponibles en cada máquina, intentará exportar a la
máquina e importar de ella, e informará de cualquier error en el
proceso.

   Si quiere probar un fichero de máquinas diferente, simplemente lo
debe especificar en la línea de órdenes:

     # guix offload test otras-maquinas.scm

   Por último, puede probar un subconjunto de máquinas cuyos nombres
coincidan con una expresión regular así:

     # guix offload test maquinas.scm '\.gnu\.org$'

   Para mostrar la carga actual de todas las máquinas de construcción,
ejecute esta orden en el nodo principal:

     # guix offload status

   ---------- Footnotes ----------

   (1) Esta característica está únicamente disponible cuando Guile-SSH
(https://github.com/artyom-potsov/guile-ssh) está presente.


File: guix.es.info,  Node: Soporte de SELinux,  Prev: Configuración de delegación del daemon,  Up: Preparación del daemon

2.4.3 Soporte de SELinux
------------------------

Guix incluye un fichero de política SELinux en ‘etc/guix-daemon.cil’ que
puede ser instalado en un sistema donde SELinux está activado, para
etiquetar los ficheros Guix y especificar el comportamiento esperado del
daemon. Ya que el sistema Guix no proporciona una política base de
SELinux, la política del daemon no puede usarse en el sistema Guix.

2.4.3.1 Instalación de la política de SELinux
.............................................

Para instalar la política ejecute esta orden como root:

     semodule -i etc/guix-daemon.cil

   Una vez hecho, vuelva a etiquetar el sistema de ficheros con
‘restorecon’ o con un mecanismo distinto que proporcione su sistema.

   Una vez la política está instalada, el sistema de ficheros ha sido
re-etiquetado, y el daemon ha sido reiniciado, debería ejecutarse en el
contexto ‘guix_daemon_t’. Puede confirmarlo con la siguiente orden:

     ps -Zax | grep guix-daemon

   Monitorice los ficheros de log de SELinux mientras ejecuta una orden
como ‘guix build hello’ para convencerse que SELinux permite todas las
operaciones necesarias.

2.4.3.2 Limitaciones
....................

Esta política no es perfecta. Aquí está una lista de limitaciones o
comportamientos extraños que deben ser considerados al desplegar la
política SELinux provista para el daemon Guix.

  1. ‘guix_daemon_socket_t’ no se usa realmente. Ninguna de las
     operaciones del socket implica contextos que tengan algo que ver
     con ‘guix_daemon_socket_t’. No hace daño tener esta etiqueta sin
     usar, pero sería preferible definir reglas del socket únicamente
     para esta etiqueta.

  2. ‘guix gc’ no puede acceder enlaces arbitrarios a los perfiles. Por
     diseño, la etiqueta del fichero del destino de un enlace simbólico
     es independiente de la etiqueta de fichero del fichero en sí.
     Aunque todos los perfiles bajo $localstatedir se etiquetan, los
     enlaces para estos perfiles heredan la etiqueta del directorio en
     el que están. Para enlaces en el directorio de la usuaria esto será
     ‘user_home_t’. Pero para los enlaces del directorio de root, o
     ‘/tmp’, o del directorio del servidor HTTP, etc., esto no
     funcionará. ‘guix gc’ se verá incapacitado para leer y seguir
     dichos enlaces.

  3. La característica del daemon de esperar conexiones TCP puede que no
     funcione más. Esto puede requerir reglas adicionales, ya que
     SELinux trata los sockets de red de forma diferente a los ficheros.

  4. Actualmente todos los ficheros con un nombre coincidente con la
     expresión regular ‘/gnu/store.+-(gux-.+|profile)/bin/guix-daemon’
     tienen asignada la etiqueta ‘guix_daemon_exec_t’; esto significa
     que _cualquier_ fichero con ese nombre en cualquier perfil tendrá
     permitida la ejecución en el dominio ‘guix_daemon_t’. Esto no es
     ideal. Una atacante podría construir un paquete que proporcione
     este ejecutable y convencer a la usuaria para instalarlo y
     ejecutarlo, lo que lo eleva al dominio ‘guix_daemon_t’. Llegadas a
     este punto, SELinux no puede prevenir que acceda a los ficheros
     permitidos para los procesos en dicho dominio.

     Podríamos generar una política mucho más restrictiva en tiempo de
     instalación, de modo que solo el nombre _exacto_ del fichero del
     ejecutable de ‘guix-daemon’ actualmente instalado sea marcado como
     ‘guix_daemon_exec_t’, en vez de usar una expresión regular amplia.
     La desventaja es que root tendría que instalar o actualizar la
     política en tiempo de instalación cada vez que se actualizase el
     paquete de Guix que proporcione el ejecutable de ‘guix-daemon’
     realmente en ejecución.


File: guix.es.info,  Node: Invocación de guix-daemon,  Next: Configuración de la aplicación,  Prev: Preparación del daemon,  Up: Instalación

2.5 Invocación de ‘guix-daemon’
===============================

El programa ‘guix-daemon’ implementa toda la funcionalidad para acceder
al almacén. Esto incluye iniciar procesos de construcción, ejecutar el
recolector de basura, comprobar la disponibilidad de un resultado de
construcción, etc. Normalmente se ejecuta como ‘root’ así:

     # guix-daemon --build-users-group=guixbuild

Para detalles obre como configurarlo, *note Preparación del daemon::.

   By default, ‘guix-daemon’ launches build processes under different
UIDs, taken from the build group specified with ‘--build-users-group’.
In addition, each build process is run in a chroot environment that only
contains the subset of the store that the build process depends on, as
specified by its derivation (*note derivation: Interfaz programática.),
plus a set of specific system directories. By default, the latter
contains ‘/dev’ and ‘/dev/pts’. Furthermore, on GNU/Linux, the build
environment is a “container”: in addition to having its own file system
tree, it has a separate mount name space, its own PID name space,
network name space, etc. This helps achieve reproducible builds (*note
Características::).

   When the daemon performs a build on behalf of the user, it creates a
build directory under ‘/tmp’ or under the directory specified by its
‘TMPDIR’ environment variable. This directory is shared with the
container for the duration of the build, though within the container,
the build tree is always called ‘/tmp/guix-build-NAME.drv-0’.

   El directorio de construcción se borra automáticamente una vez
completado el proceso, a menos que la construcción fallase y se
especificase en el cliente ‘--keep-failed’ (*note ‘--keep-failed’:
Invocación de guix build.).

   The daemon listens for connections and spawns one sub-process for
each session started by a client (one of the ‘guix’ sub-commands). The
‘guix processes’ command allows you to get an overview of the activity
on your system by viewing each of the active sessions and clients. *Note
Invocación de guix processes::, for more information.

   Se aceptan las siguientes opciones de línea de ordenes:

‘--build-users-group=GRUPO’
     Toma las usuarias de GRUPO para ejecutar los procesos de
     construcción (*note build users: Preparación del daemon.).

‘--no-substitutes’
     No usa sustituciones para la construcción de productos. Esto es,
     siempre realiza las construcciones localmente en vez de permitir la
     descarga de binarios pre-construidos (*note Sustituciones::).

     When the daemon runs with ‘--no-substitutes’, clients can still
     explicitly enable substitution via the ‘set-build-options’ remote
     procedure call (*note El almacén::).

‘--substitute-urls=URLS’
     Considera URLS la lista separada por espacios predeterminada de
     URLs de sustituciones de fuentes. Cuando se omite esta opción, se
     usa ‘https://ci.guix.gnu.org’.

     Esto significa que las sustituciones puede ser descargadas de URLS,
     mientras estén firmadas por una firma de confianza (*note
     Sustituciones::).

‘--no-offload’
     No usa la delegación de construcciones en otras máquinas (*note
     Configuración de delegación del daemon::). Es decir, siempre
     realiza las construcciones de manera local en vez de delegar
     construcciones a máquinas remotas.

‘--cache-failures’
     Almacena en la caché los fallos de construcción. Por defecto,
     únicamente las construcciones satisfactorias son almacenadas en la
     caché.

     Cuando se usa esta opción, ‘guix gc --list-failures’ puede usarse
     para consultar el conjunto de elementos del almacén marcados como
     fallidos; ‘guix gc --clear-failures’ borra los elementos del
     almacén del conjunto de fallos existentes en la caché. *Note
     Invocación de guix gc::.

‘--cores=N’
‘-c N’
     Usa N núcleos de la CPU para construir cada derivación; ‘0’
     significa tantos como haya disponibles.

     The default value is ‘0’, but it may be overridden by clients, such
     as the ‘--cores’ option of ‘guix build’ (*note Invocación de guix
     build::).

     The effect is to define the ‘NIX_BUILD_CORES’ environment variable
     in the build process, which can then use it to exploit internal
     parallelism—for instance, by running ‘make -j$NIX_BUILD_CORES’.

‘--max-jobs=N’
‘-M N’
     Permite como máximo N trabajos de construcción en paralelo. El
     valor predeterminado es ‘1’. Fijarlo a ‘0’ significa que ninguna
     construcción se realizará localmente; en vez de eso, el daemon
     delegará las construcciones (*note Configuración de delegación del
     daemon::), o simplemente fallará.

‘--max-silent-time=SEGUNDOS’
     Cuando la construcción o sustitución permanece en silencio más de
     SEGUNDOS, la finaliza e informa de un fallo de construcción.

     El valor predeterminado es ‘0’, que desactiva los plazos.

     The value specified here can be overridden by clients (*note
     ‘--max-silent-time’: Opciones comunes de construcción.).

‘--timeout=SEGUNDOS’
     Del mismo modo, cuando el proceso de construcción o sustitución
     dura más de SEGUNDOS, lo termina e informa un fallo de
     construcción.

     El valor predeterminado es ‘0’, que desactiva los plazos.

     The value specified here can be overridden by clients (*note
     ‘--timeout’: Opciones comunes de construcción.).

‘--rounds=N’
     Construye cada derivación N veces seguidas, y lanza un error si los
     resultados de las construcciones consecutivas no son idénticos
     bit-a-bit. Fíjese que esta configuración puede ser sobreescrita por
     clientes como ‘guix build’ (*note Invocación de guix build::).

     Cuando se usa conjuntamente con ‘--keep-failed’, la salida que
     difiere se mantiene en el almacén, bajo ‘/gnu/store/...-check’.
     Esto hace fácil buscar diferencias entre los dos resultados.

‘--debug’
     Produce salida de depuración.

     This is useful to debug daemon start-up issues, but then it may be
     overridden by clients, for example the ‘--verbosity’ option of
     ‘guix build’ (*note Invocación de guix build::).

‘--chroot-directory=DIR’
     Añade DIR al chroot de construcción.

     Hacer esto puede cambiar el resultado del proceso de
     construcción—por ejemplo si usa dependencias opcionales, que se
     encuentren en DIR, cuando están disponibles, y no de otra forma.
     Por esa razón, no se recomienda hacerlo. En vez de eso, asegúrese
     que cada derivación declara todas las entradas que necesita.

‘--disable-chroot’
     Desactiva la construcción en un entorno chroot.

     No se recomienda el uso de esta opción ya que, de nuevo, podría
     permitir a los procesos de construcción ganar acceso a dependencias
     no declaradas. Es necesario, no obstante, cuando ‘guix-daemon’ se
     ejecuta bajo una cuenta de usuaria sin privilegios.

‘--log-compression=TIPO’
     Comprime los logs de construcción de acuerdo a TIPO, que puede ser
     ‘gzip’, ‘bzip2’ o ‘none’.

     Unless ‘--lose-logs’ is used, all the build logs are kept in the
     LOCALSTATEDIR. To save space, the daemon automatically compresses
     them with Bzip2 by default.

‘--disable-deduplication’
     Desactiva la “deduplicación” automática en el almacén.

     Por defecto, los ficheros se añaden al almacén “deduplicados”
     automáticamente: si un nuevo fichero añadido es idéntico a otro que
     ya se encuentra en el almacén, el daemon introduce el nuevo fichero
     como un enlace duro al otro fichero. Esto puede reducir
     notablemente el uso del disco, a expensas de una carga de
     entrada/salida ligeramente incrementada al finalizar un proceso de
     construcción. Esta opción desactiva dicha optimización.

‘--gc-keep-outputs[=yes|no]’
     Determina si el recolector de basura (GC) debe mantener salidas de
     las derivaciones vivas.

     When set to ‘yes’, the GC will keep the outputs of any live
     derivation available in the store—the ‘.drv’ files. The default is
     ‘no’, meaning that derivation outputs are kept only if they are
     reachable from a GC root. *Note Invocación de guix gc::, for more
     on GC roots.

‘--gc-keep-derivations[=yes|no]’
     Determina si el recolector de basura (GC) debe mantener
     derivaciones correspondientes a salidas vivas.

     When set to ‘yes’, as is the case by default, the GC keeps
     derivations—i.e., ‘.drv’ files—as long as at least one of their
     outputs is live. This allows users to keep track of the origins of
     items in their store. Setting it to ‘no’ saves a bit of disk space.

     In this way, setting ‘--gc-keep-derivations’ to ‘yes’ causes
     liveness to flow from outputs to derivations, and setting
     ‘--gc-keep-outputs’ to ‘yes’ causes liveness to flow from
     derivations to outputs. When both are set to ‘yes’, the effect is
     to keep all the build prerequisites (the sources, compiler,
     libraries, and other build-time tools) of live objects in the
     store, regardless of whether these prerequisites are reachable from
     a GC root. This is convenient for developers since it saves
     rebuilds or downloads.

‘--impersonate-linux-2.6’
     On Linux-based systems, impersonate Linux 2.6. This means that the
     kernel’s ‘uname’ system call will report 2.6 as the release number.

     Esto puede ser útil para construir programas que (habitualmente de
     forma incorrecta) dependen en el número de versión del núcleo.

‘--lose-logs’
     Do not keep build logs. By default they are kept under
     ‘LOCALSTATEDIR/guix/log’.

‘--system=SISTEMA’
     Asume SISTEMA como el tipo actual de sistema. Por defecto es el par
     de arquitectura/núcleo encontrado durante la configuración, como
     ‘x86_64-linux’.

‘--listen=DESTINO’
     Espera conexiones en DESTINO. DESTINO se interpreta como el nombre
     del fichero del socket de dominio Unix si comienza on ‘/’ (barra a
     la derecha). En otro caso, DESTINO se interpreta como un nombre de
     máquina o un nombre de máquina y puerto a escuchar. Aquí van unos
     pocos ejemplos:

     ‘--listen=/gnu/var/daemon’
          Espera conexiones en el socket de dominio Unix
          ‘/gnu/var/daemon’, se crea si es necesario.

     ‘--listen=localhost’
          Espera conexiones TCP en la interfaz de red correspondiente a
          ‘localhost’, en el puerto 44146.

     ‘--listen=128.0.0.42:1234’
          Espera conexiones TCP en la interfaz de red correspondiente a
          ‘128.0.0.42’, en el puerto 1234.

     This option can be repeated multiple times, in which case
     ‘guix-daemon’ accepts connections on all the specified endpoints.
     Users can tell client commands what endpoint to connect to by
     setting the ‘GUIX_DAEMON_SOCKET’ environment variable (*note
     ‘GUIX_DAEMON_SOCKET’: El almacén.).

          Nota: The daemon protocol is _unauthenticated and
          unencrypted_. Using ‘--listen=HOST’ is suitable on local
          networks, such as clusters, where only trusted nodes may
          connect to the build daemon. In other cases where remote
          access to the daemon is needed, we recommend using Unix-domain
          sockets along with SSH.

     When ‘--listen’ is omitted, ‘guix-daemon’ listens for connections
     on the Unix-domain socket located at
     ‘LOCALSTATEDIR/guix/daemon-socket/socket’.


File: guix.es.info,  Node: Configuración de la aplicación,  Next: Actualizar Guix,  Prev: Invocación de guix-daemon,  Up: Instalación

2.6 Configuración de la aplicación
==================================

Cuando se usa Guix sobre una distribución GNU/Linux distinta al sistema
Guix—una “distribución distinta”—unos pocos pasos adicionales son
necesarios para tener todo preparado. Aquí están algunos de ellos.

2.6.1 Localizaciones
--------------------

Packages installed via Guix will not use the locale data of the host
system. Instead, you must first install one of the locale packages
available with Guix and then define the ‘GUIX_LOCPATH’ environment
variable:

     $ guix install glibc-locales
     $ export GUIX_LOCPATH=$HOME/.guix-profile/lib/locale

   Fíjese que el paquete ‘glibc-locales’ contiene datos para todas las
localizaciones que ofrece GNU libc y pesa alrededor de 917 MiB. De
manera alternativa, ‘glibc-utf8-locales’ tiene menor tamaño pero está
limitado a localizaciones UTF-8.

   The ‘GUIX_LOCPATH’ variable plays a role similar to ‘LOCPATH’ (*note
‘LOCPATH’: (libc)Locale Names.). There are two important differences
though:

  1. ‘GUIX_LOCPATH’ is honored only by the libc in Guix, and not by the
     libc provided by foreign distros. Thus, using ‘GUIX_LOCPATH’ allows
     you to make sure the programs of the foreign distro will not end up
     loading incompatible locale data.

  2. libc suffixes each entry of ‘GUIX_LOCPATH’ with ‘/X.Y’, where ‘X.Y’
     is the libc version—e.g., ‘2.22’. This means that, should your Guix
     profile contain a mixture of programs linked against different libc
     version, each libc version will only try to load locale data in the
     right format.

   Esto es importante porque el formato de datos de localización usado
por diferentes versiones de libc puede ser incompatible.

2.6.2 Selector de servicios de nombres
--------------------------------------

Cuando se usa Guix en una distribución distinta, _recomendamos
encarecidamente_ que el sistema ejecute el “daemon de caché del servicio
de nombres” de la biblioteca de C de GNU, ‘ncsd’, que debe escuchar en
el socket ‘/var/run/nscd/socket’. En caso de no hacerlo, las
aplicaciones instaladas con Guix pueden fallar al buscar nombres de
máquinas o cuentas de usuaria, o incluso pueden terminar abruptamente.
Los siguientes párrafos explican por qué.

   La biblioteca de C de GNU implementa un “selector de servicios de
nombres” (NSS), que es un mecanismo extensible para “búsquedas de
nombres” en general: resolución de nombres de máquinas, cuentas de
usuaria y más (*note (libc)Selector de servicios de nombres::).

   Al ser extensible, NSS permite el uso de “módulos”, los cuales
proporcionan nuevas implementaciones de búsqueda de nombres: por
ejemplo, el módulo ‘nss-mdns’ permite la resolución de nombres de
máquina ‘.local’, el módulo ‘nis’ permite la búsqueda de cuentas de
usuaria usando el servicio de información de red (NIS), etc. Estos
“servicios de búsqueda” extra se configuran para todo el sistema en
‘/etc/nsswitch.conf’, y todos los programas en ejecución respetan esta
configuración (*note (libc)NSS Configuration File::).

   Cuando se realiza una búsqueda de nombres—por ejemplo, llamando a la
función ‘getaddrinfo’ en C—las aplicaciones primero intentarán conectar
con nscd; en caso satisfactorio, nscd realiza la búsqueda de nombres en
delegación suya. Si nscd no está ejecutándose, entonces realizan la
búsqueda por ellas mismas, cargando los servicios de búsqueda de nombres
en su propio espacio de direcciones y ejecutándola. Estos servicios de
búsqueda de nombres—los ficheros ‘libnss_*.so’—son abiertos con
‘dlopen’, pero pueden venir de la biblioteca de C del sistema, en vez de
la biblioteca de C contra la que la aplicación está enlazada (la
biblioteca de C que viene en Guix).

   Y aquí es donde está el problema: si su aplicación está enlazada
contra la biblioteca de C de Guix (digamos, glibc 2.24) e intenta cargar
módulos de otra biblioteca de C (digamos, ‘libnss_mdns.so’ para glibc
2.22), probablemente terminará abruptamente o sus búsquedas de nombres
fallarán inesperadamente.

   Ejecutar ‘nscd’ en el sistema, entre otras ventajas, elimina este
problema de incompatibilidad binaria porque esos ficheros ‘libnss_*.so’
se cargan en el proceso ‘nscd’, no en la aplicación misma.

2.6.3 Tipografías X11
---------------------

The majority of graphical applications use Fontconfig to locate and load
fonts and perform X11-client-side rendering. The ‘fontconfig’ package in
Guix looks for fonts in ‘$HOME/.guix-profile’ by default. Thus, to allow
graphical applications installed with Guix to display fonts, you have to
install fonts with Guix as well. Essential font packages include
‘gs-fonts’, ‘font-dejavu’, and ‘font-gnu-freefont’.

   Una vez que haya instalado o borrado tipografías, o cuando se de
cuenta de que una aplicación no encuentra las tipografías, puede que
necesite instalar Fontconfig y forzar una actualización de su caché de
tipografías ejecutando:

     guix install fontconfig
     fc-cache -rv

   Para mostrar texto escrito en lenguas chinas, Japonés o Coreano en
aplicaciones gráficas, considere instalar ‘font-adobe-source-han-sans’ o
‘font-wqy-zenhei’. La anterior tiene múltiples salidas, una por familia
de lengua (*note Paquetes con múltiples salidas::). Por ejemplo, la
siguiente orden instala tipografías para lenguas chinas:

     guix install font-adobe-source-han-sans:cn

   Programas más antiguos como ‘xterm’ no usan Fontconfig sino que
dependen en el lado del servidor para realizar el renderizado de
tipografías. Dichos programas requieren especificar un nombre completo
de tipografía usando XLFD (Descripción lógica de tipografías X), como
esta:

     -*-dejavu sans-medium-r-normal-*-*-100-*-*-*-*-*-1

   Para ser capaz de usar estos nombres completos para las tipografías
TrueType instaladas en su perfil Guix, necesita extender la ruta de
fuentes del servidor X:

     xset +fp $(dirname $(readlink -f ~/.guix-profile/share/fonts/truetype/fonts.dir))

   Después de eso, puede ejecutar ‘xlsfonts’ (del paquete ‘xlsfonts’)
para asegurarse que sus tipografías TrueType se enumeran aquí.

2.6.4 Certificados X.509
------------------------

El paquete ‘nss-certs’ proporciona certificados X.509, que permiten a
los programas verificar los servidores accedidos por HTTPS.

   Cuando se usa Guix en una distribución distinta, puede instalar este
paquete y definir las variables de entorno relevantes de modo que los
paquetes sepan dónde buscar los certificados. *Note Certificados
X.509::, para información detallada.

2.6.5 Paquetes Emacs
--------------------

When you install Emacs packages with Guix, the Elisp files are placed
under the ‘share/emacs/site-lisp/’ directory of the profile in which
they are installed. The Elisp libraries are made available to Emacs
through the ‘EMACSLOADPATH’ environment variable, which is set when
installing Emacs itself.

   Additionally, autoload definitions are automatically evaluated at the
initialization of Emacs, by the Guix-specific
‘guix-emacs-autoload-packages’ procedure. If, for some reason, you want
to avoid auto-loading the Emacs packages installed with Guix, you can do
so by running Emacs with the ‘--no-site-file’ option (*note (emacs)Init
File::).


File: guix.es.info,  Node: Actualizar Guix,  Prev: Configuración de la aplicación,  Up: Instalación

2.7 Actualizar Guix
===================

Para actualizar Guix ejecute:

     guix pull

   *Note Invocación de guix pull::, para más información.

   En una distribución distinta puede actualizar el daemon de
construcción ejecutando:

     sudo -i guix pull

seguido de (asumiendo que su distribución usa la herramienta de gestión
de servicios systemd):

     systemctl restart guix-daemon.service

   En el Sistema Guix, la actualización del daemon se lleva a cabo con
la reconfiguración el sistema (*note ‘guix system reconfigure’:
Invocación de guix system.).


File: guix.es.info,  Node: Instalación del sistema,  Next: Gestión de paquetes,  Prev: Instalación,  Up: Top

3 Instalación del sistema
*************************

Esta sección explica cómo instalar el sistema Guix en una máquina. Guix,
como gestor de paquetes, puede instalarse sobre un sistema GNU/Linux en
ejecución, *note Instalación::.

     Nota: Está leyendo esta documentación con un lector Info. Para
     obtener detalles sobre su uso, presione la tecla <RET> (“retorno de
     carro” o “intro”) en el siguiente enlace: *note Info reader:
     (info-stnd)Top. Presione después ‘l’ para volver aquí.

     Alternatively, run ‘info info’ in another tty to keep the manual
     available.

* Menu:

* Limitaciones::             Qué puede esperar.
* Consideraciones sobre el hardware::  Hardware soportado.
* Instalación desde memoria USB y DVD::  Preparar el medio de instalación.
* Preparación para la instalación::  Red, particionado, etc.
* Instalación gráfica guiada::  Instalación gráfica fácil.
* Instalación manual::      Instalación manual para artistas del teclado.
* Tras la instalación del sistema::  Cuando la instalación ha finalizado
                                        satisfactoriamente.
* Instalación de Guix en una máquina virtual::  El patio de recreo del
                                                    sistema Guix.
* Construcción de la imagen de instalación::  Cómo esto llega a ser.


File: guix.es.info,  Node: Limitaciones,  Next: Consideraciones sobre el hardware,  Up: Instalación del sistema

3.1 Limitaciones
================

Consideramos que el sistema Guix está listo para un amplio rango de
casos de uso, tanto de servidor como de escritorio. Las garantías que
proporciona—actualizaciones transaccionales y vuelta atrás atómica,
reproducibilidad—lo convierten en un cimiento sólido.

   No obstante, antes de que proceda con la instalación, sea consciente
de las siguientes limitaciones apreciables que se conocen en la versión
1.0.1.17089-7e269:

   • No está implementada la funcionalidad del gestor de volúmenes
     lógicos (LVM).

   • Se proporcionan más y más servicios del sistema (*note
     Servicios::), pero pueden faltar algunos.

   • Están disponibles GNOME, Xfce, LXDE y Enlightenment (*note
     Servicios de escritorio::), así como un número de gestores de
     ventanas X11. No obstante, actualmente falta KDE.

   Más que una descarga de responsabilidades es una invitación a
informar de problemas (¡e historias satisfactorias!), y para unirse a
nosotras en su mejora. *Note Contribuir::, para más información.


File: guix.es.info,  Node: Consideraciones sobre el hardware,  Next: Instalación desde memoria USB y DVD,  Prev: Limitaciones,  Up: Instalación del sistema

3.2 Consideraciones sobre el hardware
=====================================

GNU Guix se enfoca en respetar la libertad de computación de las
usuarias. Se construye sobre el núcleo Linux-libre, lo que significa que
únicamente funciona hardware para el que existen controladores y
firmware libres. Hoy en día, un amplio rango del hardware común funciona
con GNU/Linux-libre—desde teclados a tarjetas gráficas a escáneres y
controladoras Ethernet. Desafortunadamente, todavía hay áreas donde los
fabricantes de hardware deniegan a las usuarias el control de su propia
computación, y dicho hardware no funciona en el sistema Guix.

   Una de las áreas principales donde faltan controladores o firmware
libre son los dispositivos WiFi. Los dispositivos WiFi que se sabe que
funcionan incluyen aquellos que usan los chips Atheros (AR9271 y
AR7010), que corresponden al controlador ‘ath9k’ de Linux-libre, y
aquellos que usan los chips Broadcom/AirForce (BCM43xx con Wireless-Core
Revisión 5), que corresponden al controlador ‘b43-open’ de Linux-libre.
Existe firmware libre para ambos, y está disponible por defecto en el
sistema Guix, como parte de ‘%base-firmware’ (*note ‘firmware’:
Referencia de operating-system.).

   La Fundación del Software Libre (https://www.fsf.org/) patrocina
“Respeta Su Libertad” (https://www.fsf.org/ryf) (RYF), un programa de
certificación para productos hardware que respetan su libertad y su
privacidad y se aseguran de que usted tenga el control sobre su
dispositivo. Le recomendamos que compruebe la lista de dispositivos
certificados RYF.

   Otro recurso útil es el sitio web H-Node (https://wwww.h-node.org/).
Contiene un catálogo de dispositivos hardware con información acerca su
funcionalidad con GNU/Linux.


File: guix.es.info,  Node: Instalación desde memoria USB y DVD,  Next: Preparación para la instalación,  Prev: Consideraciones sobre el hardware,  Up: Instalación del sistema

3.3 Instalación desde memoria USB y DVD
=======================================

An ISO-9660 installation image that can be written to a USB stick or
burnt to a DVD can be downloaded from
‘https://ftp.gnu.org/gnu/guix/guix-system-install-1.0.1.17089-7e269.x86_64-linux.iso.xz’,
where you can replace ‘x86_64-linux’ with one of:

‘x86_64-linux’
     para un sistema GNU/Linux en CPUs compatibles con la arquitectura
     de 64-bits de Intel/AMD;

‘i686-linux’
     para un sistema GNU/Linux en CPUs compatibles con la arquitectura
     de 32-bits de Intel.

   Asegúrese de descargar el fichero ‘.sig’ asociado y de verificar la
autenticidad de la imagen contra él, más o menos así:

     $ wget https://ftp.gnu.org/gnu/guix/guix-system-install-1.0.1.17089-7e269.x86_64-linux.iso.xz.sig
     $ gpg --verify guix-system-install-1.0.1.17089-7e269.x86_64-linux.iso.xz.sig

   Si la orden falla porque no dispone de la clave pública necesaria,
entonces ejecute esta otra orden para importarla:

     $ wget https://sv.gnu.org/people/viewgpg.php?user_id=15145 \
           -qO - | gpg --import -

y vuelva a ejecutar la orden ‘gpg --verify’.

   Tenga en cuenta que un aviso del tipo “Esta clave no esta certificada
con una firma de confianza” es normal.

   Esta imagen contiene las herramientas necesarias para una
instalación. Está pensada ara ser copiada _tal cual_ a una memoria USB o
DVD con espacio suficiente.

Copiado en una memoria USB
--------------------------

Para copiar la imagen en una memoria USB, siga estos pasos:

  1. Descomprima la imagen usando la orden ‘xz’:

          xz -d guix-system-install-1.0.1.17089-7e269.x86_64-linux.iso.xz

  2. Conecte una memoria USB de 1 GiB o más a su máquina, y determine su
     nombre de dispositivo. Asumiendo que la memoria USB es ‘/dev/sdX’
     copie la imagen con:

          dd if=guix-system-install-1.0.1.17089-7e269.x86_64-linux.iso of=/dev/sdX
          sync

     El acceso a ‘/dev/sdX’ normalmente necesita privilegios de root.

Grabación en un DVD
-------------------

Para copiar la imagen a un DVD, siga estos pasos:

  1. Descomprima la imagen usando la orden ‘xz’:

          xz -d guix-system-install-1.0.1.17089-7e269.x86_64-linux.iso.xz

  2. Introduzca un DVD en su máquina para grabarlo, y determine el
     nombre del dispositivo. Asumiendo que la unidad DVD es ‘/dev/srX’,
     copie la imagen con:

          growisofs -dvd-compat -Z /dev/srX=guix-system-install-1.0.1.17089-7e269.x86_64-linux.iso

     El acceso a ‘/dev/srX’ normalmente necesita privilegios de root.

Arranque
--------

Una vez hecho esto, debe ser capaz de reiniciar el sistema y arrancar
desde la memoria USB o el DVD. Para lo primero habitualmente es
necesario introducirse en la BIOS o en el menú de arranque UEFI, donde
se puede seleccionar el arranque desde la memoria USB. Para arrancar
desde Libreboot, cambie a la línea de ordenes pulsando la tecla ‘c’ y
teclee ‘search_grub usb’.

   *Note Instalación de Guix en una máquina virtual::, si, en vez de
esto, desea instalar el sistema Guix en una máquina virtual (VM).


File: guix.es.info,  Node: Preparación para la instalación,  Next: Instalación gráfica guiada,  Prev: Instalación desde memoria USB y DVD,  Up: Instalación del sistema

3.4 Preparación para la instalación
===================================

Once you have booted, you can use the guided graphical installer, which
makes it easy to get started (*note Instalación gráfica guiada::).
Alternatively, if you are already familiar with GNU/Linux and if you
want more control than what the graphical installer provides, you can
choose the “manual” installation process (*note Instalación manual::).

   El instalador gráfico está disponible en TTY1. Puede obtener consolas
de root en los TTY 3 a 6 pulsando ‘ctrl-alt-f3’, ‘ctrl-alt-f4’, etc.
TTY2 muestra esta documentación y se puede cambiar a dicha consola con
‘ctrl-alt-f2’. La documentación es explorable usando las órdenes del
lector Info (*note (info-stnd)Top::). El sistema de instalación ejecuta
el daemon GPM para ratones, el cual le permite seleccionar texto con el
botón izquierdo y pegarlo con el botón central.

     Nota: La instalación requiere acceso a Internet de modo que
     cualquier dependencia de su configuración de sistema no encontrada
     pueda ser descargada. Véase la sección “Red” más adelante.


File: guix.es.info,  Node: Instalación gráfica guiada,  Next: Instalación manual,  Prev: Preparación para la instalación,  Up: Instalación del sistema

3.5 Instalación gráfica guiada
==============================

El instalador gráfico es una interfaz de usuaria basada en texto. Le
guiará, con cajas de diálogo, a través de los pasos necesarios para
instalar el sistema GNU Guix.

   Las primeras cajas de diálogo le permiten configurar el sistema
mientras lo usa durante la instalación: puede seleccionar el idioma, la
distribución del teclado y configurar la red, la cual se usará durante
la instalación. La siguiente imagen muestra el diálogo de configuración
de red.

 [image src="images/installer-network.png" alt="configuración de red en la instalación
gráfica" ]

   Los siguientes pasos le permitirán particionar su disco duro, como se
muestra en la siguiente imagen, elegir si se usarán o no sistemas de
ficheros cifrados, introducir el nombre de la máquina, la contraseña de
root y crear cuentas adicionales, entre otras cosas.

 [image src="images/installer-partitions.png" alt="particionado en la instalación
gráfica" ]

   Tenga en cuenta que, en cualquier momento, el instalador le permite
salir de la instalación actual y retomarla en un paso previo, como se
muestra en la siguiente imagen.

 [image src="images/installer-resume.png" alt="retomado del proceso de instalación" ]

   Una vez haya finalizado, el instalador produce una configuración de
sistema operativo y la muestra (*note Uso de la configuración del
sistema::). En este punto puede pulsar “OK” y la instalación procederá.
En caso de finalización satisfactoria, puede reiniciar con el nuevo
sistema y disfrutarlo. ¡*Note Tras la instalación del sistema:: para ver
cómo proceder a continuación!


File: guix.es.info,  Node: Instalación manual,  Next: Tras la instalación del sistema,  Prev: Instalación gráfica guiada,  Up: Instalación del sistema

3.6 Instalación manual
======================

Esta sección describe como podría instalar “manualmente” el sistema
GNU Guix en su máquina. Esta opción requiere familiaridad con GNU/Linux,
con el shell y con las herramientas de administración comunes. Si piensa
que no es para usted, considere el uso del instalador gráfico guiado
(*note Instalación gráfica guiada::).

   El sistema de instalación proporciona consolas de root en los
terminales virtuales (TTY) 3 a 6; pulse ‘ctrl-alt-f3’, ‘ctrl-alt-f4’ y
sucesivas teclas para abrirlas. Incluye muchas herramientas comunes
necesarias para la instalación del sistema. Pero es también un sistema
Guix completo, lo que significa que puede instalar paquetes adicionales,
en caso de necesitarlos, mediante el uso de ‘guix package’ (*note
Invocación de guix package::).

* Menu:

* Distribución de teclado y red y particionado::  Configuración inicial.
* Procedimiento de instalación::  Instalación.


File: guix.es.info,  Node: Distribución de teclado y red y particionado,  Next: Procedimiento de instalación,  Up: Instalación manual

3.6.1 Distribución de teclado, red y particionado
-------------------------------------------------

Antes de instalar el sistema, puede desear ajustar la distribución del
teclado, configurar la red y particionar el disco duro deseado. Esta
sección le guiará durante este proceso.

3.6.1.1 Distribución de teclado
...............................

La imagen de instalación usa la distribución de teclado QWERTY de los
EEUU. Si desea cambiarla, puede usar la orden ‘loadkeys’. Por ejemplo,
la siguiente orden selecciona la distribución de teclado para el
castellano:

     loadkeys es

   Véanse los ficheros bajo ‘/run/current-system/profile/share/keymaps’
para la obtención de una lista de distribuciones de teclado disponibles.
Ejecute ‘man loadkeys’ para más información.

3.6.1.2 Red
...........

Ejecute la siguiente orden para ver los nombres asignados a sus
interfaces de red:

     ifconfig -a

... o, usando la orden específica de GNU/Linux ‘ip’:

     ip address

   El nombre de las interfaces de cable comienza con ‘e’; por ejemplo,
la interfaz que corresponde a la primera controladora Ethernet en la
placa se llama ‘eno1’. El nombre de las interfaces inalámbricas comienza
con ‘w’, como ‘w1p2s0’.

Conexión por cable
     Para configurar una red por cable ejecute la siguiente orden,
     substituyendo INTERFAZ con el nombre de la interfaz de cable que
     desea usar.

          ifconfig INTERFAZ up

     ... o, usando la orden específica de GNU/Linux ‘ip’:

          ip link set INTERFAZ up

Conexión sin cable
     Para configurar una red inalámbrica, puede crear un fichero de
     configuración para la herramienta de configuración ‘wpa_supplicant’
     (su ruta no es importante) usando uno de los editores de texto
     disponibles como ‘nano’:

          nano wpa_supplicant.conf

     Como un ejemplo, la siguiente plantilla puede colocarse en este
     fichero y funcionará para muchas redes inalámbricas, siempre que se
     proporcione el SSID y la contraseña reales de la red a la que se va
     a conectar:

          network={
            ssid="MI-SSID"
            key_mgmt=WPA-PSK
            psk="la contraseña de la red"
          }

     Inicie el servicio inalámbrico y lance su ejecución en segundo
     plano con la siguiente orden (sustituya INTERFAZ por el nombre de
     la interfaz de red que desea usar):

          wpa_supplicant -c wpa_supplicant.conf -i INTERFAZ -B

     Ejecute ‘man wpa_supplicant’ para más información.

   En este punto, necesita obtener una dirección IP. En una red donde
las direcciones IP se asignan automáticamente mediante DHCP, puede
ejecutar:

     dhclient -v INTERFAZ

   Intente hacer ping a un servidor para comprobar si la red está
funcionando correctamente:

     ping -c 3 gnu.org

   Configurar el acceso por red es casi siempre un requisito debido a
que la imagen no contiene todo el software y las herramientas que puedan
ser necesarias.

   Si necesita que el acceso a HTTP y HTTPS se produzca a través de un
proxy, ejecute la siguiente orden:

     herd set-http-proxy guix-daemon URL

donde URL es la URL del proxy, por ejemplo ‘http://example.org:8118’.

   Si lo desea, puede continuar la instalación de forma remota iniciando
un servidor SSH:

     herd start ssh-daemon

   Asegúrese de fijar una contraseña con ‘passwd’, o configurar la
verificación de clave pública de OpenSSH para la introducción en el
sistema.

3.6.1.3 Particionado de discos
..............................

A menos que se haya realizado previamente, el siguiente paso es el
particionado, y después dar formato a la/s partición/es deseadas.

   La imagen de instalación contiene varias herramientas de
particionado, incluyendo Parted (*note (parted)Overview::), ‘fdisk’ y
‘cfdisk’. Invoque su ejecución y configure el mapa de particiones
deseado en su disco:

     cfdisk

   Si su disco usa el formato de tabla de particiones GUID (GPT) y tiene
pensado instalar GRUB basado en BIOS (la opción predeterminada),
asegúrese de tener una partición de arranque BIOS disponible (*note
(grub)BIOS installation::).

   Si en vez de eso desea GRUB basado en EFI, se requiere una “Partición
del Sistema EFI” (ESP) con formato FAT32. Esta partición puede montarse
en ‘/boot/efi’ y debe tener la opción ‘esp’ activa. Por ejemplo, en
‘parted’:

     parted /dev/sda set 1 esp on

     Nota: ¿No esta segura si usar GRUB basado en EFI o en BIOS? Si el
     directorio ‘/sys/firmware/efi’ existe en la imagen de instalación,
     probablemente debería realizar una instalación EFI, usando
     ‘grub-efi-bootloader’. En otro caso, debe usar GRUB basado en BIOS,
     conocido como ‘grub-bootloader’. *Note Configuración del gestor de
     arranque::, para más información sobre cargadores de arranque.

   Una vez haya terminado con el particionado de la unidad de disco
deseada, tiene que crear un sistema de ficheros en la o las particiones
relevantes(1). Para la partición ESP, si tiene una y asumiendo que es
‘/dev/sda1’, ejecute:

     mkfs.fat -F32 /dev/sda1

   Preferentemente, asigne una etiqueta a los sistemas de ficheros de
modo que pueda referirse a ellos de forma fácil y precisa en las
declaraciones ‘file-system’ (*note Sistemas de ficheros::). Esto se
consigue habitualmente con la opción ‘-L’ de ‘mkfs.ext4’ y las ordenes
relacionadas. Por tanto, asumiendo que la partición de la raíz es
‘/dev/sda2’, se puede crear un sistema de ficheros con la etiqueta
‘mi-raiz’ de esta manera:

     mkfs.ext4 -L mi-raiz /dev/sda2

   If you are instead planning to encrypt the root partition, you can
use the Cryptsetup/LUKS utilities to do that (see ‘man cryptsetup’ for
more information). Assuming you want to store the root partition on
‘/dev/sda2’, the command sequence would be along these lines:

     cryptsetup luksFormat /dev/sda2
     cryptsetup open --type luks /dev/sda1 mi-particion
     mkfs.ext4 -L mi-raiz /dev/mapper/mi-particion

   Una vez hecho esto, monte el sistema de ficheros deseado bajo ‘/mnt’
con una orden como (de nuevo, asumiendo que ‘mi-raiz’ es la etiqueta del
sistema de ficheros raíz):

     mount LABEL=mi-raiz /mnt

   Monte también cualquier otro sistema de ficheros que desee usar en el
sistema resultante relativamente a esta ruta. Si ha optado por
‘/boot/efi’ como el punto de montaje de EFI, por ejemplo, ahora debe ser
montada en ‘/mnt/boot/efi’ para que ‘guix system init’ pueda encontrarla
más adelante.

   Finalmente, si planea usar una o más particiones de intercambio
(*note swap space: (libc)Memory Concepts.), asegúrese de inicializarla
con ‘mkswap’. Asumiendo que tuviese una partición de intercambio en
‘/dev/sda3’, ejecutaría:

     mkswap /dev/sda3
     swapon /dev/sda3

   De manera alternativa, puede usar un fichero de intercambio. Por
ejemplo, asumiendo que en el nuevo sistema desea usar el fichero
‘/fichero-de-intercambio’ como tal, ejecutaría(2):

     # Esto son 10GiB de espacio de intercambio. Ajuste "count" para
     # cambiar el tamaño.
     dd if=/dev/zero of=/mnt/swapfile bs=1MiB count=10240
     # Por seguridad, se le conceden permisos de lectura y escritura
     # únicamente a root.
     chmod 600 /mnt/swapfile
     mkswap /mnt/swapfile
     swapon /mnt/swapfile

   Fíjese que si ha cifrado la partición raíz y creado un fichero de
intercambio en su sistema de ficheros como se ha descrito anteriormente,
el cifrado también protege al fichero de intercambio, como a cualquier
fichero en dicho sistema de ficheros.

   ---------- Footnotes ----------

   (1) Actualmente el sistema Guix únicamente permite sistemas de
ficheros ext4, btrfs y JFS. En particular, el código que lee UUIDs del
sistema de ficheros y etiquetas únicamente funciona para dichos sistemas
de ficheros.

   (2) Este ejemplo funcionará para muchos tipos de sistemas de ficheros
(por ejemplo, ext4). No obstante, para los sistemas de ficheros con
mecanismos de copia-durante-escritura (por ejemplo, btrfs) los pasos
pueden ser diferentes. Para obtener más detalles, véanse las páginas de
manual para ‘mkswap’ y ‘swapon’.


File: guix.es.info,  Node: Procedimiento de instalación,  Prev: Distribución de teclado y red y particionado,  Up: Instalación manual

3.6.2 Procedimiento de instalación
----------------------------------

Con las particiones deseadas listas y la raíz deseada montada en ‘/mnt’,
estamos preparadas para empezar. Primero, ejecute:

     herd start cow-store /mnt

   Esto activa la copia-durante-escritura en ‘/gnu/store’, de modo que
los paquetes que se añadan durante la fase de instalación se escriban en
el disco montado en ‘/mnt’ en vez de permanecer en memoria. Esto es
necesario debido a que la primera fase de la orden ‘guix system init’
(vea más adelante) implica descargas o construcciones en ‘/gnu/store’,
el cual, inicialmente, está un sistema de ficheros en memoria.

   Después debe editar un fichero y proporcionar la declaración de
sistema operativo a instalar. Para dicho fin, el sistema de instalación
viene con tres editores de texto. Recomendamos GNU nano (*note
(nano)Top::), que permite el resaltado de sintaxis y correspondencia de
paréntesis; los otros editores son GNU Zile (un clon de Emacs) y nvi (un
clon del editor ‘vi’ original de BSD). Le recomendamos encarecidamente
almacenar ese fichero en el sistema de ficheros raíz, digamos, como
‘/mnt/etc/config.scm’. En caso de no hacerlo, habrá perdido su
configuración del sistema una vez arranque en el sistema recién
instalado.

   *Note Uso de la configuración del sistema::, para hacerse una idea
del fichero de configuración. Las configuraciones de ejemplo mencionadas
en esa sección están disponibles bajo ‘/etc/configuration’ en la imagen
de instalación. Por tanto, para empezar con una configuración del
sistema que proporcione un servidor gráfico (un sistema de
“escritorio”), puede ejecutar algo parecido a estas órdenes:

     # mkdir /mnt/etc
     # cp /etc/configuration/desktop.scm /mnt/etc/config.scm
     # nano /mnt/etc/config.scm

   Debe prestar atención a lo que su fichero de configuración contiene,
y en particular:

   • Asegúrese que la forma ‘bootloader-configuration’ especifica la
     localización deseada de la instalación de GRUB. Debe mencionar
     ‘grub-bootloader’ si está usando GRUB con el arranque antiguo, o
     ‘grub-efi-bootloader’ para sistemas más nuevos UEFI. Para los
     sistemas antiguos, el campo ‘target’ denomina un dispositivo, como
     ‘/dev/sda’; para los sistemas UEFI denomina la ruta de una
     partición EFI montada, como ‘/boot/efi’; asegúrese de que la ruta
     está actualmente montada y haya una entrada ‘file-system’
     especificada en su configuración.

   • Asegúrese que las etiquetas de su sistema de ficheros corresponden
     con el valor de sus campos ‘device’ respectivos en su configuración
     ‘file-system’, asumiendo que su configuración ‘file-system’ usa el
     procedimiento ‘file-system-label’ en su campo ‘device’.

   • Si hay particiones cifradas o en RAID, asegúrese de añadir un campo
     ‘mapped-devices’ para describirlas (*note Dispositivos
     traducidos::).

   Una vez haya terminado de preparar el fichero de configuración, el
nuevo sistema debe ser inicializado (recuerde que el sistema de ficheros
raíz deseado está montado bajo ‘/mnt’):

     guix system init /mnt/etc/config.scm /mnt

Esto copia todos los ficheros necesarios e instala GRUB en ‘/dev/sdX’, a
menos que proporcione la opción ‘--no-bootloader’. Para más información,
*note Invocación de guix system::. Esta orden puede desencadenar
descargas o construcciones de paquetes no encontrados, lo cual puede
tomar algún tiempo.

   Una vez que la orden se complete—¡y, deseablemente, de forma
satisfactoria!—puede ejecutar ‘reboot’ y arrancar con el nuevo sistema.
La contraseña de ‘root’ en el nuevo sistema está vacía inicialmente;
otras contraseñas de usuarias tienen que ser inicializadas ejecutando la
orden ‘passwd’ como ‘root’, a menos que en su configuración se
especifique de otra manera (*note contraseñas de cuentas de usuaria:
user-account-password.). ¡*Note Tras la instalación del sistema:: para
proceder a continuación!


File: guix.es.info,  Node: Tras la instalación del sistema,  Next: Instalación de Guix en una máquina virtual,  Prev: Instalación manual,  Up: Instalación del sistema

3.7 Tras la instalación del sistema
===================================

¡Éxito! ¡Ha arrancado en el sistema Guix! De ahora en adelante, puede
actualizar el sistema cuando quiera mediante la ejecución de, digamos:

     guix pull
     sudo guix system reconfigure /etc/config.scm

Esto construye una nueva generación del sistema con los últimos paquetes
y servicios (*note Invocación de guix system::). Recomendamos realizarlo
de manera regular de modo que su sistema incluya las últimas
actualizaciones de seguridad (*note Actualizaciones de seguridad::).

     Nota: Note that ‘sudo guix’ runs your user’s ‘guix’ command and
     _not_ root’s, because ‘sudo’ leaves ‘PATH’ unchanged. To explicitly
     run root’s ‘guix’, type ‘sudo -i guix ...’.

     La diferencia es importante aquí, puesto que ‘guix pull’ actualiza
     la orden ‘guix’ y las definiciones de paquetes únicamente para la
     usuaria que lo ejecute. Esto significa que si desea usar ‘guix
     system reconfigure’ en un shell en el que haya ingresado al sistema
     como root, deberá ejecutar de manera de manera separada ‘guix
     pull’.

   ¡Unase a nosotras en ‘#guix’ en la red IRC Freenode o en
‘guix-devel@gnu.org’ para compartir su experiencia!


File: guix.es.info,  Node: Instalación de Guix en una máquina virtual,  Next: Construcción de la imagen de instalación,  Prev: Tras la instalación del sistema,  Up: Instalación del sistema

3.8 Instalación de Guix en una máquina virtual
==============================================

Si desea instalar el sistema Guix en una máquina virtual (VM) o en un
servidor privado virtual (VPS) en vez de en su preciada máquina, esta
sección es para usted.

   Si quiere arrancar una VM QEMU (https://qemu.org/) para instalar el
sistema Guix en una imagen de disco, siga estos pasos:

  1. Primero, obtenga y descomprima la imagen de instalación del sistema
     Guix como se ha descrito previamente (*note Instalación desde
     memoria USB y DVD::).

  2. Cree una imagen de disco que contendrá el sistema instalado. Para
     crear una imagen de disco con formato qcow2, use la orden
     ‘qemu-img’:

          qemu-img create -f qcow2 guix-system.img 50G

     El fichero que obtenga será mucho menor de 50GB (típicamente menos
     de 1MB), pero crecerá cuando el dispositivo de almacenamiento
     virtualizado se vaya llenando.

  3. Arranque la imagen de instalación USB en una máquina virtual:

          qemu-system-x86_64 -m 1024 -smp 1 -enable-kvm \
            -nic user,model=virtio-net-pci -boot menu=on,order=d \
            -drive file=guix-system.img \
            -drive media=cdrom,file=guix-system-install-1.0.1.17089-7e269.SISTEMA.iso

     ‘-enable-kvm’ es opcional, pero mejora el rendimiento
     significativamente, *note Ejecutar Guix en una máquina virtual::.

  4. Ahora es root en la VM, prosiga con el procedimiento de
     instalación. *Note Preparación para la instalación::, y siga las
     instrucciones.

   Una vez complete la instalación, puede arrancar el sistema que está
en la imagen ‘guix-system.img’. *Note Ejecutar Guix en una máquina
virtual::, para información sobre cómo hacerlo.


File: guix.es.info,  Node: Construcción de la imagen de instalación,  Prev: Instalación de Guix en una máquina virtual,  Up: Instalación del sistema

3.9 Construcción de la imagen de instalación
============================================

La imagen de instalación descrita anteriormente se construyó usando la
orden ‘guix system’, específicamente:

     guix system disk-image --file-system-type=iso9660 \
       gnu/system/install.scm

   Eche un vistazo a ‘gnu/system/install.scm’ en el árbol de fuentes, y
vea también *note Invocación de guix system:: para más información
acerca de la imagen de instalación.

3.10 Construcción de la imagen de instalación para placas ARM
=============================================================

Muchos dispositivos con procesador ARM necesitan una variante específica
del cargador de arranque U-Boot (https://www.denx.de/wiki/U-Boot/).

   Si construye una imagen de disco y el cargador de arranque no está
disponible de otro modo (en otra unidad de arranque, etc.), es
recomendable construir una imagen que incluya el cargador,
específicamente:

     guix system disk-image --system=armhf-linux -e '((@ (gnu system install) os-with-u-boot) (@ (gnu system install) installation-os) "A20-OLinuXino-Lime2")'

   ‘A20-OLinuXino-Lime2’ es el nombre de la placa. Si especifica una
placa no válida, una lista de placas posibles será mostrada.


File: guix.es.info,  Node: Gestión de paquetes,  Next: Desarrollo,  Prev: Instalación del sistema,  Up: Top

4 Gestión de paquetes
*********************

El propósito de GNU Guix es permitir a las usuarias instalar, actualizar
y borrar fácilmente paquetes de software, sin tener que conocer acerca
de sus procedimientos de construcción o dependencias. Guix también va
más allá de este conjunto obvio de características.

   Este capítulo describe las principales características de Guix, así
como las herramientas de gestión de paquetes que ofrece. Junto a la
interfaz de línea de órdenes descrita a continuación (*note ‘guix
package’: Invocación de guix package, también puede usar la interfaz
Emacs-Guix (*note (emacs-guix)Top::), tras la instalación del paquete
‘emacs-guix’ (ejecute la orden ‘M-x guix-help’ para iniciarse en su
uso):

     guix install emacs-guix

* Menu:

* Características::         Cómo Guix dará brillo a su vida.
* Invocación de guix package::  Instalación de paquetes, borrado, etc.
* Sustituciones::            Descargar binarios pre-construidos.
* Paquetes con múltiples salidas::  Un único paquete de fuentes,
                                       múltiples salidas.
* Invocación de guix gc::   Ejecutar el recolector de basura.
* Invocación de guix pull::  Obtener la última versión de Guix y la
                                distribución.
* Canales::                  Personalizar el recolector de basura.
* Invocación de guix time-machine::  Ejecutar una versión antigua de Guix.
* Inferiores::               Interactuar con otra revisión de Guix.
* Invocación de guix describe::  Muestra información acerca de su
                                    revisión de Guix.
* Invocación de guix archive::  Exportar e importar ficheros del almacén.


File: guix.es.info,  Node: Características,  Next: Invocación de guix package,  Up: Gestión de paquetes

4.1 Características
===================

Cuando se usa Guix, cada paquete se encuentra en el “almacén de
paquetes”, en su propio directorio—algo que se asemeja a
‘/gnu/store/xxx-paquete-1.2’, donde ‘xxx’ es una cadena en base32.

   En vez de referirse a estos directorios, las usuarias tienen su
propio “perfil”, el cual apunta a los paquetes que realmente desean
usar. Estos perfiles se almacenan en el directorio de cada usuaria, en
‘$HOME/.guix-profile’.

   Por ejemplo, ‘alicia’ instala GCC 4.7.2. Como resultado,
‘/home/alicia/.guix-profile/bin/gcc’ apunta a
‘/gnu/store/...-gcc-4.7.2/bin/gcc’. Ahora, en la misma máquina, ‘rober’
ha instalado ya GCC 4.8.0. El perfil de ‘rober’ simplemente sigue
apuntando a ‘/gnu/store/...-gcc-4.8.0/bin/gcc’—es decir, ambas versiones
de GCC pueden coexistir en el mismo sistema sin ninguna interferencia.

   La orden ‘guix package’ es la herramienta central para gestión de
paquetes (*note Invocación de guix package::). Opera en los perfiles de
usuaria, y puede ser usada _con privilegios de usuaria normal_.

   La orden proporciona las operaciones obvias de instalación, borrado y
actualización. Cada invocación es en realidad una _transacción_: o bien
la operación especificada se realiza satisfactoriamente, o bien nada
sucede. Por tanto, si el proceso ‘guix package’ es finalizado durante
una transacción, o un fallo eléctrico ocurre durante la transacción, el
perfil de usuaria permanece en su estado previo, y permanece usable.

   Además, cualquier transacción de paquetes puede ser _vuelta atrás_.
Si, por ejemplo, una actualización instala una nueva versión de un
paquete que resulta tener un error importante, las usuarias pueden
volver a la instancia previa de su perfil, de la cual se tiene
constancia que funcionaba bien. De igual modo, la configuración global
del sistema en Guix está sujeta a actualizaciones transaccionales y
vuelta atrás (*note Uso de la configuración del sistema::).

   Todos los paquetes en el almacén de paquetes pueden ser _eliminados
por el recolector de basura_. Guix puede determinar a qué paquetes hacen
referencia todavía los perfiles de usuarias, y eliminar aquellos que, de
forma demostrable, no se haga referencia en ningún perfil (*note
Invocación de guix gc::). Las usuarias pueden también borrar
explícitamente generaciones antiguas de su perfil para que los paquetes
a los que hacen referencia puedan ser recolectados.

   Guix toma una aproximación “puramente funcional” en la gestión de
paquetes, como se describe en la introducción (*note Introducción::).
Cada nombre de directorio de paquete en ‘/gnu/store’ contiene un hash de
todas las entradas que fueron usadas para construir el
paquete—compilador, bibliotecas, guiones de construcción, etc. Esta
correspondencia directa permite a las usuarias asegurarse que una
instalación dada de un paquete corresponde al estado actual de su
distribución. Esto también ayuda a maximizar la “reproducibilidad de la
construcción”: gracias al uso de entornos aislados de construcción, una
construcción dada probablemente generará ficheros idénticos bit-a-bit
cuando se realice en máquinas diferentes (*note container: Invocación de
guix-daemon.).

   Estos cimientos permiten a Guix ofrecer “despliegues transparentes de
binarios/fuentes”. Cuando un binario pre-construido para un elemento de
‘/gnu/store’ está disponible para descarga de una fuente externa—una
“sustitución”, Guix simplemente lo descarga y desempaqueta; en otro caso
construye el paquete de las fuentes, localmente (*note Sustituciones::).
Debido a que los resultados de construcción son normalmente
reproducibles bit-a-bit, las usuarias no tienen que confiar en los
servidores que proporcionan sustituciones: pueden forzar una
construcción local y _retar_ a las proveedoras (*note Invocación de guix
challenge::).

   El control sobre el entorno de construcción es una característica que
también es útil para desarrolladoras. La orden ‘guix environment’
permite a desarrolladoras de un paquete configurar rápidamente el
entorno de desarrollo correcto para su paquete, sin tener que instalar
manualmente las dependencias del paquete en su perfil (*note Invocación
de guix environment::).

   Todo Guix y sus definiciones de paquetes están bajo control de
versiones, y ‘guix pull’ le permite “viajar en el tiempo” por la
historia del mismo Guix (*note Invocación de guix pull::). Esto hace
posible replicar una instancia de Guix en una máquina diferente o en un
punto posterior del tiempo, lo que a su vez le permite _replicar
entornos de software completos_, mientras que mantiene un preciso
“seguimiento de la procedencia” del software.


File: guix.es.info,  Node: Invocación de guix package,  Next: Sustituciones,  Prev: Características,  Up: Gestión de paquetes

4.2 Invocación de ‘guix package’
================================

La orden ‘guix package’ es la herramienta que permite a las usuarias
instalar, actualizar y borrar paquetes, así como volver a
configuraciones previas. Opera únicamente en el perfil propio de la
usuaria, y funciona con privilegios de usuaria normal (*note
Características::). Su sintaxis es:

     guix package OPCIONES

   Primariamente, OPCIONES especifica las operaciones a ser realizadas
durante la transacción. Al completarse, un nuevo perfil es creado, pero
las “generaciones” previas del perfil permanecen disponibles, en caso de
que la usuaria quisiera volver atrás.

   Por ejemplo, para borrar ‘lua’ e instalar ‘guile’ y ‘guile-cairo’ en
una única transacción:

     guix package -r lua -i guile guile-cairo

   Para su conveniencia, también se proporcionan los siguientes alias:

   • ‘guix search’ es un alias de ‘guix package -s’,
   • ‘guix install’ es un alias de ‘guix package -i’,
   • ‘guix remove’ es un alias de ‘guix package -r’,
   • ‘guix upgrade’ es un alias de ‘guix package -u’
   • y ‘guix show’ es un alias de ‘guix package --show=’.

   Estos alias tienen menos capacidad expresiva que ‘guix package’ y
proporcionan menos opciones, por lo que en algunos casos es probable que
desee usar ‘guix package’ directamente.

   ‘guix package’ también proporciona una “aproximación declarativa”,
donde la usuaria especifica el conjunto exacto de paquetes a poner
disponibles y la pasa a través de la opción ‘--manifest’ (*note
‘--manifest’: profile-manifest.).

   For each user, a symlink to the user’s default profile is
automatically created in ‘$HOME/.guix-profile’. This symlink always
points to the current generation of the user’s default profile. Thus,
users can add ‘$HOME/.guix-profile/bin’ to their ‘PATH’ environment
variable, and so on. Si no está usando el sistema Guix, considere la
adición de las siguientes líneas en su ‘~/.bash_profile’ (*note
(bash)Bash Startup Files::) de manera que los nuevos shell que ejecute
obtengan todas las definiciones correctas de las variables de entorno:

     GUIX_PROFILE="$HOME/.guix-profile" ; \
     source "$HOME/.guix-profile/etc/profile"

   In a multi-user setup, user profiles are stored in a place registered
as a “garbage-collector root”, which ‘$HOME/.guix-profile’ points to
(*note Invocación de guix gc::). That directory is normally
‘LOCALSTATEDIR/guix/profiles/per-user/USER’, where LOCALSTATEDIR is the
value passed to ‘configure’ as ‘--localstatedir’, and USER is the user
name. The ‘per-user’ directory is created when ‘guix-daemon’ is started,
and the USER sub-directory is created by ‘guix package’.

   Las OPCIONES pueden ser las siguientes:

‘--install=PAQUETE ...’
‘-i PAQUETE ...’
     Instala los PAQUETEs especificados.

     Each PACKAGE may specify either a simple package name, such as
     ‘guile’, or a package name followed by an at-sign and version
     number, such as ‘guile@1.8.8’ or simply ‘guile@1.8’ (in the latter
     case, the newest version prefixed by ‘1.8’ is selected).

     Si no se especifica un número de versión, la última versión
     disponible será seleccionada. Además, PAQUETE puede contener dos
     puntos, seguido por el nombre de una de las salidas del paquete,
     como en ‘gcc:doc’ o ‘binutils@2.22:lib’ (*note Paquetes con
     múltiples salidas::). Los paquetes con el nombre correspondiente (y
     opcionalmente la versión) se buscan entre los módulos de la
     distribución GNU (*note Módulos de paquetes::).

     A veces los paquetes tienen “entradas propagadas”: estas son las
     dependencias que se instalan automáticamente junto al paquete
     requerido (*note ‘propagated-inputs’ in ‘package’ objects:
     package-propagated-inputs, para información sobre las entradas
     propagadas en las definiciones de paquete).

     Un ejemplo es la biblioteca GNU MPC: sus ficheros de cabecera C
     hacen referencia a los de la biblioteca GNU MPFR, que a su vez
     hacen referencia a los de la biblioteca GMP. Por tanto, cuando se
     instala MPC, las bibliotecas MPFR y GMP también se instalan en el
     perfil; borrar MPC también borra MPFR y GMP—a menos que también se
     hayan instalado explícitamente por la usuaria.

     Besides, packages sometimes rely on the definition of environment
     variables for their search paths (see explanation of
     ‘--search-paths’ below). Any missing or possibly incorrect
     environment variable definitions are reported here.

‘--install-from-expression=EXP’
‘-e EXP’
     Instala el paquete al que EXP evalúa.

     EXP debe ser una expresión Scheme que evalúe a un objeto
     ‘<package>’. Esta opción es notablemente útil para diferenciar
     entre variantes con el mismo nombre de paquete, con expresiones
     como ‘(@ (gnu packages base) guile-final)’.

     Fíjese que esta opción instala la primera salida del paquete
     especificado, lo cual puede ser insuficiente cuando se necesita una
     salida específica de un paquete con múltiples salidas.

‘--install-from-file=FICHERO’
‘-f FICHERO’
     Instala el paquete que resulta de evaluar el código en FICHERO.

     Como un ejemplo, FICHERO puede contener una definición como esta
     (*note Definición de paquetes::):

          (use-modules (guix)
                       (guix build-system gnu)
                       (guix licenses))

          (package
            (name "hello")
            (version "2.10")
            (source (origin
                      (method url-fetch)
                      (uri (string-append "mirror://gnu/hello/hello-" version
                                          ".tar.gz"))
                      (sha256
                       (base32
                        "0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i"))))
            (build-system gnu-build-system)
            (synopsis "Hello, GNU world: An example GNU package")
            (description "Guess what GNU Hello prints!")
            (home-page "http://www.gnu.org/software/hello/")
            (license gpl3+))

     Las desarrolladoras pueden encontrarlo útil para incluir un fichero
     ‘guix.scm’ in la raíz del árbol de fuentes de su proyecto que puede
     ser usado para probar imágenes de desarrollo y crear entornos de
     desarrollo reproducibles (*note Invocación de guix environment::).

     The FILE may also contain a JSON representation of one or more
     package definitions. Running ‘guix package -f’ on ‘hello.json’ with
     the following contents would result in installing the package
     ‘greeter’ after building ‘myhello’:

          [
            {
              "name": "myhello",
              "version": "2.10",
              "source": "mirror://gnu/hello/hello-2.10.tar.gz",
              "build-system": "gnu",
              "arguments": {
                "tests?": false
              }
              "home-page": "https://www.gnu.org/software/hello/",
              "synopsis": "Hello, GNU world: An example GNU package",
              "description": "GNU Hello prints a greeting.",
              "license": "GPL-3.0+",
              "native-inputs": ["gettext"]
            },
            {
              "name": "greeter",
              "version": "1.0",
              "source": "https://example.com/greeter-1.0.tar.gz",
              "build-system": "gnu",
              "arguments": {
                "test-target": "foo",
                "parallel-build?": false,
              },
              "home-page": "https://example.com/",
              "synopsis": "Greeter using GNU Hello",
              "description": "This is a wrapper around GNU Hello.",
              "license": "GPL-3.0+",
              "inputs": ["myhello", "hello"]
            }
          ]

‘--remove=PAQUETE ...’
‘-r PAQUETE ...’
     Borra los PAQUETEs especificados.

     As for ‘--install’, each PACKAGE may specify a version number
     and/or output name in addition to the package name. For instance,
     ‘-r glibc:debug’ would remove the ‘debug’ output of ‘glibc’.

‘--upgrade[=REGEXP ...]’
‘-u [REGEXP ...]’
     Upgrade all the installed packages. If one or more REGEXPs are
     specified, upgrade only installed packages whose name matches a
     REGEXP. Also see the ‘--do-not-upgrade’ option below.

     Tenga en cuenta que esto actualiza los paquetes a la última versión
     encontrada en la distribución instalada actualmente. Para
     actualizar su distribución, debe ejecutar regularmente ‘guix pull’
     (*note Invocación de guix pull::).

‘--do-not-upgrade[=REGEXP ...]’
     When used together with the ‘--upgrade’ option, do _not_ upgrade
     any packages whose name matches a REGEXP. For example, to upgrade
     all packages in the current profile except those containing the
     substring “emacs”:

          $ guix package --upgrade . --do-not-upgrade emacs

‘--manifest=FICHERO’
‘-m FICHERO’
     Crea una nueva generación del perfil desde el objeto de manifiesto
     devuelto por el código Scheme en FICHERO. Esta opción puede
     repetirse varias veces, en cuyo caso los manifiestos se concatenan.

     This allows you to _declare_ the profile’s contents rather than
     constructing it through a sequence of ‘--install’ and similar
     commands. The advantage is that FILE can be put under version
     control, copied to different machines to reproduce the same
     profile, and so on.

     FICHERO debe devolver un objeto “manifest”, que es básicamente una
     lista de paquetes:

          (use-package-modules guile emacs)

          (packages->manifest
           (list emacs
                 guile-2.0
                 ;; Usa una salida específica del paquete.
                 (list guile-2.0 "debug")))

     En este ejemplo tenemos que conocer qué módulos definen las
     variables ‘emacs’ y ‘guile-2.0’ para proporcionar la línea
     ‘use-package-modules’ correcta, lo cual puede ser complicado. En
     cambio podemos proporcionar especificaciones regulares de paquetes
     y dejar a ‘specifications->manifest’ buscar los objetos de paquete
     correspondientes así:

          (specifications->manifest
           '("emacs" "guile@2.2" "guile@2.2:debug"))

‘--roll-back’
     Vuelve a la “generación” previa del perfil—es decir, deshace la
     última transacción.

     When combined with options such as ‘--install’, roll back occurs
     before any other actions.

     Cuando se vuelve atrás en la primera generación que realmente
     contiene paquetes instalados, se hace que el perfil apunte a la
     “generación cero”, la cual no contiene ningún fichero a excepción
     de sus propios metadatos.

     Después de haber vuelto atrás, instalar, borrar o actualizar
     paquetes sobreescribe las generaciones futuras previas. Por tanto,
     la historia de las generaciones en un perfil es siempre linear.

‘--switch-generation=PATRÓN’
‘-S PATRÓN’
     Cambia a una generación particular definida por el PATRÓN.

     PATTERN may be either a generation number or a number prefixed with
     “+” or “-”. The latter means: move forward/backward by a specified
     number of generations. For example, if you want to return to the
     latest generation after ‘--roll-back’, use
     ‘--switch-generation=+1’.

     The difference between ‘--roll-back’ and ‘--switch-generation=-1’
     is that ‘--switch-generation’ will not make a zeroth generation, so
     if a specified generation does not exist, the current generation
     will not be changed.

‘--search-paths[=TIPO]’
     Informa de variables de entorno, en sintaxis Bash, que pueden
     necesitarse para usar el conjunto de paquetes instalado. Estas
     variables de entorno se usan para especificar las “rutas de
     búsqueda” para ficheros usadas por algunos de los paquetes.

     For example, GCC needs the ‘CPATH’ and ‘LIBRARY_PATH’ environment
     variables to be defined so it can look for headers and libraries in
     the user’s profile (*note (gcc)Environment Variables::). If GCC
     and, say, the C library are installed in the profile, then
     ‘--search-paths’ will suggest setting these variables to
     ‘PROFILE/include’ and ‘PROFILE/lib’, respectively.

     El caso de uso típico es para definir estas variables de entorno en
     el shell:

          $ eval `guix package --search-paths`

     TIPO puede ser ‘exact’, ‘prefix’ o ‘suffix’, lo que significa que
     las definiciones de variables de entorno devueltas serán
     respectivamente las configuraciones exactas, prefijos o sufijos del
     valor actual de dichas variables. Cuando se omite, el valor
     predeterminado de TIPO es ‘exact’.

     Esta opción puede usarse para calcular las rutas de búsqueda
     _combinadas_ de varios perfiles. Considere este ejemplo:

          $ guix package -p foo -i guile
          $ guix package -p bar -i guile-json
          $ guix package -p foo -p bar --search-paths

     The last command above reports about the ‘GUILE_LOAD_PATH’
     variable, even though, taken individually, neither ‘foo’ nor ‘bar’
     would lead to that recommendation.

‘--profile=PERFIL’
‘-p PERFIL’
     Usa PERFIL en vez del perfil predeterminado de la usuaria.

     PERFIL debe ser el nombre de un fichero que se creará tras
     completar las tareas. Concretamente, PERFIL sera simplemente un
     enlace simbólico (“symlink”) que apunta al verdadero perfil en el
     que se instalan los paquetes:

          $ guix install hello -p ~/código/mi-perfil
          ...
          $ ~/código/mi-perfil/bin/hello
          ¡Hola mundo!

     Todo lo necesario para deshacerse del perfil es borrar dicho enlace
     simbólico y sus enlaces relacionados que apuntan a generaciones
     específicas:

          $ rm ~/código/mi-perfil ~/código/mi-perfil-*-link

‘--list-profiles’
     Enumera los perfiles de la usuaria:

          $ guix package --list-profiles
          /home/carlos/.guix-profile
          /home/carlos/código/mi-perfil
          /home/carlos/código/perfil-desarrollo
          /home/carlos/tmp/prueba

     Cuando se ejecuta como root, enumera todos los perfiles de todas
     las usuarias.

‘--allow-collisions’
     Permite colisiones de paquetes en el nuevo perfil. ¡Úselo bajo su
     propio riesgo!

     Por defecto, ‘guix package’ informa como un error las “colisiones”
     en el perfil. Las colisiones ocurren cuando dos o más versiones
     diferentes o variantes de un paquete dado se han seleccionado para
     el perfil.

‘--bootstrap’
     Use el Guile usado para el lanzamiento para construir el perfil.
     Esta opción es util únicamente a las desarrolladoras de la
     distribución.

   Además de estas acciones, ‘guix package’ acepta las siguientes
opciones para consultar el estado actual de un perfil, o la
disponibilidad de paquetes:

‘--search=REGEXP’
‘-s REGEXP’
     Enumera los paquetes disponibles cuyo nombre, sinopsis o
     descripción corresponde con REGEXP (sin tener en cuenta la
     capitalización), ordenados por relevancia. Imprime todos los
     metadatos de los paquetes coincidentes en formato ‘recutils’ (*note
     GNU recutils databases: (recutils)Top.).

     Esto permite extraer campos específicos usando la orden ‘recsel’,
     por ejemplo:

          $ guix package -s malloc | recsel -p name,version,relevance
          name: jemalloc
          version: 4.5.0
          relevance: 6

          name: glibc
          version: 2.25
          relevance: 1

          name: libgc
          version: 7.6.0
          relevance: 1

     De manera similar, para mostrar el nombre de todos los paquetes
     disponibles bajo los términos de la GNU LGPL versión 3:

          $ guix package -s "" | recsel -p name -e 'license ~ "LGPL 3"'
          name: elfutils

          name: gmp
          ...

     También es posible refinar los resultados de búsqueda mediante el
     uso de varias opciones ‘-s’, o varios parámetros a ‘guix search’.
     Por ejemplo, la siguiente orden devuelve un lista de juegos de
     mesa(1) (esta vez mediante el uso del alias ‘guix search’:

          $ guix search '\<board\>' game | recsel -p name
          name: gnubg
          ...

     Si omitimos ‘-s game’, también obtendríamos paquetes de software
     que tengan que ver con placas de circuitos impresos ("circuit
     board" en inglés); borrar los signos mayor y menor alrededor de
     ‘board’ añadiría paquetes que tienen que ver con teclados (keyboard
     en inglés).

     Y ahora para un ejemplo más elaborado. La siguiente orden busca
     bibliotecas criptográficas, descarta bibliotecas Haskell, Perl,
     Python y Ruby, e imprime el nombre y la sinopsis de los paquetes
     resultantes:

          $ guix search crypto library | \
              recsel -e '! (name ~ "^(ghc|perl|python|ruby)")' -p name,synopsis

     *Note (recutils)Selection Expressions::, para más información en
     “expresiones de selección” para ‘recsel -e’.

‘--show=PAQUETE’
     Muestra los detalles del PAQUETE, tomado de la lista disponible de
     paquetes, en formato ‘recutils’ (*note GNU recutils databases:
     (recutils)Top.).

          $ guix package --show=python | recsel -p name,version
          name: python
          version: 2.7.6

          name: python
          version: 3.3.5

     También puede especificar el nombre completo de un paquete para
     únicamente obtener detalles sobre una versión específica (esta vez
     usando el alias ‘guix show’):
          $ guix show python@3.4 | recsel -p name,version
          name: python
          version: 3.4.3

‘--list-installed[=REGEXP]’
‘-I [REGEXP]’
     Enumera los paquetes actualmente instalados en el perfil
     especificado, con los últimos paquetes instalados mostrados al
     final. Cuando se especifica REGEXP, enumera únicamente los paquetes
     instalados cuyos nombres son aceptados por REGEXP.

     Por cada paquete instalado, imprime los siguientes elementos,
     separados por tabuladores: el nombre del paquete, la cadena de
     versión, la parte del paquete que está instalada (por ejemplo,
     ‘out’ para la salida predeterminada, ‘include’ para sus cabeceras,
     etc.), y la ruta de este paquete en el almacén.

‘--list-available[=REGEXP]’
‘-A [REGEXP]’
     Enumera los paquetes disponibles actualmente en la distribución
     para este sistema (*note Distribución GNU::). Cuando se especifica
     REGEXP, enumera únicamente paquetes disponibles cuyo nombre
     coincide con REGEXP.

     Por cada paquete, imprime los siguientes elementos separados por
     tabuladores: su nombre, su cadena de versión, las partes del
     paquete (*note Paquetes con múltiples salidas::) y la dirección de
     las fuentes de su definición.

‘--list-generations[=PATRÓN]’
‘-l [PATRÓN]’
     Devuelve una lista de generaciones junto a sus fechas de creación;
     para cada generación, muestra los paquetes instalados, con los
     paquetes instalados más recientemente mostrados los últimos. Fíjese
     que la generación cero nunca se muestra.

     Por cada paquete instalado, imprime los siguientes elementos,
     separados por tabuladores: el nombre de un paquete, su cadena de
     versión, la parte del paquete que está instalada (*note Paquetes
     con múltiples salidas::), y la ruta de este paquete en el almacén.

     Cuando se usa PATRÓN, la orden devuelve únicamente las generaciones
     que se ajustan al patrón. Entre los patrones adecuados se
     encuentran:

        • _Enteros y enteros separados por comas_. Ambos patrones
          denotan generation numbers. For instance,
          ‘--list-generations=1’ returns the first one.

          And ‘--list-generations=1,8,2’ outputs three generations in
          the specified order. Neither spaces nor trailing commas are
          allowed.

        • _Ranges_. ‘--list-generations=2..9’ prints the las
          generaciones especificadas y todas las intermedias. Fíjese que
          el inicio de un rango debe ser menor a su fin.

          It is also possible to omit the endpoint. For example,
          ‘--list-generations=2..’, returns all generations starting
          from the second one.

        • _Duraciones_. Puede también obtener los últimos _N_ días,
          semanas, or months by passing an integer along with the first
          letter of the duration. For example, ‘--list-generations=20d’
          lists generations that are up to 20 days old.

‘--delete-generations[=PATRÓN]’
‘-d [PATRÓN]’
     Cuando se omite PATRÓN, borra todas las generaciones excepto la
     actual.

     This command accepts the same patterns as ‘--list-generations’.
     When PATTERN is specified, delete the matching generations. When
     PATTERN specifies a duration, generations _older_ than the
     specified duration match. For instance, ‘--delete-generations=1m’
     deletes generations that are more than one month old.

     Si la generación actual entra en el patrón, _no_ es borrada.
     Tampoco la generación cero es borrada nunca.

     Fíjese que borrar generaciones previene volver atrás a ellas.
     Consecuentemente esta orden debe ser usada con cuidado.

   Finally, since ‘guix package’ may actually start build processes, it
supports all the common build options (*note Opciones comunes de
construcción::). It also supports package transformation options, such
as ‘--with-source’ (*note Opciones de transformación de paquetes::).
However, note that package transformations are lost when upgrading; to
preserve transformations across upgrades, you should define your own
package variant in a Guile module and add it to ‘GUIX_PACKAGE_PATH’
(*note Definición de paquetes::).

   ---------- Footnotes ----------

   (1) NdT: board en inglés.


File: guix.es.info,  Node: Sustituciones,  Next: Paquetes con múltiples salidas,  Prev: Invocación de guix package,  Up: Gestión de paquetes

4.3 Sustituciones
=================

Guix permite despliegues transparentes de fuentes/binarios, lo que
significa que puede tanto construir cosas localmente, como descargar
elementos preconstruidos de un servidor, o ambas. Llamamos a esos
elementos preconstruidos “sustituciones”—son sustituciones de los
resultados de construcciones locales. En muchos casos, descargar una
sustitución es mucho más rápido que construirla localmente.

   Las sustituciones pueden ser cualquier cosa que resulte de una
construcción de una derivación (*note Derivaciones::). Por supuesto, en
el caso común, son paquetes binarios preconstruidos, pero los archivos
de fuentes, por ejemplo, que también resultan de construcciones de
derivaciones, pueden estar disponibles como sustituciones.

* Menu:

* Servidor oficial de sustituciones.::  Una fuente particular de
                                          sustituciones.
* Autorización de servidores de sustituciones::  Cómo activar o desactivar
                                                    las sustituciones.
* Verificación de sustituciones::  Cómo verifica las sustituciones Guix.
* Configuración de la pasarela.::  Cómo obtener sustituciones a través de
                                      una pasarela.
* Fallos en las sustituciones::  Qué pasa cuando una sustitución falla.
* Sobre la confianza en binarios::  ¿Cómo puede confiar en esa masa amorfa
                                      de datos binarios?


File: guix.es.info,  Node: Servidor oficial de sustituciones.,  Next: Autorización de servidores de sustituciones,  Up: Sustituciones

4.3.1 Servidor oficial de sustituciones.
----------------------------------------

El servidor ‘ci.guix.gnu.org’ es una fachada a una granja de
construcción oficial que construye paquetes de Guix continuamente para
algunas arquitecturas, y los pone disponibles como sustituciones. Esta
es la fuente predeterminada de sustituciones; puede ser forzada a
cambiar pasando la opción ‘--substitute-urls’ bien a ‘guix-daemon’
(*note ‘guix-daemon --substitute-urls’: daemon-substitute-urls.) o bien
a herramientas cliente como ‘guix package’ (*note client
‘--substitute-urls’ option: client-substitute-urls.).

   Las URLs de sustituciones pueden ser tanto HTTP como HTTPS. Se
recomienda HTTPS porque las comunicaciones están cifradas; de modo
contrario, usar HTTP hace visibles todas las comunicaciones para alguien
que las intercepte, quien puede usar la información obtenida para
determinar, por ejemplo, si su sistema tiene vulnerabilidades de
seguridad sin parchear.

   El uso de sustituciones de la granja de construcción oficial se
realiza de manera predeterminada cuando se usa el sistema Guix (*note
Distribución GNU::). No obstante, no se realiza de manera predeterminada
cuando se usa Guix en una distribución anfitriona, a menos que las
active explícitamente via uno de los pasos recomendados de instalación
(*note Instalación::). Los siguientes párrafos describen como activar o
desactivar las sustituciones para la granja oficial de construcción; el
mismo procedimiento puede usarse para activar las sustituciones desde
cualquier otro servidor que las proporcione.


File: guix.es.info,  Node: Autorización de servidores de sustituciones,  Next: Verificación de sustituciones,  Prev: Servidor oficial de sustituciones.,  Up: Sustituciones

4.3.2 Autorización de servidores de sustituciones
-------------------------------------------------

Para permitir a Guix descargar sustituciones de ‘ci.guix.gnu.org’ o un
espejo suyo, debe añadir su clave pública a la lista de control de
acceso (ACL) de las importaciones de archivos, mediante el uso de la
orden ‘guix archive’ (*note Invocación de guix archive::). Hacerlo
implica que confía que ‘ci.guix.gnu.org’ no ha sido comprometido y
proporciona sustituciones genuinas.

   La clave pública para ‘ci.guix.gnu.org’ se instala junto a Guix, en
‘PREFIJO/share/guix/ci.guix.gnu.org.pub’, donde PREFIJO es el prefij de
instalación de Guix. Si ha instalado Guix desde las fuentes, debe
asegurarse de que comprobó la firma GPG de
‘guix-1.0.1.17089-7e269.tar.gz’, el cual contiene el fichero de clave
pública. Una vez hecho, puede ejecutar algo así:

     # guix archive --authorize < PREFIJO/share/guix/ci.guix.gnu.org.pub

   Una vez esté autorizada, la salida de una orden como ‘guix build’
debería cambiar de algo como:

     $ guix build emacs --dry-run
     Se construirían las siguientes derivaciones:
        /gnu/store/yr7bnx8xwcayd6j95r2clmkdl1qh688w-emacs-24.3.drv
        /gnu/store/x8qsh1hlhgjx6cwsjyvybnfv2i37z23w-dbus-1.6.4.tar.gz.drv
        /gnu/store/1ixwp12fl950d15h2cj11c73733jay0z-alsa-lib-1.0.27.1.tar.bz2.drv
        /gnu/store/nlma1pw0p603fpfiqy7kn4zm105r5dmw-util-linux-2.21.drv
     ...

a algo así:

     $ guix build emacs --dry-run
     Se descargarían 112.3 MB:
        /gnu/store/pk3n22lbq6ydamyymqkkz7i69wiwjiwi-emacs-24.3
        /gnu/store/2ygn4ncnhrpr61rssa6z0d9x22si0va3-libjpeg-8d
        /gnu/store/71yz6lgx4dazma9dwn2mcjxaah9w77jq-cairo-1.12.16
        /gnu/store/7zdhgp0n1518lvfn8mb96sxqfmvqrl7v-libxrender-0.9.7
     ...

El texto ha cambiado de “Se construirían las siguientes derivaciones” a
“Se descargarían 112.3 MB”. Esto indica que las sustituciones de
‘ci.guix.gnu.org’ son usables y serán descargadas, cuando sea posible,
en construcciones futuras.

   The substitute mechanism can be disabled globally by running
‘guix-daemon’ with ‘--no-substitutes’ (*note Invocación de
guix-daemon::). It can also be disabled temporarily by passing the
‘--no-substitutes’ option to ‘guix package’, ‘guix build’, and other
command-line tools.


File: guix.es.info,  Node: Verificación de sustituciones,  Next: Configuración de la pasarela.,  Prev: Autorización de servidores de sustituciones,  Up: Sustituciones

4.3.3 Verificación de sustituciones
-----------------------------------

Guix detecta y emite errores cuando se intenta usar una sustitución que
ha sido adulterado. Del mismo modo, ignora las sustituciones que no
están firmadas, o que no están firmadas por una de las firmas enumeradas
en la ACL.

   No obstante hay una excepción: si un servidor no autorizado
proporciona sustituciones que son _idénticas bit-a-bit_ a aquellas
proporcionadas por un servidor autorizado, entonces el servidor no
autorizado puede ser usado para descargas. Por ejemplo, asumiendo que
hemos seleccionado dos servidores de sustituciones con esta opción:

     --substitute-urls="https://a.example.org https://b.example.org"

If the ACL contains only the key for ‘b.example.org’, and if
‘a.example.org’ happens to serve the _exact same_ substitutes, then Guix
will download substitutes from ‘a.example.org’ because it comes first in
the list and can be considered a mirror of ‘b.example.org’. In practice,
independent build machines usually produce the same binaries, thanks to
bit-reproducible builds (see below).

   When using HTTPS, the server’s X.509 certificate is _not_ validated
(in other words, the server is not authenticated), contrary to what
HTTPS clients such as Web browsers usually do. This is because Guix
authenticates substitute information itself, as explained above, which
is what we care about (whereas X.509 certificates are about
authenticating bindings between domain names and public keys).


File: guix.es.info,  Node: Configuración de la pasarela.,  Next: Fallos en las sustituciones,  Prev: Verificación de sustituciones,  Up: Sustituciones

4.3.4 Configuración de la pasarela.
-----------------------------------

Substitutes are downloaded over HTTP or HTTPS. The ‘http_proxy’ and
‘https_proxy’ environment variables can be set in the environment of
‘guix-daemon’ and are honored for downloads of substitutes. Note that
the value of those environment variables in the environment where ‘guix
build’, ‘guix package’, and other client commands are run has
_absolutely no effect_.


File: guix.es.info,  Node: Fallos en las sustituciones,  Next: Sobre la confianza en binarios,  Prev: Configuración de la pasarela.,  Up: Sustituciones

4.3.5 Fallos en las sustituciones
---------------------------------

Incluso cuando una sustitución de una derivación está disponible, a
veces el intento de sustitución puede fallar. Esto puede suceder por
varias razones: el servidor de sustituciones puede estar desconectado,
la sustitución puede haber sido borrada, la conexión puede
interrumpirse, etc.

   When substitutes are enabled and a substitute for a derivation is
available, but the substitution attempt fails, Guix will attempt to
build the derivation locally depending on whether or not ‘--fallback’
was given (*note common build option ‘--fallback’: fallback-option.).
Specifically, if ‘--fallback’ was omitted, then no local build will be
performed, and the derivation is considered to have failed. However, if
‘--fallback’ was given, then Guix will attempt to build the derivation
locally, and the success or failure of the derivation depends on the
success or failure of the local build. Note that when substitutes are
disabled or no substitute is available for the derivation in question, a
local build will _always_ be performed, regardless of whether or not
‘--fallback’ was given.

   Para hacerse una idea de cuantas sustituciones hay disponibles en
este momento, puede intentar ejecutar la orden ‘guix weather’ (*note
Invocación de guix weather::). Esta orden proporciona estadísticas de
las sustituciones proporcionadas por un servidor.


File: guix.es.info,  Node: Sobre la confianza en binarios,  Prev: Fallos en las sustituciones,  Up: Sustituciones

4.3.6 Sobre la confianza en binarios
------------------------------------

Hoy en día, el control individual sobre nuestra propia computación está
a merced de instituciones, empresas y grupos con suficiente poder y
determinación para subvertir la infraestructura de computación y
explotar sus vulnerabilidades. Mientras que usar las sustituciones de
‘ci.guix.gnu.org’ puede ser conveniente, recomendamos a las usuarias
también construir sus paquetes, o incluso mantener su propia granja de
construcción, de modo que ‘ci.guix.gnu.org’ sea un objetivo menos
interesante. Una manera de ayudar es publicando el software que
construya usando ‘guix publish’ de modo que otras tengan otro servidor
más como opción para descargar sustituciones (*note Invocación de guix
publish::).

   Guix tiene los cimientos para maximizar la reproducibilidad de las
construcciones (*note Características::). En la mayor parte de los
casos, construcciones independientes de un paquete o derivación dada
deben emitir resultados idénticos bit a bit. Por tanto, a través de un
conjunto diverso de construcciones independientes de paquetes, podemos
reforzar la integridad de nuestros sistemas. La orden ‘guix challenge’
intenta ayudar a las usuarias en comprobar servidores de sustituciones,
y asiste a las desarrolladoras encontrando construcciones no
deterministas de paquetes (*note Invocación de guix challenge::).
Similarmente, la opción ‘--check’ de ‘guix build’ permite a las usuarias
si las sustituciones previamente instaladas son genuinas mediante su
reconstrucción local (*note ‘guix build --check’: build-check.).

   En el futuro, queremos que Guix permita la publicación y obtención de
binarios hacia/desde otras usuarias, entre pares (P2P). En caso de
interesarle hablar sobre este proyecto, unase a nosotras en
<guix-devel@gnu.org>.


File: guix.es.info,  Node: Paquetes con múltiples salidas,  Next: Invocación de guix gc,  Prev: Sustituciones,  Up: Gestión de paquetes

4.4 Paquetes con múltiples salidas
==================================

Habitualmente, los paquetes definidos en Guix tienen una “salida”
única—es decir, el paquete de fuentes proporcionará exactamente un
directorio en el almacén. Cuando se ejecuta ‘guix install glibc’, se
instala la salida predeterminada del paquete GNU libc; la salida
predeterminada se llama ‘out’, pero su nombre puede omitirse como se
mostró en esta orden. En este caso particular, la salida predeterminada
de ‘glibc’ contiene todos ficheros de cabecera C, bibliotecas dinámicas,
bibliotecas estáticas, documentación Info y otros ficheros auxiliares.

   A veces es más apropiado separar varios tipos de ficheros producidos
por un paquete único de fuentes en salidas separadas. Por ejemplo, la
biblioteca C GLib (usada por GTK+ y paquetes relacionados) instala más
de 20 MiB de documentación de referencia como páginas HTML. Para ahorrar
espacio para usuarias que no la necesiten, la documentación va a una
salida separada, llamada ‘doc’. Para instalar la salida principal de
GLib, que contiene todo menos la documentación, se debe ejecutar:

     guix install glib

   La orden que instala su documentación es:

     guix install glib:doc

   Algunos paquetes instalan programas con diferentes “huellas de
dependencias”. Por ejemplo, el paquete WordNet instala tanto
herramientas de línea de órdenes como interfaces gráficas de usuaria
(IGU). Las primeras dependen únicamente de la biblioteca de C, mientras
que las últimas dependen en Tcl/Tk y las bibliotecas de X subyacentes.
En este caso, dejamos las herramientas de línea de órdenes en la salida
predeterminada, mientras que las IGU están en una salida separada. Esto
permite a las usuarias que no necesitan una IGU ahorrar espacio. La
orden ‘guix size’ puede ayudar a exponer estas situaciones (*note
Invocación de guix size::). ‘guix graph’ también puede ser útil (*note
Invocación de guix graph::).

   Hay varios de estos paquetes con salida múltiple en la distribución
GNU. Otros nombres de salida convencionales incluyen ‘lib’ para
bibliotecas y posiblemente ficheros de cabecera, ‘bin’ para programas
independientes y ‘debug’ para información de depuración (*note
Instalación de ficheros de depuración::). La salida de los paquetes se
enumera en la tercera columna del resultado de ‘guix package
--list-available’ (*note Invocación de guix package::).


File: guix.es.info,  Node: Invocación de guix gc,  Next: Invocación de guix pull,  Prev: Paquetes con múltiples salidas,  Up: Gestión de paquetes

4.5 Invocación de ‘guix gc’
===========================

Los paquetes instalados, pero no usados, pueden ser “recolectados”. La
orden ‘guix gc’ permite a las usuarias ejecutar explícitamente el
recolector de basura para reclamar espacio del directorio
‘/gnu/store’—¡borrar ficheros o directorios manualmente puede dañar el
almacén sin reparación posible!

   El recolector de basura tiene un conjunto de “raíces” conocidas:
cualquier fichero en ‘/gnu/store’ alcanzable desde una raíz se considera
“vivo” y no puede ser borrado; cualquier otro fichero se considera
“muerto” y puede ser borrado. El conjunto de raíces del recolector de
basura (“raíces del GC” para abreviar) incluye los perfiles
predeterminados de las usuarias; por defecto los enlaces bajo
‘/var/guix/gcroots’ representan dichas raíces. Por ejemplo, nuevas
raíces del GC pueden añadirse con ‘guix build --root’ (*note Invocación
de guix build::). La orden ‘guix gc --list-roots’ las enumera.

   Antes de ejecutar ‘guix gc --collect-garbage’ para liberar espacio,
habitualmente es útil borrar generaciones antiguas de los perfiles de
usuaria; de ese modo, las construcciones antiguas de paquetes a las que
dichas generaciones hacen referencia puedan ser reclamadas. Esto se
consigue ejecutando ‘guix package --delete-generations’ (*note
Invocación de guix package::).

   Nuestra recomendación es ejecutar una recolección de basura
periódicamente, o cuando tenga poco espacio en el disco. Por ejemplo,
para garantizar que al menos 5 GB están disponibles en su disco,
simplemente ejecute:

     guix gc -F 5G

   Es completamente seguro ejecutarla como un trabajo periódico
no-interactivo (*note Ejecución de tareas programadas::, para la
configuración de un trabajo de ese tipo). La ejecución de ‘guix gc’ sin
ningún parámetro recolectará tanta basura como se pueda, pero eso es no
es normalmente conveniente: puede encontrarse teniendo que reconstruir o
volviendo a bajar software que está “muerto” desde el punto de vista del
recolector pero que es necesario para construir otras piezas de
software—por ejemplo, la cadena de herramientas de compilación.

   The ‘guix gc’ command has three modes of operation: it can be used to
garbage-collect any dead files (the default), to delete specific files
(the ‘--delete’ option), to print garbage-collector information, or for
more advanced queries. The garbage collection options are as follows:

‘--collect-garbage[=MIN]’
‘-C [MIN]’
     Recolecta basura—es decir, ficheros no alcanzables de ‘/gnu/store’
     y subdirectorios. Esta operación es la predeterminada cuando no se
     especifican opciones.

     Cuando se proporciona MIN, para una vez que MIN bytes han sido
     recolectados. MIN puede ser un número de bytes, o puede incluir una
     unidad como sufijo, como ‘MiB’ para mebibytes y ‘GB’ para gigabytes
     (*note size specifications: (coreutils)Block size.).

     Cuando se omite MIN, recolecta toda la basura.

‘--free-space=LIBRE’
‘-F LIBRE’
     Recolecta basura hasta que haya espacio LIBRE bajo ‘/gnu/store’, si
     es posible: LIBRE denota espacio de almacenamiento, por ejemplo
     ‘500MiB’, como se ha descrito previamente.

     Cuando LIBRE o más está ya disponible en ‘/gnu/store’, no hace nada
     y sale inmediatamente.

‘--delete-generations[=DURACIÓN]’
‘-d [DURACIÓN]’
     Antes de comenzar el proceso de recolección de basura, borra todas
     las generaciones anteriores a DURACIÓN, para todos los perfiles de
     la usuaria; cuando se ejecuta como root esto aplica a los perfiles
     de _todas las usuarias_.

     Por ejemplo, esta orden borra todas las generaciones de todos sus
     perfiles que tengan más de 2 meses de antigüedad (excepto
     generaciones que sean las actuales), y una vez hecho procede a
     liberar espacio hasta que al menos 10 GiB estén disponibles:

          guix gc -d 2m -F 10G

‘--delete’
‘-D’
     Intenta borrar todos los ficheros del almacén y directorios
     especificados como parámetros. Esto falla si alguno de los ficheros
     no están en el almacén, o todavía están vivos.

‘--list-failures’
     Enumera los elementos del almacén correspondientes a construcciones
     fallidas existentes en la caché.

     Esto no muestra nada a menos que el daemon se haya ejecutado
     pasando ‘--cache-failures’ (*note ‘--cache-failures’: Invocación de
     guix-daemon.).

‘--list-roots’
     Enumera las raíces del recolector de basura poseídas por la
     usuaria; cuando se ejecuta como root, enumera _todas_ las raíces
     del recolector de basura.

‘--list-busy’
     Enumera los elementos del almacén que actualmente están siendo
     usados por procesos en ejecución. Estos elementos del almacén se
     consideran de manera efectiva raíces del recolector de basura: no
     pueden borrarse.

‘--clear-failures’
     Borra los elementos especificados del almacén de la caché de
     construcciones fallidas.

     De nuevo, esta opción únicamente tiene sentido cuando el daemon se
     inicia con ‘--cache-failures’. De otro modo, no hace nada.

‘--list-dead’
     Muestra la lista de ficheros y directorios muertos todavía
     presentes en el almacén—es decir, ficheros y directorios que ya no
     se pueden alcanzar desde ninguna raíz.

‘--list-live’
     Muestra la lista de ficheros y directorios del almacén vivos.

   Además, las referencias entre los ficheros del almacén pueden ser
consultadas:

‘--references’
‘--referrers’
     Enumera las referencias (o, respectivamente, los referentes) de los
     ficheros del almacén pasados como parámetros.

‘--requisites’
‘-R’
     Enumera los requisitos los ficheros del almacén pasados como
     parámetros. Los requisitos incluyen los mismos ficheros del
     almacén, sus referencias, las referencias de estas, recursivamente.
     En otras palabras, la lista devuelta es la “clausura transitiva” de
     los ficheros del almacén.

     *Note Invocación de guix size::, para una herramienta que perfila
     el tamaño de la clausura de un elemento. *Note Invocación de guix
     graph::, para una herramienta de visualización del grafo de
     referencias.

‘--derivers’
     Devuelve la/s derivación/es que conducen a los elementos del
     almacén dados (*note Derivaciones::).

     Por ejemplo, esta orden:

          guix gc --derivers `guix package -I ^emacs$ | cut -f4`

     devuelve el/los fichero/s ‘.drv’ que conducen al paquete ‘emacs’
     instalado en su perfil.

     Fíjese que puede haber cero ficheros ‘.drv’ encontrados, por
     ejemplo porque estos ficheros han sido recolectados. Puede haber
     más de un fichero ‘.drv’ encontrado debido a derivaciones de salida
     fija.

   Por último, las siguientes opciones le permiten comprobar la
integridad del almacén y controlar el uso del disco.

‘--verify[=OPCIONES]’
     Verifica la integridad del almacén.

     Por defecto, comprueba que todos los elementos del almacén marcados
     como válidos en la base de datos del daemon realmente existen en
     ‘/gnu/store’.

     Cuando se proporcionan, OPCIONES debe ser una lista separada por
     comas que contenga uno o más valores ‘contents’ and ‘repair’.

     Cuando se usa ‘--verify=contents’, el daemon calcula el hash del
     contenido de cada elemento del almacén y lo compara contra el hash
     de su base de datos. Las incongruencias se muestran como
     corrupciones de datos. Debido a que recorre _todos los ficheros del
     almacén_, esta orden puede tomar mucho tiempo, especialmente en
     sistemas con una unidad de disco lenta.

     El uso de ‘--verify=repair’ o ‘--verify=contents,repair’ hace que
     el daemon intente reparar elementos corruptos del almacén
     obteniendo sustituciones para dichos elementos (*note
     Sustituciones::). Debido a que la reparación no es atómica, y por
     tanto potencialmente peligrosa, está disponible únicamente a la
     administradora del sistema. Una alternativa ligera, cuando sabe
     exactamente qué elementos del almacén están corruptos, es ‘guix
     build --repair’ (*note Invocación de guix build::).

‘--optimize’
     Optimiza el almacén sustituyendo ficheros idénticos por enlaces
     duros—esto es la “deduplicación”.

     The daemon performs deduplication after each successful build or
     archive import, unless it was started with
     ‘--disable-deduplication’ (*note ‘--disable-deduplication’:
     Invocación de guix-daemon.). Thus, this option is primarily useful
     when the daemon was running with ‘--disable-deduplication’.


File: guix.es.info,  Node: Invocación de guix pull,  Next: Canales,  Prev: Invocación de guix gc,  Up: Gestión de paquetes

4.6 Invocación de ‘guix pull’
=============================

Los paquetes se instalan o actualizan con la última versión disponible
en la distribución disponible actualmente en su máquina local. Para
actualizar dicha distribución, junto a las herramientas de Guix, debe
ejecutar ‘guix pull’: esta orden descarga el último código fuente de
Guix y descripciones de paquetes, y lo despliega. El código fuente se
descarga de un repositorio Git (https://git-scm.com), por defecto el
repositorio oficial de GNU Guix, lo que no obstante puede ser
personalizado.

   Específicamente, ‘guix pull’ descarga código de los “canales” (*note
Canales::) especificados en una de las posibilidades siguientes, en este
orden:

  1. la opción ‘--channels’;
  2. el fichero ‘~/.config/guix/channels.scm’ de la usuaria;
  3. el fichero ‘/etc/guix/channels.scm’ común al sistema;
  4. los canales predeterminados en código especificados en la variable
     ‘%default-channels’.

   Una vez completada, ‘guix package’ usará paquetes y versiones de
paquetes de esta copia recién obtenida de Guix. No solo eso, sino que
todas las órdenes de Guix y los módulos Scheme también se tomarán de la
última versión. Nuevas sub-órdenes ‘guix’ incorporadas por la
actualización también estarán disponibles.

   Cualquier usuaria puede actualizar su copia de Guix usando ‘guix
pull’, y el efecto está limitado a la usuaria que ejecute ‘guix pull’.
Por ejemplo, cuando la usuaria ‘root’ ejecuta ‘guix pull’, dicha acción
no produce ningún efecto en la versión del Guix que la usuaria ‘alicia’
ve, y viceversa.

   El resultado de ejecutar ‘guix pull’ es un “perfil” disponible bajo
‘~/.config/guix/current’ conteniendo el último Guix. Por tanto,
asegúrese de añadirlo al inicio de sus rutas de búsqueda de modo que use
la última versión, de modo similar para el manual Info(*note
Documentación::).

     export PATH="$HOME/.config/guix/current/bin:$PATH"
     export INFOPATH="$HOME/.config/guix/current/share/info:$INFOPATH"

   The ‘--list-generations’ or ‘-l’ option lists past generations
produced by ‘guix pull’, along with details about their provenance:

     $ guix pull -l
     Generación 1	10 jun 2018 00:18:18
       guix 65956ad
         URL del repositorio: https://git.savannah.gnu.org/git/guix.git
         rama: origin/master
         revisión: 65956ad3526ba09e1f7a40722c96c6ef7c0936fe

     Generación 2	11 jun 2018 11:02:49
       guix e0cc7f6
         URL del repositorio: https://git.savannah.gnu.org/git/guix.git
         rama: origin/master
         revisión: e0cc7f669bec22c37481dd03a7941c7d11a64f1d
       2 paquetes nuevos: keepalived, libnfnetlink
       6 paquetes actualizados: emacs-nix-mode@2.0.4,
         guile2.0-guix@0.14.0-12.77a1aac, guix@0.14.0-12.77a1aac,
         heimdal@7.5.0, milkytracker@1.02.00, nix@2.0.4

     Generación 3	13 jun 2018 23:31:07	(current)
       guix 844cc1c
         URL del repositorio: https://git.savannah.gnu.org/git/guix.git
         rama: origin/master
         revisión: 844cc1c8f394f03b404c5bb3aee086922373490c
       28 paquetes nuevos: emacs-helm-ls-git, emacs-helm-mu, ...
       69 paquetes actualizados: borg@1.1.6, cheese@3.28.0, ...

   *note ‘guix describe’: Invocación de guix describe, para otras formas
de describir el estado actual de Guix.

   El perfil ‘~/.config/guix/current’ funciona exactamente igual que los
perfiles creados por ‘guix package’ (*note Invocación de guix
package::). Es decir, puede enumerar generaciones, volver a una
generación previa—esto es, la versión anterior de Guix—, etcétera:

     $ guix pull --roll-back
     se pasó de la generación 3 a la 2
     $ guix pull --delete-generations=1
     borrando /var/guix/profiles/per-user/carlos/current-guix-1-link

   También puede usar ‘guix package’ (*note Invocación de guix
package::) para gestionar el perfil proporcionando su nombre de manera
específica:
     $ guix package -p ~/.config/guix/current --roll-back
     se pasó de la generación 3 a la 2
     $ guix package -p ~/.config/guix/current --delete-generations=1
     borrando /var/guix/profiles/per-user/carlos/current-guix-1-link

   La orden ‘guix pull’ se invoca habitualmente sin parámetros, pero
permite las siguientes opciones:

‘--url=URL’
‘--commit=REVISIÓN’
‘--branch=RAMA’
     Descarga el código para el canal ‘guix’ de la URL especificada, en
     la REVISIÓN proporcionada (un ID de revisión Git representada como
     una cadena hexadecimal), o RAMA.

     Estas opciones se proporcionan por conveniencia, pero también puede
     especificar su configuración en el fichero
     ‘~/.config/guix/channels.scm’ o usando la opción ‘--channels’ (vea
     más adelante).

‘--channels=FICHERO’
‘-C FICHERO’
     Lee la lista de canales de FICHERO en vez de
     ‘~/.config/guix/channels.scm’ o ‘/etc/guix/channels.scm’. FICHERO
     debe contener código Scheme que evalúe a una lista de objetos
     “channel”. *Note Canales::, para más información.

‘--news’
‘-N’
     Muestra la lista de paquetes añadidos o actualizados desde la
     última generación, así como, ocasionalmente, noticias escritas por
     las autoras del canal para las usuarias (*note Writing Channel
     News: Canales.).

     La información del paquete es la misma que la que se muestra cuando
     termina ‘guix pull’, pero sin la elipsis; es también similar a la
     salida de ‘guix pull -l’ para la última generación (véase a
     continuación).

‘--list-generations[=PATRÓN]’
‘-l [PATRÓN]’
     Enumera todas las generaciones de ‘~/.config/guix/current’ o, si se
     proporciona un PATRÓN, el subconjunto de generaciones que
     correspondan con el PATRÓN. La sintaxis de PATRÓN es la misma que
     ‘guix package --list-generations’ (*note Invocación de guix
     package::).

‘--roll-back’
     Vuelve a la “generación” previa de ‘~/.config/guix/current’—es
     decir, deshace la última transacción.

‘--switch-generation=PATRÓN’
‘-S PATRÓN’
     Cambia a una generación particular definida por el PATRÓN.

     PATTERN may be either a generation number or a number prefixed with
     “+” or “-”. The latter means: move forward/backward by a specified
     number of generations. For example, if you want to return to the
     latest generation after ‘--roll-back’, use
     ‘--switch-generation=+1’.

‘--delete-generations[=PATRÓN]’
‘-d [PATRÓN]’
     Cuando se omite PATRÓN, borra todas las generaciones excepto la
     actual.

     This command accepts the same patterns as ‘--list-generations’.
     When PATTERN is specified, delete the matching generations. When
     PATTERN specifies a duration, generations _older_ than the
     specified duration match. For instance, ‘--delete-generations=1m’
     deletes generations that are more than one month old.

     Si la generación actual entra en el patrón, _no_ será borrada.

     Fíjese que borrar generaciones previene volver atrás a ellas.
     Consecuentemente esta orden debe ser usada con cuidado.

     *note Invocación de guix describe::, para una forma de mostrar
     información sobre únicamente la generación actual.

‘--profile=PERFIL’
‘-p PERFIL’
     Usa PERFIL en vez de ‘~/.config/guix/current’.

‘--dry-run’
‘-n’
     Muestra qué revisión/es del canal serían usadas y qué se
     construiría o sustituiría, sin efectuar ninguna acción real.

‘--allow-downgrades’
     Allow pulling older or unrelated revisions of channels than those
     currently in use.

     By default, ‘guix pull’ protects against so-called “downgrade
     attacks” whereby the Git repository of a channel would be reset to
     an earlier or unrelated revision of itself, potentially leading you
     to install older, known-vulnerable versions of software packages.

          Nota: Make sure you understand its security implications
          before using ‘--allow-downgrades’.

‘--system=SISTEMA’
‘-s SISTEMA’
     Intenta construir paquetes para SISTEMA—por ejemplo,
     ‘x86_64-linux’—en vez del tipo de sistema de la máquina de
     construcción.

‘--verbose’
     Produce salida prolija, escribiendo los logs de construcción por la
     salida de error estándar.

‘--bootstrap’
     Use el Guile usado para el lanzamiento para construir el último
     Guix. Esta opción es útil para las desarrolladoras de Guix
     únicamente.

   El mecanismo de “canales” le permite instruir a ‘guix pull’ de qué
repositorio y rama obtener los datos, así como repositorios
_adicionales_ que contengan módulos de paquetes que deben ser
desplegados. *Note Canales::, para más información.

   Además, ‘guix pull’ acepta todas las opciones de construcción comunes
(*note Opciones comunes de construcción::).


File: guix.es.info,  Node: Canales,  Next: Invocación de guix time-machine,  Prev: Invocación de guix pull,  Up: Gestión de paquetes

4.7 Canales
===========

Guix y su colección de paquetes son actualizados ejecutando ‘guix pull’
(*note Invocación de guix pull::). Por defecto ‘guix pull’ descarga y
despliega el mismo Guix del repositorio oficial de GNU Guix. Esto puede
ser personalizado definiendo “canales” en el fichero
‘~/.config/guix/channels.scm’. Un canal especifica una URL y una rama de
un repositorio Git para ser desplegado, y ‘guix pull’ puede ser
instruido para tomar los datos de uno o más canales. En otras palabras,
los canales se pueden usar para _personalizar_ y para _extender_ Guix,
como vemos a continuación.

4.7.1 Uso de un canal de Guix personalizado
-------------------------------------------

El canal llamado ‘guix’ especifica de donde el mismo Guix—sus
herramientas de línea de órdenes y su colección de paquetes—debe ser
descargado. Por ejemplo, suponga que quiere actualizar de su propia
copia del repositorio Guix en ‘example.org’, y específicamente la rama
‘super-hacks’, para ello puede escribir en ‘~/.config/guix/channels.scm’
esta especificación:

     ;; Le dice a 'guix pull' que use mi propio repositorio.
     (list (channel
             (name 'guix)
             (url "https://example.org/mi-guix.git")
             (branch "super-hacks")))

De aquí en adelante, ‘guix pull’ obtendrá el código de la rama
‘super-hacks’ del repositorio en ‘example.org’.

4.7.2 Especificación de canales adicionales
-------------------------------------------

También puede especificar _canales adicionales_ de los que obtener
datos. Digamos que tiene un montón de variaciones personalizadas de
paquetes que piensa que no tiene mucho sentido contribuir al proyecto
Guix, pero quiere tener esos paquetes disponibles transparentemente en
su línea de órdenes. Primero escribiría módulos que contengan esas
definiciones de paquete (*note Módulos de paquetes::), los mantendría en
un repositorio Git, y entonces usted y cualquier otra persona podría
usarlos como un canal adicional del que obtener paquetes. Limpio, ¿no?

     Aviso: Antes de que, querida usuaria, grite—“¡Guau, esto es _la
     caña_!”—y publique su canal personal al mundo, nos gustaría
     compartir algunas palabras de precaución:

        • Antes de publicar un canal, por favor considere contribuir sus
          definiciones de paquete al propio Guix (*note Contribuir::).
          Guix como proyecto es abierto a software libre de todo tipo, y
          los paquetes en el propio Guix están disponibles para todas
          las usuarias de Guix y se benefician del proceso de gestión de
          calidad del proyecto.

        • Cuando mantiene definiciones de paquete fuera de Guix,
          nosotras, las desarrolladoras de Guix, consideramos que _la
          carga de la compatibilidad cae de su lado_. Recuerde que los
          módulos y definiciones de paquetes son solo código Scheme que
          usa varias interfaces programáticas (APIs). Queremos mantener
          la libertad de cambiar dichas interfaces para seguir mejorando
          Guix, posiblemente en formas que pueden romper su canal. Nunca
          cambiamos las interfaces gratuitamente, pero _no_ vamos
          tampoco a congelar las interfaces.

        • Corolario: si está usando un canal externo y el canal se
          rompe, por favor _informe del problema a las autoras del
          canal_, no al proyecto Guix.

     ¡Ha quedado advertida! Habiendo dicho esto, creemos que los canales
     externos son una forma práctica de ejercitar su libertad para
     aumentar la colección de paquetes de Guix y compartir su mejoras,
     que son pilares básicos del software libre
     (https://www.gnu.org/philosophy/free-sw.html). Por favor, envíenos
     un correo a <guix-devel@gnu.org> si quiere hablar sobre esto.

   Para usar un canal, escriba en ‘~/.config/guix/channels.scm’ para
instruir a ‘guix pull’ para obtener datos de él _además_ de los canales
Guix predeterminados:

     ;; Añade mis paquetes personales a aquellos que Guix provee.
     (cons (channel
             (name 'mis-paquetes-personales)
             (url "https://example.org/paquetes-personales.git"))
           %default-channels)

Fíjese que el fragmento previo es (¡como siempre!) código Scheme; usamos
‘cons’ para añadir un canal a la lista de canales a la que la variable
‘%default-channels’ hace referencia (*note ‘cons’ and lists:
(guile)Pairs.). Con el fichero en este lugar, ‘guix pull’ no solo
construye Guix sino también los módulos de paquetes de su propio
repositorio. El resultado en ‘~/.config/guix/current’ es la unión de
Guix con sus propios módulos de paquetes:

     $ guix pull --list-generations
     ...
     Generation 19	Aug 27 2018 16:20:48
       guix d894ab8
         repository URL: https://git.savannah.gnu.org/git/guix.git
         branch: master
         commit: d894ab8e9bfabcefa6c49d9ba2e834dd5a73a300
       mis-paquetes-personales dd3df5e
         repository URL: https://example.org/paquetes-personales.git
         branch: master
         commit: dd3df5e2c8818760a8fc0bd699e55d3b69fef2bb
       11 new packages: mi-gimp, mi-emacs-con-cosas, ...
       4 packages upgraded: emacs-racket-mode@0.0.2-2.1b78827, ...

La salida de ‘guix pull’ previa muestra que la generación 19 incluye
tanto Guix como paquetes del canal ‘mis-paquetes-personales’. Entre los
paquetes nuevos y actualizados que son enumerados, algunos como
‘mi-gimp’ y ‘mi-emacs-con-cosas’ pueden venir de
‘mis-paquetes-personales’, mientras que otros vienen del canal
predeterminado de Guix.

   Para crear un canal, cree un repositorio Git que contenga sus propios
módulos de paquetes y haga que esté disponible. El repositorio puede
contener cualquier cosa, pero un canal útil contendrá módulos Guile que
exportan paquetes. Una vez comience a usar un canal, Guix se comportará
como si el directorio raíz del repositorio Git de dicho canal hubiese
sido añadido a la ruta de carga de Guile (*note (guile)Load Paths::).
Por ejemplo, si su canal contiene un fichero en
‘mis-paquetes/mis-herramientas.scm’ que define un módulo, entonces dicho
módulo estará disponible bajo el nombre ‘(mis-paquetes
mis-herramientas)’, y podrá usarlo como cualquier otro módulo (*note
(guile)Módulos::).

4.7.3 Declaración de dependencias de canales
--------------------------------------------

Las autoras de canales pueden decidir aumentar una colección de paquetes
proporcionada por otros canales. Pueden declarar su canal como
dependiente de otros canales en el fichero de metadatos ‘.guix-channel’,
que debe encontrarse en la raíz del repositorio del canal.

   Este fichero de metadatos debe contener una expresión-S simple como
esta:

     (channel
      (version 0)
      (dependencies
       (channel
        (name una-coleccion)
        (url "https://example.org/primera-coleccion.git"))
       (channel
        (name otra-coleccion)
        (url "https://example.org/segunda-coleccion.git")
        (branch "pruebas"))))

   En el ejemplo previo, este canal se declara como dependiente de otros
dos canales, que se obtendrán de manera automática. Los módulos
proporcionados por el canal se compilarán en un entorno donde los
módulos de todos estos canales declarados estén disponibles.

   De cara a la confianza proporcionada y el esfuerzo que supondrá su
mantenimiento, debería evitar depender de canales que no controle, y
debería intentar minimizar el número de dependencias.

4.7.4 Módulos de paquetes en un subdirectorio
---------------------------------------------

Como autora de un canal, es posible que desee mantener los módulos de su
canal en un subdirectorio. Si sus módulos se encuentran en el
subdirectorio ‘guix’, debe añadir un fichero ‘.guix-channel’ de
metadatos que contenga:

     (channel
       (version 0)
       (directory "guix"))

4.7.5 Escritura de noticias del canal
-------------------------------------

Las autoras los canales pueden querer ocasionalmente comunicar
información a sus usuarias acerca de cambios importantes en el canal.
Podrían mandar un correo a todo el mundo, pero esto no es tan
conveniente.

   En vez de eso, los canales proporcionan un “fichero de noticias”;
cuando las usuarias de un canal ejecutan ‘guix pull’, dicho fichero de
noticias se lee automáticamente y ‘guix pull --news’ puede mostrar los
anuncios que correspondan a las nuevas revisiones que se han obtenido,
si existen.

   Para hacerlo, las autoras del canal deben declarar primero el nombre
del fichero de noticias en su fichero ‘.guix-channel’:

     (channel
       (version 0)
       (news-file "etc/noticias.txt"))

   El fichero de noticias en sí, ‘etc/noticias.txt’ en este ejemplo,
debe ser similar a este:

     (channel-news
       (version 0)
       (entry (tag "the-bug-fix")
              (title (en "Fixed terrible bug")
                     (fr "Oh la la")
                     (es "Podemos volver a dormir en calma"))
              (body (en "@emph{Good news}!  It's fixed!")
                    (eo "Certe ĝi pli bone funkcias nun!")
                    (es "¡Al fin se ha corregido el error!")))
       (entry (commit "bdcabe815cd28144a2d2b4bc3c5057b051fa9906")
              (title (en "Added a great package")
                     (ca "Què vol dir guix?")
                     (ca "Nuevo paquete añadido"))
              (body (en "Don't miss the @code{hello} package!")
                    (es "Atención a la versátil herramienta @code{hello}"))))

   Este fichero consiste en una lista de “entradas de noticias”. Cada
entrada(1) se asocia a una revisión o una etiqueta: describe los cambios
llevados a cabo en ella, y posiblemente también en revisiones
anteriores. Las usuarias ven las entradas únicamente la primera vez que
obtienen la revisión a la que la entrada hace referencia.

   El campo del título (‘title’) debe ser un resumen de una línea
mientras que el cuerpo de la noticia (‘body’) puede ser arbitrariamente
largo, y ambos pueden contener marcas de Texinfo (*note
(texinfo)Overview::). Tanto el título como el cuerpo son una lista de
tuplas de etiqueta de lengua y mensaje, lo que permite a ‘guix pull’
mostrar las noticias en la lengua que corresponde a la localización de
la usuaria.

   Si desea traducir las noticias siguiendo un flujo de trabajo basado
en gettext, puede extraer las cadenas traducibles con ‘xgettext’ (*note
(gettext)xgettext Invocation::). Por ejemplo, asumiendo que escribe las
entradas de noticias primero en inglés, la siguiente orden crea un
fichero PO que contiene las cadenas a traducir:

     xgettext -o news.po -l scheme -ken etc/news.scm

   En resumen, sí, puede usar su canal como un blog. Pero tenga en
cuenta que esto puede que _no sea exactamente_ lo que sus usuarias
podrían esperar.

4.7.6 Replicación de Guix
-------------------------

La salida de ‘guix pull --list-generations’ previa muestra precisamente
qué revisiones se usaron para construir esta instancia de Guix. Por
tanto podemos replicarla, digamos, en otra máquina, proporcionando una
especificaciones de canales en ‘~/.config/guix/channels.scm’ que está
“clavada” en estas revisiones:

     ;; Despliega unas revisiones específicas de mis canales de interés.
     (list (channel
            (name 'guix)
            (url "https://git.savannah.gnu.org/git/guix.git")
            (commit "d894ab8e9bfabcefa6c49d9ba2e834dd5a73a300"))
           (channel
            (name 'mis-paquetes-personales)
            (url "https://example.org/paquetes-personales.git")
            (branch "dd3df5e2c8818760a8fc0bd699e55d3b69fef2bb")))

   La orden ‘guix describe --format=channels’ puede incluso generar esta
lista de canales directamente (*note Invocación de guix describe::). El
fichero resultante puede usarse con la opción -C de ‘guix pull’ (*note
Invocación de guix pull::) o ‘guix time-machine’ (*note Invocación de
guix time-machine::).

   En este punto las dos máquinas ejecutan _exactamente el mismo Guix_,
con acceso a _exactamente los mismos paquetes_. La salida de ‘guix build
gimp’ en una máquina debe ser exactamente la misma, bit a bit, que la
salida de la misma orden en la otra máquina. Esto también significa que
ambas máquinas tienen acceso a todo el código fuente de Guix y,
transitivamente, a todo el código fuente de cada paquete que define.

   Esto le proporciona superpoderes, lo que le permite seguir la pista
de la procedencia de los artefactos binarios con un grano muy fino, y
reproducir entornos de software a su voluntad—un tipo de capacidad de
“meta-reproducibilidad”, si lo desea. *Note Inferiores::, para otro modo
de tomar ventaja de estos superpoderes.

   ---------- Footnotes ----------

   (1) NdT: “entry” en inglés


File: guix.es.info,  Node: Invocación de guix time-machine,  Next: Inferiores,  Prev: Canales,  Up: Gestión de paquetes

4.8 Invocación de ‘guix time-machine’
=====================================

La orden ‘guix time-machine’ proporciona acceso a otras revisiones de
Guix, por ejemplo para instalar versiones antiguas de un paquete, o para
reproducir una computación en un entorno idéntico. La revisión de Guix
que se usará se define por el identificador de una revisión o por un
fichero de descripción de canales creado con ‘guix describe’ (*note
Invocación de guix describe::).

   La sintaxis general es:

     guix time-machine OPCIONES... -- ORDEN PARAM...

   donde ORDEN and PARAM... se proporcionan sin modificar a la orden
‘guix’ de la revisión especificada. Las OPCIONES que definen esta
revisión son las mismas que se usan con ‘guix pull’ (*note Invocación de
guix pull::):

‘--url=URL’
‘--commit=REVISIÓN’
‘--branch=RAMA’
     Usa el canal ‘guix’ de la URL especificada, en la REVISIÓN
     proporcionada (un ID de revisión Git representada como una cadena
     hexadecimal), o RAMA.

‘--channels=FICHERO’
‘-C FICHERO’
     Lee la lista de canales de FICHERO. FICHERO debe contener código
     Scheme que evalúe a una lista de objetos “channel”. *Note
     Canales::, para más información.

   Como con ‘guix pull’, la ausencia de opciones significa que se usará
la última revisión de la rama master. Por tanto la orden

     guix time-machine -- build hello

   construirá el paquete ‘hello’ como esté definido en la rama master,
que en general es la última revisión de Guix que haya instalado. ¡Los
viajes temporales funcionan en ambas direcciones!

   Tenga en cuenta que ‘guix time-machine’ puede desencadenar
construcciones de canales y sus dependencias, y que pueden controlarse
mediante las opciones de construcción estándar (*note Opciones comunes
de construcción::).


File: guix.es.info,  Node: Inferiores,  Next: Invocación de guix describe,  Prev: Invocación de guix time-machine,  Up: Gestión de paquetes

4.9 Inferiores
==============

     Nota: La funcionalidad descrita aquí es una “versión de evaluación
     tecnológica” en la versión 1.0.1.17089-7e269. Como tal, la interfaz
     está sujeta a cambios.

   A veces necesita mezclar paquetes de revisiones de la revisión de
Guix que está ejecutando actualmente con paquetes disponibles en una
revisión diferente. Los “inferiores” de Guix le permiten conseguirlo
componiendo diferentes revisiones de Guix de modo arbitrario.

   Técnicamente, un “inferior” es esencialmente un proceso Guix separado
conectado con su Guix principal a través de una sesión interactiva
(*note Invocación de guix repl::). El módulo ‘(guix inferior)’ le
permite crear inferiores y comunicarse con ellos. También proporciona
una interfaz de alto nivel para buscar y manipular los paquetes que un
inferior proporciona—“paquetes de inferiores”.

   Cuando se combina con los canales (*note Canales::), los inferiores
proporcionan una forma simple de interactuar con una revisión separada
de Guix. Por ejemplo, asumamos que desea instalar en su perfil el
paquete ‘guile’ actual, junto al paquete ‘guile-json’ como existía en
una revisión más antigua de Guix—quizá porque las versiones nuevas de
‘guile-json’ tienen un API incompatible y quiere ejecutar su código
contra la API antigua. Para hacerlo, puede escribir un manifiesto para
usarlo con ‘guix package --manifest’ (*note Invocación de guix
package::); en dicho manifiesto puede crear un inferior para esa versión
antigua de Guix que le interesa, y buscará el paquete ‘guile-json’ en el
inferior:

     (use-modules (guix inferior) (guix channels)
                  (srfi srfi-1))   ;para 'first'

     (define channels
       ;; Esta es la revisión antigua de donde queremos
       ;; extraer guile-json.
       (list (channel
              (name 'guix)
              (url "https://git.savannah.gnu.org/git/guix.git")
              (commit
               "65956ad3526ba09e1f7a40722c96c6ef7c0936fe"))))

     (define inferior
       ;; Un inferior que representa la revisión previa.
       (inferior-for-channels channels))

     ;; Ahora crea un manifiesto con el paquete "guile" actual
     ;; y el antiguo paquete "guile-json".
     (packages->manifest
      (list (first (lookup-inferior-packages inferior "guile-json"))
            (specification->package "guile")))

   En su primera ejecución, ‘guix package --manifest’ puede tener que
construir el canal que especificó antes de crear el inferior; las
siguientes ejecuciones serán mucho más rápidas porque la revisión de
Guix estará en la caché.

   El módulo ‘(guix inferior)’ proporciona los siguientes procedimientos
para abrir un inferior:

 -- Procedimiento Scheme: inferior-for-channels CANALES
          [#:cache-directory] [#:ttl]
     Devuelve un inferior para CANALES, una lista de canales. Usa la
     caché en CACHE-DIRECTORY, donde las entradas pueden ser reclamadas
     después de TTL segundos. Este procedimiento abre una nueva conexión
     al daemon de construcción.

     Como efecto secundario, este procedimiento puede construir o
     sustituir binarios para CANALES, lo cual puede tomar cierto tiempo.

 -- Procedimiento Scheme: open-inferior DIRECTORIO [#:command
          "bin/guix"]
     Abre el Guix inferior en DIRECTORIO, ejecutando ‘DIRECTORIO/COMMAND
     repl’ o su equivalente. Devuelve ‘#f’ si el inferior no pudo ser
     ejecutado.

   Los procedimientos enumerados a continuación le permiten obtener y
manipular paquetes de inferiores.

 -- Procedimiento Scheme: inferior-packages INFERIOR
     Devuelve la lista de paquetes conocida por INFERIOR.

 -- Procedimiento Scheme: lookup-inferior-packages INFERIOR NOMBRE
          [VERSIÓN]
     Devuelve la lista ordenada de paquetes del inferior que
     corresponden con NOMBRE en INFERIOR, con los números de versión más
     altos primero. Si VERSIÓN tiene un valor verdadero, devuelve
     únicamente paquetes con un número de versión cuyo prefijo es
     VERSIÓN.

 -- Procedimiento Scheme: inferior-package? OBJ
     Devuelve verdadero si OBJ es un paquete inferior.

 -- Procedimiento Scheme: inferior-package-name PAQUETE
 -- Procedimiento Scheme: inferior-package-version PAQUETE
 -- Procedimiento Scheme: inferior-package-synopsis PAQUETE
 -- Procedimiento Scheme: inferior-package-description PAQUETE
 -- Procedimiento Scheme: inferior-package-home-page PAQUETE
 -- Procedimiento Scheme: inferior-package-location PAQUETE
 -- Procedimiento Scheme: inferior-package-inputs PAQUETE
 -- Procedimiento Scheme: inferior-package-native-inputs PAQUETE
 -- Procedimiento Scheme: inferior-package-propagated-inputs PAQUETE
 -- Procedimiento Scheme: inferior-package-transitive-propagated-inputs
          PAQUETE
 -- Procedimiento Scheme: inferior-package-native-search-paths PAQUETE
 -- Procedimiento Scheme:
          inferior-package-transitive-native-search-paths PAQUETE
 -- Procedimiento Scheme: inferior-package-search-paths PAQUETE
     Estos procedimientos son la contraparte de los accesos a los
     registros de paquete (*note Referencia de package::). La mayor
     parte funcionan interrogando al inferior del que PAQUETE viene, por
     lo que el inferior debe estar vivo cuando llama a dichos
     procedimientos.

   Los paquetes de inferiores pueden ser usados transparentemente como
cualquier otro paquete u objeto-tipo-fichero en expresiones-G (*note
Expresiones-G::). También se manejan transparentemente por el
procedimiento ‘packages->manifest’, el cual se usa habitualmente en los
manifiestos (*note the ‘--manifest’ option of ‘guix package’: Invocación
de guix package.). Por tanto puede insertar un paquete de inferior
prácticamente en cualquier lugar que pueda insertar un paquete normal:
en manifiestos, en el campo ‘packages’ de su declaración
‘operating-system’, etcétera.


File: guix.es.info,  Node: Invocación de guix describe,  Next: Invocación de guix archive,  Prev: Inferiores,  Up: Gestión de paquetes

4.10 Invocación de ‘guix describe’
==================================

A menudo desea responder a preguntas como: “¿Qué revisión de Guix estoy
usando?” o “¿Qué canales estoy usando?” Esto es una información muy útil
en muchas situaciones: si quiere _replicar_ un entorno en una máquina
diferente o cuenta de usuaria, si desea informar de un error o
determinar qué cambio en los canales que usa lo causó, o si quiere
almacenar el estado de su sistema por razones de reproducibilidad. La
orden ‘guix describe’ responde a estas preguntas.

   Cuando se ejecuta desde un ‘guix’ bajado con ‘guix pull’, ‘guix
describe’ muestra el/los canal/es desde el/los que se construyó,
incluyendo la URL de su repositorio y los IDs de las revisiones (*note
Canales::):

     $ guix describe
     Generation 10	Sep 03 2018 17:32:44	(current)
       guix e0fa68c
         repository URL: https://git.savannah.gnu.org/git/guix.git
         branch: master
         commit: e0fa68c7718fffd33d81af415279d6ddb518f727

   Si está familiarizado con el sistema de control de versiones Git,
esto es similar a ‘git describe’; la salida también es similar a la de
‘guix pull --list-generations’, pero limitada a la generación actual
(*note the ‘--list-generations’ option: Invocación de guix pull.).
Debido a que el ID de revisión Git mostrado antes refiere sin
ambigüedades al estado de Guix, esta información es todo lo necesario
para describir la revisión de Guix que usa, y también para replicarla.

   Para facilitar la replicación de Guix, también se le puede solicitar
a ‘guix describe’ devolver una lista de canales en vez de la descripción
legible por humanos mostrada antes:

     $ guix describe -f channels
     (list (channel
             (name 'guix)
             (url "https://git.savannah.gnu.org/git/guix.git")
             (commit
               "e0fa68c7718fffd33d81af415279d6ddb518f727")))

Puede almacenar esto en un fichero y se lo puede proporcionar a ‘guix
pull -C’ en otra máquina o en un momento futuro, lo que instanciará
_esta revisión exacta de Guix_ (*note the ‘-C’ option: Invocación de
guix pull.). De aquí en adelante, ya que puede desplegar la misma
revisión de Guix, puede también _replicar un entorno completo de
software_. Nosotras humildemente consideramos que esto es
_impresionante_, ¡y esperamos que le guste a usted también!

   Los detalles de las opciones aceptadas por ‘guix describe’ son las
siguientes:

‘--format=FORMATO’
‘-f FORMATO’
     Produce salida en el FORMATO especificado, uno de:

     ‘human’
          produce salida legible por humanos;
     ‘channels’
          produce una lista de especificaciones de canales que puede ser
          pasada a ‘guix pull -C’ o instalada como
          ‘~/.config/guix/channels.scm’ (*note Invocación de guix
          pull::);
     ‘json’
          produce una lista de especificaciones de canales en formato
          JSON;
     ‘recutils’
          produce una lista de especificaciones de canales en formato
          Recutils.

‘--list-formats’
     Display available formats for ‘--format’ option.

‘--profile=PERFIL’
‘-p PERFIL’
     Muestra información acerca del PERFIL.


File: guix.es.info,  Node: Invocación de guix archive,  Prev: Invocación de guix describe,  Up: Gestión de paquetes

4.11 Invocación de ‘guix archive’
=================================

La orden ‘guix archive’ permite a las usuarias “exportar” ficheros del
almacén en un único archivador, e “importarlos” posteriormente en una
máquina que ejecute Guix. En particular, permite que los ficheros del
almacén sean transferidos de una máquina al almacén de otra máquina.

     Nota: Si está buscando una forma de producir archivos en un formato
     adecuado para herramientas distintas a Guix, *note Invocación de
     guix pack::.

   Para exportar ficheros del almacén como un archivo por la salida
estándar, ejecute:

     guix archive --export OPCIONES ESPECIFICACIONES...

   ESPECIFICACIONES deben ser o bien nombres de ficheros del almacén o
especificaciones de paquetes, como las de ‘guix package’ (*note
Invocación de guix package::). Por ejemplo, la siguiente orden crea un
archivo que contiene la salida ‘gui’ del paquete ‘git’ y la salida
principal de ‘emacs’:

     guix archive --export git:gui /gnu/store/...-emacs-24.3 > great.nar

   Si los paquetes especificados no están todavía construidos, ‘guix
archive’ los construye automáticamente. El proceso de construcción puede
controlarse mediante las opciones de construcción comunes (*note
Opciones comunes de construcción::).

   Para transferir el paquete ‘emacs’ a una máquina conectada por SSH,
se ejecutaría:

     guix archive --export -r emacs | ssh otra-maquina guix archive --import

De manera similar, un perfil de usuaria completo puede transferirse de
una máquina a otra de esta manera:

     guix archive --export -r $(readlink -f ~/.guix-profile) | \
       ssh otra-maquina guix archive --import

However, note that, in both examples, all of ‘emacs’ and the profile as
well as all of their dependencies are transferred (due to ‘-r’),
regardless of what is already available in the store on the target
machine. The ‘--missing’ option can help figure out which items are
missing from the target store. The ‘guix copy’ command simplifies and
optimizes this whole process, so this is probably what you should use in
this case (*note Invocación de guix copy::).

   Los archivos se almacenan en el formato de “archivo normalizado” o
“nar”, el cual es comparable a ‘tar’ en el espíritu, pero con
diferencias que lo hacen más apropiado para nuestro propósito. Primero,
en vez de almacenar todos los metadatos Unix de cada fichero, el formato
nar solo menciona el tipo de fichero (normal, directorio o enlace
simbólico); los permisos Unix y el par propietario/grupo se descartan.
En segundo lugar, el orden en el cual las entradas de directorios se
almacenan siempre siguen el orden de los nombres de ficheros de acuerdo
a la ordenación de cadenas en la localización C. Esto hace la producción
del archivo completamente determinista.

   Durante la exportación, el daemon firma digitalmente los contenidos
del archivo, y la firma digital se adjunta. Durante la importación, el
daemon verifica la firma y rechaza la importación en caso de una firma
inválida o si la clave firmante no está autorizada.

   Las opciones principales son:

‘--export’
     Export the specified store files or packages (see below). Write the
     resulting archive to the standard output.

     Dependencies are _not_ included in the output, unless ‘--recursive’
     is passed.

‘-r’
‘--recursive’
     When combined with ‘--export’, this instructs ‘guix archive’ to
     include dependencies of the given items in the archive. Thus, the
     resulting archive is self-contained: it contains the closure of the
     exported store items.

‘--import’
     Read an archive from the standard input, and import the files
     listed therein into the store. Abort if the archive has an invalid
     digital signature, or if it is signed by a public key not among the
     authorized keys (see ‘--authorize’ below).

‘--missing’
     Lee una lista de nombres de ficheros del almacén de la entrada
     estándar, uno por línea, y escribe en la salida estándar el
     subconjunto de estos ficheros que faltan en el almacén.

‘--generate-key[=PARÁMETROS]’
     Generate a new key pair for the daemon. This is a prerequisite
     before archives can be exported with ‘--export’. Note that this
     operation usually takes time, because it needs to gather enough
     entropy to generate the key pair.

     The generated key pair is typically stored under ‘/etc/guix’, in
     ‘signing-key.pub’ (public key) and ‘signing-key.sec’ (private key,
     which must be kept secret). When PARAMETERS is omitted, an ECDSA
     key using the Ed25519 curve is generated, or, for Libgcrypt
     versions before 1.6.0, it is a 4096-bit RSA key. Alternatively,
     PARAMETERS can specify ‘genkey’ parameters suitable for Libgcrypt
     (*note ‘gcry_pk_genkey’: (gcrypt)General public-key related
     Functions.).

‘--authorize’
     Autoriza importaciones firmadas con la clave pública pasada por la
     entrada estándar. La clave pública debe estar en el “formato
     avanzado de expresiones-s”—es decir, el mismo formato que el
     fichero ‘signing-key.pub’.

     La lista de claves autorizadas se mantiene en el fichero editable
     por personas ‘/etc/guix/acl’. El fichero contiene “expresiones-s en
     formato avanzado” (https://people.csail.mit.edu/rivest/Sexp.text) y
     está estructurado como una lista de control de acceso en el formato
     Infraestructura Simple de Clave Pública (SPKI)
     (https://theworld.com/~cme/spki.txt).

‘--extract=DIRECTORIO’
‘-x DIRECTORIO’
     Lee un único elemento del archivo como es ofrecido por los
     servidores de sustituciones (*note Sustituciones::) y lo extrae a
     DIRECTORIO. Esta es una operación de bajo nivel necesitada
     únicamente para casos muy concretos; véase a continuación.

     Por ejemplo, la siguiente orden extrae la sustitución de Emacs
     ofrecida por ‘ci.guix.gnu.org’ en ‘/tmp/emacs’:

          $ wget -O - \
            https://ci.guix.gnu.org/nar/gzip/...-emacs-24.5 \
            | gunzip | guix archive -x /tmp/emacs

     Los archivos de un único elemento son diferentes de los archivos de
     múltiples elementos producidos por ‘guix archive --export’;
     contienen un único elemento del almacén, y _no_ embeben una firma.
     Por tanto esta operación _no_ verifica la firma y su salida debe
     considerarse insegura.

     The primary purpose of this operation is to facilitate inspection
     of archive contents coming from possibly untrusted substitute
     servers (*note Invocación de guix challenge::).

‘--list’
‘-t’
     Lee un único elemento del archivo como es ofrecido por los
     servidores de sustituciones (*note Sustituciones::) e imprime la
     lista de ficheros que contiene, como en este ejemplo:

          $ wget -O - \
            https://ci.guix.gnu.org/nar/lzip/...-emacs-26.3 \
            | lzip -d | guix archive -t


File: guix.es.info,  Node: Desarrollo,  Next: Interfaz programática,  Prev: Gestión de paquetes,  Up: Top

5 Desarrollo
************

Si es una desarrolladora de software, Guix le proporciona herramientas
que debería encontrar útiles—independientemente del lenguaje en el que
desarrolle actualmente. Esto es sobre lo que trata este capítulo.

   La orden ‘guix environment’ proporciona una manera conveniente de
configurar un “entorno de desarrollo” que contenga todas las
dependencias y herramientas necesarias para trabajar en el paquete de
software de su elección. La orden ‘guix pack’ le permite crear
“aplicaciones empaquetadas” que pueden ser distribuidas con facilidad a
usuarias que no usen Guix.

* Menu:

* Invocación de guix environment::  Configurar entornos de desarrollo.
* Invocación de guix pack::  Creación de empaquetados de software.
* La cadena de herramientas de GCC::  Working with languages supported by
                                        GCC.


File: guix.es.info,  Node: Invocación de guix environment,  Next: Invocación de guix pack,  Up: Desarrollo

5.1 Invocación de ‘guix environment’
====================================

El propósito de ‘guix environment’ es ayudar a las hackers en la
creación de entornos de desarrollo reproducibles sin modificar los
paquetes de su perfil. La herramienta ‘guix environment’ toma uno o más
paquetes, construye todas sus entradas y crea un entorno shell para
usarlos.

   La sintaxis general es:

     guix environment OPCIONES PAQUETE...

   El ejemplo siguiente lanza un nuevo shell preparado para el
desarrollo de GNU Guile:

     guix environment guile

   If the needed dependencies are not built yet, ‘guix environment’
automatically builds them. The environment of the new shell is an
augmented version of the environment that ‘guix environment’ was run in.
It contains the necessary search paths for building the given package
added to the existing environment variables. To create a “pure”
environment, in which the original environment variables have been
unset, use the ‘--pure’ option(1).

   ‘guix environment’ defines the ‘GUIX_ENVIRONMENT’ variable in the
shell it spawns; its value is the file name of the profile of this
environment. This allows users to, say, define a specific prompt for
development environments in their ‘.bashrc’ (*note (bash)Bash Startup
Files::):

     if [ -n "$GUIX_ENVIRONMENT" ]
     then
         export PS1="\u@\h \w [dev]\$ "
     fi

... o para explorar el perfil:

     $ ls "$GUIX_ENVIRONMENT/bin"

   Adicionalmente, más de un paquete puede ser especificado, en cuyo
caso se usa la unión de las entradas de los paquetes proporcionados. Por
ejemplo, la siguiente orden lanza un shell donde todas las dependencias
tanto de Guile como de Emacs están disponibles:

     guix environment guile emacs

   A veces no se desea una sesión interactiva de shell. Una orden
arbitraria se puede invocar usando el valor ‘--’ para separar la orden
del resto de los parámetros:

     guix environment guile -- make -j4

   En otras situaciones, es más conveniente especificar una lista de
paquetes necesarios en el entorno. Por ejemplo, la siguiente orden
ejecuta ‘python’ desde un entorno que contiene Python 2.7 y NumPy:

     guix environment --ad-hoc python2-numpy python-2.7 -- python

   Furthermore, one might want the dependencies of a package and also
some additional packages that are not build-time or runtime
dependencies, but are useful when developing nonetheless. Because of
this, the ‘--ad-hoc’ flag is positional. Packages appearing before
‘--ad-hoc’ are interpreted as packages whose dependencies will be added
to the environment. Packages appearing after are interpreted as packages
that will be added to the environment directly. For example, the
following command creates a Guix development environment that
additionally includes Git and strace:

     guix environment --pure guix --ad-hoc git strace

   En ocasiones es deseable aislar el entorno tanto como sea posible,
para obtener la máxima pureza y reproducibilidad. En particular, cuando
se usa Guix en una distribución anfitriona que no es el sistema Guix, es
deseable prevenir acceso a ‘/usr/bin’ y otros recursos del sistema desde
el entorno de desarrollo. Por ejemplo, la siguiente orden lanza un REPL
Guile en un “contenedor” donde únicamente el almacén y el directorio
actual están montados:

     guix environment --ad-hoc --container guile -- guile

     Nota: The ‘--container’ option requires Linux-libre 3.19 or newer.

   Another typical use case for containers is to run security-sensitive
applications such as a web browser. To run Eolie, we must expose and
share some files and directories; we include ‘nss-certs’ and expose
‘/etc/ssl/certs/’ for HTTPS authentication; finally we preserve the the
‘DISPLAY’ environment variable since containerized graphical
applications won’t display without it.

     guix environment --preserve='^DISPLAY$' --container --network \
       --expose=/etc/machine-id \
       --expose=/etc/ssl/certs/ \
       --share=$HOME/.local/share/eolie/=$HOME/.local/share/eolie/ \
       --ad-hoc eolie nss-certs dbus --  eolie

   Las opciones disponibles se resumen a continuación.

‘--root=FICHERO’
‘-r FICHERO’
     Hace que FICHERO sea un enlace simbólico al perfil para este
     entorno, y lo registra como una raíz del recolector de basura.

     Esto es útil si desea proteger su entorno de la recolección de
     basura, hacerlo “persistente”.

     Cuando se omite esta opción, el entorno se protege de la
     recolección de basura únicamente por la duración de la sesión ‘guix
     environment’. Esto significa que la siguiente vez que vuelva a
     crear el mismo entorno, puede tener que reconstruir o volver a
     descargar paquetes. *Note Invocación de guix gc::, para más
     información sobre las raíces del recolector de basura.

‘--expression=EXPR’
‘-e EXPR’
     Crea un entorno para el paquete o lista de paquetes a los que
     evalúa EXPR.

     Por ejemplo, ejecutando:

          guix environment -e '(@ (gnu packages maths) petsc-openmpi)'

     inicia un shell con el entorno para esta variante específica del
     paquete PETSc.

     Ejecutar:

          guix environment --ad-hoc -e '(@ (gnu) %base-packages)'

     inicia un shell con todos los paquetes básicos del sistema
     disponibles.

     Las órdenes previas usan únicamente la salida predeterminada de los
     paquetes dados. Para seleccionar otras salidas, tuplas de dos
     elementos pueden ser especificadas:

          guix environment --ad-hoc -e '(list (@ (gnu packages bash) bash) "include")'

‘--load=FICHERO’
‘-l FICHERO’
     Crea un entorno para el paquete o la lista de paquetes a la que el
     código en FICHERO evalúa.

     Como un ejemplo, FICHERO puede contener una definición como esta
     (*note Definición de paquetes::):

          (use-modules (guix)
                       (gnu packages gdb)
                       (gnu packages autotools)
                       (gnu packages texinfo))
          
          ;; Augment the package definition of GDB with the build tools
          ;; needed when developing GDB (and which are not needed when
          ;; simply installing it.)
          (package (inherit gdb)
            (native-inputs `(("autoconf" ,autoconf-2.64)
                             ("automake" ,automake)
                             ("texinfo" ,texinfo)
                             ,@(package-native-inputs gdb))))

‘--manifest=FICHERO’
‘-m FICHERO’
     Crea un entorno para los paquetes contenidos en el objeto manifest
     devuelto por el código Scheme en FILE. Esta opción se puede repetir
     varias veces, en cuyo caso los manifiestos se concatenan.

     Esto es similar a la opción del mismo nombre en ‘guix package’
     (*note ‘--manifest’: profile-manifest.) y usa los mismos ficheros
     de manifiesto.

‘--ad-hoc’
     Incluye todos los paquetes especificados en el entorno resultante,
     como si un paquete ad hoc hubiese sido definido con ellos como
     entradas. Esta opción es útil para la creación rápida un entorno
     sin tener que escribir una expresión de paquete que contenga las
     entradas deseadas.

     Por ejemplo, la orden:

          guix environment --ad-hoc guile guile-sdl -- guile

     ejecuta ‘guile’ en un entorno donde están disponibles Guile y
     Guile-SDL.

     Fíjese que este ejemplo solicita implícitamente la salida
     predeterminada de ‘guile’ y ‘guile-sdl’, pero es posible solicitar
     una salida específica—por ejemplo, ‘glib:bin’ solicita la salida
     ‘bin’ de ‘glib’ (*note Paquetes con múltiples salidas::).

     This option may be composed with the default behavior of ‘guix
     environment’. Packages appearing before ‘--ad-hoc’ are interpreted
     as packages whose dependencies will be added to the environment,
     the default behavior. Packages appearing after are interpreted as
     packages that will be added to the environment directly.

‘--pure’
     Unset existing environment variables when building the new
     environment, except those specified with ‘--preserve’ (see below).
     This has the effect of creating an environment in which search
     paths only contain package inputs.

‘--preserve=REGEXP’
‘-E REGEXP’
     Cuando se usa junto a ‘--pure’, preserva las variables de entorno
     que corresponden con REGEXP—en otras palabras, las pone en una
     lista de variables de entorno que deben preservarse. Esta opción
     puede repetirse varias veces.

          guix environment --pure --preserve=^SLURM --ad-hoc openmpi ... \
            -- mpirun ...

     This example runs ‘mpirun’ in a context where the only environment
     variables defined are ‘PATH’, environment variables whose name
     starts with ‘SLURM’, as well as the usual “precious” variables
     (‘HOME’, ‘USER’, etc.).

‘--search-paths’
     Muestra las definiciones de variables de entorno que componen el
     entorno.

‘--system=SISTEMA’
‘-s SISTEMA’
     Intenta construir para SISTEMA—por ejemplo, ‘i686-linux’.

‘--container’
‘-C’
     Run COMMAND within an isolated container. The current working
     directory outside the container is mapped inside the container.
     Additionally, unless overridden with ‘--user’, a dummy home
     directory is created that matches the current user’s home
     directory, and ‘/etc/passwd’ is configured accordingly.

     The spawned process runs as the current user outside the container.
     Inside the container, it has the same UID and GID as the current
     user, unless ‘--user’ is passed (see below).

‘--network’
‘-N’
     Para contenedores, comparte el espacio de nombres de red con el
     sistema anfitrión. Los contenedores creados sin esta opción
     únicamente tienen acceso a la red local.

‘--link-profile’
‘-P’
     For containers, link the environment profile to ‘~/.guix-profile’
     within the container. This is equivalent to running the command ‘ln
     -s $GUIX_ENVIRONMENT ~/.guix-profile’ within the container. Linking
     will fail and abort the environment if the directory already
     exists, which will certainly be the case if ‘guix environment’ was
     invoked in the user’s home directory.

     Certain packages are configured to look in ‘~/.guix-profile’ for
     configuration files and data;(2) ‘--link-profile’ allows these
     programs to behave as expected within the environment.

‘--user=USUARIA’
‘-u USUARIA’
     Para contenedores, usa el nombre de usuaria USUARIA en vez de la
     actual. La entrada generada en ‘/etc/passwd’ dentro del contenedor
     contendrá el nombre USUARIA; su directorio será ‘/home/USUARIA’ y
     ningún dato GECOS de la usuaria se copiará. Más aún, el UID y GID
     dentro del contenedor son 1000. USUARIA no debe existir en el
     sistema.

     Additionally, any shared or exposed path (see ‘--share’ and
     ‘--expose’ respectively) whose target is within the current user’s
     home directory will be remapped relative to ‘/home/USER’; this
     includes the automatic mapping of the current working directory.

          # expondrá las rutas /home/foo/ddt, /home/foo/prueba y /home/foo/objetivo
          cd $HOME/ddt
          guix environment --container --user=foo \
               --expose=$HOME/prueba \
               --expose=/tmp/objetivo=$HOME/objetivo

     Mientras esto limita el escape de la identidad de la usuaria a
     través de las rutas de sus directorios y cada uno de los campos de
     usuaria, esto es únicamente un componente útil de una solución de
     privacidad/anonimato más amplia—no una solución completa.

‘--no-cwd’
     For containers, the default behavior is to share the current
     working directory with the isolated container and immediately
     change to that directory within the container. If this is
     undesirable, ‘--no-cwd’ will cause the current working directory to
     _not_ be automatically shared and will change to the user’s home
     directory within the container instead. See also ‘--user’.

‘--expose=FUENTE[=DESTINO]’
‘--share=FUENTE[=DESTINO]’
     For containers, ‘--expose’ (resp. ‘--share’) exposes the file
     system SOURCE from the host system as the read-only (resp.
     writable) file system TARGET within the container. If TARGET is not
     specified, SOURCE is used as the target mount point in the
     container.

     El ejemplo a continuación lanza una sesión interactiva de Guile en
     un contenedor donde el directorio principal de la usuaria es
     accesible en modo solo-lectura a través del directorio
     ‘/intercambio’:

          guix environment --container --expose=$HOME=/intercambio --ad-hoc guile -- guile

   Además, ‘guix environment’ acepta todas las opciones comunes de
construcción que permite ‘guix build’ (*note Opciones comunes de
construcción::) así como las opciones de transformación de paquetes
(*note Opciones de transformación de paquetes::).

   ---------- Footnotes ----------

   (1) Users sometimes wrongfully augment environment variables such as
‘PATH’ in their ‘~/.bashrc’ file. As a consequence, when ‘guix
environment’ launches it, Bash may read ‘~/.bashrc’, thereby introducing
“impurities” in these environment variables. It is an error to define
such environment variables in ‘.bashrc’; instead, they should be defined
in ‘.bash_profile’, which is sourced only by log-in shells. *Note
(bash)Bash Startup Files::, for details on Bash start-up files.

   (2) For example, the ‘fontconfig’ package inspects
‘~/.guix-profile/share/fonts’ for additional fonts.


File: guix.es.info,  Node: Invocación de guix pack,  Next: La cadena de herramientas de GCC,  Prev: Invocación de guix environment,  Up: Desarrollo

5.2 Invocación de ‘guix pack’
=============================

De manera ocasional querrá dar software a gente que (¡todavía!) no tiene
la suerte de usar Guix. Usted les diría que ejecuten ‘guix package -i
ALGO’, pero eso no es posible en este caso. Aquí es donde viene ‘guix
pack’.

     Nota: Si está buscando formas de intercambiar binarios entre
     máquinas que ya ejecutan Guix, *note Invocación de guix copy::,
     *note Invocación de guix publish::, y *note Invocación de guix
     archive::.

   La orden ‘guix pack’ crea un “paquete” reducido o “empaquetado de
software”: crea un archivador tar u otro tipo que contiene los binarios
del software en el que está interesada y todas sus dependencias. El
archivo resultante puede ser usado en una máquina que no tiene Guix, y
la gente puede ejecutar exactamente los mismos binarios que usted tiene
con Guix. El paquete en sí es creado de forma reproducible bit-a-bit,
para que cualquiera pueda verificar que realmente contiene los
resultados de construcción que pretende distribuir.

   Por ejemplo, para crear un empaquetado que contenga Guile, Emacs,
Geiser y todas sus dependencias, puede ejecutar:

     $ guix pack guile emacs geiser
     ...
     /gnu/store/...-pack.tar.gz

   El resultado aquí es un archivador tar que contiene un directorio de
‘/gnu/store’ con todos los paquetes relevantes. El archivador resultante
contiene un “perfil” con los tres paquetes de interés; el perfil es el
mismo que se hubiera creado por ‘guix package -i’. Este es el mecanismo
usado para crear el propio archivador de binarios separado de Guix
(*note Instalación binaria::).

   Las usuarias de este empaquetad tendrán que ejecutar
‘/gnu/store/...-profile/bin/guile’ para ejecutar guile, lo que puede
resultar inconveniente. Para evitarlo, puede crear, digamos, un enlace
simbólico ‘/opt/gnu/bin’ al perfil:

     guix pack -S /opt/gnu/bin=bin guile emacs geiser

De este modo, las usuarias pueden escribir alegremente
‘/opt/gnu/bin/guile’ y disfrutar.

   What if the recipient of your pack does not have root privileges on
their machine, and thus cannot unpack it in the root file system? In
that case, you will want to use the ‘--relocatable’ option (see below).
This option produces “relocatable binaries”, meaning they they can be
placed anywhere in the file system hierarchy: in the example above,
users can unpack your tarball in their home directory and directly run
‘./opt/gnu/bin/guile’.

   De manera alternativa, puede producir un empaquetado en el formato de
imagen Docker usando la siguiente orden:

     guix pack -f docker -S /bin=bin guile guile-readline

El resultado es un archivador “tar” que puede ser proporcionado a la
orden ‘docker load’, seguida de ‘docker run’:

     docker load < FICHERO
     docker run -ti guile-guile-readline /bin/guile

donde FICHERO es la imagen devuelta por GUIX PACK, y
‘guile-guile-readline’ es la “etiqueta de imagen”. Véase la
documentación de Docker
(https://docs.docker.com/engine/reference/commandline/load/) para más
información.

   Otra opción más es producir una imagen SquashFS con la siguiente
orden:

     guix pack -f squashfs bash guile emacs geiser

The result is a SquashFS file system image that can either be mounted or
directly be used as a file system container image with the Singularity
container execution environment (https://www.sylabs.io/docs/), using
commands like ‘singularity shell’ or ‘singularity exec’.

   Varias opciones de la línea de órdenes le permiten personalizar su
empaquetado:

‘--format=FORMATO’
‘-f FORMATO’
     Produce un empaquetado en el FORMATO específico.

     Los formatos disponibles son:

     ‘tarball’
          Es el formato predeterminado. Produce un archivador que
          contiene todos los binarios y enlaces simbólicos
          especificados.

     ‘docker’
          Produce un archivador que sigue la especificación de imágenes
          Docker
          (https://github.com/docker/docker/blob/master/image/spec/v1.2.md).
          El “nombre de repositorio” como aparece en la salida de la
          orden ‘docker images’ se calcula a partir de los nombres de
          paquete proporcionados en la línea de órdenes o en el fichero
          de manifiesto.

     ‘squashfs’
          Produce una imagen SquashFS que contiene todos los binarios y
          enlaces simbólicos especificados, así como puntos de montaje
          vacíos para sistemas de ficheros virtuales como procfs.

               Nota: Singularity _necesita_ que proporcione ‘/bin/sh’ en
               la imagen. Por esta razón, ‘guix pack -f squashfs’
               siempre implica ‘-S /bin=bin’. Por tanto, su invocación
               de ‘guix pack’ debe siempre comenzar de manera similar a
               esta:

                    guix pack -f squashfs bash ...

               Si se olvida del paquete ‘bash’ (o similar), ‘singularity
               run’ y ‘singularity exec’ fallarán con el mensaje “no
               existe el fichero o directorio”, lo que no sirve de
               ayuda.

‘--relocatable’
‘-R’
     Produce “binarios reposicionables”—es decir, binarios que se pueden
     encontrar en cualquier lugar de la jerarquía del sistema de
     ficheros, y ejecutarse desde allí.

     When this option is passed once, the resulting binaries require
     support for “user namespaces” in the kernel Linux; when passed
     _twice_(1), relocatable binaries fall to back to other techniques
     if user namespaces are unavailable, and essentially work
     anywhere—see below for the implications.

     Por ejemplo, si crea un empaquetado que contiene Bash con:

          guix pack -RR -S /mybin=bin bash

     ... puede copiar ese empaquetado a una máquina que no tiene Guix, y
     desde su directorio, como una usuaria normal, ejecutar:

          tar xf pack.tar.gz
          ./mibin/sh

     En ese shell, si escribe ‘ls /gnu/store’, notará que ‘/gnu/store’
     muestra y contiene todas las dependencias de ‘bash’, ¡incluso
     cuando la máquina no tiene el directorio ‘/gnu/store’! Esto es
     probablemente el modo más simple de desplegar software construido
     en Guix en una máquina no-Guix.

          Nota: No obstante hay un punto a tener en cuenta: esta técnica
          descansa en la característica de “espacios de nombres de
          usuaria” del núcleo Linux, la cual permite a usuarias no
          privilegiadas montar o cambiar la raíz. Versiones antiguas de
          Linux no los implementan, y algunas distribuciones GNU/Linux
          los desactivan.

          To produce relocatable binaries that work even in the absence
          of user namespaces, pass ‘--relocatable’ or ‘-R’ _twice_. In
          that case, binaries will try user namespace support and fall
          back to another “execution engine” if user namespaces are not
          supported. The following execution engines are supported:

          ‘default’
               Try user namespaces and fall back to PRoot if user
               namespaces are not supported (see below).

          ‘performance’
               Try user namespaces and fall back to Fakechroot if user
               namespaces are not supported (see below).

          ‘userns’
               Run the program through user namespaces and abort if they
               are not supported.

          ‘proot’
               Run through PRoot. The PRoot
               (https://proot-me.github.io/) program provides the
               necessary support for file system virtualization. It
               achieves that by using the ‘ptrace’ system call on the
               running program. This approach has the advantage to work
               without requiring special kernel support, but it incurs
               run-time overhead every time a system call is made.

          ‘fakechroot’
               Run through Fakechroot. Fakechroot
               (https://github.com/dex4er/fakechroot/) virtualizes file
               system accesses by intercepting calls to C library
               functions such as ‘open’, ‘stat’, ‘exec’, and so on.
               Unlike PRoot, it incurs very little overhead. However, it
               does not always work: for example, some file system
               accesses made from within the C library are not
               intercepted, and file system accesses made via direct
               syscalls are not intercepted either, leading to erratic
               behavior.

          When running a wrapped program, you can explicitly request one
          of the execution engines listed above by setting the
          ‘GUIX_EXECUTION_ENGINE’ environment variable accordingly.

‘--entry-point=ORDEN’
     Usa ORDEN como el “punto de entrada” del empaquetado resultante, si
     el formato de empaquetado lo permite—actualmente ‘docker’ y
     ‘squashfs’ (Singularity) lo permiten. ORDEN debe ser una ruta
     relativa al perfil contenido en el empaquetado.

     El punto de entrada especifica la orden que herramientas como
     ‘docker run’ o ‘singularity run’ arrancan de manera automática de
     forma predeterminada. Por ejemplo, puede ejecutar:

          guix pack -f docker --entry-point=bin/guile guile

     El empaquetado resultante puede cargarse fácilmente y ‘docker run’
     sin parámetros adicionales lanzará ‘bin/guile’:

          docker load -i pack.tar.gz
          docker run IMAGE-ID

‘--expression=EXPR’
‘-e EXPR’
     Considera el paquete al que evalúa EXPR

     This has the same purpose as the same-named option in ‘guix build’
     (*note ‘--expression’ in ‘guix build’: Opciones de construcción
     adicionales.).

‘--manifest=FICHERO’
‘-m FICHERO’
     Usa los paquetes contenidos en el objeto manifest devuelto por el
     código Scheme en FICHERO. Esta opción puede repetirse varias veces,
     en cuyo caso los manifiestos se concatenan.

     Esto tiene un propósito similar al de la opción del mismo nombre en
     ‘guix package’ (*note ‘--manifest’: profile-manifest.) y usa los
     mismos ficheros de manifiesto. Esto le permite definir una
     colección de paquetes una vez y usarla tanto para crear perfiles
     como para crear archivos en máquinas que no tienen instalado Guix.
     Fíjese que puede especificar _o bien_ un fichero de manifiesto _o
     bien_ una lista de paquetes, pero no ambas.

‘--system=SISTEMA’
‘-s SISTEMA’
     Intenta construir paquetes para SISTEMA—por ejemplo,
     ‘x86_64-linux’—en vez del tipo de sistema de la máquina de
     construcción.

‘--target=TRIPLETA’
     Cross-build for TRIPLET, which must be a valid GNU triplet, such as
     ‘"aarch64-linux-gnu"’ (*note GNU configuration triplets:
     (autoconf)Specifying target triplets.).

‘--compression=HERRAMIENTA’
‘-C HERRAMIENTA’
     Comprime el archivador resultante usando HERRAMIENTA—un valor que
     puede ser ‘gzip’, ‘bzip2’, ‘xz’, ‘lzip’ o ‘none’ para no usar
     compresión.

‘--symlink=SPEC’
‘-S SPEC’
     Añade los enlaces simbólicos especificados por SPEC al empaquetado.
     Esta opción puede aparecer varias veces.

     La forma de SPEC es ‘FUENTE=DESTINO’, donde FUENTE es el enlace
     simbólico que será creado y DESTINO es el destino del enlace
     simbólico.

     Por ejemplo, ‘-S /opt/gnu/bin=bin’ crea un enlace simbólico
     ‘/opt/gnu/bin’ apuntando al subdirectorio ‘bin’ del perfil.

‘--save-provenance’
     Almacena la información de procedencia para paquetes proporcionados
     en la línea de órdenes. La información de procedencia incluye la
     URL y revisión de los canales en uso (*note Canales::).

     La información de procedencia se almacena en el fichero
     ‘/gnu/store/...-profile/manifest’ dentro del empaquetado, junto a
     los metadatos habituales del paquete—el nombre y la versión de cada
     paquete, sus entradas propagadas, etcétera. Es información útil
     para la parte receptora del empaquetado, quien de ese modo conoce
     como se obtuvo (supuestamente) dicho empaquetado.

     Esta opción no se usa de manera predeterminada debido a que, como
     las marcas de tiempo, la información de procedencia no aportan nada
     al proceso de construcción. En otras palabras, hay una infinidad de
     URL de canales e identificadores de revisiones que pueden llevar al
     mismo empaquetado. Almacenar estos metadatos “silenciosos” en la
     salida puede potencialmente romper la propiedad de reproducibilidad
     bit a bit entre fuentes y binarios.

‘--root=FICHERO’
‘-r FICHERO’
     Hace que FICHERO sea un enlace simbólico al empaquetado resultante,
     y lo registra como una raíz del recolector de basura.

‘--localstatedir’
‘--profile-name=NOMBRE’
     Incluye el “directorio de estado local”, ‘/var/guix’, en el
     empaquetado resultante, y notablemente el perfil
     ‘/var/guix/profiles/per-user/root/NOMBRE’—por defecto NOMBRE es
     ‘guix-profile’, que corresponde con ‘~root/.guix-profile’.

     ‘/var/guix’ contiene la base de datos del almacén (*note El
     almacén::) así como las raíces del recolector de basura (*note
     Invocación de guix gc::). Proporcionarlo junto al empaquetado
     significa que el almacén está “completo” y Guix puede trabajar con
     él; no proporcionarlo significa que el almacén está “muerto”: no se
     pueden añadir o borrar nuevos elementos después de la extracción
     del empaquetado.

     Un caso de uso para esto es el archivador tar autocontenido de
     binarios de Guix (*note Instalación binaria::).

‘--derivation’
‘-d’
     Imprime el nombre de la derivación que construye el empaquetado.

‘--bootstrap’
     Usa los binarios del lanzamiento para construir el empaquetado.
     Esta opción es útil únicamente a las desarrolladoras de Guix.

   Además, ‘guix pack’ acepta todas las opciones comunes de construcción
(*note Opciones comunes de construcción::) y todas las opciones de
transformación de paquetes (*note Opciones de transformación de
paquetes::).

   ---------- Footnotes ----------

   (1) Here’s a trick to memorize it: ‘-RR’, which adds PRoot support,
can be thought of as the abbreviation of “Really Relocatable”. Neat,
isn’t it?


File: guix.es.info,  Node: La cadena de herramientas de GCC,  Prev: Invocación de guix pack,  Up: Desarrollo

5.3 La cadena de herramientas de GCC
====================================

If you need a complete toolchain for compiling and linking C or C++
source code, use the ‘gcc-toolchain’ package. This package provides a
complete GCC toolchain for C/C++ development, including GCC itself, the
GNU C Library (headers and binaries, plus debugging symbols in the
‘debug’ output), Binutils, and a linker wrapper.

   The wrapper’s purpose is to inspect the ‘-L’ and ‘-l’ switches passed
to the linker, add corresponding ‘-rpath’ arguments, and invoke the
actual linker with this new set of arguments. You can instruct the
wrapper to refuse to link against libraries not in the store by setting
the ‘GUIX_LD_WRAPPER_ALLOW_IMPURITIES’ environment variable to ‘no’.

   The package ‘gfortran-toolchain’ provides a complete GCC toolchain
for Fortran development. For other languages, please use ‘guix search
gcc toolchain’ (*note Invoking guix package: guix-search.).


File: guix.es.info,  Node: Interfaz programática,  Next: Utilidades,  Prev: Desarrollo,  Up: Top

6 Interfaz programática
***********************

GNU Guix proporciona viarias interfaces programáticas Scheme (APIs) para
definir, construir y consultar paquetes. La primera interfaz permite a
las usuarias escribir definiciones de paquetes a alto nivel. Estas
definiciones referencian conceptos familiares de empaquetamiento, como
el nombre y la versión de un paquete, su sistema de construcción y sus
dependencias. Estas definiciones se pueden convertir en acciones
concretas de construcción.

   Las acciones de construcción son realizadas por el daemon Guix, en
delegación de las usuarias. En una configuración estándar, el daemon
tiene acceso de escritura al almacén—el directorio ‘/gnu/store’—mientras
que las usuarias no. En la configuración recomendada el daemon también
realiza las construcciones en chroots, bajo usuarias específicas de
construcción, para minimizar la interferencia con el resto del sistema.

   Las APIs de nivel más bajo están disponibles para interactuar con el
daemon y el almacén. Para instruir al daemon para realizar una acción de
construcción, las usuarias realmente proporcionan una “derivación”. Una
derivación es una representación de bajo nivel de las acciones de
construcción a tomar, y el entorno en el que deberían suceder—las
derivaciones son a las definiciones de paquetes lo que es el ensamblador
a los programas en C. El término “derivación” viene del hecho de que los
resultados de la construcción _derivan_ de ellas.

   Este capítulo describe todas estas APIs en orden, empezando por las
definiciones de alto nivel de paquetes.

* Menu:

* Módulos de paquetes::     Paquetes bajo el punto de vista del
                               programador.
* Definición de paquetes::  Definir nuevos paquetes.
* Sistemas de construcción::  Especificar como se construyen los paquetes.
* El almacén::              Manipular el almacén de paquetes.
* Derivaciones::             Interfaz de bajo nivel de las derivaciones de
                               los paquetes.
* La mónada del almacén::  Interfaz puramente funcional del almacén.
* Expresiones-G::            Manipular expresiones de construcción.
* Invocación de guix repl::  Enredar con Guix interactivamente.


File: guix.es.info,  Node: Módulos de paquetes,  Next: Definición de paquetes,  Up: Interfaz programática

6.1 Módulos de paquetes
=======================

Desde un punto de vista programático, las definiciones de paquetes de la
distribución GNU se proporcionan por módulos Guile en el espacio de
nombres ‘(gnu packages ...)’(1) (*note Guile modules: (guile)Módulos.).
Por ejemplo, el módulo ‘(gnu packages emacs)’ exporta una variable con
nombre ‘emacs’, que está asociada a un objeto ‘<package>’ (*note
Definición de paquetes::).

   El espacio de nombres de módulos ‘(gnu packages ...)’ se recorre
automáticamente en busca de paquetes en las herramientas de línea de
ordenes. Por ejemplo, cuando se ejecuta ‘guix install emacs’, todos los
módulos ‘(gnu packages ...)’ son procesados hasta encontrar uno que
exporte un objeto de paquete cuyo nombre sea ‘emacs’. Esta búsqueda de
paquetes se implementa en el módulo ‘(gnu packages)’.

   Users can store package definitions in modules with different
names—e.g., ‘(my-packages emacs)’(2). There are two ways to make these
package definitions visible to the user interfaces:

  1. By adding the directory containing your package modules to the
     search path with the ‘-L’ flag of ‘guix package’ and other commands
     (*note Opciones comunes de construcción::), or by setting the
     ‘GUIX_PACKAGE_PATH’ environment variable described below.

  2. Mediante la definición de un “canal” y la configuración de ‘guix
     pull’ de manera que se actualice desde él. Un canal es
     esencialmente un repositorio Git que contiene módulos de paquetes.
     *Note Canales::, para más información sobre cómo definir y usar
     canales.

   ‘GUIX_PACKAGE_PATH’ works similarly to other search path variables:

 -- Variable de entorno: GUIX_PACKAGE_PATH
     Es una lista separada por dos puntos de directorios en los que se
     buscarán módulos de paquetes adicionales. Los directorios
     enumerados en esta variable tienen preferencia sobre los propios
     módulos de la distribución.

   La distribución es “auto-contenida” y completamente “basada en el
lanzamiento inicial”: cada paquete se construye basado únicamente en
otros paquetes de la distribución. La raíz de este grafo de dependencias
es un pequeño conjunto de “binarios del lanzamiento inicial”,
proporcionados por el módulo ‘(gnu packages bootstrap)’. Para más
información sobre el lanzamiento inicial, *note Lanzamiento inicial::.

   ---------- Footnotes ----------

   (1) Fíjese que los paquetes bajo el espacio de nombres de módulo
‘(gnu packages ...)’ no son necesariamente “paquetes GNU”. Este esquema
de nombrado de módulos sigue la convención habitual de Guile para el
nombrado de módulos: ‘gnu’ significa que estos módulos se distribuyen
como parte del sistema GNU, y ‘packages’ identifica módulos que definen
paquetes.

   (2) Note that the file name and module name must match. For instance,
the ‘(my-packages emacs)’ module must be stored in a
‘my-packages/emacs.scm’ file relative to the load path specified with
‘--load-path’ or ‘GUIX_PACKAGE_PATH’. *Note (guile)Modules and the File
System::, for details.


File: guix.es.info,  Node: Definición de paquetes,  Next: Sistemas de construcción,  Prev: Módulos de paquetes,  Up: Interfaz programática

6.2 Definición de paquetes
==========================

La interfaz de alto nivel de las definiciones de paquetes está
implementada en los módulos ‘(guix packages)’ y ‘(guix build-system)’.
Como un ejemplo, la definición de paquete, o “receta”, para el paquete
GNU Hello es como sigue:

     (define-module (gnu packages hello)
       #:use-module (guix packages)
       #:use-module (guix download)
       #:use-module (guix build-system gnu)
       #:use-module (guix licenses)
       #:use-module (gnu packages gawk))

     (define-public hello
       (package
         (name "hello")
         (version "2.10")
         (source (origin
                   (method url-fetch)
                   (uri (string-append "mirror://gnu/hello/hello-" version
                                       ".tar.gz"))
                   (sha256
                    (base32
                     "0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i"))))
         (build-system gnu-build-system)
         (arguments '(#:configure-flags '("--enable-silent-rules")))
         (inputs `(("gawk" ,gawk)))
         (synopsis "Hello, GNU world: An example GNU package")
         (description "Guess what GNU Hello prints!")
         (home-page "https://www.gnu.org/software/hello/")
         (license gpl3+)))

Sin ser una experta en Scheme—pero conociendo un poco de inglés—, la
lectora puede haber supuesto el significado de varios campos aquí. Esta
expresión asocia la variable ‘hello’ al objeto ‘<package>’, que
esencialmente es un registro (*note Scheme records: (guile)SRFI-9.).
Este objeto de paquete puede ser inspeccionado usando los procedimientos
encontrados en el módulo ‘(guix packages)’; por ejemplo, ‘(package-name
hello)’ devuelve—¡sorpresa!—‘"hello"’.

   Con suerte, puede que sea capaz de importar parte o toda la
definición del paquete de su interés de otro repositorio, usando la
orden ‘guix import’ (*note Invocación de guix import::).

   En el ejemplo previo, HELLO se define en un módulo para ella, ‘(gnu
packages hello)’. Técnicamente, esto no es estrictamente necesario, pero
es conveniente hacerlo: todos los paquetes definidos en módulos bajo
‘(gnu packages ...)’ se reconocen automáticamente en las herramientas de
línea de órdenes (*note Módulos de paquetes::).

   Hay unos pocos puntos que merece la pena destacar de la definición de
paquete previa:

   • El campo ‘source’ del paquete es un objeto ‘<origin>’ (*note
     Referencia de origin::, para la referencia completa). Aquí se usa
     el método ‘url-fetch’ de ‘(guix download)’, lo que significa que la
     fuente es un fichero a descargar por FTP o HTTP.

     El prefijo ‘mirror://gnu’ instruye a ‘url-fetch’ para usar uno de
     los espejos GNU definidos en ‘(guix download)’.

     El campo ‘sha256’ especifica el hash SHA256 esperado del fichero
     descargado. Es obligatorio, y permite a Guix comprobar la
     integridad del fichero. La forma ‘(base32 ...)’ introduce la
     representación base32 del hash. Puede obtener esta información con
     ‘guix download’ (*note Invocación de guix download::) y ‘guix hash’
     (*note Invocación de guix hash::).

     Cuando sea necesario, la forma ‘origin’ también puede tener un
     campo ‘patches’ con la lista de parches a ser aplicados, y un campo
     ‘snippet’ con una expresión Scheme para modificar el código fuente.

   • El campo ‘build-system’ especifica el procedimiento de construcción
     del paquete (*note Sistemas de construcción::). Aquí,
     GNU-BUILD-SYSTEM representa el familiar sistema de construcción
     GNU, donde los paquetes pueden configurarse, construirse e
     instalarse con la secuencia de ordenes habitual ‘./configure &&
     make && make check && make install’.

   • The ‘arguments’ field specifies options for the build system (*note
     Sistemas de construcción::). Here it is interpreted by
     GNU-BUILD-SYSTEM as a request run ‘configure’ with the
     ‘--enable-silent-rules’ flag.

     ¿Qué son estas comillas simples (‘'’)? Son sintaxis Scheme para
     introducir una lista literal; ‘'’ es sinónimo de ‘quote’. *Note
     quoting: (guile)Expression Syntax, para más detalles. Aquí el valor
     del campo ‘arguments’ es una lista de parámetros pasada al sistema
     de construcción, como con ‘apply’ (*note ‘apply’: (guile)Fly
     Evaluation.).

     La secuencia almohadilla-dos puntos (‘#:’) define una “palabra
     clave” Scheme (*note (guile)Keywords::), y ‘#:configure-flags’ es
     una palabra clave usada para pasar un parámetro nominal al sistema
     de construcción (*note (guile)Coding With Keywords::).

   • El campo ‘inputs’ especifica las entradas al proceso de
     construcción—es decir, dependencias de tiempo de construcción o
     ejecución del paquete. Aquí, definimos una entrada llamada
     ‘"gawk"’, cuyo valor es el de la variable GAWK; GAWK en sí apunta a
     un objeto ‘<package>’.

     De nuevo, ‘`’ (un acento grave, sinónimo de ‘quasiquote’) nos
     permite introducir una lista literal en el campo ‘inputs’, mientras
     que ‘,’ (una coma, sinónimo de ‘unquote’) nos permite insertar un
     valor en dicha lista (*note unquote: (guile)Expression Syntax.).

     Fíjese que no hace falta que GCC, Coreutils, Bash y otras
     herramientas esenciales se especifiquen como entradas aquí. En vez
     de eso, GNU-BUILD-SYSTEM se hace cargo de asegurar que están
     presentes (*note Sistemas de construcción::).

     No obstante, cualquier otra dependencia debe ser especificada en el
     campo ‘inputs’. Las dependencias no especificadas aquí simplemente
     no estarán disponibles para el proceso de construcción, provocando
     posiblemente un fallo de construcción.

   *Note Referencia de package::, para una descripción completa de los
campos posibles.

   Una vez la definición de paquete esté en su lugar, el paquete puede
ser construido realmente usando la herramienta de línea de órdenes ‘guix
build’ (*note Invocación de guix build::), pudiendo resolver cualquier
fallo de construcción que encuentre (*note Depuración de fallos de
construcción::). Puede volver a la definición del paquete fácilmente
usando la orden ‘guix edit’ (*note Invocación de guix edit::). *Note
Guías de empaquetamiento::, para más información sobre cómo probar
definiciones de paquetes, y *note Invocación de guix lint::, para
información sobre cómo comprobar la consistencia del estilo de una
definición. Por último, *note Canales::, para información sobre cómo
extender la distribución añadiendo sus propias definiciones de paquetes
en un “canal”.

   Finalmente, la actualización de la definición con una nueva versión
oficial puede ser automatizada parcialmente por la orden ‘guix refresh’
(*note Invocación de guix refresh::).

   Behind the scenes, a derivation corresponding to the ‘<package>’
object is first computed by the ‘package-derivation’ procedure. That
derivation is stored in a ‘.drv’ file under ‘/gnu/store’. The build
actions it prescribes may then be realized by using the
‘build-derivations’ procedure (*note El almacén::).

 -- Procedimiento Scheme: package-derivation ALMACÉN PAQUETE [SISTEMA]
     Devuelve el objeto ‘<derivation>’ del PAQUETE pra el SISTEMA (*note
     Derivaciones::).

     PAQUETE debe ser un objeto ‘<package>’ válido, y SISTEMA debe ser
     una cadena que denote el tipo de sistema objetivo—por ejemplo,
     ‘"x86_64-linux"’ para un sistema GNU x86_64 basado en Linux.
     ALMACÉN debe ser una conexión al daemon, que opera en el almacén
     (*note El almacén::).

De manera similar, es posible calcular una derivación que construye de
forma cruzada un paquete para otro sistema:

 -- Procedimiento Scheme: package-cross-derivation ALMACÉN PAQUETE
          PLATAFORMA [SISTEMA]
     Devuelve el objeto ‘<derivation>’ de PAQUETE compilado de forma
     cruzada desde SISTEMA a PLATAFORMA.

     TARGET must be a valid GNU triplet denoting the target hardware and
     operating system, such as ‘"aarch64-linux-gnu"’ (*note
     (autoconf)Specifying Target Triplets::).

   Los paquetes se pueden manipular de forma arbitraria. Un ejemplo de
transformación útil es la “reescritura de entradas”, donde el árbol de
dependencias de un paquete se reescribe reemplazando entradas
específicas por otras:

 -- Procedimiento Scheme: package-input-rewriting REEMPLAZOS
          [NOMBRE-REESCRITO]
     Devuelve un procedimiento que, cuando se le pasa un paquete,
     reemplaza sus dependencias directas e indirectas (pero no sus
     entradas implícitas) de acuerdo a REEMPLAZOS. REEMPLAZOS es una
     lista de pares de paquetes; el primer elemento de cada par es el
     paquete a reemplazar, el segundo es el reemplazo.

     Opcionalmente, NOMBRE-REESCRITO es un procedimiento de un parámetro
     que toma el nombre del paquete y devuelve su nuevo nombre tras la
     reescritura.

Considere este ejemplo:

     (define libressl-en-vez-de-openssl
       ;; Esto es un procedimiento para reemplazar OPENSSL
       ;; por LIBRESSL, recursivamente.
       (package-input-rewriting `((,openssl . ,libressl))))

     (define git-con-libressl
       (libressl-en-vez-de-openssl git))

Aquí primero definimos un procedimiento de reescritura que substituye
OPENSSL por LIBRESSL. Una vez hecho esto, lo usamos para definir una
“variante” del paquete GIT que usa LIBRESSL en vez de OPENSSL. Esto es
exactamente lo que hace la opción de línea de órdenes ‘--with-input’
(*note ‘--with-input’: Opciones de transformación de paquetes.).

   La siguiente variante de ‘package-input-rewriting’ puede encontrar
paquetes a reemplazar por su nombre en vez de por su identidad.

 -- Procedimiento Scheme: package-input-rewriting/spec REEMPLAZOS
     Devuelve un procedimiento que, proporcionado un paquete, realiza
     los REEMPLAZOS proporcionados sobre todo el grafo del paquete
     (excluyendo las entradas implícitas). REEMPLAZOS es una lista de
     pares de especificación y procedimiento; cada especificación es una
     especificación de paquete como ‘"gcc"’ o ‘"guile@2"’, y cada
     procedimiento toma un paquete que corresponda con la especificación
     y devuelve un reemplazo para dicho paquete.

   El ejemplo previo podría ser reescrito de esta forma:

     (define libressl-en-vez-de-openssl
       ;; Reemplaza todos los paquetes llamados "openssl" con LibreSSL.
       (package-input-rewriting/spec `(("openssl" . ,(const libressl)))))

   La diferencia principal en este caso es que, esta vez, los paquetes
se buscan por su especificación y no por su identidad. En otras
palabras, cualquier paquete en el grafo que se llame ‘openssl’ será
reemplazado.

   Un procedimiento más genérico para reescribir el grafo de
dependencias de un paquete es ‘package-mapping’: acepta cambios
arbitrarios sobre nodos del grafo.

 -- Scheme Procedure: package-mapping PROC [CORTAR?]
     Devuelve un procedimiento que, dado un paquete, aplica PROC a todos
     los paquetes de los que depende y devuelve el paquete resultante.
     El procedimiento para la recursión cuando CORTAR? devuelve
     verdadero para un paquete dado.

* Menu:

* Referencia de package::    El tipo de datos de los paquetes.
* Referencia de origin::     El tipo de datos de orígenes.


File: guix.es.info,  Node: Referencia de package,  Next: Referencia de origin,  Up: Definición de paquetes

6.2.1 Referencia de ‘package’
-----------------------------

Esta sección resume todas las opciones disponibles en declaraciones
‘package’ (*note Definición de paquetes::).

 -- Tipo de datos: package
     Este es el tipo de datos que representa la receta de un paquete.

     ‘name’
          El nombre del paquete, como una cadena.

     ‘version’
          La versión del paquete, como una cadena.

     ‘source’
          Un objeto que determina cómo se debería obtener el código
          fuente del paquete. La mayor parte del tiempo, es un objeto
          ‘origin’, que denota un fichero obtenido de Internet (*note
          Referencia de origin::). También puede ser cualquier otro
          objeto “tipo-fichero” como ‘local-file’, que denota un fichero
          del sistema local de ficheros (*note ‘local-file’:
          Expresiones-G.).

     ‘build-system’
          El sistema de construcción que debe ser usado para construir
          el paquete (*note Sistemas de construcción::).

     ‘arguments’ (predeterminados: ‘'()’)
          Los parámetros que deben ser pasados al sistema de
          construcción. Es una lista que normalmente contiene una
          secuencia de pares de palabra clave y valor.

     ‘inputs’ (predeterminadas: ‘'()’)
     ‘native-inputs’ (predeterminadas: ‘'()’)
     ‘propagated-inputs’ (predeterminadas: ‘'()’)
          Estos campos enumeran las dependencias del paquete. Cada uno
          es una lista de tuplas, donde cada tupla tiene una etiqueta
          para la entrada (una cadena) como su primer elemento, un
          paquete, origen o derivación como su segundo elemento, y
          opcionalmente el nombre de la salida que debe ser usada, cuyo
          valor predeterminado es ‘"out"’ (*note Paquetes con múltiples
          salidas::, para más información sobre salidas de paquetes).
          Por ejemplo, la lista siguiente especifica tres entradas:

               `(("libffi" ,libffi)
                 ("libunistring" ,libunistring)
                 ("glib:bin" ,glib "bin"))  ;la salida "bin" de Glib

          La distinción entre ‘native-inputs’ y ‘inputs’ es necesaria
          cuando se considera la compilación cruzada. Cuando se compila
          desde una arquitectura distinta, las dependencias enumeradas
          en ‘inputs’ son construidas para la arquitectura _objetivo_;
          de modo contrario, las dependencias enumeradas en
          ‘native-inputs’ se construyen para la arquitectura de la
          máquina de _construcción_.

          ‘native-inputs’ se usa típicamente para enumerar herramientas
          necesarias en tiempo de construcción, pero no en tiempo de
          ejecución, como Autoconf, Automake, pkg-config, Gettext o
          Bison. ‘guix lint’ puede informar de probables errores en este
          área (*note Invocación de guix lint::).

          Lastly, ‘propagated-inputs’ is similar to ‘inputs’, but the
          specified packages will be automatically installed alongside
          the package they belong to (*note ‘guix package’:
          package-cmd-propagated-inputs, for information on how ‘guix
          package’ deals with propagated inputs).

          Por ejemplo esto es necesario cuando una biblioteca C/C++
          necesita cabeceras de otra biblioteca para compilar, o cuando
          un fichero pkg-config se refiere a otro via su campo
          ‘Requires’.

          Otro ejemplo donde ‘propagated-inputs’ es útil es en lenguajes
          que carecen de la facilidad de almacenar la ruta de búsqueda
          de tiempo de ejecución de la misma manera que el campo
          ‘RUNPATH’ de los ficheros ELF; esto incluye Guile, Python,
          Perl y más. Para asegurarse que las bibliotecas escritas en
          esos lenguajes puedan encontrar en tiempo de ejecución el
          código de las bibliotecas de las que dependen, las
          dependencias de tiempo de ejecución deben enumerarse en
          ‘propagated-inputs’ en vez de en ‘inputs’.

     ‘outputs’ (predeterminada: ‘'("out")’)
          La lista de nombres de salidas del paquete. *Note Paquetes con
          múltiples salidas::, para usos típicos de salidas adicionales.

     ‘native-search-paths’ (predeterminadas: ‘'()’)
     ‘search-paths’ (predeterminadas: ‘'()’)
          Una lista de objetos ‘search-path-specification’ describiendo
          las variables de entorno de rutas de búsqueda respetadas por
          el paquete.

     ‘replacement’ (predeterminado: ‘1.0’)
          Esto debe ser o bien ‘#f’ o bien un objeto package que será
          usado como “reemplazo” para ete paquete. *Note injertos:
          Actualizaciones de seguridad, para más detalles.

     ‘synopsis’
          Una descripción en una línea del paquete.

     ‘description’
          Una descripción más elaborada del paquete.

     ‘license’
          La licencia del paquete; un valor de ‘(guix licenses)’, o una
          lista de dichos valores.

     ‘home-page’
          La URL de la página principal del paquete, como una cadena.

     ‘supported-systems’ (default: ‘%supported-systems’)
          La lista de sistemas en los que se mantiene el paquete, como
          cadenas de la forma ‘arquitectura-núcleo’, por ejemplo
          ‘"x86_64-linux"’.

     ‘location’ (predeterminada: la localización de los fuentes de la forma ‘package’)
          La localización de las fuentes del paquete. Es útil forzar su
          valor cuando se hereda de otro paquete, en cuyo caso este
          campo no se corrige automáticamente.

 -- Sintaxis Scheme: this-package
     Cuando se usa en el _ámbito léxico_ de la definición de un paquete,
     este identificador resuelve al paquete que se está definiendo.

     El ejemplo previo muestra cómo añadir un paquete como su propia
     entrada nativa cuando se compila de forma cruzada:

          (package
            (name "guile")
            ;; ...

            ;; Cuando se compila de forma cruzada, Guile, por ejemplo
            ;; depende de una versión nativa de sí mismo. Añadirla aquí.
            (native-inputs (if (%current-target-system)
                               `(("self" ,this-package))
                               '())))

     Es un error hacer referencia a ‘this-package’ fuera de la
     definición de un paquete.


File: guix.es.info,  Node: Referencia de origin,  Prev: Referencia de package,  Up: Definición de paquetes

6.2.2 Referencia de ‘origin’
----------------------------

Esta sección resume todas las opciones disponibles en declaraciones
‘origin’ (*note Definición de paquetes::).

 -- Tipo de datos: origin
     Este es el tipo de datos que representa un origen de código fuente.

     ‘uri’
          Un objeto que contiene el URI de las fuentes. El tipo de
          objeto depende del valor de ‘method’ (véase a continuación).
          Por ejemplo, cuando se usa el método URL-FETCH de ‘(guix
          download)’, los valores adecuados para ‘uri’ son: una cadena
          que contiene una URL, o una lista de cadenas.

     ‘method’
          Un procedimiento que maneja el URI.

          Algunos ejemplos son:

          URL-FETCH de ‘(guix download)’
               descarga un fichero de la URL HTTP, HTTPS o FTP
               especificada en el campo ‘uri’;

          GIT-FETCH de ‘(guix git-download)’
               clona el repositorio de control de versiones Git, y
               prepara la revisión especificada en el campo ‘uri’ como
               un objeto ‘git-reference’; una referencia ‘git-reference’
               tiene esta forma:

                    (git-reference
                      (url "https://git.savannah.gnu.org/git/hello.git")
                      (commit "v2.10"))

     ‘sha256’
          A bytevector containing the SHA-256 hash of the source. This
          is equivalent to providing a ‘content-hash’ SHA256 object in
          the ‘hash’ field described below.

     ‘hash’
          The ‘content-hash’ object of the source—see below for how to
          use ‘content-hash’.

          Puede obtener esta información usando ‘guix download’ (*note
          Invocación de guix download::) o ‘guix hash’ (*note Invocación
          de guix hash::).

     ‘file-name’ (predeterminado: ‘#f’)
          El nombre de fichero bajo el que el código fuente se
          almacenará. Cuando este es ‘#f’, un valor predeterminado
          sensato se usará en la mayor parte de casos. En caso de que
          las fuentes se obtengan de una URL, el nombre de fichero de la
          URL se usará. Para copias de trabajo de sistemas de control de
          versiones, se recomienda proporcionar el nombre de fichero
          explícitamente ya que el predeterminado no es muy descriptivo.

     ‘patches’ (predeterminados: ‘'()’)
          Una lista de nombres de ficheros, orígenes u objetos
          tipo-fichero (*note objetos “tipo-fichero”: Expresiones-G.)
          apuntando a parches que deben ser aplicados a las fuentes.

          La lista de parches debe ser incondicional. En particular, no
          puede depender del valor de ‘%current-system’ o
          ‘%current-target-system’.

     ‘snippet’ (predeterminado: ‘#f’)
          Una expresión-G (*note Expresiones-G::) o expresión-S que se
          ejecutará en el directorio de fuentes. Esta es una forma
          conveniente de modificar el software, a veces más que un
          parche.

     ‘patch-flags’ (predeterminadas: ‘'("-p1")’)
          Una lista de opciones de línea de órdenes que deberían ser
          pasadas a la orden ‘patch’.

     ‘patch-inputs’ (predeterminada: ‘#f’)
          Paquetes o derivaciones de entrada al proceso de aplicación de
          los parches. Cuando es ‘#f’, se proporciona el conjunto
          habitual de entradas necesarias para la aplicación de parches,
          como GNU Patch.

     ‘modules’ (predeterminados: ‘'()’)
          Una lista de módulos Guile que debe ser cargada durante el
          proceso de aplicación de parches y mientras se ejecuta el
          código del campo ‘snippet’.

     ‘patch-guile’ (predeterminado: ‘#f’)
          El paquete Guile que debe ser usado durante la aplicación de
          parches. Cuando es ‘#f’ se usa un valor predeterminado.

 -- Data Type: content-hash VALUE [ALGORITHM]
     Construct a content hash object for the given ALGORITHM, and with
     VALUE as its hash value. When ALGORITHM is omitted, assume it is
     ‘sha256’.

     VALUE can be a literal string, in which case it is base32-decoded,
     or it can be a bytevector.

     The following forms are all equivalent:

          (content-hash "05zxkyz9bv3j9h0xyid1rhvh3klhsmrpkf3bcs6frvlgyr2gwilj")
          (content-hash "05zxkyz9bv3j9h0xyid1rhvh3klhsmrpkf3bcs6frvlgyr2gwilj"
                        sha256)
          (content-hash (base32
                         "05zxkyz9bv3j9h0xyid1rhvh3klhsmrpkf3bcs6frvlgyr2gwilj"))
          (content-hash (base64 "kkb+RPaP7uyMZmu4eXPVkM4BN8yhRd8BTHLslb6f/Rc=")
                        sha256)

     Technically, ‘content-hash’ is currently implemented as a macro. It
     performs sanity checks at macro-expansion time, when possible, such
     as ensuring that VALUE has the right size for ALGORITHM.


File: guix.es.info,  Node: Sistemas de construcción,  Next: El almacén,  Prev: Definición de paquetes,  Up: Interfaz programática

6.3 Sistemas de construcción
============================

Cada definición de paquete especifica un “sistema de construcción” y
parámetros para dicho sistema de construcción (*note Definición de
paquetes::). Este campo ‘build-system’ representa el procedimiento de
construcción del paquete, así como las dependencias implícitas de dicho
procedimiento de construcción.

   Los sistemas de construcción son objetos ‘<build-system>’. La
interfaz para crear y manipularlos se proporciona en el módulo ‘(guix
build-system)’, y otros módulos exportan sistemas de construcción
reales.

   En su implementación, los sistemas de construcción primero compilan
los objetos package a objetos “bag”. Una bolsa (traducción de “bag”) es
como un paquete, pero con menos ornamentos—en otras palabras, una bolsa
es una representación a un nivel más bajo de un paquete, que contiene
todas las entradas de dicho paquete, incluyendo algunas implícitamente
añadidas por el sistema de construcción. Esta representación intermedia
se compila entonces a una derivación (*note Derivaciones::).

   Los sistemas de construcción aceptan una lista opcional de
“parámetros”. En las definiciones de paquete, estos son pasados vía el
campo ‘arguments’ (*note Definición de paquetes::). Normalmente son
parámetros con palabras clave (*note keyword arguments in Guile:
(guile)Optional Arguments.). El valor de estos parámetros normalmente se
evalúa en la “capa de construcción”—es decir, por un proceso Guile
lanzado por el daemon (*note Derivaciones::).

   El sistema de construcción principal es GNU-BUILD-SYSTEM, el cual
implementa el procedimiento estándar de construcción para GNU y muchos
otros paquetes. Se proporciona por el módulo ‘(guix build-system gnu)’.

 -- Variable Scheme: gnu-build-system
     GNU-BUILD-SYSTEM representa el sistema de construcción GNU y sus
     variantes (*note configuration and makefile conventions:
     (standards)Configuration.).

     En resumen, los paquetes que lo usan se configuran, construyen e
     instalan con la habitual secuencia de órdenes ‘./configure && make
     && make check && make install’. En la práctica, algunos pasos
     adicionales son necesarios habitualmente. Todos estos pasos se
     dividen en “fases” separadas, notablemente(1):

     ‘unpack’
          Extrae el archivador tar de la fuente, y cambia el directorio
          actual al directorio recién extraído. Si la fuente es
          realmente un directorio, lo copia al árbol de construcción y
          entra en ese directorio.

     ‘patch-source-shebangs’
          Sustituye secuencias “#!” encontradas al inicio de los
          ficheros de fuentes para que hagan referencia a los nombres
          correctos de ficheros del almacén. Por ejemplo, esto cambia
          ‘#!/bin/sh’ por ‘#!/gnu/store/...-bash-4.3/bin/sh’.

     ‘configure’
          Run the ‘configure’ script with a number of default options,
          such as ‘--prefix=/gnu/store/...’, as well as the options
          specified by the ‘#:configure-flags’ argument.

     ‘build’
          Ejecuta ‘make’ con la lista de opciones especificadas en
          ‘#:make-flags’. Si el parámetro ‘#:parallel-build?’ es
          verdadero (por defecto), construye con ‘make -j’.

     ‘check’
          Ejecuta ‘make check’, u otro objetivo especificado con
          ‘#:test-target’, a menos que se pasase ‘#:tests? #f’. Si el
          parámetro ‘#:parallel-tests?’ es verdadero (por defecto),
          ejecuta ‘make check -j’.

     ‘install’
          Ejecuta ‘make install’ con las opciones enumeradas en
          ‘#:make-flags’.

     ‘patch-shebangs’
          Sustituye las secuencias “#!” en los ficheros ejecutables
          instalados.

     ‘strip’
          Extrae los símbolos de depuración de ficheros ELF (a menos que
          el valor de ‘#:strip-binaries?’ sea falso), y los copia a la
          salida ‘debug’ cuando esté disponible (*note Instalación de
          ficheros de depuración::).

     El módulo del lado de construcción ‘(guix build gnu-build-system)’
     define %STANDARD-PHASES como la lista predeterminada de fases de
     construcción. %STANDARD-PHASES es una lista de pares
     símbolo/procedimiento, donde el procedimiento implementa realmente
     la fase.

     La lista de fases usadas para un paquete particular se puede
     cambiar con el parámetro ‘#:phases’. Por ejemplo, pasar:

          #:phases (modify-phases %standard-phases (delete 'configure))

     significa que todas las fases descritas anteriormente serán usadas,
     excepto la fase ‘configure’.

     Además, este sistema de construcción asegura que el entorno
     “estándar” para paquetes GNU está disponible. Esto incluye
     herramientas como GCC, libc, Coreutils, Bash, Make, Diffutils, grep
     y sed (vea el módulo ‘(guix build system gnu)’ para una lista
     completa). A estas las llamamos las “entradas implícitas” de un
     paquete, porque las definiciones de paquete no las mencionan.

   Hay definidos otros objetos ‘<build-system>’ para implementar otras
convenciones y herramientas usadas por paquetes de software libre.
Heredan la mayor parte de GNU-BUILD-SYSTEM, y se diferencian
principalmente en el conjunto de entradas implícitamente añadidas al
proceso de construcción, y en la lista de fases ejecutadas. Algunos de
estos sistemas de construcción se enumeran a continuación.

 -- Variable Scheme: ant-build-system
     ‘(guix build-system ant)’ exporta esta variable. Implementa el
     procedimiento de construcción de paquetes Java que pueden
     construirse con la herramienta de construcción Ant
     (https://ant.apache.org/).

     Añade tanto ‘ant’ como el “kit de desarrollo Java” (JDK), que
     proporciona el paquete ‘icedtea’, al conjunto de entradas. Se
     pueden especificar paquetes diferentes con los parámetros ‘#:ant’ y
     ‘#:jdk’, respectivamente.

     Cuando el paquete original no proporciona un fichero Ant apropiado,
     el parámetro ‘#:jar-name’ puede usarse para generar un fichero de
     construcción Ant ‘build.xml’ mínimo con tareas para construir el
     archivo jar especificado. En este caso, el parámetro ‘#:source-dir’
     se puede usar para especificar el subdirectorio de fuentes, con
     “src” como valor predeterminado.

     El parámetro ‘#:main-class’ puede usarse con el fichero de
     construcción Ant mínimo para especificar la clase main del archivo
     jar producido. Esto permite ejecutar el archivo jar. El parámetro
     ‘#:test-include’ puede usarse para especificar la lista de tests
     junit a ejecutar. El valor predeterminado es ‘(list
     "**/*Test.java")’. ‘#:test-exclude’ puede usarse para desactivar
     algunas pruebas. Su valor predeterminado es ‘(list
     "**/Abstract*.java")’ ya que las clases abstractas no se pueden
     ejecutar como pruebas.

     El parámetro ‘#:build-target’ se puede usar para especificar la
     tarea Ant que debe ser ejecutada durante la fase ‘build’. Por
     defecto se ejecuta la tarea “jar”.

 -- Variable Scheme: android-ndk-build-system
     Esta variable es exportada por ‘(guix build-system android-ndk)’.
     Implementa un procedimiento de construcción para paquetes Android
     NDK (kit de desarrollo nativo) usando un proceso de construcción
     específico de Guix.

     The build system assumes that packages install their public
     interface (header) files to the subdirectory ‘include’ of the ‘out’
     output and their libraries to the subdirectory ‘lib’ the ‘out’
     output.

     También se asume que la unión de todas las dependencias de un
     paquete no tiene ficheros en conflicto.

     En este momento no funciona la compilación cruzada - por lo que las
     bibliotecas y los ficheros de cabecera se asumen que son locales.

 -- Variable Scheme: asdf-build-system/source
 -- Variable Scheme: asdf-build-system/sbcl
 -- Variable Scheme: asdf-build-system/ecl

     Estas variables, exportadas por ‘(guix build-system asdf)’,
     implementan procedimientos de construcción para paquetes Common
     Lisp usando “ASDF”’ (https://common-lisp.net/project/asdf). ASDF es
     una utilidad de definición de sistema para programas y bibliotecas
     Common Lisp.

     El sistema ‘asdf-build-system/source’ instala los paquetes en forma
     de fuentes, y puede ser cargado usando cualquier implementación
     common lisp, vía ASDF. Los otros, como ‘asdf-build-system/sbcl’,
     instalan sistemas binarios en el formato entendido por una
     implementación particular. Estos sistemas de construcción también
     pueden usarse para producir programas ejecutables, o imágenes lisp
     que contengan un conjunto precargado de paquetes.

     El sistema de construcción usa convenciones de nombres. Para
     paquetes binarios, el paquete debería estar prefijado con la
     implementación lisp, como ‘sbcl-’ para ‘asdf-build-system/sbcl’.

     Adicionalmente, el paquete de fuentes correspondiente debe
     etiquetarse usando la misma convención que los paquetes python (vea
     *note Módulos Python::), usando el prefijo ‘cl-’.

     Para paquetes binarios, cada sistema debe definirse como un paquete
     Guix. Si el campo ‘origin’ de un paquete contiene varios sistemas,
     las variaciones del paquete pueden crearse para construir todos los
     sistemas. Los paquetes de fuentes, los cuales usan
     ‘asdf-build-system/source’, pueden contener varios sistemas.

     Para crear programa ejecutables e imágenes, se pueden usar los
     procedimientos del lado de construcción ‘build-program’ y
     ‘build-image’. Deben llamarse en la fase de construcción después de
     la fase ‘create-symlinks’, de modo que el sistema recién construido
     pueda ser usado dentro de la imagen resultante. ‘build-program’
     necesita una lista de expresiones Common Lisp a través del
     parámetro ‘#:entry-prgogram’.

     If the system is not defined within its own ‘.asd’ file of the same
     name, then the ‘#:asd-file’ parameter should be used to specify
     which file the system is defined in. Furthermore, if the package
     defines a system for its tests in a separate file, it will be
     loaded before the tests are run if it is specified by the
     ‘#:test-asd-file’ parameter. If it is not set, the files
     ‘<system>-tests.asd’, ‘<system>-test.asd’, ‘tests.asd’, and
     ‘test.asd’ will be tried if they exist.

     Si por alguna razón el paquete debe ser nombrado de una forma
     diferente a la sugerida por las convenciones de nombres, el
     parámetro ‘#:asd-system-name’ puede usarse para especificar el
     nombre del sistema.

 -- Variable Scheme: cargo-build-system
     Esta variable se exporta en ‘(guix build-system cargo)’. Permite la
     construcción de paquetes usando Cargo, la herramienta de
     construcción del lenguaje de programación Rust
     (https://www.rust-lang.org).

     Automáticamente añade ‘rustc’ y ‘cargo’ al conjunto de entradas. Se
     puede especificar el uso de un paquete Rust distinto con el
     parámetro ‘#:rust’.

     Las dependencias normales de cargo se añadirán a la definición del
     paquete a través del parámetro ‘#:cargo-inputs’ como una lista de
     pares de nombre y especificación, donde la especificación puede ser
     un paquete o una definición de fuentes ‘source’. Tenga en cuenta
     que la especificación debe evaluar a una ruta o a un archivo
     comprimido con gzip que incluya un fichero ‘Cargo.toml’ en su raíz,
     o será ignorado. De manera parecida, las dependencias de desarrollo
     de cargo deben añadirse a la definición del paquete a través del
     parámetro ‘#:cargo-development-inputs’.

     En su fase ‘configure’, este sistema de construcción hará que
     cualquier fuente de entrada especificada en los parámetros
     ‘#:cargo-inputs’ y ‘#:cargo-development-inputs’ esté disponible
     para cargo. También borrará cualquier fichero ‘Cargo.lock’ incluido
     para que sea recreado por ‘cargo’ durante la fase ‘build’ de
     construcción. La fase ‘install’ instala los binarios que el “crate”
     haya definido.

 -- Variable Scheme: copy-build-system
     Esta variable se exporta en ‘(guix build-system copy)’. Permite la
     construcción de paquetes simples que no necesitan mucha compilación
     y en su mayor parte dependen únicamente de la copia de ficheros en
     distintas rutas.

     Añade gran parte de los paquetes de ‘gnu-build-system’ al conjunto
     de entradas. Por esta razón, ‘copy-build-system’ no necesita toda
     la verborrea que habitualmente requiere ‘trivial-build-system’.

     Para simplificar más aún el proceso de instalación de ficheros, se
     expone un parámetro ‘#:install-plan’ para permitir a quien genera
     el paquete especificar dónde van los distintos ficheros. El plan de
     instalación (‘#:install-plan’) es una lista de ‘(FUENTE DESTINO
     [FILTRO])’. Los FILTROs son opcionales.

        • Cuando FUENTE corresponde con un fichero o un directorio sin
          la barra final, se instala en DESTINO.
             • Si DESTINO contiene una barra al final, FUENTE se instala
               con su nombre de fichero en la ruta DESTINO.
             • En otro caso se instala FUENTE como DESTINO.

        • Cuando FUENTE es un directorio terminado en una barra, o
          cuando se usa algún FILTRO, la barra al final de DESTINO tiene
          el significado que se describió anteriormente.
             • Sin FILTROS, instala todo el _contenido_ de FUENTE en
               DESTINO.
             • Cuando FILTRO contiene ‘#:include’, ‘#:include-regexp’,
               ‘#:exclude’, ‘#:exclude-regexp’, únicamente se
               seleccionan los ficheros instalados dependiendo de los
               filtros. Cada filtro se especifica como una lista de
               cadenas.
                  • Con ‘#:include’, se instalan todos los ficheros de
                    la ruta cuyo sufijo corresponda con al menos uno de
                    los elementos de la lista proporcionada.
                  • Con ‘#:include-regexp’ se instalan todos los
                    ficheros cuyas rutas relativas correspondan con al
                    menos una de las expresiones regulares en la lista
                    proporcionada.
                  • Los filtros ‘#:exclude’ y ‘#:exclude-regexp’ son
                    complementarios a sus equivalentes inclusivos. Sin
                    opciones ‘#:include’, se instalan todos los ficheros
                    excepto aquellos que correspondan con los filtros de
                    exclusión. Si se proporcionan tanto inclusiones como
                    exclusiones, las exclusiones tienen efecto sobre los
                    resultados de las inclusiones.
          En todos los casos, las rutas relativas a FUENTE se preservan
          dentro de DESTINO.

     Ejemplos:

        • ‘("foo/bar" "share/my-app/")’: Instala ‘bar’ en
          ‘share/my-app/bar’.
        • ‘("foo/bar" "share/my-app/baz")’: Instala ‘bar’ en
          ‘share/my-app/baz’.
        • ‘("foo/" "share/my-app")’: Instala el contenido de ‘foo’
          dentro de ‘share/my-app’, por ejemplo, instala ‘foo/sub/file’
          en ‘share/my-app/sub/file’.
        • ‘("foo/" "share/my-app" #:include ("sub/file"))’: Instala
          únicamente ‘foo/sub/file’ en ‘share/my-app/sub/file’.
        • ‘("foo/sub" "share/my-app" #:include ("file"))’: Instala
          ‘foo/sub/file’ en ‘share/my-app/file’.

 -- Variable Scheme: clojure-build-system
     Esta variable se exporta en ‘(guix build-system clojure)’.
     Implementa un procedimiento de construcción simple para paquetes
     Clojure (https://clojure.org/) usando directamente ‘compile’ en
     Clojure. La compilación cruzada no está disponible todavía.

     Añade ‘clojure’, ‘icedtea’ y ‘zip’ al conjunto de entradas. Se
     pueden especificar paquetes diferentes con los parámetros
     ‘#:clojure’, ‘#:jdk’ y ‘#:zip’, respectivamente.

     Una lista de directorios de fuentes, directorios de pruebas y
     nombres de jar pueden especificarse con los parámetros
     ‘#:source-dirs’, ‘#:test-dirs’ y ‘#:jar-names’, respectivamente. El
     directorio de compilación y la clase principal pueden especificarse
     con los parámetros ‘#:compile-dir’ y ‘#:main-class’,
     respectivamente. Otros parámetros se documentan más adelante.

     Este sistema de construcción es una extensión de ANT-BUILD-SYSTEM,
     pero con las siguientes fases cambiadas:

     ‘build’
          Esta fase llama ‘compile’ en Clojure para compilar los
          ficheros de fuentes y ejecuta ‘jar’ para crear archivadores
          jar tanto de ficheros de fuentes y compilados de acuerdo con
          las listas de inclusión y exclusión especificadas en
          ‘#:aot-include’ y ‘#:aot-exclude’, respectivamente. La lista
          de exclusión tiene prioridad sobre la de inclusión. Estas
          listas consisten en símbolos que representan bibliotecas
          Clojure o la palabra clave especial ‘#:all’ que representa
          todas las bibliotecas encontradas en los directorios de
          fuentes. El parámetro ‘#:omit-source?’ determina si las
          fuentes deben incluirse en los archivadores jar.

     ‘check’
          Esta fase ejecuta las pruebas de acuerdo a las listas de
          inclusión y exclusión especificadas en ‘#:test-include’ y
          ‘#:test-exclude’, respectivamente. Sus significados son
          análogos a los de ‘#:aot-include’ y ‘#:aot-exclude’, excepto
          que la palabra clave especial ‘#:all’ designa ahora a todas
          las bibliotecas Clojure encontradas en los directorios de
          pruebas. El parámetro ‘#:tests?’ determina si se deben
          ejecutar las pruebas.

     ‘install’
          Esta fase instala todos los archivadores jar construidos
          previamente.

     Además de las previas, este sistema de construcción contiene una
     fase adicional:

     ‘install-doc’
          Esta fase instala todos los ficheros de nivel superior con un
          nombre que corresponda con %DOC-REGEX. Una expresión regular
          diferente se puede especificar con el parámetro ‘#:doc-regex’.
          Todos los ficheros dentro (recursivamente) de los directorios
          de documentación especificados en ‘#:doc-dirs’ se instalan
          también.

 -- Variable Scheme: cmake-build-system
     Esta variable se exporta en ‘(guix build-system cmake)’. Implementa
     el procedimiento de construcción para paquetes que usen la
     herramienta de construcción CMake (https://www.cmake.org).

     Automáticamente añade el paquete ‘cmake’ al conjunto de entradas.
     El paquete usado se puede especificar con el parámetro ‘#:cmake’.

     El parámetro ‘#:configure-flags’ se toma como una lista de opciones
     a pasar a ‘cmake’. El parámetro ‘#:build-type’ especifica en
     términos abstractos las opciones pasadas al compilador; su valor
     predeterminado es ‘"RelWithDebInfo"’ (quiere decir “modo de entrega
     con información de depuración”), lo que aproximadamente significa
     que el código se compila con ‘-O2 -g’, lo cual es el caso
     predeterminado en paquetes basados en Autoconf.

 -- Variable Scheme: dune-build-system
     Esta variable se exporta en ‘(guix build-system dune)’. Permite la
     construcción de paquetes mediante el uso de Dune
     (https://dune.build/), una herramienta de construcción para el
     lenguaje de programación OCaml. Se implementa como una extensión de
     ‘ocaml-build-system’ que se describe a continuación. Como tal, se
     pueden proporcionar los parámetros ‘#:ocaml’ y ‘#:findlib’ a este
     sistema de construcción.

     Automáticamente añade el paquete ‘dune’ al conjunto de entradas. El
     paquete usado se puede especificar con el parámetro ‘#:dune’.

     No existe una fase ‘configure’ debido a que los paquetes dune no
     necesitan ser configurados típicamente. El parámetro
     ‘#:build-flags’ se toma como una lista de opciones proporcionadas a
     la orden ‘dune’ durante la construcción.

     El parámetro ‘#:jbuild?’ puede proporcionarse para usar la orden
     ‘jbuild’ en vez de la más reciente ‘dune’ durante la construcción
     de un paquete. Su valor predeterminado es ‘#f’.

     El parámetro ‘#:package’ puede proporcionarse para especificar un
     nombre de paquete, lo que resulta útil cuando un paquete contiene
     múltiples paquetes y únicamente quiere construir uno de ellos. Es
     equivalente a proporcionar el parámetro ‘-p’ a ‘dune’.

 -- Variable Scheme: go-build-system
     Esta variable se exporta en ‘(guix build-system go)’. Implementa el
     procedimiento de construcción para paquetes Go usando los
     mecanismos de construcción de Go
     (https://golang.org/cmd/go/#hdr-Compile_packages_and_dependencies)
     estándares.

     Se espera que la usuaria proporcione un valor para el parámetro
     ‘#:import-path’ y, en algunos caso, ‘#:unpack-path’. La ruta de
     importación (https://golang.org/doc/code.html#ImportPaths)
     corresponde a la ruta del sistema de ficheros esperada por los
     guiones de construcción del paquete y los paquetes a los que hace
     referencia, y proporciona una forma de hacer referencia a un
     paquete Go unívocamente. Está basado típicamente en una combinación
     de la URI remota del paquete de ficheros de fuente y la estructura
     jerárquica del sistema de ficheros. En algunos casos, necesitará
     desempaquetar el código fuente del paquete en una estructura de
     directorios diferente a la indicada en la ruta de importación, y
     ‘#:unpack-path’ debe usarse en dichos casos.

     Los paquetes que proporcionan bibliotecas Go deben instalar su
     código fuente en la salida de la construcción. El parámetro
     ‘#:install-source?’, cuyo valor por defecto es ‘#t’, controla si se
     instalará o no el código fuente. Puede proporcionarse ‘#f’ en
     paquetes que proporcionan únicamente ficheros ejecutables.

 -- Variable Scheme: glib-or-gtk-build-system
     Esta variable se exporta en ‘(guix build-system glib-or-gtk)’. Está
     pensada para usarse con paquetes que usan GLib o GTK+.

     Este sistema de construcción añade las dos fases siguientes a las
     definidas en GNU-BUILD-SYSTEM:

     ‘glib-or-gtk-wrap’
          The phase ‘glib-or-gtk-wrap’ ensures that programs in ‘bin/’
          are able to find GLib “schemas” and GTK+ modules
          (https://developer.gnome.org/gtk3/stable/gtk-running.html).
          This is achieved by wrapping the programs in launch scripts
          that appropriately set the ‘XDG_DATA_DIRS’ and ‘GTK_PATH’
          environment variables.

          Es posible excluir salidas específicas del paquete del proceso
          de recubrimiento enumerando sus nombres en el parámetro
          ‘#:glib-org-gtk-wrap-excluded-outputs’. Esto es útil cuando se
          sabe que una salida no contiene binarios GLib o GTK+, y cuando
          empaquetar gratuitamente añadiría una dependencia de dicha
          salida en GLib y GTK+.

     ‘glib-or-gtk-compile-schemas’
          La fase ‘glib-or-gtk-compile-schemas’ se asegura que todos los
          esquemas GSettings
          (https://developer.gnome.org/gio/stable/glib-compile-schemas.html)
          o GLib se compilan. La compilación la realiza el programa
          ‘glib-compile-schemas’. Lo proporciona el paquete ‘glib:bin’
          que se importa automáticamente por el sistema de construcción.
          El paquete ‘glib’ que proporciona ‘glib-compile-schemas’ puede
          especificarse con el parámetro ‘#:glib’.

     Ambas fases se ejecutan tras la fase ‘install’.

 -- Variable Scheme: guile-build-system
     Este sistema de construcción es para paquetes Guile que consisten
     exclusivamente en código Scheme y son tan simples que no tienen ni
     siquiera un fichero Makefile, menos un guión ‘configure’. Compila
     código Scheme usando ‘guild compile’ (*note (guile)Compilation::) e
     instala los ficheros ‘.scm’ y ‘.go’ en el lugar correcto. También
     instala documentación.

     This build system supports cross-compilation by using the
     ‘--target’ option of ‘guild compile’.

     Los paquetes construidos con ‘guile-build-system’ deben
     proporcionar un paquete Guile en su campo ‘native-inputs’.

 -- Variable Scheme: julia-build-system
     This variable is exported by ‘(guix build-system julia)’. It
     implements the build procedure used by julia
     (https://julialang.org/) packages, which essentially is similar to
     running ‘julia -e 'using Pkg; Pkg.add(package)'’ in an environment
     where ‘JULIA_LOAD_PATH’ contains the paths to all Julia package
     inputs. Tests are run not run.

     Los paquetes Julia necesitan que el campo ‘file-name’ de la fuente
     sea el nombre real del paquete, con mayúsculas y minúsculas
     correctamente escritas.

     Para los paquetes que tienen dependencias de bibliotecas dinámicas,
     puede que sea necesario que escriba manualmente el fichero
     ‘/deps/deps.jl’. Habitualmente es una línea de ‘const variable =
     /gnu/store/biblioteca.so’ por cada dependencia, además de una
     función vacía ‘check_deps() = nothing’.

     Algunos paquetes antiguos que no usan todavía ‘Package.toml’
     también necesitan la creación de este fichero. La función
     ‘julia-create-package-toml’ ayuda en la creación de dicho fichero.
     Debe proporcionarle las salidas y las fuentes del paquete, su
     nombre (el mismo que en el parámetro ‘file-name’), el uuid del
     paquete, la versión del paquete y una lista de dependencias
     especificadas a partir de su nombre y su uuid.

 -- Variable Scheme: minify-build-system
     Esta variable se exporta en ‘(guix build-system minify)’.
     Implementa un procedimiento de minificación para paquetes
     JavaScript simples.

     Añade ‘uglify-js’ al conjunto de entradas y lo utiliza para
     comprimir todos los ficheros JavaScript en el directorio ‘src’. Un
     paquete de minificación diferente puede especificarse con el
     parámetro ‘#:uglify-js’, pero se espera que el paquete escriba el
     código minificado en la salida estándar.

     Cuando los ficheros JavaScript de entrada no se encuentran en el
     directorio ‘src’, el parámetro ‘#:javascript-files’ puede usarse
     para especificar una lista de nombres de fichero que proporcionar
     al minificador.

 -- Variable Scheme: ocaml-build-system
     Esta variable se exporta en ‘(guix build-system ocaml)’. Implementa
     un procedimiento de construcción para paquetes OCaml
     (https://ocaml.org), que consiste en seleccionar el conjunto
     correcto de órdenes a ejecutar para cada paquete. Los paquetes
     OCaml pueden esperar la ejecución de muchas ordenes diferentes.
     Este sistema de construcción probará algunas de ellas.

     Cuando el paquete tiene un fichero ‘setup.ml’ presente en el nivel
     superior, se ejecuta ‘ocaml setup.ml -configure’, ‘ocaml setup.ml
     -build’ y ‘ocaml setup.ml -install’. El sistema de construcción
     asumirá que este fichero se generó con
     <http://oasis.forge.ocamlcore.org/ OASIS> y se encargará de
     establecer el prefijo y la activación de las pruebas si no se
     desactivaron. Puede pasar opciones de configuración y construcción
     con ‘#:configure-flags’ y ‘#:build-flags’, respectivamente. El
     parámetro ‘#:test-flags’ puede usarse para cambiar el conjunto de
     opciones usadas para activar las pruebas. El parámetro
     ‘#:use-make?’ puede usarse para ignorar este sistema en las fases
     de construcción e instalación.

     Cuando el paquete tiene un fichero ‘configure’, se asume que es un
     guión de configuración hecho a mano que necesita un formato de
     parámetros diferente a los del sistema ‘gnu-build-system’. Puede
     añadir más opciones con el parámetro ‘#:configure-flags’.

     Cuando el paquete tiene un fichero ‘Makefile’ (o ‘#:use-make?’ es
     ‘#t’), será usado y se pueden proporcionar más opciones para las
     fases de construcción y e instalación con el parámetro
     ‘#:make-flags’.

     Por último, algunos paquetes no tienen estos ficheros y usan unas
     localizaciones de algún modo estándares para su sistema de
     construcción. En este caso, el sistema de construcción ejecutará
     ‘ocaml pkg/pkg.ml’ o ‘ocaml pkg/build.ml’ y se hará cargo de
     proporcionar la ruta del módulo findlib necesario. Se pueden pasar
     opciones adicionales con el parámetro ‘#:build-flags’. De la
     instalación se hace cargo ‘opam-installer’. En este caso, el
     paquete ‘opam’ debe añadirse al campo ‘native-inputs’ de la
     definición del paquete.

     Note that most OCaml packages assume they will be installed in the
     same directory as OCaml, which is not what we want in guix. In
     particular, they will install ‘.so’ files in their module’s
     directory, which is usually fine because it is in the OCaml
     compiler directory. In guix though, these libraries cannot be found
     and we use ‘CAML_LD_LIBRARY_PATH’. This variable points to
     ‘lib/ocaml/site-lib/stubslibs’ and this is where ‘.so’ libraries
     should be installed.

 -- Variable Scheme: python-build-system
     Esta variable se exporta en ‘(guix build-system python)’.
     Implementa el procedimiento más o menos estándar de construcción
     usado por paquetes Python, que consiste en la ejecución de ‘python
     setup.py build’ y ‘python setup.py install
     --prefix=/gnu/store/...’.

     For packages that install stand-alone Python programs under ‘bin/’,
     it takes care of wrapping these programs so that their ‘PYTHONPATH’
     environment variable points to all the Python libraries they depend
     on.

     Se puede especificar el paquete Python usado para llevar a cabo la
     construcción con el parámetro ‘#:python’. Esta es habitualmente una
     forma de forzar la construcción de un paquete para una versión
     específica del intérprete Python, lo que puede ser necesario si el
     paquete es compatible únicamente con una versión del intérprete.

     De manera predeterminada guix llama a ‘setup.py’ bajo el control de
     ‘setuptools’ de manera similar a lo realizado por ‘pip’. Algunos
     paquetes no son compatibles con setuptools (y pip), por lo que
     puede desactivar esta configuración estableciendo el parámetro
     ‘#:use-setuptools’ a ‘#f’.

 -- Variable Scheme: perl-build-system
     Esta variable se exporta en ‘(guix build-system perl)’. Implementa
     el procedimiento de construcción estándar para paquetes Perl, lo
     que o bien consiste en la ejecución de ‘perl Build.PL
     --prefix=/gnu/store/...’, seguido de ‘Build’ y ‘Build install’; o
     en la ejecución de ‘perl Makefile.PL PREFIX=/gnu/store/...’,
     seguida de ‘make’ y ‘make install’, dependiendo de si ‘Build.PL’ o
     ‘Makefile.PL’ están presentes en la distribución del paquete. El
     primero tiene preferencia si existen tanto ‘Build.PL’ como
     ‘Makefile.PL’ en la distribución del paquete. Esta preferencia
     puede ser invertida mediante la especificación del valor ‘#t’ en el
     parámetro ‘#:make-maker?’.

     La invocación inicial de ‘perl Makefile.PL’ o ‘perl Build.PL’ pasa
     a su vez las opciones especificadas por los parámetros
     ‘#:make-maker-flags’ o ‘#:module-build-flags’, respectivamente.

     El paquete Perl usado puede especificarse con ‘#:perl’.

 -- Variable Scheme: qt-build-system
     Esta variable se exporta en ‘(guix build-system qt)’. Está pensado
     para usarse con aplicaciones que usen Qt o KDE.

     Este sistema de construcción añade las dos fases siguientes a las
     definidas en CMAKE-BUILD-SYSTEM:

     ‘check-setup’
          La fase ‘check-setup’ prepara el entorno para la ejecución de
          las comprobaciones usadas habitualmente por los programas de
          pruebas de Qt. Por ahora únicamente proporciona valor a
          algunas variables de entorno: ‘QT_QPA_PLATFORM=offscreen’,
          ‘DBUS_FATAL_WARNINGS=0’ y ‘CTEST_OUTPUT_ON_FAILURE=1’.

          Esta fase se añade previamente a la fase ‘check’. Es una fase
          separada para facilitar el ajuste si fuese necesario.

     ‘qt-wrap’
          La fase ‘qt-wrap’ busca las rutas de módulos de Qt5, las rutas
          de QML y algunas rutas XDG en las entradas y la salida. En
          caso de que alguna ruta se encuentra, todos los programas en
          los directorios ‘bin/’, ‘sbin/’, ‘libexec/’ y ‘lib/libexec/’
          de la salida se envuelven en guiones que definen las variables
          de entorno necesarias.

          Es posible excluir salidas específicas del paquete del proceso
          de recubrimiento enumerando sus nombres en el parámetro
          ‘#:qt-wrap-excluded-outputs’. Esto es útil cuando se sabe que
          una salida no contiene binarios que usen Qt, y cuando
          empaquetar gratuitamente añadiría una dependencia de dicha
          salida en Qt.

          Ambas fases se añaden tras la fase ‘install’.

 -- Variable Scheme: r-build-system
     This variable is exported by ‘(guix build-system r)’. It implements
     the build procedure used by R (https://r-project.org) packages,
     which essentially is little more than running ‘R CMD INSTALL
     --library=/gnu/store/...’ in an environment where ‘R_LIBS_SITE’
     contains the paths to all R package inputs. Tests are run after
     installation using the R function ‘tools::testInstalledPackage’.

 -- Variable Scheme: rakudo-build-system
     Esta variable se exporta en ‘(guix build-system rakudo)’.
     Implementa el procedimiento de construcción usado por Rakudo
     (https://rakudo.org/) para paquetes Perl6 (https://perl6.org/).
     Instala el paquete en ‘/gnu/store/.../NOMBRE-VERSIÓN/share/perl6’ e
     instala los binarios, ficheros de bibliotecas y recursos, así como
     recubre los ficheros en el directorio ‘bin/’. Las pruebas pueden
     omitirse proporcionando ‘#f’ en el parámetro ‘tests?’.

     El paquete rakudo en uso puede especificarse con ‘rakudo’. El
     paquete perl6-tap-harness en uso durante las pruebas puede
     especificarse con ‘#:prove6’ o eliminarse proporcionando ‘#f’ al
     parámetro ‘with-prove6?’. El paquete perl6-zef en uso durante las
     pruebas e instalación puede especificarse con ‘#:zef’ o eliminarse
     proporcionando ‘#f’ al parámetro ‘with-zef?’.

 -- Variable Scheme: texlive-build-system
     This variable is exported by ‘(guix build-system texlive)’. It is
     used to build TeX packages in batch mode with a specified engine.
     The build system sets the ‘TEXINPUTS’ variable to find all TeX
     source files in the inputs.

     Por defecto ejecuta ‘luatex’ en todos los ficheros que terminan en
     ‘ins’. Un motor y formato diferente puede especificarse con el
     parámetro ‘#:tex-format’. Los diferentes objetivos de construcción
     pueden especificarse con el parámetro ‘#:build-targets’, que espera
     una lista de nombres de fichero. El sistema de construcción añade
     únicamente ‘texlive-bin’ y ‘texlive-latex-base’ (ambos desde ‘(gnu
     packages tex)’ a las entradas. Ambos pueden forzarse con los
     parámetros ‘#:texlive-bin’ y ‘#:texlive-latex-base’
     respectivamente.

     El parámetro ‘#:tex-directory’ le dice al sistema de construcción
     dónde instalar los ficheros construidos bajo el árbol texmf.

 -- Variable Scheme: ruby-build-system
     Esta variable se exporta en ‘(guix build-system ruby)’. Implementa
     el procedimiento de construcción de RubyGems usado por los paquetes
     Ruby, que implica la ejecución de ‘gem build’ seguida de ‘gem
     install’.

     El campo ‘source’ de un paquete que usa este sistema de
     construcción típicamente se refiere a un archivo gem, ya que este
     es el formato usado por las desarrolladoras Ruby cuando publican su
     software. El sistema de construcción desempaqueta el archivo gem,
     potencialmente parchea las fuentes, ejecuta la batería de pruebas,
     vuelve a empaquetar el archivo gem y lo instala. Adicionalmente, se
     puede hacer referencia a directorios y archivadores tar para
     permitir la construcción de archivos gem no publicados desde Git o
     un archivador tar de publicación de fuentes tradicional.

     Se puede especificar el paquete Ruby usado mediante el parámetro
     ‘#:ruby’. Una lista de opciones adicionales pueden pasarse a la
     orden ‘gem’ en el parámetro ‘#:gem-flags’.

 -- Variable Scheme: waf-build-system
     Esta variable se exporta en ‘(guix build-system waf)’. Implementa
     un procedimiento de construcción alrededor del guión ‘waf’. Las
     fases comunes—‘configure’, ‘build’ y ‘install’—se implementan
     pasando sus nombres como parámetros al guión ‘waf’.

     El guión ‘waf’ es ejecutado por el intérprete Python. El paquete
     Python usado para la ejecución puede ser especificado con el
     parámetro ‘#:python’.

 -- Variable Scheme: scons-build-system
     Esta variable se exporta en ‘(guix build-system scons)’. Implementa
     en procedimiento de construcción usado por la herramienta de
     construcción de software SCons. Este sistema de construcción
     ejecuta ‘scons’ para construir el paquete, ‘scons test’ para
     ejecutar las pruebas y después ‘scons install’ para instalar el
     paquete.

     Las opciones adicionales a pasar a ‘scons’ se pueden especificar
     con el parámetro ‘#:scons-flags’. Los objetivos predeterminados de
     construcción (build) e instalación (install) pueden modificarse con
     ‘#:build-targets’ y ‘#:install-targets’ respectivamente. La versión
     de Python usada para ejecutar SCons puede especificarse
     seleccionando el paquete SCons apropiado con el parámetro
     ‘#:scons’.

 -- Variable Scheme: haskell-build-system
     Esta variable se exporta en ‘(guix build-system haskell)’.
     Implementa el procedimiento de construcción Cabal usado por
     paquetes Haskell, el cual implica la ejecución de ‘runhaskell
     Setup.hs configure --prefix=/gnu/store/...’ y ‘runhaskell Setup.hs
     build’. En vez de instalar el paquete ejecutando ‘runhaskell
     Setup.hs install’, para evitar el intento de registro de
     bibliotecas en el directorio de solo-lectura del compilador en el
     almacén, el sistema de construcción usa ‘runhaskell Setup.hs copy’,
     seguido de ‘runhaskell Setup.hs register’. Además, el sistema de
     construcción genera la documentación del paquete ejecutando
     ‘runhaskell Setup.hs haddock’, a menos que se pasase ‘#:haddock?
     #f’. Parámetros opcionales de Haddock pueden proporcionarse con la
     ayuda del parámetro ‘#:haddock-flags’. Si el fichero ‘Setup.hs’ no
     es encontrado, el sistema de construcción busca ‘Setup.lhs’ a su
     vez.

     El compilador Haskell usado puede especificarse con el parámetro
     ‘#:haskell’ cuyo valor predeterminado es ‘ghc’.

 -- Variable Scheme: dub-build-system
     Esta variable se exporta en ‘(guix build-system dub)’. Implementa
     el procedimiento de construcción Dub usado por los paquetes D, que
     implica la ejecución de ‘dub build’ y ‘dub run’. La instalación se
     lleva a cabo con la copia manual de los ficheros.

     El compilador D usado puede ser especificado con el parámetro
     ‘#:ldc’ cuyo valor predeterminado es ‘ldc’.

 -- Variable Scheme: emacs-build-system
     Esta variable se exporta en ‘(guix build-system emacs)’. Implementa
     un procedimiento de instalación similar al propio sistema de
     empaquetado de Emacs (*note (emacs)Packages::).

     Primero crea el fichero ‘PAQUETE-autoloads.el’, tras lo que compila
     todos los ficheros Emacs Lisp. De manera diferente al sistema de
     paquetes de Emacs, los ficheros de documentación Info se mueven al
     directorio estándar de documentación y se borra el fichero ‘dir’.
     Los ficheros del paquete Elisp se instalan directamente en
     ‘share/emacs/site-lisp’.

 -- Variable Scheme: font-build-system
     Esta variable se exporta en ‘(guix build-system font)’. Implementa
     un procedimiento de instalación para paquetes de fuentes donde las
     proveedoras originales proporcionan ficheros de tipografía
     TrueType, OpenType, etc. precompilados que simplemente necesitan
     copiarse en su lugar. Copia los ficheros de tipografías a las
     localizaciones estándar en el directorio de salida.

 -- Variable Scheme: meson-build-system
     Esta variable se exporta en ‘(guix build-system meson)’. Implementa
     el procedimiento de construcción para paquetes que usan Meson
     (https://mesonbuild.com) como su sistema de construcción.

     Añade Meson y Ninja (https://ninja-build.org/) al conjunto de
     entradas, y pueden cambiarse con los parámetros ‘#:meson’ y
     ‘#:ninja’ en caso necesario. La versión de Meson predeterminada es
     ‘meson-for-build’, la cual es especial puesto que no limpia el
     ‘RUNPATH’ de los binarios y bibliotecas durante la instalación.

     Este sistema de construcción es una extensión de GNU-BUILD-SYSTEM,
     pero con las siguientes fases cambiadas por otras específicas para
     Meson:

     ‘configure’
          The phase runs ‘meson’ with the flags specified in
          ‘#:configure-flags’. The flag ‘--buildtype’ is always set to
          ‘debugoptimized’ unless something else is specified in
          ‘#:build-type’.

     ‘build’
          Esta fase ejecuta ‘ninja’ para construir el paquete en
          paralelo por defecto, pero esto puede cambiarse con
          ‘#:parallel-build?’.

     ‘check’
          Esta fase ejecuta ‘ninja’ con el objetivo especificado en
          ‘#:test-target’, cuyo valor predeterminado es ‘"test"’.

     ‘install’
          Esta fase ejecuta ‘ninja install’ y no puede cambiarse.

     Aparte de estas, el sistema de ejecución también añade las
     siguientes fases:

     ‘fix-runpath’
          Esta fase se asegura de que todos los binarios pueden
          encontrar las bibliotecas que necesitan. Busca las bibliotecas
          necesarias en subdirectorios del paquete en construcción, y
          añade estas a ‘RUNPATH’ en caso necesario. También elimina
          referencias a bibliotecas introducidas en la fase de
          construcción por ‘meson-for-build’, como las dependencias de
          las pruebas, que no se necesitan realmente para la ejecución
          del programa.

     ‘glib-or-gtk-wrap’
          Esta fase es la fase proporcionada por
          ‘glib-or-gtk-build-system’, y no está activa por defecto.
          Puede activarse con ‘#:glib-or-gtk’.

     ‘glib-or-gtk-compile-schemas’
          Esta fase es la fase proporcionada por
          ‘glib-or-gtk-build-system’, y no está activa por defecto.
          Puede activarse con ‘#:glib-or-gtk’.

 -- Variable Scheme: linux-module-build-system
     LINUX-MODULE-BUILD-SYSTEM permite la construcción de módulos del
     núcleo Linux.

     Este sistema de construcción es una extensión de GNU-BUILD-SYSTEM,
     pero con las siguientes fases cambiadas:

     ‘configure’
          Esta fase configura el entorno de modo que el Makefile del
          núcleo Linux pueda usarse para la construcción del módulo
          externo del núcleo.

     ‘build’
          Esta fase usa el Makefile del núcleo Linux para construir el
          módulo externo del núcleo.

     ‘install’
          Esta fase usa el Makefile del núcleo Linux para instalar el
          módulo externo del núcleo.

     It is possible and useful to specify the Linux kernel to use for
     building the module (in the ‘arguments’ form of a package using the
     ‘linux-module-build-system’, use the key ‘#:linux’ to specify it).

 -- Variable Scheme: node-build-system
     Esta variable se exporta en ‘(guix build-system node)’. Implementa
     el procedimiento de construcción usado por Node.js
     (https://nodejs.org), que implementa una aproximación de la orden
     ‘npm install’, seguida de una orden ‘npm test’.

     El paquete Node.js usado para interpretar las órdenes ‘npm’ puede
     especificarse a través del parámetro ‘#:node’ cuyo valor
     predeterminado es ‘node’.

   Por último, para paquetes que no necesiten nada tan sofisticado se
proporciona un sistema de construcción “trivial”. Es trivial en el
sentido de que no proporciona prácticamente funcionalidad: no incorpora
entradas implícitas y no tiene una noción de fases de construcción.

 -- Variable Scheme: trivial-build-system
     Esta variable se exporta en ‘(guix build-system trivial)’.

     Este sistema de construcción necesita un parámetro ‘#:builder’.
     Este parámetro debe ser una expresión Scheme que construya la(s)
     salida(s) del paquete—como en ‘build-expression->derivation’ (*note
     ‘build-expression->derivation’: Derivaciones.).

   ---------- Footnotes ----------

   (1) Rogamos que se inspeccionen los módulos ‘(guix build
gnu-build-system)’ para más detalles sobre las fases de construcción

