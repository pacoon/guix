This is guix.info, produced by makeinfo version 6.7 from guix.texi.

Copyright © 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020 Ludovic
Courtès
Copyright © 2013, 2014, 2016 Andreas Enge
Copyright © 2013 Nikita Karetnikov
Copyright © 2014, 2015, 2016 Alex Kost
Copyright © 2015, 2016 Mathieu Lirzin
Copyright © 2014 Pierre-Antoine Rault
Copyright © 2015 Taylan Ulrich Bayırlı/Kammer
Copyright © 2015, 2016, 2017, 2019, 2020 Leo Famulari
Copyright © 2015, 2016, 2017, 2018, 2019, 2020 Ricardo Wurmus
Copyright © 2016 Ben Woodcroft
Copyright © 2016, 2017, 2018 Chris Marusich
Copyright © 2016, 2017, 2018, 2019, 2020 Efraim Flashner
Copyright © 2016 John Darrington
Copyright © 2016, 2017 Nikita Gillmann
Copyright © 2016, 2017, 2018, 2019, 2020 Jan Nieuwenhuizen
Copyright © 2016, 2017, 2018, 2019, 2020 Julien Lepiller
Copyright © 2016 Alex ter Weele
Copyright © 2016, 2017, 2018, 2019 Christopher Baines
Copyright © 2017, 2018, 2019 Clément Lassieur
Copyright © 2017, 2018 Mathieu Othacehe
Copyright © 2017 Federico Beffa
Copyright © 2017, 2018 Carlo Zancanaro
Copyright © 2017 Thomas Danckaert
Copyright © 2017 humanitiesNerd
Copyright © 2017 Christopher Allan Webber
Copyright © 2017, 2018, 2019, 2020 Marius Bakke
Copyright © 2017, 2019, 2020 Hartmut Goebel
Copyright © 2017, 2019, 2020 Maxim Cournoyer
Copyright © 2017, 2018, 2019, 2020 Tobias Geerinckx-Rice
Copyright © 2017 George Clemmer
Copyright © 2017 Andy Wingo
Copyright © 2017, 2018, 2019 Arun Isaac
Copyright © 2017 nee
Copyright © 2018 Rutger Helling
Copyright © 2018 Oleg Pykhalov
Copyright © 2018 Mike Gerwitz
Copyright © 2018 Pierre-Antoine Rouby
Copyright © 2018, 2019 Gábor Boskovits
Copyright © 2018, 2019 Florian Pelz
Copyright © 2018 Laura Lazzati
Copyright © 2018 Alex Vong
Copyright © 2019 Josh Holland
Copyright © 2019, 2020 Diego Nicola Barbato
Copyright © 2019 Ivan Petkov
Copyright © 2019 Jakob L. Kreuze
Copyright © 2019 Kyle Andrews
Copyright © 2019 Alex Griffin
Copyright © 2019 Guillaume Le Vaillant
Copyright © 2020 Leo Prikler
Copyright © 2019, 2020 Simon Tournier
Copyright © 2020 Wiktor Żelazny
Copyright © 2020 Damien Cassou
Copyright © 2020 Jakub Kądziołka
Copyright © 2020 Jack Hill
Copyright © 2020 Naga Malleswari
Copyright © 2020 Brice Waegeneire
Copyright © 2020 R Veera Kumar
Copyright © 2020 Pierre Langlois
Copyright © 2020 pinoaffe

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled “GNU Free
Documentation License”.
INFO-DIR-SECTION System administration
START-INFO-DIR-ENTRY
* Guix: (guix).       Manage installed software and system configuration.
* guix package: (guix)Invoking guix package.  Installing, removing, and upgrading packages.
* guix gc: (guix)Invoking guix gc.            Reclaiming unused disk space.
* guix pull: (guix)Invoking guix pull.        Update the list of available packages.
* guix system: (guix)Invoking guix system.    Manage the operating system configuration.
* guix deploy: (guix)Invoking guix deploy.    Manage operating system configurations for remote hosts.
END-INFO-DIR-ENTRY

INFO-DIR-SECTION Software development
START-INFO-DIR-ENTRY
* guix environment: (guix)Invoking guix environment. Building development environments with Guix.
* guix build: (guix)Invoking guix build.      Building packages.
* guix pack: (guix)Invoking guix pack.        Creating binary bundles.
END-INFO-DIR-ENTRY


File: guix.info,  Node: Top,  Next: Introduction,  Up: (dir)

GNU Guix
********

This document describes GNU Guix version 1.0.1.17089-7e269, a functional
package management tool written for the GNU system.

   This manual is also available in Simplified Chinese (*note
(guix.zh_CN)Top::), French (*note (guix.fr)Top::), German (*note
(guix.de)Top::), Spanish (*note (guix.es)Top::), and Russian (*note
(guix.ru)Top::).  If you would like to translate it in your native
language, consider joining the Translation Project
(https://translationproject.org/domain/guix-manual.html).

* Menu:

* Introduction::                What is Guix about?
* Installation::                Installing Guix.
* System Installation::         Installing the whole operating system.
* Package Management::          Package installation, upgrade, etc.
* Development::                 Guix-aided software development.
* Programming Interface::       Using Guix in Scheme.
* Utilities::                   Package management commands.
* System Configuration::        Configuring the operating system.
* Documentation::               Browsing software user manuals.
* Installing Debugging Files::  Feeding the debugger.
* Security Updates::            Deploying security fixes quickly.
* Bootstrapping::               GNU/Linux built from scratch.
* Porting::                     Targeting another platform or kernel.
* Contributing::                Your help needed!

* Acknowledgments::             Thanks!
* GNU Free Documentation License::  The license of this manual.
* Concept Index::               Concepts.
* Programming Index::           Data types, functions, and variables.

 — The Detailed Node Listing —

Introduction

* Managing Software the Guix Way::      What’s special.
* GNU Distribution::                    The packages and tools.

Installation

* Binary Installation::         Getting Guix running in no time!
* Requirements::                Software needed to build and run Guix.
* Running the Test Suite::      Testing Guix.
* Setting Up the Daemon::       Preparing the build daemon’s environment.
* Invoking guix-daemon::        Running the build daemon.
* Application Setup::           Application-specific setup.

Setting Up the Daemon

* Build Environment Setup::     Preparing the isolated build environment.
* Daemon Offload Setup::        Offloading builds to remote machines.
* SELinux Support::             Using an SELinux policy for the daemon.

System Installation

* Limitations::                 What you can expect.
* Hardware Considerations::     Supported hardware.
* USB Stick and DVD Installation::  Preparing the installation medium.
* Preparing for Installation::  Networking, partitioning, etc.
* Guided Graphical Installation::  Easy graphical installation.
* Manual Installation::         Manual installation for wizards.
* After System Installation::   When installation succeeded.
* Installing Guix in a VM::     Guix System playground.
* Building the Installation Image::  How this comes to be.

Manual Installation

* Keyboard Layout and Networking and Partitioning:: Initial setup.
* Proceeding with the Installation::  Installing.

Package Management

* Features::                    How Guix will make your life brighter.
* Invoking guix package::       Package installation, removal, etc.
* Substitutes::                 Downloading pre-built binaries.
* Packages with Multiple Outputs::  Single source package, multiple outputs.
* Invoking guix gc::            Running the garbage collector.
* Invoking guix pull::          Fetching the latest Guix and distribution.
* Channels::                    Customizing the package collection.
* Invoking guix time-machine::  Running an older revision of Guix.
* Inferiors::                   Interacting with another revision of Guix.
* Invoking guix describe::      Display information about your Guix revision.
* Invoking guix archive::       Exporting and importing store files.

Substitutes

* Official Substitute Server::  One particular source of substitutes.
* Substitute Server Authorization::  How to enable or disable substitutes.
* Substitute Authentication::   How Guix verifies substitutes.
* Proxy Settings::              How to get substitutes via proxy.
* Substitution Failure::        What happens when substitution fails.
* On Trusting Binaries::        How can you trust that binary blob?

Development

* Invoking guix environment::   Setting up development environments.
* Invoking guix pack::          Creating software bundles.
* The GCC toolchain::           Working with languages supported by GCC.

Programming Interface

* Package Modules::             Packages from the programmer’s viewpoint.
* Defining Packages::           Defining new packages.
* Build Systems::               Specifying how packages are built.
* The Store::                   Manipulating the package store.
* Derivations::                 Low-level interface to package derivations.
* The Store Monad::             Purely functional interface to the store.
* G-Expressions::               Manipulating build expressions.
* Invoking guix repl::          Fiddling with Guix interactively.

Defining Packages

* package Reference::           The package data type.
* origin Reference::            The origin data type.

Utilities

* Invoking guix build::         Building packages from the command line.
* Invoking guix edit::          Editing package definitions.
* Invoking guix download::      Downloading a file and printing its hash.
* Invoking guix hash::          Computing the cryptographic hash of a file.
* Invoking guix import::        Importing package definitions.
* Invoking guix refresh::       Updating package definitions.
* Invoking guix lint::          Finding errors in package definitions.
* Invoking guix size::          Profiling disk usage.
* Invoking guix graph::         Visualizing the graph of packages.
* Invoking guix publish::       Sharing substitutes.
* Invoking guix challenge::     Challenging substitute servers.
* Invoking guix copy::          Copying to and from a remote store.
* Invoking guix container::     Process isolation.
* Invoking guix weather::       Assessing substitute availability.
* Invoking guix processes::     Listing client processes.

Invoking ‘guix build’

* Common Build Options::        Build options for most commands.
* Package Transformation Options::  Creating variants of packages.
* Additional Build Options::    Options specific to ’guix build’.
* Debugging Build Failures::    Real life packaging experience.

System Configuration

* Using the Configuration System::  Customizing your GNU system.
* operating-system Reference::  Detail of operating-system declarations.
* File Systems::                Configuring file system mounts.
* Mapped Devices::              Block device extra processing.
* User Accounts::               Specifying user accounts.
* Keyboard Layout::             How the system interprets key strokes.
* Locales::                     Language and cultural convention settings.
* Services::                    Specifying system services.
* Setuid Programs::             Programs running with root privileges.
* X.509 Certificates::          Authenticating HTTPS servers.
* Name Service Switch::         Configuring libc’s name service switch.
* Initial RAM Disk::            Linux-Libre bootstrapping.
* Bootloader Configuration::    Configuring the boot loader.
* Invoking guix system::        Instantiating a system configuration.
* Invoking guix deploy::        Deploying a system configuration to a remote host.
* Running Guix in a VM::        How to run Guix System in a virtual machine.
* Defining Services::           Adding new service definitions.

Services

* Base Services::               Essential system services.
* Scheduled Job Execution::     The mcron service.
* Log Rotation::                The rottlog service.
* Networking Services::         Network setup, SSH daemon, etc.
* X Window::                    Graphical display.
* Printing Services::           Local and remote printer support.
* Desktop Services::            D-Bus and desktop services.
* Sound Services::              ALSA and Pulseaudio services.
* Database Services::           SQL databases, key-value stores, etc.
* Mail Services::               IMAP, POP3, SMTP, and all that.
* Messaging Services::          Messaging services.
* Telephony Services::          Telephony services.
* Monitoring Services::         Monitoring services.
* Kerberos Services::           Kerberos services.
* Web Services::                Web servers.
* Certificate Services::        TLS certificates via Let’s Encrypt.
* DNS Services::                DNS daemons.
* VPN Services::                VPN daemons.
* Network File System::         NFS related services.
* Continuous Integration::      The Cuirass service.
* Power Management Services::   Extending battery life.
* Audio Services::              The MPD.
* Virtualization Services::     Virtualization services.
* Version Control Services::    Providing remote access to Git repositories.
* Game Services::               Game servers.
* PAM Mount Service::           Service to mount volumes when logging in.
* Guix Services::               Services relating specifically to Guix.
* Linux Services::              Services tied to the Linux kernel.
* Hurd Services::               Services specific to a Hurd System.
* Miscellaneous Services::      Other services.

Defining Services

* Service Composition::         The model for composing services.
* Service Types and Services::  Types and services.
* Service Reference::           API reference.
* Shepherd Services::           A particular type of service.



File: guix.info,  Node: Introduction,  Next: Installation,  Prev: Top,  Up: Top

1 Introduction
**************

GNU Guix(1) is a package management tool for and distribution of the GNU
system.  Guix makes it easy for unprivileged users to install, upgrade,
or remove software packages, to roll back to a previous package set, to
build packages from source, and generally assists with the creation and
maintenance of software environments.

   You can install GNU Guix on top of an existing GNU/Linux system where
it complements the available tools without interference (*note
Installation::), or you can use it as a standalone operating system
distribution, “Guix System”(2).  *Note GNU Distribution::.

* Menu:

* Managing Software the Guix Way::      What’s special.
* GNU Distribution::                    The packages and tools.

   ---------- Footnotes ----------

   (1) “Guix” is pronounced like “geeks”, or “ɡiːks” using the
international phonetic alphabet (IPA).

   (2) We used to refer to Guix System as “Guix System Distribution” or
“GuixSD”.  We now consider it makes more sense to group everything under
the “Guix” banner since, after all, Guix System is readily available
through the ‘guix system’ command, even if you’re using a different
distro underneath!


File: guix.info,  Node: Managing Software the Guix Way,  Next: GNU Distribution,  Up: Introduction

1.1 Managing Software the Guix Way
==================================

Guix provides a command-line package management interface (*note Package
Management::), tools to help with software development (*note
Development::), command-line utilities for more advanced usage, (*note
Utilities::), as well as Scheme programming interfaces (*note
Programming Interface::).  Its “build daemon” is responsible for
building packages on behalf of users (*note Setting Up the Daemon::) and
for downloading pre-built binaries from authorized sources (*note
Substitutes::).

   Guix includes package definitions for many GNU and non-GNU packages,
all of which respect the user’s computing freedom
(https://www.gnu.org/philosophy/free-sw.html).  It is _extensible_:
users can write their own package definitions (*note Defining
Packages::) and make them available as independent package modules
(*note Package Modules::).  It is also _customizable_: users can
_derive_ specialized package definitions from existing ones, including
from the command line (*note Package Transformation Options::).

   Under the hood, Guix implements the “functional package management”
discipline pioneered by Nix (*note Acknowledgments::).  In Guix, the
package build and installation process is seen as a _function_, in the
mathematical sense.  That function takes inputs, such as build scripts,
a compiler, and libraries, and returns an installed package.  As a pure
function, its result depends solely on its inputs—for instance, it
cannot refer to software or scripts that were not explicitly passed as
inputs.  A build function always produces the same result when passed a
given set of inputs.  It cannot alter the environment of the running
system in any way; for instance, it cannot create, modify, or delete
files outside of its build and installation directories.  This is
achieved by running build processes in isolated environments (or
“containers”), where only their explicit inputs are visible.

   The result of package build functions is “cached” in the file system,
in a special directory called “the store” (*note The Store::).  Each
package is installed in a directory of its own in the store—by default
under ‘/gnu/store’.  The directory name contains a hash of all the
inputs used to build that package; thus, changing an input yields a
different directory name.

   This approach is the foundation for the salient features of Guix:
support for transactional package upgrade and rollback, per-user
installation, and garbage collection of packages (*note Features::).


File: guix.info,  Node: GNU Distribution,  Prev: Managing Software the Guix Way,  Up: Introduction

1.2 GNU Distribution
====================

Guix comes with a distribution of the GNU system consisting entirely of
free software(1).  The distribution can be installed on its own (*note
System Installation::), but it is also possible to install Guix as a
package manager on top of an installed GNU/Linux system (*note
Installation::).  When we need to distinguish between the two, we refer
to the standalone distribution as Guix System.

   The distribution provides core GNU packages such as GNU libc, GCC,
and Binutils, as well as many GNU and non-GNU applications.  The
complete list of available packages can be browsed on-line
(https://www.gnu.org/software/guix/packages) or by running ‘guix
package’ (*note Invoking guix package::):

     guix package --list-available

   Our goal is to provide a practical 100% free software distribution of
Linux-based and other variants of GNU, with a focus on the promotion and
tight integration of GNU components, and an emphasis on programs and
tools that help users exert that freedom.

   Packages are currently available on the following platforms:

‘x86_64-linux’
     Intel/AMD ‘x86_64’ architecture, Linux-Libre kernel;

‘i686-linux’
     Intel 32-bit architecture (IA32), Linux-Libre kernel;

‘armhf-linux’
     ARMv7-A architecture with hard float, Thumb-2 and NEON, using the
     EABI hard-float application binary interface (ABI), and Linux-Libre
     kernel.

‘aarch64-linux’
     little-endian 64-bit ARMv8-A processors, Linux-Libre kernel.

‘mips64el-linux (deprecated)’
     little-endian 64-bit MIPS processors, specifically the Loongson
     series, n32 ABI, and Linux-Libre kernel.  This configuration is no
     longer fully supported; in particular, there is no ongoing work to
     ensure that this architecture still works.  Should someone decide
     they wish to revive this architecture then the code is still
     available.

   With Guix System, you _declare_ all aspects of the operating system
configuration and Guix takes care of instantiating the configuration in
a transactional, reproducible, and stateless fashion (*note System
Configuration::).  Guix System uses the Linux-libre kernel, the Shepherd
initialization system (*note (shepherd)Introduction::), the well-known
GNU utilities and tool chain, as well as the graphical environment or
system services of your choice.

   Guix System is available on all the above platforms except
‘mips64el-linux’.

For information on porting to other architectures or kernels, *note
Porting::.

   Building this distribution is a cooperative effort, and you are
invited to join!  *Note Contributing::, for information about how you
can help.

   ---------- Footnotes ----------

   (1) The term “free” here refers to the freedom provided to users of
that software (https://www.gnu.org/philosophy/free-sw.html).


File: guix.info,  Node: Installation,  Next: System Installation,  Prev: Introduction,  Up: Top

2 Installation
**************

     Note: We recommend the use of this shell installer script
     (https://git.savannah.gnu.org/cgit/guix.git/plain/etc/guix-install.sh)
     to install Guix on top of a running GNU/Linux system, thereafter
     called a “foreign distro”.(1)  The script automates the download,
     installation, and initial configuration of Guix.  It should be run
     as the root user.

   When installed on a foreign distro, GNU Guix complements the
available tools without interference.  Its data lives exclusively in two
directories, usually ‘/gnu/store’ and ‘/var/guix’; other files on your
system, such as ‘/etc’, are left untouched.

   Once installed, Guix can be updated by running ‘guix pull’ (*note
Invoking guix pull::).

   If you prefer to perform the installation steps manually or want to
tweak them, you may find the following subsections useful.  They
describe the software requirements of Guix, as well as how to install it
manually and get ready to use it.

* Menu:

* Binary Installation::         Getting Guix running in no time!
* Requirements::                Software needed to build and run Guix.
* Running the Test Suite::      Testing Guix.
* Setting Up the Daemon::       Preparing the build daemon’s environment.
* Invoking guix-daemon::        Running the build daemon.
* Application Setup::           Application-specific setup.
* Upgrading Guix::              Upgrading Guix and its build daemon.

   ---------- Footnotes ----------

   (1) This section is concerned with the installation of the package
manager, which can be done on top of a running GNU/Linux system.  If,
instead, you want to install the complete GNU operating system, *note
System Installation::.


File: guix.info,  Node: Binary Installation,  Next: Requirements,  Up: Installation

2.1 Binary Installation
=======================

This section describes how to install Guix on an arbitrary system from a
self-contained tarball providing binaries for Guix and for all its
dependencies.  This is often quicker than installing from source, which
is described in the next sections.  The only requirement is to have
GNU tar and Xz.

     Note: We recommend the use of this shell installer script
     (https://git.savannah.gnu.org/cgit/guix.git/plain/etc/guix-install.sh).
     The script automates the download, installation, and initial
     configuration steps described below.  It should be run as the root
     user.  As root, you can thus run this:

          cd /tmp
          wget https://git.savannah.gnu.org/cgit/guix.git/plain/etc/guix-install.sh
          chmod +x guix-install.sh
          ./guix-install.sh

   Installing goes along these lines:

  1. Download the binary tarball from
     ‘https://ftp.gnu.org/gnu/guix/guix-binary-1.0.1.17089-7e269.x86_64-linux.tar.xz’,
     where ‘x86_64-linux’ can be replaced with ‘i686-linux’ for an
     ‘i686’ (32-bits) machine already running the kernel Linux, and so
     on (*note GNU Distribution::).

     Make sure to download the associated ‘.sig’ file and to verify the
     authenticity of the tarball against it, along these lines:

          $ wget https://ftp.gnu.org/gnu/guix/guix-binary-1.0.1.17089-7e269.x86_64-linux.tar.xz.sig
          $ gpg --verify guix-binary-1.0.1.17089-7e269.x86_64-linux.tar.xz.sig

     If that command fails because you do not have the required public
     key, then run this command to import it:

          $ wget https://sv.gnu.org/people/viewgpg.php?user_id=15145 \
                -qO - | gpg --import -

     and rerun the ‘gpg --verify’ command.

     Take note that a warning like “This key is not certified with a
     trusted signature!” is normal.

  2. Now, you need to become the ‘root’ user.  Depending on your
     distribution, you may have to run ‘su -’ or ‘sudo -i’.  As ‘root’,
     run:

          # cd /tmp
          # tar --warning=no-timestamp -xf \
               /path/to/guix-binary-1.0.1.17089-7e269.x86_64-linux.tar.xz
          # mv var/guix /var/ && mv gnu /

     This creates ‘/gnu/store’ (*note The Store::) and ‘/var/guix’.  The
     latter contains a ready-to-use profile for ‘root’ (see next step).

     Do _not_ unpack the tarball on a working Guix system since that
     would overwrite its own essential files.

     The ‘--warning=no-timestamp’ option makes sure GNU tar does not
     emit warnings about “implausibly old time stamps” (such warnings
     were triggered by GNU tar 1.26 and older; recent versions are
     fine).  They stem from the fact that all the files in the archive
     have their modification time set to zero (which means January 1st,
     1970).  This is done on purpose to make sure the archive content is
     independent of its creation time, thus making it reproducible.

  3. Make the profile available under ‘~root/.config/guix/current’,
     which is where ‘guix pull’ will install updates (*note Invoking
     guix pull::):

          # mkdir -p ~root/.config/guix
          # ln -sf /var/guix/profiles/per-user/root/current-guix \
                   ~root/.config/guix/current

     Source ‘etc/profile’ to augment ‘PATH’ and other relevant
     environment variables:

          # GUIX_PROFILE="`echo ~root`/.config/guix/current" ; \
            source $GUIX_PROFILE/etc/profile

  4. Create the group and user accounts for build users as explained
     below (*note Build Environment Setup::).

  5. Run the daemon, and set it to automatically start on boot.

     If your host distro uses the systemd init system, this can be
     achieved with these commands:

          # cp ~root/.config/guix/current/lib/systemd/system/gnu-store.mount \
               ~root/.config/guix/current/lib/systemd/system/guix-daemon.service \
               /etc/systemd/system/
          # systemctl enable --now gnu-store.mount guix-daemon

     If your host distro uses the Upstart init system:

          # initctl reload-configuration
          # cp ~root/.config/guix/current/lib/upstart/system/guix-daemon.conf \
               /etc/init/
          # start guix-daemon

     Otherwise, you can still start the daemon manually with:

          # ~root/.config/guix/current/bin/guix-daemon \
                 --build-users-group=guixbuild

  6. Make the ‘guix’ command available to other users on the machine,
     for instance with:

          # mkdir -p /usr/local/bin
          # cd /usr/local/bin
          # ln -s /var/guix/profiles/per-user/root/current-guix/bin/guix

     It is also a good idea to make the Info version of this manual
     available there:

          # mkdir -p /usr/local/share/info
          # cd /usr/local/share/info
          # for i in /var/guix/profiles/per-user/root/current-guix/share/info/* ;
            do ln -s $i ; done

     That way, assuming ‘/usr/local/share/info’ is in the search path,
     running ‘info guix’ will open this manual (*note (texinfo)Other
     Info Directories::, for more details on changing the Info search
     path).

  7. To use substitutes from ‘ci.guix.gnu.org’ or one of its mirrors
     (*note Substitutes::), authorize them:

          # guix archive --authorize < \
               ~root/.config/guix/current/share/guix/ci.guix.gnu.org.pub

  8. Each user may need to perform a few additional steps to make their
     Guix environment ready for use, *note Application Setup::.

   Voilà, the installation is complete!

   You can confirm that Guix is working by installing a sample package
into the root profile:

     # guix install hello

   The binary installation tarball can be (re)produced and verified
simply by running the following command in the Guix source tree:

     make guix-binary.SYSTEM.tar.xz

... which, in turn, runs:

     guix pack -s SYSTEM --localstatedir \
       --profile-name=current-guix guix

   *Note Invoking guix pack::, for more info on this handy tool.


File: guix.info,  Node: Requirements,  Next: Running the Test Suite,  Prev: Binary Installation,  Up: Installation

2.2 Requirements
================

This section lists requirements when building Guix from source.  The
build procedure for Guix is the same as for other GNU software, and is
not covered here.  Please see the files ‘README’ and ‘INSTALL’ in the
Guix source tree for additional details.

   GNU Guix is available for download from its website at
<https://www.gnu.org/software/guix/>.

   GNU Guix depends on the following packages:

   • GNU Guile (https://gnu.org/software/guile/), version 3.0.x or
     2.2.x;
   • Guile-Gcrypt (https://notabug.org/cwebber/guile-gcrypt), version
     0.1.0 or later;
   • GnuTLS (https://gnutls.org/), specifically its Guile bindings
     (*note how to install the GnuTLS bindings for Guile:
     (gnutls-guile)Guile Preparations.);
   • Guile-SQLite3 (https://notabug.org/guile-sqlite3/guile-sqlite3),
     version 0.1.0 or later;
   • Guile-Git (https://gitlab.com/guile-git/guile-git), from August
     2017 or later;
   • Guile-JSON (https://savannah.nongnu.org/projects/guile-json/) 3.x;
   • zlib (https://zlib.net);
   • GNU Make (https://www.gnu.org/software/make/).

   The following dependencies are optional:

   • Support for build offloading (*note Daemon Offload Setup::) and
     ‘guix copy’ (*note Invoking guix copy::) depends on Guile-SSH
     (https://github.com/artyom-poptsov/guile-ssh), version 0.12.0 or
     later.

   • When lzlib (https://www.nongnu.org/lzip/lzlib.html) is available,
     lzlib substitutes can be used and ‘guix publish’ can compress
     substitutes with lzlib.

   • When libbz2 (http://www.bzip.org) is available, ‘guix-daemon’ can
     use it to compress build logs.

   Unless ‘--disable-daemon’ was passed to ‘configure’, the following
packages are also needed:

   • GNU libgcrypt (https://gnupg.org/);
   • SQLite 3 (https://sqlite.org);
   • GCC’s g++ (https://gcc.gnu.org), with support for the C++11
     standard.

   When configuring Guix on a system that already has a Guix
installation, be sure to specify the same state directory as the
existing installation using the ‘--localstatedir’ option of the
‘configure’ script (*note ‘localstatedir’: (standards)Directory
Variables.).  Usually, this LOCALSTATEDIR option is set to the value
‘/var’.  The ‘configure’ script protects against unintended
misconfiguration of LOCALSTATEDIR so you do not inadvertently corrupt
your store (*note The Store::).


File: guix.info,  Node: Running the Test Suite,  Next: Setting Up the Daemon,  Prev: Requirements,  Up: Installation

2.3 Running the Test Suite
==========================

After a successful ‘configure’ and ‘make’ run, it is a good idea to run
the test suite.  It can help catch issues with the setup or environment,
or bugs in Guix itself—and really, reporting test failures is a good way
to help improve the software.  To run the test suite, type:

     make check

   Test cases can run in parallel: you can use the ‘-j’ option of
GNU make to speed things up.  The first run may take a few minutes on a
recent machine; subsequent runs will be faster because the store that is
created for test purposes will already have various things in cache.

   It is also possible to run a subset of the tests by defining the
‘TESTS’ makefile variable as in this example:

     make check TESTS="tests/store.scm tests/cpio.scm"

   By default, tests results are displayed at a file level.  In order to
see the details of every individual test cases, it is possible to define
the ‘SCM_LOG_DRIVER_FLAGS’ makefile variable as in this example:

     make check TESTS="tests/base64.scm" SCM_LOG_DRIVER_FLAGS="--brief=no"

   Upon failure, please email <bug-guix@gnu.org> and attach the
‘test-suite.log’ file.  Please specify the Guix version being used as
well as version numbers of the dependencies (*note Requirements::) in
your message.

   Guix also comes with a whole-system test suite that tests complete
Guix System instances.  It can only run on systems where Guix is already
installed, using:

     make check-system

or, again, by defining ‘TESTS’ to select a subset of tests to run:

     make check-system TESTS="basic mcron"

   These system tests are defined in the ‘(gnu tests ...)’ modules.
They work by running the operating systems under test with lightweight
instrumentation in a virtual machine (VM). They can be computationally
intensive or rather cheap, depending on whether substitutes are
available for their dependencies (*note Substitutes::).  Some of them
require a lot of storage space to hold VM images.

   Again in case of test failures, please send <bug-guix@gnu.org> all
the details.


File: guix.info,  Node: Setting Up the Daemon,  Next: Invoking guix-daemon,  Prev: Running the Test Suite,  Up: Installation

2.4 Setting Up the Daemon
=========================

Operations such as building a package or running the garbage collector
are all performed by a specialized process, the “build daemon”, on
behalf of clients.  Only the daemon may access the store and its
associated database.  Thus, any operation that manipulates the store
goes through the daemon.  For instance, command-line tools such as ‘guix
package’ and ‘guix build’ communicate with the daemon (via remote
procedure calls) to instruct it what to do.

   The following sections explain how to prepare the build daemon’s
environment.  See also *note Substitutes::, for information on how to
allow the daemon to download pre-built binaries.

* Menu:

* Build Environment Setup::     Preparing the isolated build environment.
* Daemon Offload Setup::        Offloading builds to remote machines.
* SELinux Support::             Using an SELinux policy for the daemon.


File: guix.info,  Node: Build Environment Setup,  Next: Daemon Offload Setup,  Up: Setting Up the Daemon

2.4.1 Build Environment Setup
-----------------------------

In a standard multi-user setup, Guix and its daemon—the ‘guix-daemon’
program—are installed by the system administrator; ‘/gnu/store’ is owned
by ‘root’ and ‘guix-daemon’ runs as ‘root’.  Unprivileged users may use
Guix tools to build packages or otherwise access the store, and the
daemon will do it on their behalf, ensuring that the store is kept in a
consistent state, and allowing built packages to be shared among users.

   When ‘guix-daemon’ runs as ‘root’, you may not want package build
processes themselves to run as ‘root’ too, for obvious security reasons.
To avoid that, a special pool of “build users” should be created for use
by build processes started by the daemon.  These build users need not
have a shell and a home directory: they will just be used when the
daemon drops ‘root’ privileges in build processes.  Having several such
users allows the daemon to launch distinct build processes under
separate UIDs, which guarantees that they do not interfere with each
other—an essential feature since builds are regarded as pure functions
(*note Introduction::).

   On a GNU/Linux system, a build user pool may be created like this
(using Bash syntax and the ‘shadow’ commands):

     # groupadd --system guixbuild
     # for i in `seq -w 1 10`;
       do
         useradd -g guixbuild -G guixbuild           \
                 -d /var/empty -s `which nologin`    \
                 -c "Guix build user $i" --system    \
                 guixbuilder$i;
       done

The number of build users determines how many build jobs may run in
parallel, as specified by the ‘--max-jobs’ option (*note ‘--max-jobs’:
Invoking guix-daemon.).  To use ‘guix system vm’ and related commands,
you may need to add the build users to the ‘kvm’ group so they can
access ‘/dev/kvm’, using ‘-G guixbuild,kvm’ instead of ‘-G guixbuild’
(*note Invoking guix system::).

   The ‘guix-daemon’ program may then be run as ‘root’ with the
following command(1):

     # guix-daemon --build-users-group=guixbuild

This way, the daemon starts build processes in a chroot, under one of
the ‘guixbuilder’ users.  On GNU/Linux, by default, the chroot
environment contains nothing but:

   • a minimal ‘/dev’ directory, created mostly independently from the
     host ‘/dev’(2);

   • the ‘/proc’ directory; it only shows the processes of the container
     since a separate PID name space is used;

   • ‘/etc/passwd’ with an entry for the current user and an entry for
     user ‘nobody’;

   • ‘/etc/group’ with an entry for the user’s group;

   • ‘/etc/hosts’ with an entry that maps ‘localhost’ to ‘127.0.0.1’;

   • a writable ‘/tmp’ directory.

   You can influence the directory where the daemon stores build trees
via the ‘TMPDIR’ environment variable.  However, the build tree within
the chroot is always called ‘/tmp/guix-build-NAME.drv-0’, where NAME is
the derivation name—e.g., ‘coreutils-8.24’.  This way, the value of
‘TMPDIR’ does not leak inside build environments, which avoids
discrepancies in cases where build processes capture the name of their
build tree.

   The daemon also honors the ‘http_proxy’ and ‘https_proxy’ environment
variables for HTTP and HTTPS downloads it performs, be it for
fixed-output derivations (*note Derivations::) or for substitutes (*note
Substitutes::).

   If you are installing Guix as an unprivileged user, it is still
possible to run ‘guix-daemon’ provided you pass ‘--disable-chroot’.
However, build processes will not be isolated from one another, and not
from the rest of the system.  Thus, build processes may interfere with
each other, and may access programs, libraries, and other files
available on the system—making it much harder to view them as _pure_
functions.

   ---------- Footnotes ----------

   (1) If your machine uses the systemd init system, dropping the
‘PREFIX/lib/systemd/system/guix-daemon.service’ file in
‘/etc/systemd/system’ will ensure that ‘guix-daemon’ is automatically
started.  Similarly, if your machine uses the Upstart init system, drop
the ‘PREFIX/lib/upstart/system/guix-daemon.conf’ file in ‘/etc/init’.

   (2) “Mostly”, because while the set of files that appear in the
chroot’s ‘/dev’ is fixed, most of these files can only be created if the
host has them.


File: guix.info,  Node: Daemon Offload Setup,  Next: SELinux Support,  Prev: Build Environment Setup,  Up: Setting Up the Daemon

2.4.2 Using the Offload Facility
--------------------------------

When desired, the build daemon can “offload” derivation builds to other
machines running Guix, using the ‘offload’ “build hook”(1).  When that
feature is enabled, a list of user-specified build machines is read from
‘/etc/guix/machines.scm’; every time a build is requested, for instance
via ‘guix build’, the daemon attempts to offload it to one of the
machines that satisfy the constraints of the derivation, in particular
its system type—e.g., ‘x86_64-linux’.  Missing prerequisites for the
build are copied over SSH to the target machine, which then proceeds
with the build; upon success the output(s) of the build are copied back
to the initial machine.

   The ‘/etc/guix/machines.scm’ file typically looks like this:

     (list (build-machine
             (name "eightysix.example.org")
             (system "x86_64-linux")
             (host-key "ssh-ed25519 AAAAC3Nza...")
             (user "bob")
             (speed 2.))     ;incredibly fast!

           (build-machine
             (name "armeight.example.org")
             (system "aarch64-linux")
             (host-key "ssh-rsa AAAAB3Nza...")
             (user "alice")
             (private-key
              (string-append (getenv "HOME")
                             "/.ssh/identity-for-guix"))))

In the example above we specify a list of two build machines, one for
the ‘x86_64’ architecture and one for the ‘aarch64’ architecture.

   In fact, this file is—not surprisingly!—a Scheme file that is
evaluated when the ‘offload’ hook is started.  Its return value must be
a list of ‘build-machine’ objects.  While this example shows a fixed
list of build machines, one could imagine, say, using DNS-SD to return a
list of potential build machines discovered in the local network (*note
Guile-Avahi: (guile-avahi)Introduction.).  The ‘build-machine’ data type
is detailed below.

 -- Data Type: build-machine
     This data type represents build machines to which the daemon may
     offload builds.  The important fields are:

     ‘name’
          The host name of the remote machine.

     ‘system’
          The system type of the remote machine—e.g., ‘"x86_64-linux"’.

     ‘user’
          The user account to use when connecting to the remote machine
          over SSH. Note that the SSH key pair must _not_ be
          passphrase-protected, to allow non-interactive logins.

     ‘host-key’
          This must be the machine’s SSH “public host key” in OpenSSH
          format.  This is used to authenticate the machine when we
          connect to it.  It is a long string that looks like this:

               ssh-ed25519 AAAAC3NzaC...mde+UhL hint@example.org

          If the machine is running the OpenSSH daemon, ‘sshd’, the host
          key can be found in a file such as
          ‘/etc/ssh/ssh_host_ed25519_key.pub’.

          If the machine is running the SSH daemon of GNU lsh, ‘lshd’,
          the host key is in ‘/etc/lsh/host-key.pub’ or a similar file.
          It can be converted to the OpenSSH format using
          ‘lsh-export-key’ (*note (lsh)Converting keys::):

               $ lsh-export-key --openssh < /etc/lsh/host-key.pub
               ssh-rsa AAAAB3NzaC1yc2EAAAAEOp8FoQAAAQEAs1eB46LV...

     A number of optional fields may be specified:

     ‘port’ (default: ‘22’)
          Port number of SSH server on the machine.

     ‘private-key’ (default: ‘~root/.ssh/id_rsa’)
          The SSH private key file to use when connecting to the
          machine, in OpenSSH format.  This key must not be protected
          with a passphrase.

          Note that the default value is the private key _of the root
          account_.  Make sure it exists if you use the default.

     ‘compression’ (default: ‘"zlib@openssh.com,zlib"’)
     ‘compression-level’ (default: ‘3’)
          The SSH-level compression methods and compression level
          requested.

          Note that offloading relies on SSH compression to reduce
          bandwidth usage when transferring files to and from build
          machines.

     ‘daemon-socket’ (default: ‘"/var/guix/daemon-socket/socket"’)
          File name of the Unix-domain socket ‘guix-daemon’ is listening
          to on that machine.

     ‘parallel-builds’ (default: ‘1’)
          The number of builds that may run in parallel on the machine.

     ‘speed’ (default: ‘1.0’)
          A “relative speed factor”.  The offload scheduler will tend to
          prefer machines with a higher speed factor.

     ‘features’ (default: ‘'()’)
          A list of strings denoting specific features supported by the
          machine.  An example is ‘"kvm"’ for machines that have the KVM
          Linux modules and corresponding hardware support.  Derivations
          can request features by name, and they will be scheduled on
          matching build machines.

   The ‘guix’ command must be in the search path on the build machines.
You can check whether this is the case by running:

     ssh build-machine guix repl --version

   There is one last thing to do once ‘machines.scm’ is in place.  As
explained above, when offloading, files are transferred back and forth
between the machine stores.  For this to work, you first need to
generate a key pair on each machine to allow the daemon to export signed
archives of files from the store (*note Invoking guix archive::):

     # guix archive --generate-key

Each build machine must authorize the key of the master machine so that
it accepts store items it receives from the master:

     # guix archive --authorize < master-public-key.txt

Likewise, the master machine must authorize the key of each build
machine.

   All the fuss with keys is here to express pairwise mutual trust
relations between the master and the build machines.  Concretely, when
the master receives files from a build machine (and vice versa), its
build daemon can make sure they are genuine, have not been tampered
with, and that they are signed by an authorized key.

   To test whether your setup is operational, run this command on the
master node:

     # guix offload test

   This will attempt to connect to each of the build machines specified
in ‘/etc/guix/machines.scm’, make sure Guile and the Guix modules are
available on each machine, attempt to export to the machine and import
from it, and report any error in the process.

   If you want to test a different machine file, just specify it on the
command line:

     # guix offload test machines-qualif.scm

   Last, you can test the subset of the machines whose name matches a
regular expression like this:

     # guix offload test machines.scm '\.gnu\.org$'

   To display the current load of all build hosts, run this command on
the main node:

     # guix offload status

   ---------- Footnotes ----------

   (1) This feature is available only when Guile-SSH
(https://github.com/artyom-poptsov/guile-ssh) is present.


File: guix.info,  Node: SELinux Support,  Prev: Daemon Offload Setup,  Up: Setting Up the Daemon

2.4.3 SELinux Support
---------------------

Guix includes an SELinux policy file at ‘etc/guix-daemon.cil’ that can
be installed on a system where SELinux is enabled, in order to label
Guix files and to specify the expected behavior of the daemon.  Since
Guix System does not provide an SELinux base policy, the daemon policy
cannot be used on Guix System.

2.4.3.1 Installing the SELinux policy
.....................................

To install the policy run this command as root:

     semodule -i etc/guix-daemon.cil

   Then relabel the file system with ‘restorecon’ or by a different
mechanism provided by your system.

   Once the policy is installed, the file system has been relabeled, and
the daemon has been restarted, it should be running in the
‘guix_daemon_t’ context.  You can confirm this with the following
command:

     ps -Zax | grep guix-daemon

   Monitor the SELinux log files as you run a command like ‘guix build
hello’ to convince yourself that SELinux permits all necessary
operations.

2.4.3.2 Limitations
...................

This policy is not perfect.  Here is a list of limitations or quirks
that should be considered when deploying the provided SELinux policy for
the Guix daemon.

  1. ‘guix_daemon_socket_t’ isn’t actually used.  None of the socket
     operations involve contexts that have anything to do with
     ‘guix_daemon_socket_t’.  It doesn’t hurt to have this unused label,
     but it would be preferrable to define socket rules for only this
     label.

  2. ‘guix gc’ cannot access arbitrary links to profiles.  By design,
     the file label of the destination of a symlink is independent of
     the file label of the link itself.  Although all profiles under
     $localstatedir are labelled, the links to these profiles inherit
     the label of the directory they are in.  For links in the user’s
     home directory this will be ‘user_home_t’.  But for links from the
     root user’s home directory, or ‘/tmp’, or the HTTP server’s working
     directory, etc, this won’t work.  ‘guix gc’ would be prevented from
     reading and following these links.

  3. The daemon’s feature to listen for TCP connections might no longer
     work.  This might require extra rules, because SELinux treats
     network sockets differently from files.

  4. Currently all files with a name matching the regular expression
     ‘/gnu/store/.+-(guix-.+|profile)/bin/guix-daemon’ are assigned the
     label ‘guix_daemon_exec_t’; this means that _any_ file with that
     name in any profile would be permitted to run in the
     ‘guix_daemon_t’ domain.  This is not ideal.  An attacker could
     build a package that provides this executable and convince a user
     to install and run it, which lifts it into the ‘guix_daemon_t’
     domain.  At that point SELinux could not prevent it from accessing
     files that are allowed for processes in that domain.

     We could generate a much more restrictive policy at installation
     time, so that only the _exact_ file name of the currently installed
     ‘guix-daemon’ executable would be labelled with
     ‘guix_daemon_exec_t’, instead of using a broad regular expression.
     The downside is that root would have to install or upgrade the
     policy at installation time whenever the Guix package that provides
     the effectively running ‘guix-daemon’ executable is upgraded.


File: guix.info,  Node: Invoking guix-daemon,  Next: Application Setup,  Prev: Setting Up the Daemon,  Up: Installation

2.5 Invoking ‘guix-daemon’
==========================

The ‘guix-daemon’ program implements all the functionality to access the
store.  This includes launching build processes, running the garbage
collector, querying the availability of a build result, etc.  It is
normally run as ‘root’ like this:

     # guix-daemon --build-users-group=guixbuild

For details on how to set it up, *note Setting Up the Daemon::.

   By default, ‘guix-daemon’ launches build processes under different
UIDs, taken from the build group specified with ‘--build-users-group’.
In addition, each build process is run in a chroot environment that only
contains the subset of the store that the build process depends on, as
specified by its derivation (*note derivation: Programming Interface.),
plus a set of specific system directories.  By default, the latter
contains ‘/dev’ and ‘/dev/pts’.  Furthermore, on GNU/Linux, the build
environment is a “container”: in addition to having its own file system
tree, it has a separate mount name space, its own PID name space,
network name space, etc.  This helps achieve reproducible builds (*note
Features::).

   When the daemon performs a build on behalf of the user, it creates a
build directory under ‘/tmp’ or under the directory specified by its
‘TMPDIR’ environment variable.  This directory is shared with the
container for the duration of the build, though within the container,
the build tree is always called ‘/tmp/guix-build-NAME.drv-0’.

   The build directory is automatically deleted upon completion, unless
the build failed and the client specified ‘--keep-failed’ (*note
‘--keep-failed’: Invoking guix build.).

   The daemon listens for connections and spawns one sub-process for
each session started by a client (one of the ‘guix’ sub-commands).  The
‘guix processes’ command allows you to get an overview of the activity
on your system by viewing each of the active sessions and clients.
*Note Invoking guix processes::, for more information.

   The following command-line options are supported:

‘--build-users-group=GROUP’
     Take users from GROUP to run build processes (*note build users:
     Setting Up the Daemon.).

‘--no-substitutes’
     Do not use substitutes for build products.  That is, always build
     things locally instead of allowing downloads of pre-built binaries
     (*note Substitutes::).

     When the daemon runs with ‘--no-substitutes’, clients can still
     explicitly enable substitution via the ‘set-build-options’ remote
     procedure call (*note The Store::).

‘--substitute-urls=URLS’
     Consider URLS the default whitespace-separated list of substitute
     source URLs.  When this option is omitted,
     ‘https://ci.guix.gnu.org’ is used.

     This means that substitutes may be downloaded from URLS, as long as
     they are signed by a trusted signature (*note Substitutes::).

‘--no-offload’
     Do not use offload builds to other machines (*note Daemon Offload
     Setup::).  That is, always build things locally instead of
     offloading builds to remote machines.

‘--cache-failures’
     Cache build failures.  By default, only successful builds are
     cached.

     When this option is used, ‘guix gc --list-failures’ can be used to
     query the set of store items marked as failed; ‘guix gc
     --clear-failures’ removes store items from the set of cached
     failures.  *Note Invoking guix gc::.

‘--cores=N’
‘-c N’
     Use N CPU cores to build each derivation; ‘0’ means as many as
     available.

     The default value is ‘0’, but it may be overridden by clients, such
     as the ‘--cores’ option of ‘guix build’ (*note Invoking guix
     build::).

     The effect is to define the ‘NIX_BUILD_CORES’ environment variable
     in the build process, which can then use it to exploit internal
     parallelism—for instance, by running ‘make -j$NIX_BUILD_CORES’.

‘--max-jobs=N’
‘-M N’
     Allow at most N build jobs in parallel.  The default value is ‘1’.
     Setting it to ‘0’ means that no builds will be performed locally;
     instead, the daemon will offload builds (*note Daemon Offload
     Setup::), or simply fail.

‘--max-silent-time=SECONDS’
     When the build or substitution process remains silent for more than
     SECONDS, terminate it and report a build failure.

     The default value is ‘0’, which disables the timeout.

     The value specified here can be overridden by clients (*note
     ‘--max-silent-time’: Common Build Options.).

‘--timeout=SECONDS’
     Likewise, when the build or substitution process lasts for more
     than SECONDS, terminate it and report a build failure.

     The default value is ‘0’, which disables the timeout.

     The value specified here can be overridden by clients (*note
     ‘--timeout’: Common Build Options.).

‘--rounds=N’
     Build each derivation N times in a row, and raise an error if
     consecutive build results are not bit-for-bit identical.  Note that
     this setting can be overridden by clients such as ‘guix build’
     (*note Invoking guix build::).

     When used in conjunction with ‘--keep-failed’, the differing output
     is kept in the store, under ‘/gnu/store/...-check’.  This makes it
     easy to look for differences between the two results.

‘--debug’
     Produce debugging output.

     This is useful to debug daemon start-up issues, but then it may be
     overridden by clients, for example the ‘--verbosity’ option of
     ‘guix build’ (*note Invoking guix build::).

‘--chroot-directory=DIR’
     Add DIR to the build chroot.

     Doing this may change the result of build processes—for instance if
     they use optional dependencies found in DIR when it is available,
     and not otherwise.  For that reason, it is not recommended to do
     so.  Instead, make sure that each derivation declares all the
     inputs that it needs.

‘--disable-chroot’
     Disable chroot builds.

     Using this option is not recommended since, again, it would allow
     build processes to gain access to undeclared dependencies.  It is
     necessary, though, when ‘guix-daemon’ is running under an
     unprivileged user account.

‘--log-compression=TYPE’
     Compress build logs according to TYPE, one of ‘gzip’, ‘bzip2’, or
     ‘none’.

     Unless ‘--lose-logs’ is used, all the build logs are kept in the
     LOCALSTATEDIR.  To save space, the daemon automatically compresses
     them with Bzip2 by default.

‘--disable-deduplication’
     Disable automatic file “deduplication” in the store.

     By default, files added to the store are automatically
     “deduplicated”: if a newly added file is identical to another one
     found in the store, the daemon makes the new file a hard link to
     the other file.  This can noticeably reduce disk usage, at the
     expense of slightly increased input/output load at the end of a
     build process.  This option disables this optimization.

‘--gc-keep-outputs[=yes|no]’
     Tell whether the garbage collector (GC) must keep outputs of live
     derivations.

     When set to ‘yes’, the GC will keep the outputs of any live
     derivation available in the store—the ‘.drv’ files.  The default is
     ‘no’, meaning that derivation outputs are kept only if they are
     reachable from a GC root.  *Note Invoking guix gc::, for more on GC
     roots.

‘--gc-keep-derivations[=yes|no]’
     Tell whether the garbage collector (GC) must keep derivations
     corresponding to live outputs.

     When set to ‘yes’, as is the case by default, the GC keeps
     derivations—i.e., ‘.drv’ files—as long as at least one of their
     outputs is live.  This allows users to keep track of the origins of
     items in their store.  Setting it to ‘no’ saves a bit of disk
     space.

     In this way, setting ‘--gc-keep-derivations’ to ‘yes’ causes
     liveness to flow from outputs to derivations, and setting
     ‘--gc-keep-outputs’ to ‘yes’ causes liveness to flow from
     derivations to outputs.  When both are set to ‘yes’, the effect is
     to keep all the build prerequisites (the sources, compiler,
     libraries, and other build-time tools) of live objects in the
     store, regardless of whether these prerequisites are reachable from
     a GC root.  This is convenient for developers since it saves
     rebuilds or downloads.

‘--impersonate-linux-2.6’
     On Linux-based systems, impersonate Linux 2.6.  This means that the
     kernel’s ‘uname’ system call will report 2.6 as the release number.

     This might be helpful to build programs that (usually wrongfully)
     depend on the kernel version number.

‘--lose-logs’
     Do not keep build logs.  By default they are kept under
     ‘LOCALSTATEDIR/guix/log’.

‘--system=SYSTEM’
     Assume SYSTEM as the current system type.  By default it is the
     architecture/kernel pair found at configure time, such as
     ‘x86_64-linux’.

‘--listen=ENDPOINT’
     Listen for connections on ENDPOINT.  ENDPOINT is interpreted as the
     file name of a Unix-domain socket if it starts with ‘/’ (slash
     sign).  Otherwise, ENDPOINT is interpreted as a host name or host
     name and port to listen to.  Here are a few examples:

     ‘--listen=/gnu/var/daemon’
          Listen for connections on the ‘/gnu/var/daemon’ Unix-domain
          socket, creating it if needed.

     ‘--listen=localhost’
          Listen for TCP connections on the network interface
          corresponding to ‘localhost’, on port 44146.

     ‘--listen=128.0.0.42:1234’
          Listen for TCP connections on the network interface
          corresponding to ‘128.0.0.42’, on port 1234.

     This option can be repeated multiple times, in which case
     ‘guix-daemon’ accepts connections on all the specified endpoints.
     Users can tell client commands what endpoint to connect to by
     setting the ‘GUIX_DAEMON_SOCKET’ environment variable (*note
     ‘GUIX_DAEMON_SOCKET’: The Store.).

          Note: The daemon protocol is _unauthenticated and
          unencrypted_.  Using ‘--listen=HOST’ is suitable on local
          networks, such as clusters, where only trusted nodes may
          connect to the build daemon.  In other cases where remote
          access to the daemon is needed, we recommend using Unix-domain
          sockets along with SSH.

     When ‘--listen’ is omitted, ‘guix-daemon’ listens for connections
     on the Unix-domain socket located at
     ‘LOCALSTATEDIR/guix/daemon-socket/socket’.


File: guix.info,  Node: Application Setup,  Next: Upgrading Guix,  Prev: Invoking guix-daemon,  Up: Installation

2.6 Application Setup
=====================

When using Guix on top of GNU/Linux distribution other than Guix
System—a so-called “foreign distro”—a few additional steps are needed to
get everything in place.  Here are some of them.

2.6.1 Locales
-------------

Packages installed via Guix will not use the locale data of the host
system.  Instead, you must first install one of the locale packages
available with Guix and then define the ‘GUIX_LOCPATH’ environment
variable:

     $ guix install glibc-locales
     $ export GUIX_LOCPATH=$HOME/.guix-profile/lib/locale

   Note that the ‘glibc-locales’ package contains data for all the
locales supported by the GNU libc and weighs in at around 917 MiB.
Alternatively, the ‘glibc-utf8-locales’ is smaller but limited to a few
UTF-8 locales.

   The ‘GUIX_LOCPATH’ variable plays a role similar to ‘LOCPATH’ (*note
‘LOCPATH’: (libc)Locale Names.).  There are two important differences
though:

  1. ‘GUIX_LOCPATH’ is honored only by the libc in Guix, and not by the
     libc provided by foreign distros.  Thus, using ‘GUIX_LOCPATH’
     allows you to make sure the programs of the foreign distro will not
     end up loading incompatible locale data.

  2. libc suffixes each entry of ‘GUIX_LOCPATH’ with ‘/X.Y’, where ‘X.Y’
     is the libc version—e.g., ‘2.22’.  This means that, should your
     Guix profile contain a mixture of programs linked against different
     libc version, each libc version will only try to load locale data
     in the right format.

   This is important because the locale data format used by different
libc versions may be incompatible.

2.6.2 Name Service Switch
-------------------------

When using Guix on a foreign distro, we _strongly recommend_ that the
system run the GNU C library’s “name service cache daemon”, ‘nscd’,
which should be listening on the ‘/var/run/nscd/socket’ socket.  Failing
to do that, applications installed with Guix may fail to look up host
names or user accounts, or may even crash.  The next paragraphs explain
why.

   The GNU C library implements a “name service switch” (NSS), which is
an extensible mechanism for “name lookups” in general: host name
resolution, user accounts, and more (*note (libc)Name Service Switch::).

   Being extensible, the NSS supports “plugins”, which provide new name
lookup implementations: for example, the ‘nss-mdns’ plugin allow
resolution of ‘.local’ host names, the ‘nis’ plugin allows user account
lookup using the Network information service (NIS), and so on.  These
extra “lookup services” are configured system-wide in
‘/etc/nsswitch.conf’, and all the programs running on the system honor
those settings (*note (libc)NSS Configuration File::).

   When they perform a name lookup—for instance by calling the
‘getaddrinfo’ function in C—applications first try to connect to the
nscd; on success, nscd performs name lookups on their behalf.  If the
nscd is not running, then they perform the name lookup by themselves, by
loading the name lookup services into their own address space and
running it.  These name lookup services—the ‘libnss_*.so’ files—are
‘dlopen’’d, but they may come from the host system’s C library, rather
than from the C library the application is linked against (the C library
coming from Guix).

   And this is where the problem is: if your application is linked
against Guix’s C library (say, glibc 2.24) and tries to load NSS plugins
from another C library (say, ‘libnss_mdns.so’ for glibc 2.22), it will
likely crash or have its name lookups fail unexpectedly.

   Running ‘nscd’ on the system, among other advantages, eliminates this
binary incompatibility problem because those ‘libnss_*.so’ files are
loaded in the ‘nscd’ process, not in applications themselves.

2.6.3 X11 Fonts
---------------

The majority of graphical applications use Fontconfig to locate and load
fonts and perform X11-client-side rendering.  The ‘fontconfig’ package
in Guix looks for fonts in ‘$HOME/.guix-profile’ by default.  Thus, to
allow graphical applications installed with Guix to display fonts, you
have to install fonts with Guix as well.  Essential font packages
include ‘gs-fonts’, ‘font-dejavu’, and ‘font-gnu-freefont’.

   Once you have installed or removed fonts, or when you notice an
application that does not find fonts, you may need to install Fontconfig
and to force an update of its font cache by running:

     guix install fontconfig
     fc-cache -rv

   To display text written in Chinese languages, Japanese, or Korean in
graphical applications, consider installing ‘font-adobe-source-han-sans’
or ‘font-wqy-zenhei’.  The former has multiple outputs, one per language
family (*note Packages with Multiple Outputs::).  For instance, the
following command installs fonts for Chinese languages:

     guix install font-adobe-source-han-sans:cn

   Older programs such as ‘xterm’ do not use Fontconfig and instead rely
on server-side font rendering.  Such programs require to specify a full
name of a font using XLFD (X Logical Font Description), like this:

     -*-dejavu sans-medium-r-normal-*-*-100-*-*-*-*-*-1

   To be able to use such full names for the TrueType fonts installed in
your Guix profile, you need to extend the font path of the X server:

     xset +fp $(dirname $(readlink -f ~/.guix-profile/share/fonts/truetype/fonts.dir))

   After that, you can run ‘xlsfonts’ (from ‘xlsfonts’ package) to make
sure your TrueType fonts are listed there.

2.6.4 X.509 Certificates
------------------------

The ‘nss-certs’ package provides X.509 certificates, which allow
programs to authenticate Web servers accessed over HTTPS.

   When using Guix on a foreign distro, you can install this package and
define the relevant environment variables so that packages know where to
look for certificates.  *Note X.509 Certificates::, for detailed
information.

2.6.5 Emacs Packages
--------------------

When you install Emacs packages with Guix, the Elisp files are placed
under the ‘share/emacs/site-lisp/’ directory of the profile in which
they are installed.  The Elisp libraries are made available to Emacs
through the ‘EMACSLOADPATH’ environment variable, which is set when
installing Emacs itself.

   Additionally, autoload definitions are automatically evaluated at the
initialization of Emacs, by the Guix-specific
‘guix-emacs-autoload-packages’ procedure.  If, for some reason, you want
to avoid auto-loading the Emacs packages installed with Guix, you can do
so by running Emacs with the ‘--no-site-file’ option (*note (emacs)Init
File::).


File: guix.info,  Node: Upgrading Guix,  Prev: Application Setup,  Up: Installation

2.7 Upgrading Guix
==================

To upgrade Guix, run:

     guix pull

   *Note Invoking guix pull::, for more information.

   On a foreign distro, you can upgrade the build daemon by running:

     sudo -i guix pull

followed by (assuming your distro uses the systemd service management
tool):

     systemctl restart guix-daemon.service

   On Guix System, upgrading the daemon is achieved by reconfiguring the
system (*note ‘guix system reconfigure’: Invoking guix system.).


File: guix.info,  Node: System Installation,  Next: Package Management,  Prev: Installation,  Up: Top

3 System Installation
*********************

This section explains how to install Guix System on a machine.  Guix, as
a package manager, can also be installed on top of a running GNU/Linux
system, *note Installation::.

     Note: You are reading this documentation with an Info reader.  For
     details on how to use it, hit the <RET> key (“return” or “enter”)
     on the link that follows: *note Info reader: (info-stnd)Top.  Hit
     ‘l’ afterwards to come back here.

     Alternatively, run ‘info info’ in another tty to keep the manual
     available.

* Menu:

* Limitations::                 What you can expect.
* Hardware Considerations::     Supported hardware.
* USB Stick and DVD Installation::  Preparing the installation medium.
* Preparing for Installation::  Networking, partitioning, etc.
* Guided Graphical Installation::  Easy graphical installation.
* Manual Installation::         Manual installation for wizards.
* After System Installation::   When installation succeeded.
* Installing Guix in a VM::     Guix System playground.
* Building the Installation Image::  How this comes to be.


File: guix.info,  Node: Limitations,  Next: Hardware Considerations,  Up: System Installation

3.1 Limitations
===============

We consider Guix System to be ready for a wide range of “desktop” and
server use cases.  The reliability guarantees it provides—transactional
upgrades and rollbacks, reproducibility—make it a solid foundation.

   Nevertheless, before you proceed with the installation, be aware of
the following noteworthy limitations applicable to version
1.0.1.17089-7e269:

   • Support for the Logical Volume Manager (LVM) is missing.

   • More and more system services are provided (*note Services::), but
     some may be missing.

   • GNOME, Xfce, LXDE, and Enlightenment are available (*note Desktop
     Services::), as well as a number of X11 window managers.  However,
     KDE is currently missing.

   More than a disclaimer, this is an invitation to report issues (and
success stories!), and to join us in improving it.  *Note
Contributing::, for more info.


File: guix.info,  Node: Hardware Considerations,  Next: USB Stick and DVD Installation,  Prev: Limitations,  Up: System Installation

3.2 Hardware Considerations
===========================

GNU Guix focuses on respecting the user’s computing freedom.  It builds
around the kernel Linux-libre, which means that only hardware for which
free software drivers and firmware exist is supported.  Nowadays, a wide
range of off-the-shelf hardware is supported on GNU/Linux-libre—from
keyboards to graphics cards to scanners and Ethernet controllers.
Unfortunately, there are still areas where hardware vendors deny users
control over their own computing, and such hardware is not supported on
Guix System.

   One of the main areas where free drivers or firmware are lacking is
WiFi devices.  WiFi devices known to work include those using Atheros
chips (AR9271 and AR7010), which corresponds to the ‘ath9k’ Linux-libre
driver, and those using Broadcom/AirForce chips (BCM43xx with
Wireless-Core Revision 5), which corresponds to the ‘b43-open’
Linux-libre driver.  Free firmware exists for both and is available
out-of-the-box on Guix System, as part of ‘%base-firmware’ (*note
‘firmware’: operating-system Reference.).

   The Free Software Foundation (https://www.fsf.org/) runs “Respects
Your Freedom” (https://www.fsf.org/ryf) (RYF), a certification program
for hardware products that respect your freedom and your privacy and
ensure that you have control over your device.  We encourage you to
check the list of RYF-certified devices.

   Another useful resource is the H-Node (https://www.h-node.org/) web
site.  It contains a catalog of hardware devices with information about
their support in GNU/Linux.


File: guix.info,  Node: USB Stick and DVD Installation,  Next: Preparing for Installation,  Prev: Hardware Considerations,  Up: System Installation

3.3 USB Stick and DVD Installation
==================================

An ISO-9660 installation image that can be written to a USB stick or
burnt to a DVD can be downloaded from
‘https://ftp.gnu.org/gnu/guix/guix-system-install-1.0.1.17089-7e269.x86_64-linux.iso.xz’,
where you can replace ‘x86_64-linux’ with one of:

‘x86_64-linux’
     for a GNU/Linux system on Intel/AMD-compatible 64-bit CPUs;

‘i686-linux’
     for a 32-bit GNU/Linux system on Intel-compatible CPUs.

   Make sure to download the associated ‘.sig’ file and to verify the
authenticity of the image against it, along these lines:

     $ wget https://ftp.gnu.org/gnu/guix/guix-system-install-1.0.1.17089-7e269.x86_64-linux.iso.xz.sig
     $ gpg --verify guix-system-install-1.0.1.17089-7e269.x86_64-linux.iso.xz.sig

   If that command fails because you do not have the required public
key, then run this command to import it:

     $ wget https://sv.gnu.org/people/viewgpg.php?user_id=15145 \
           -qO - | gpg --import -

and rerun the ‘gpg --verify’ command.

   Take note that a warning like “This key is not certified with a
trusted signature!” is normal.

   This image contains the tools necessary for an installation.  It is
meant to be copied _as is_ to a large-enough USB stick or DVD.

Copying to a USB Stick
----------------------

To copy the image to a USB stick, follow these steps:

  1. Decompress the image using the ‘xz’ command:

          xz -d guix-system-install-1.0.1.17089-7e269.x86_64-linux.iso.xz

  2. Insert a USB stick of 1 GiB or more into your machine, and
     determine its device name.  Assuming that the USB stick is known as
     ‘/dev/sdX’, copy the image with:

          dd if=guix-system-install-1.0.1.17089-7e269.x86_64-linux.iso of=/dev/sdX
          sync

     Access to ‘/dev/sdX’ usually requires root privileges.

Burning on a DVD
----------------

To copy the image to a DVD, follow these steps:

  1. Decompress the image using the ‘xz’ command:

          xz -d guix-system-install-1.0.1.17089-7e269.x86_64-linux.iso.xz

  2. Insert a blank DVD into your machine, and determine its device
     name.  Assuming that the DVD drive is known as ‘/dev/srX’, copy the
     image with:

          growisofs -dvd-compat -Z /dev/srX=guix-system-install-1.0.1.17089-7e269.x86_64-linux.iso

     Access to ‘/dev/srX’ usually requires root privileges.

Booting
-------

Once this is done, you should be able to reboot the system and boot from
the USB stick or DVD. The latter usually requires you to get in the BIOS
or UEFI boot menu, where you can choose to boot from the USB stick.  In
order to boot from Libreboot, switch to the command mode by pressing the
‘c’ key and type ‘search_grub usb’.

   *Note Installing Guix in a VM::, if, instead, you would like to
install Guix System in a virtual machine (VM).


File: guix.info,  Node: Preparing for Installation,  Next: Guided Graphical Installation,  Prev: USB Stick and DVD Installation,  Up: System Installation

3.4 Preparing for Installation
==============================

Once you have booted, you can use the guided graphical installer, which
makes it easy to get started (*note Guided Graphical Installation::).
Alternatively, if you are already familiar with GNU/Linux and if you
want more control than what the graphical installer provides, you can
choose the “manual” installation process (*note Manual Installation::).

   The graphical installer is available on TTY1.  You can obtain root
shells on TTYs 3 to 6 by hitting ‘ctrl-alt-f3’, ‘ctrl-alt-f4’, etc.
TTY2 shows this documentation and you can reach it with ‘ctrl-alt-f2’.
Documentation is browsable using the Info reader commands (*note
(info-stnd)Top::).  The installation system runs the GPM mouse daemon,
which allows you to select text with the left mouse button and to paste
it with the middle button.

     Note: Installation requires access to the Internet so that any
     missing dependencies of your system configuration can be
     downloaded.  See the “Networking” section below.


File: guix.info,  Node: Guided Graphical Installation,  Next: Manual Installation,  Prev: Preparing for Installation,  Up: System Installation

3.5 Guided Graphical Installation
=================================

The graphical installer is a text-based user interface.  It will guide
you, with dialog boxes, through the steps needed to install GNU Guix
System.

   The first dialog boxes allow you to set up the system as you use it
during the installation: you can choose the language, keyboard layout,
and set up networking, which will be used during the installation.  The
image below shows the networking dialog.

 [image src="images/installer-network.png" alt="networking setup with the graphical installer" ]

   Later steps allow you to partition your hard disk, as shown in the
image below, to choose whether or not to use encrypted file systems, to
enter the host name and root password, and to create an additional
account, among other things.

 [image src="images/installer-partitions.png" alt="partitioning with the graphical installer" ]

   Note that, at any time, the installer allows you to exit the current
installation step and resume at a previous step, as show in the image
below.

 [image src="images/installer-resume.png" alt="resuming the installation process" ]

   Once you’re done, the installer produces an operating system
configuration and displays it (*note Using the Configuration System::).
At that point you can hit “OK” and installation will proceed.  On
success, you can reboot into the new system and enjoy.  *Note After
System Installation::, for what’s next!


File: guix.info,  Node: Manual Installation,  Next: After System Installation,  Prev: Guided Graphical Installation,  Up: System Installation

3.6 Manual Installation
=======================

This section describes how you would “manually” install GNU Guix System
on your machine.  This option requires familiarity with GNU/Linux, with
the shell, and with common administration tools.  If you think this is
not for you, consider using the guided graphical installer (*note Guided
Graphical Installation::).

   The installation system provides root shells on TTYs 3 to 6; press
‘ctrl-alt-f3’, ‘ctrl-alt-f4’, and so on to reach them.  It includes many
common tools needed to install the system.  But it is also a full-blown
Guix System, which means that you can install additional packages,
should you need it, using ‘guix package’ (*note Invoking guix
package::).

* Menu:

* Keyboard Layout and Networking and Partitioning:: Initial setup.
* Proceeding with the Installation::  Installing.


File: guix.info,  Node: Keyboard Layout and Networking and Partitioning,  Next: Proceeding with the Installation,  Up: Manual Installation

3.6.1 Keyboard Layout, Networking, and Partitioning
---------------------------------------------------

Before you can install the system, you may want to adjust the keyboard
layout, set up networking, and partition your target hard disk.  This
section will guide you through this.

3.6.1.1 Keyboard Layout
.......................

The installation image uses the US qwerty keyboard layout.  If you want
to change it, you can use the ‘loadkeys’ command.  For example, the
following command selects the Dvorak keyboard layout:

     loadkeys dvorak

   See the files under ‘/run/current-system/profile/share/keymaps’ for a
list of available keyboard layouts.  Run ‘man loadkeys’ for more
information.

3.6.1.2 Networking
..................

Run the following command to see what your network interfaces are
called:

     ifconfig -a

... or, using the GNU/Linux-specific ‘ip’ command:

     ip address

   Wired interfaces have a name starting with ‘e’; for example, the
interface corresponding to the first on-board Ethernet controller is
called ‘eno1’.  Wireless interfaces have a name starting with ‘w’, like
‘w1p2s0’.

Wired connection
     To configure a wired network run the following command,
     substituting INTERFACE with the name of the wired interface you
     want to use.

          ifconfig INTERFACE up

     ... or, using the GNU/Linux-specific ‘ip’ command:

          ip link set INTERFACE up

Wireless connection
     To configure wireless networking, you can create a configuration
     file for the ‘wpa_supplicant’ configuration tool (its location is
     not important) using one of the available text editors such as
     ‘nano’:

          nano wpa_supplicant.conf

     As an example, the following stanza can go to this file and will
     work for many wireless networks, provided you give the actual SSID
     and passphrase for the network you are connecting to:

          network={
            ssid="MY-SSID"
            key_mgmt=WPA-PSK
            psk="the network's secret passphrase"
          }

     Start the wireless service and run it in the background with the
     following command (substitute INTERFACE with the name of the
     network interface you want to use):

          wpa_supplicant -c wpa_supplicant.conf -i INTERFACE -B

     Run ‘man wpa_supplicant’ for more information.

   At this point, you need to acquire an IP address.  On a network where
IP addresses are automatically assigned via DHCP, you can run:

     dhclient -v INTERFACE

   Try to ping a server to see if networking is up and running:

     ping -c 3 gnu.org

   Setting up network access is almost always a requirement because the
image does not contain all the software and tools that may be needed.

   If you need HTTP and HTTPS access to go through a proxy, run the
following command:

     herd set-http-proxy guix-daemon URL

where URL is the proxy URL, for example ‘http://example.org:8118’.

   If you want to, you can continue the installation remotely by
starting an SSH server:

     herd start ssh-daemon

   Make sure to either set a password with ‘passwd’, or configure
OpenSSH public key authentication before logging in.

3.6.1.3 Disk Partitioning
.........................

Unless this has already been done, the next step is to partition, and
then format the target partition(s).

   The installation image includes several partitioning tools, including
Parted (*note (parted)Overview::), ‘fdisk’, and ‘cfdisk’.  Run it and
set up your disk with the partition layout you want:

     cfdisk

   If your disk uses the GUID Partition Table (GPT) format and you plan
to install BIOS-based GRUB (which is the default), make sure a BIOS Boot
Partition is available (*note (grub)BIOS installation::).

   If you instead wish to use EFI-based GRUB, a FAT32 “EFI System
Partition” (ESP) is required.  This partition can be mounted at
‘/boot/efi’ for instance and must have the ‘esp’ flag set.  E.g., for
‘parted’:

     parted /dev/sda set 1 esp on

     Note: Unsure whether to use EFI- or BIOS-based GRUB? If the
     directory ‘/sys/firmware/efi’ exists in the installation image,
     then you should probably perform an EFI installation, using
     ‘grub-efi-bootloader’.  Otherwise you should use the BIOS-based
     GRUB, known as ‘grub-bootloader’.  *Note Bootloader
     Configuration::, for more info on bootloaders.

   Once you are done partitioning the target hard disk drive, you have
to create a file system on the relevant partition(s)(1).  For the ESP,
if you have one and assuming it is ‘/dev/sda1’, run:

     mkfs.fat -F32 /dev/sda1

   For the root file system, ext4 is the most widely used format.  Other
file systems, such as Btrfs, support compression, which is reported to
nicely complement file deduplication that the daemon performs
independently of the file system (*note deduplication: Invoking
guix-daemon.).

   Preferably, assign file systems a label so that you can easily and
reliably refer to them in ‘file-system’ declarations (*note File
Systems::).  This is typically done using the ‘-L’ option of ‘mkfs.ext4’
and related commands.  So, assuming the target root partition lives at
‘/dev/sda2’, a file system with the label ‘my-root’ can be created with:

     mkfs.ext4 -L my-root /dev/sda2

   If you are instead planning to encrypt the root partition, you can
use the Cryptsetup/LUKS utilities to do that (see ‘man cryptsetup’ for
more information).  Assuming you want to store the root partition on
‘/dev/sda2’, the command sequence would be along these lines:

     cryptsetup luksFormat /dev/sda2
     cryptsetup open --type luks /dev/sda2 my-partition
     mkfs.ext4 -L my-root /dev/mapper/my-partition

   Once that is done, mount the target file system under ‘/mnt’ with a
command like (again, assuming ‘my-root’ is the label of the root file
system):

     mount LABEL=my-root /mnt

   Also mount any other file systems you would like to use on the target
system relative to this path.  If you have opted for ‘/boot/efi’ as an
EFI mount point for example, mount it at ‘/mnt/boot/efi’ now so it is
found by ‘guix system init’ afterwards.

   Finally, if you plan to use one or more swap partitions (*note swap
space: (libc)Memory Concepts.), make sure to initialize them with
‘mkswap’.  Assuming you have one swap partition on ‘/dev/sda3’, you
would run:

     mkswap /dev/sda3
     swapon /dev/sda3

   Alternatively, you may use a swap file.  For example, assuming that
in the new system you want to use the file ‘/swapfile’ as a swap file,
you would run(2):

     # This is 10 GiB of swap space.  Adjust "count" to change the size.
     dd if=/dev/zero of=/mnt/swapfile bs=1MiB count=10240
     # For security, make the file readable and writable only by root.
     chmod 600 /mnt/swapfile
     mkswap /mnt/swapfile
     swapon /mnt/swapfile

   Note that if you have encrypted the root partition and created a swap
file in its file system as described above, then the encryption also
protects the swap file, just like any other file in that file system.

   ---------- Footnotes ----------

   (1) Currently Guix System only supports ext4, btrfs, and JFS file
systems.  In particular, code that reads file system UUIDs and labels
only works for these file system types.

   (2) This example will work for many types of file systems (e.g.,
ext4).  However, for copy-on-write file systems (e.g., btrfs), the
required steps may be different.  For details, see the manual pages for
‘mkswap’ and ‘swapon’.


File: guix.info,  Node: Proceeding with the Installation,  Prev: Keyboard Layout and Networking and Partitioning,  Up: Manual Installation

3.6.2 Proceeding with the Installation
--------------------------------------

With the target partitions ready and the target root mounted on ‘/mnt’,
we’re ready to go.  First, run:

     herd start cow-store /mnt

   This makes ‘/gnu/store’ copy-on-write, such that packages added to it
during the installation phase are written to the target disk on ‘/mnt’
rather than kept in memory.  This is necessary because the first phase
of the ‘guix system init’ command (see below) entails downloads or
builds to ‘/gnu/store’ which, initially, is an in-memory file system.

   Next, you have to edit a file and provide the declaration of the
operating system to be installed.  To that end, the installation system
comes with three text editors.  We recommend GNU nano (*note
(nano)Top::), which supports syntax highlighting and parentheses
matching; other editors include GNU Zile (an Emacs clone), and nvi (a
clone of the original BSD ‘vi’ editor).  We strongly recommend storing
that file on the target root file system, say, as ‘/mnt/etc/config.scm’.
Failing to do that, you will have lost your configuration file once you
have rebooted into the newly-installed system.

   *Note Using the Configuration System::, for an overview of the
configuration file.  The example configurations discussed in that
section are available under ‘/etc/configuration’ in the installation
image.  Thus, to get started with a system configuration providing a
graphical display server (a “desktop” system), you can run something
along these lines:

     # mkdir /mnt/etc
     # cp /etc/configuration/desktop.scm /mnt/etc/config.scm
     # nano /mnt/etc/config.scm

   You should pay attention to what your configuration file contains,
and in particular:

   • Make sure the ‘bootloader-configuration’ form refers to the target
     you want to install GRUB on.  It should mention ‘grub-bootloader’
     if you are installing GRUB in the legacy way, or
     ‘grub-efi-bootloader’ for newer UEFI systems.  For legacy systems,
     the ‘target’ field names a device, like ‘/dev/sda’; for UEFI
     systems it names a path to a mounted EFI partition, like
     ‘/boot/efi’; do make sure the path is currently mounted and a
     ‘file-system’ entry is specified in your configuration.

   • Be sure that your file system labels match the value of their
     respective ‘device’ fields in your ‘file-system’ configuration,
     assuming your ‘file-system’ configuration uses the
     ‘file-system-label’ procedure in its ‘device’ field.

   • If there are encrypted or RAID partitions, make sure to add a
     ‘mapped-devices’ field to describe them (*note Mapped Devices::).

   Once you are done preparing the configuration file, the new system
must be initialized (remember that the target root file system is
mounted under ‘/mnt’):

     guix system init /mnt/etc/config.scm /mnt

This copies all the necessary files and installs GRUB on ‘/dev/sdX’,
unless you pass the ‘--no-bootloader’ option.  For more information,
*note Invoking guix system::.  This command may trigger downloads or
builds of missing packages, which can take some time.

   Once that command has completed—and hopefully succeeded!—you can run
‘reboot’ and boot into the new system.  The ‘root’ password in the new
system is initially empty; other users’ passwords need to be initialized
by running the ‘passwd’ command as ‘root’, unless your configuration
specifies otherwise (*note user account passwords:
user-account-password.).  *Note After System Installation::, for what’s
next!


File: guix.info,  Node: After System Installation,  Next: Installing Guix in a VM,  Prev: Manual Installation,  Up: System Installation

3.7 After System Installation
=============================

Success, you’ve now booted into Guix System!  From then on, you can
update the system whenever you want by running, say:

     guix pull
     sudo guix system reconfigure /etc/config.scm

This builds a new system generation with the latest packages and
services (*note Invoking guix system::).  We recommend doing that
regularly so that your system includes the latest security updates
(*note Security Updates::).

     Note: Note that ‘sudo guix’ runs your user’s ‘guix’ command and
     _not_ root’s, because ‘sudo’ leaves ‘PATH’ unchanged.  To
     explicitly run root’s ‘guix’, type ‘sudo -i guix ...’.

     The difference matters here, because ‘guix pull’ updates the ‘guix’
     command and package definitions only for the user it is ran as.
     This means that if you choose to use ‘guix system reconfigure’ in
     root’s login shell, you’ll need to ‘guix pull’ separately.

   Join us on ‘#guix’ on the Freenode IRC network or on
<guix-devel@gnu.org> to share your experience!


File: guix.info,  Node: Installing Guix in a VM,  Next: Building the Installation Image,  Prev: After System Installation,  Up: System Installation

3.8 Installing Guix in a Virtual Machine
========================================

If you’d like to install Guix System in a virtual machine (VM) or on a
virtual private server (VPS) rather than on your beloved machine, this
section is for you.

   To boot a QEMU (https://qemu.org/) VM for installing Guix System in a
disk image, follow these steps:

  1. First, retrieve and decompress the Guix system installation image
     as described previously (*note USB Stick and DVD Installation::).

  2. Create a disk image that will hold the installed system.  To make a
     qcow2-formatted disk image, use the ‘qemu-img’ command:

          qemu-img create -f qcow2 guix-system.img 50G

     The resulting file will be much smaller than 50 GB (typically less
     than 1 MB), but it will grow as the virtualized storage device is
     filled up.

  3. Boot the USB installation image in an VM:

          qemu-system-x86_64 -m 1024 -smp 1 -enable-kvm \
            -nic user,model=virtio-net-pci -boot menu=on,order=d \
            -drive file=guix-system.img \
            -drive media=cdrom,file=guix-system-install-1.0.1.17089-7e269.SYSTEM.iso

     ‘-enable-kvm’ is optional, but significantly improves performance,
     *note Running Guix in a VM::.

  4. You’re now root in the VM, proceed with the installation process.
     *Note Preparing for Installation::, and follow the instructions.

   Once installation is complete, you can boot the system that’s on your
‘guix-system.img’ image.  *Note Running Guix in a VM::, for how to do
that.


File: guix.info,  Node: Building the Installation Image,  Prev: Installing Guix in a VM,  Up: System Installation

3.9 Building the Installation Image
===================================

The installation image described above was built using the ‘guix system’
command, specifically:

     guix system disk-image --file-system-type=iso9660 \
       gnu/system/install.scm

   Have a look at ‘gnu/system/install.scm’ in the source tree, and see
also *note Invoking guix system:: for more information about the
installation image.

3.10 Building the Installation Image for ARM Boards
===================================================

Many ARM boards require a specific variant of the U-Boot
(https://www.denx.de/wiki/U-Boot/) bootloader.

   If you build a disk image and the bootloader is not available
otherwise (on another boot drive etc), it’s advisable to build an image
that includes the bootloader, specifically:

     guix system disk-image --system=armhf-linux -e '((@ (gnu system install) os-with-u-boot) (@ (gnu system install) installation-os) "A20-OLinuXino-Lime2")'

   ‘A20-OLinuXino-Lime2’ is the name of the board.  If you specify an
invalid board, a list of possible boards will be printed.


File: guix.info,  Node: Package Management,  Next: Development,  Prev: System Installation,  Up: Top

4 Package Management
********************

The purpose of GNU Guix is to allow users to easily install, upgrade,
and remove software packages, without having to know about their build
procedures or dependencies.  Guix also goes beyond this obvious set of
features.

   This chapter describes the main features of Guix, as well as the
package management tools it provides.  Along with the command-line
interface described below (*note ‘guix package’: Invoking guix
package.), you may also use the Emacs-Guix interface (*note
(emacs-guix)Top::), after installing ‘emacs-guix’ package (run ‘M-x
guix-help’ command to start with it):

     guix install emacs-guix

* Menu:

* Features::                    How Guix will make your life brighter.
* Invoking guix package::       Package installation, removal, etc.
* Substitutes::                 Downloading pre-built binaries.
* Packages with Multiple Outputs::  Single source package, multiple outputs.
* Invoking guix gc::            Running the garbage collector.
* Invoking guix pull::          Fetching the latest Guix and distribution.
* Channels::                    Customizing the package collection.
* Invoking guix time-machine::  Running an older revision of Guix.
* Inferiors::                   Interacting with another revision of Guix.
* Invoking guix describe::      Display information about your Guix revision.
* Invoking guix archive::       Exporting and importing store files.


File: guix.info,  Node: Features,  Next: Invoking guix package,  Up: Package Management

4.1 Features
============

When using Guix, each package ends up in the “package store”, in its own
directory—something that resembles ‘/gnu/store/xxx-package-1.2’, where
‘xxx’ is a base32 string.

   Instead of referring to these directories, users have their own
“profile”, which points to the packages that they actually want to use.
These profiles are stored within each user’s home directory, at
‘$HOME/.guix-profile’.

   For example, ‘alice’ installs GCC 4.7.2.  As a result,
‘/home/alice/.guix-profile/bin/gcc’ points to
‘/gnu/store/...-gcc-4.7.2/bin/gcc’.  Now, on the same machine, ‘bob’ had
already installed GCC 4.8.0.  The profile of ‘bob’ simply continues to
point to ‘/gnu/store/...-gcc-4.8.0/bin/gcc’—i.e., both versions of GCC
coexist on the same system without any interference.

   The ‘guix package’ command is the central tool to manage packages
(*note Invoking guix package::).  It operates on the per-user profiles,
and can be used _with normal user privileges_.

   The command provides the obvious install, remove, and upgrade
operations.  Each invocation is actually a _transaction_: either the
specified operation succeeds, or nothing happens.  Thus, if the ‘guix
package’ process is terminated during the transaction, or if a power
outage occurs during the transaction, then the user’s profile remains in
its previous state, and remains usable.

   In addition, any package transaction may be _rolled back_.  So, if,
for example, an upgrade installs a new version of a package that turns
out to have a serious bug, users may roll back to the previous instance
of their profile, which was known to work well.  Similarly, the global
system configuration on Guix is subject to transactional upgrades and
roll-back (*note Using the Configuration System::).

   All packages in the package store may be _garbage-collected_.  Guix
can determine which packages are still referenced by user profiles, and
remove those that are provably no longer referenced (*note Invoking guix
gc::).  Users may also explicitly remove old generations of their
profile so that the packages they refer to can be collected.

   Guix takes a “purely functional” approach to package management, as
described in the introduction (*note Introduction::).  Each ‘/gnu/store’
package directory name contains a hash of all the inputs that were used
to build that package—compiler, libraries, build scripts, etc.  This
direct correspondence allows users to make sure a given package
installation matches the current state of their distribution.  It also
helps maximize “build reproducibility”: thanks to the isolated build
environments that are used, a given build is likely to yield
bit-identical files when performed on different machines (*note
container: Invoking guix-daemon.).

   This foundation allows Guix to support “transparent binary/source
deployment”.  When a pre-built binary for a ‘/gnu/store’ item is
available from an external source—a “substitute”, Guix just downloads it
and unpacks it; otherwise, it builds the package from source, locally
(*note Substitutes::).  Because build results are usually bit-for-bit
reproducible, users do not have to trust servers that provide
substitutes: they can force a local build and _challenge_ providers
(*note Invoking guix challenge::).

   Control over the build environment is a feature that is also useful
for developers.  The ‘guix environment’ command allows developers of a
package to quickly set up the right development environment for their
package, without having to manually install the dependencies of the
package into their profile (*note Invoking guix environment::).

   All of Guix and its package definitions is version-controlled, and
‘guix pull’ allows you to “travel in time” on the history of Guix itself
(*note Invoking guix pull::).  This makes it possible to replicate a
Guix instance on a different machine or at a later point in time, which
in turn allows you to _replicate complete software environments_, while
retaining precise “provenance tracking” of the software.


File: guix.info,  Node: Invoking guix package,  Next: Substitutes,  Prev: Features,  Up: Package Management

4.2 Invoking ‘guix package’
===========================

The ‘guix package’ command is the tool that allows users to install,
upgrade, and remove packages, as well as rolling back to previous
configurations.  It operates only on the user’s own profile, and works
with normal user privileges (*note Features::).  Its syntax is:

     guix package OPTIONS

   Primarily, OPTIONS specifies the operations to be performed during
the transaction.  Upon completion, a new profile is created, but
previous “generations” of the profile remain available, should the user
want to roll back.

   For example, to remove ‘lua’ and install ‘guile’ and ‘guile-cairo’ in
a single transaction:

     guix package -r lua -i guile guile-cairo

   For your convenience, we also provide the following aliases:

   • ‘guix search’ is an alias for ‘guix package -s’,
   • ‘guix install’ is an alias for ‘guix package -i’,
   • ‘guix remove’ is an alias for ‘guix package -r’,
   • ‘guix upgrade’ is an alias for ‘guix package -u’,
   • and ‘guix show’ is an alias for ‘guix package --show=’.

   These aliases are less expressive than ‘guix package’ and provide
fewer options, so in some cases you’ll probably want to use ‘guix
package’ directly.

   ‘guix package’ also supports a “declarative approach” whereby the
user specifies the exact set of packages to be available and passes it
via the ‘--manifest’ option (*note ‘--manifest’: profile-manifest.).

   For each user, a symlink to the user’s default profile is
automatically created in ‘$HOME/.guix-profile’.  This symlink always
points to the current generation of the user’s default profile.  Thus,
users can add ‘$HOME/.guix-profile/bin’ to their ‘PATH’ environment
variable, and so on.  If you are not using Guix System, consider adding
the following lines to your ‘~/.bash_profile’ (*note (bash)Bash Startup
Files::) so that newly-spawned shells get all the right environment
variable definitions:

     GUIX_PROFILE="$HOME/.guix-profile" ; \
     source "$HOME/.guix-profile/etc/profile"

   In a multi-user setup, user profiles are stored in a place registered
as a “garbage-collector root”, which ‘$HOME/.guix-profile’ points to
(*note Invoking guix gc::).  That directory is normally
‘LOCALSTATEDIR/guix/profiles/per-user/USER’, where LOCALSTATEDIR is the
value passed to ‘configure’ as ‘--localstatedir’, and USER is the user
name.  The ‘per-user’ directory is created when ‘guix-daemon’ is
started, and the USER sub-directory is created by ‘guix package’.

   The OPTIONS can be among the following:

‘--install=PACKAGE ...’
‘-i PACKAGE ...’
     Install the specified PACKAGEs.

     Each PACKAGE may specify either a simple package name, such as
     ‘guile’, or a package name followed by an at-sign and version
     number, such as ‘guile@1.8.8’ or simply ‘guile@1.8’ (in the latter
     case, the newest version prefixed by ‘1.8’ is selected).

     If no version number is specified, the newest available version
     will be selected.  In addition, PACKAGE may contain a colon,
     followed by the name of one of the outputs of the package, as in
     ‘gcc:doc’ or ‘binutils@2.22:lib’ (*note Packages with Multiple
     Outputs::).  Packages with a corresponding name (and optionally
     version) are searched for among the GNU distribution modules (*note
     Package Modules::).

     Sometimes packages have “propagated inputs”: these are dependencies
     that automatically get installed along with the required package
     (*note ‘propagated-inputs’ in ‘package’ objects:
     package-propagated-inputs, for information about propagated inputs
     in package definitions).

     An example is the GNU MPC library: its C header files refer to
     those of the GNU MPFR library, which in turn refer to those of the
     GMP library.  Thus, when installing MPC, the MPFR and GMP libraries
     also get installed in the profile; removing MPC also removes MPFR
     and GMP—unless they had also been explicitly installed by the user.

     Besides, packages sometimes rely on the definition of environment
     variables for their search paths (see explanation of
     ‘--search-paths’ below).  Any missing or possibly incorrect
     environment variable definitions are reported here.

‘--install-from-expression=EXP’
‘-e EXP’
     Install the package EXP evaluates to.

     EXP must be a Scheme expression that evaluates to a ‘<package>’
     object.  This option is notably useful to disambiguate between
     same-named variants of a package, with expressions such as ‘(@ (gnu
     packages base) guile-final)’.

     Note that this option installs the first output of the specified
     package, which may be insufficient when needing a specific output
     of a multiple-output package.

‘--install-from-file=FILE’
‘-f FILE’
     Install the package that the code within FILE evaluates to.

     As an example, FILE might contain a definition like this (*note
     Defining Packages::):

          (use-modules (guix)
                       (guix build-system gnu)
                       (guix licenses))

          (package
            (name "hello")
            (version "2.10")
            (source (origin
                      (method url-fetch)
                      (uri (string-append "mirror://gnu/hello/hello-" version
                                          ".tar.gz"))
                      (sha256
                       (base32
                        "0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i"))))
            (build-system gnu-build-system)
            (synopsis "Hello, GNU world: An example GNU package")
            (description "Guess what GNU Hello prints!")
            (home-page "http://www.gnu.org/software/hello/")
            (license gpl3+))

     Developers may find it useful to include such a ‘guix.scm’ file in
     the root of their project source tree that can be used to test
     development snapshots and create reproducible development
     environments (*note Invoking guix environment::).

     The FILE may also contain a JSON representation of one or more
     package definitions.  Running ‘guix package -f’ on ‘hello.json’
     with the following contents would result in installing the package
     ‘greeter’ after building ‘myhello’:

          [
            {
              "name": "myhello",
              "version": "2.10",
              "source": "mirror://gnu/hello/hello-2.10.tar.gz",
              "build-system": "gnu",
              "arguments": {
                "tests?": false
              }
              "home-page": "https://www.gnu.org/software/hello/",
              "synopsis": "Hello, GNU world: An example GNU package",
              "description": "GNU Hello prints a greeting.",
              "license": "GPL-3.0+",
              "native-inputs": ["gettext"]
            },
            {
              "name": "greeter",
              "version": "1.0",
              "source": "https://example.com/greeter-1.0.tar.gz",
              "build-system": "gnu",
              "arguments": {
                "test-target": "foo",
                "parallel-build?": false,
              },
              "home-page": "https://example.com/",
              "synopsis": "Greeter using GNU Hello",
              "description": "This is a wrapper around GNU Hello.",
              "license": "GPL-3.0+",
              "inputs": ["myhello", "hello"]
            }
          ]

‘--remove=PACKAGE ...’
‘-r PACKAGE ...’
     Remove the specified PACKAGEs.

     As for ‘--install’, each PACKAGE may specify a version number
     and/or output name in addition to the package name.  For instance,
     ‘-r glibc:debug’ would remove the ‘debug’ output of ‘glibc’.

‘--upgrade[=REGEXP ...]’
‘-u [REGEXP ...]’
     Upgrade all the installed packages.  If one or more REGEXPs are
     specified, upgrade only installed packages whose name matches a
     REGEXP.  Also see the ‘--do-not-upgrade’ option below.

     Note that this upgrades package to the latest version of packages
     found in the distribution currently installed.  To update your
     distribution, you should regularly run ‘guix pull’ (*note Invoking
     guix pull::).

‘--do-not-upgrade[=REGEXP ...]’
     When used together with the ‘--upgrade’ option, do _not_ upgrade
     any packages whose name matches a REGEXP.  For example, to upgrade
     all packages in the current profile except those containing the
     substring “emacs”:

          $ guix package --upgrade . --do-not-upgrade emacs

‘--manifest=FILE’
‘-m FILE’
     Create a new generation of the profile from the manifest object
     returned by the Scheme code in FILE.  This option can be repeated
     several times, in which case the manifests are concatenated.

     This allows you to _declare_ the profile’s contents rather than
     constructing it through a sequence of ‘--install’ and similar
     commands.  The advantage is that FILE can be put under version
     control, copied to different machines to reproduce the same
     profile, and so on.

     FILE must return a “manifest” object, which is roughly a list of
     packages:

          (use-package-modules guile emacs)

          (packages->manifest
           (list emacs
                 guile-2.0
                 ;; Use a specific package output.
                 (list guile-2.0 "debug")))

     In this example we have to know which modules define the ‘emacs’
     and ‘guile-2.0’ variables to provide the right
     ‘use-package-modules’ line, which can be cumbersome.  We can
     instead provide regular package specifications and let
     ‘specifications->manifest’ look up the corresponding package
     objects, like this:

          (specifications->manifest
           '("emacs" "guile@2.2" "guile@2.2:debug"))

‘--roll-back’
     Roll back to the previous “generation” of the profile—i.e., undo
     the last transaction.

     When combined with options such as ‘--install’, roll back occurs
     before any other actions.

     When rolling back from the first generation that actually contains
     installed packages, the profile is made to point to the “zeroth
     generation”, which contains no files apart from its own metadata.

     After having rolled back, installing, removing, or upgrading
     packages overwrites previous future generations.  Thus, the history
     of the generations in a profile is always linear.

‘--switch-generation=PATTERN’
‘-S PATTERN’
     Switch to a particular generation defined by PATTERN.

     PATTERN may be either a generation number or a number prefixed with
     “+” or “-”.  The latter means: move forward/backward by a specified
     number of generations.  For example, if you want to return to the
     latest generation after ‘--roll-back’, use
     ‘--switch-generation=+1’.

     The difference between ‘--roll-back’ and ‘--switch-generation=-1’
     is that ‘--switch-generation’ will not make a zeroth generation, so
     if a specified generation does not exist, the current generation
     will not be changed.

‘--search-paths[=KIND]’
     Report environment variable definitions, in Bash syntax, that may
     be needed in order to use the set of installed packages.  These
     environment variables are used to specify “search paths” for files
     used by some of the installed packages.

     For example, GCC needs the ‘CPATH’ and ‘LIBRARY_PATH’ environment
     variables to be defined so it can look for headers and libraries in
     the user’s profile (*note (gcc)Environment Variables::).  If GCC
     and, say, the C library are installed in the profile, then
     ‘--search-paths’ will suggest setting these variables to
     ‘PROFILE/include’ and ‘PROFILE/lib’, respectively.

     The typical use case is to define these environment variables in
     the shell:

          $ eval `guix package --search-paths`

     KIND may be one of ‘exact’, ‘prefix’, or ‘suffix’, meaning that the
     returned environment variable definitions will either be exact
     settings, or prefixes or suffixes of the current value of these
     variables.  When omitted, KIND defaults to ‘exact’.

     This option can also be used to compute the _combined_ search paths
     of several profiles.  Consider this example:

          $ guix package -p foo -i guile
          $ guix package -p bar -i guile-json
          $ guix package -p foo -p bar --search-paths

     The last command above reports about the ‘GUILE_LOAD_PATH’
     variable, even though, taken individually, neither ‘foo’ nor ‘bar’
     would lead to that recommendation.

‘--profile=PROFILE’
‘-p PROFILE’
     Use PROFILE instead of the user’s default profile.

     PROFILE must be the name of a file that will be created upon
     completion.  Concretely, PROFILE will be a mere symbolic link
     (“symlink”) pointing to the actual profile where packages are
     installed:

          $ guix install hello -p ~/code/my-profile
          ...
          $ ~/code/my-profile/bin/hello
          Hello, world!

     All it takes to get rid of the profile is to remove this symlink
     and its siblings that point to specific generations:

          $ rm ~/code/my-profile ~/code/my-profile-*-link

‘--list-profiles’
     List all the user’s profiles:

          $ guix package --list-profiles
          /home/charlie/.guix-profile
          /home/charlie/code/my-profile
          /home/charlie/code/devel-profile
          /home/charlie/tmp/test

     When running as root, list all the profiles of all the users.

‘--allow-collisions’
     Allow colliding packages in the new profile.  Use at your own risk!

     By default, ‘guix package’ reports as an error “collisions” in the
     profile.  Collisions happen when two or more different versions or
     variants of a given package end up in the profile.

‘--bootstrap’
     Use the bootstrap Guile to build the profile.  This option is only
     useful to distribution developers.

   In addition to these actions, ‘guix package’ supports the following
options to query the current state of a profile, or the availability of
packages:

‘--search=REGEXP’
‘-s REGEXP’
     List the available packages whose name, synopsis, or description
     matches REGEXP (in a case-insensitive fashion), sorted by
     relevance.  Print all the metadata of matching packages in
     ‘recutils’ format (*note GNU recutils databases: (recutils)Top.).

     This allows specific fields to be extracted using the ‘recsel’
     command, for instance:

          $ guix package -s malloc | recsel -p name,version,relevance
          name: jemalloc
          version: 4.5.0
          relevance: 6

          name: glibc
          version: 2.25
          relevance: 1

          name: libgc
          version: 7.6.0
          relevance: 1

     Similarly, to show the name of all the packages available under the
     terms of the GNU LGPL version 3:

          $ guix package -s "" | recsel -p name -e 'license ~ "LGPL 3"'
          name: elfutils

          name: gmp
          ...

     It is also possible to refine search results using several ‘-s’
     flags to ‘guix package’, or several arguments to ‘guix search’.
     For example, the following command returns a list of board games
     (this time using the ‘guix search’ alias):

          $ guix search '\<board\>' game | recsel -p name
          name: gnubg
          ...

     If we were to omit ‘-s game’, we would also get software packages
     that deal with printed circuit boards; removing the angle brackets
     around ‘board’ would further add packages that have to do with
     keyboards.

     And now for a more elaborate example.  The following command
     searches for cryptographic libraries, filters out Haskell, Perl,
     Python, and Ruby libraries, and prints the name and synopsis of the
     matching packages:

          $ guix search crypto library | \
              recsel -e '! (name ~ "^(ghc|perl|python|ruby)")' -p name,synopsis

     *Note (recutils)Selection Expressions::, for more information on
     “selection expressions” for ‘recsel -e’.

‘--show=PACKAGE’
     Show details about PACKAGE, taken from the list of available
     packages, in ‘recutils’ format (*note GNU recutils databases:
     (recutils)Top.).

          $ guix package --show=python | recsel -p name,version
          name: python
          version: 2.7.6

          name: python
          version: 3.3.5

     You may also specify the full name of a package to only get details
     about a specific version of it (this time using the ‘guix show’
     alias):
          $ guix show python@3.4 | recsel -p name,version
          name: python
          version: 3.4.3

‘--list-installed[=REGEXP]’
‘-I [REGEXP]’
     List the currently installed packages in the specified profile,
     with the most recently installed packages shown last.  When REGEXP
     is specified, list only installed packages whose name matches
     REGEXP.

     For each installed package, print the following items, separated by
     tabs: the package name, its version string, the part of the package
     that is installed (for instance, ‘out’ for the default output,
     ‘include’ for its headers, etc.), and the path of this package in
     the store.

‘--list-available[=REGEXP]’
‘-A [REGEXP]’
     List packages currently available in the distribution for this
     system (*note GNU Distribution::).  When REGEXP is specified, list
     only available packages whose name matches REGEXP.

     For each package, print the following items separated by tabs: its
     name, its version string, the parts of the package (*note Packages
     with Multiple Outputs::), and the source location of its
     definition.

‘--list-generations[=PATTERN]’
‘-l [PATTERN]’
     Return a list of generations along with their creation dates; for
     each generation, show the installed packages, with the most
     recently installed packages shown last.  Note that the zeroth
     generation is never shown.

     For each installed package, print the following items, separated by
     tabs: the name of a package, its version string, the part of the
     package that is installed (*note Packages with Multiple Outputs::),
     and the location of this package in the store.

     When PATTERN is used, the command returns only matching
     generations.  Valid patterns include:

        • _Integers and comma-separated integers_.  Both patterns denote
          generation numbers.  For instance, ‘--list-generations=1’
          returns the first one.

          And ‘--list-generations=1,8,2’ outputs three generations in
          the specified order.  Neither spaces nor trailing commas are
          allowed.

        • _Ranges_.  ‘--list-generations=2..9’ prints the specified
          generations and everything in between.  Note that the start of
          a range must be smaller than its end.

          It is also possible to omit the endpoint.  For example,
          ‘--list-generations=2..’, returns all generations starting
          from the second one.

        • _Durations_.  You can also get the last _N_ days, weeks, or
          months by passing an integer along with the first letter of
          the duration.  For example, ‘--list-generations=20d’ lists
          generations that are up to 20 days old.

‘--delete-generations[=PATTERN]’
‘-d [PATTERN]’
     When PATTERN is omitted, delete all generations except the current
     one.

     This command accepts the same patterns as ‘--list-generations’.
     When PATTERN is specified, delete the matching generations.  When
     PATTERN specifies a duration, generations _older_ than the
     specified duration match.  For instance, ‘--delete-generations=1m’
     deletes generations that are more than one month old.

     If the current generation matches, it is _not_ deleted.  Also, the
     zeroth generation is never deleted.

     Note that deleting generations prevents rolling back to them.
     Consequently, this command must be used with care.

   Finally, since ‘guix package’ may actually start build processes, it
supports all the common build options (*note Common Build Options::).
It also supports package transformation options, such as ‘--with-source’
(*note Package Transformation Options::).  However, note that package
transformations are lost when upgrading; to preserve transformations
across upgrades, you should define your own package variant in a Guile
module and add it to ‘GUIX_PACKAGE_PATH’ (*note Defining Packages::).


File: guix.info,  Node: Substitutes,  Next: Packages with Multiple Outputs,  Prev: Invoking guix package,  Up: Package Management

4.3 Substitutes
===============

Guix supports transparent source/binary deployment, which means that it
can either build things locally, or download pre-built items from a
server, or both.  We call these pre-built items “substitutes”—they are
substitutes for local build results.  In many cases, downloading a
substitute is much faster than building things locally.

   Substitutes can be anything resulting from a derivation build (*note
Derivations::).  Of course, in the common case, they are pre-built
package binaries, but source tarballs, for instance, which also result
from derivation builds, can be available as substitutes.

* Menu:

* Official Substitute Server::  One particular source of substitutes.
* Substitute Server Authorization::  How to enable or disable substitutes.
* Substitute Authentication::   How Guix verifies substitutes.
* Proxy Settings::              How to get substitutes via proxy.
* Substitution Failure::        What happens when substitution fails.
* On Trusting Binaries::        How can you trust that binary blob?


File: guix.info,  Node: Official Substitute Server,  Next: Substitute Server Authorization,  Up: Substitutes

4.3.1 Official Substitute Server
--------------------------------

The ‘ci.guix.gnu.org’ server is a front-end to an official build farm
that builds packages from Guix continuously for some architectures, and
makes them available as substitutes.  This is the default source of
substitutes; it can be overridden by passing the ‘--substitute-urls’
option either to ‘guix-daemon’ (*note ‘guix-daemon --substitute-urls’:
daemon-substitute-urls.) or to client tools such as ‘guix package’
(*note client ‘--substitute-urls’ option: client-substitute-urls.).

   Substitute URLs can be either HTTP or HTTPS. HTTPS is recommended
because communications are encrypted; conversely, using HTTP makes all
communications visible to an eavesdropper, who could use the information
gathered to determine, for instance, whether your system has unpatched
security vulnerabilities.

   Substitutes from the official build farm are enabled by default when
using Guix System (*note GNU Distribution::).  However, they are
disabled by default when using Guix on a foreign distribution, unless
you have explicitly enabled them via one of the recommended installation
steps (*note Installation::).  The following paragraphs describe how to
enable or disable substitutes for the official build farm; the same
procedure can also be used to enable substitutes for any other
substitute server.


File: guix.info,  Node: Substitute Server Authorization,  Next: Substitute Authentication,  Prev: Official Substitute Server,  Up: Substitutes

4.3.2 Substitute Server Authorization
-------------------------------------

To allow Guix to download substitutes from ‘ci.guix.gnu.org’ or a mirror
thereof, you must add its public key to the access control list (ACL) of
archive imports, using the ‘guix archive’ command (*note Invoking guix
archive::).  Doing so implies that you trust ‘ci.guix.gnu.org’ to not be
compromised and to serve genuine substitutes.

   The public key for ‘ci.guix.gnu.org’ is installed along with Guix, in
‘PREFIX/share/guix/ci.guix.gnu.org.pub’, where PREFIX is the
installation prefix of Guix.  If you installed Guix from source, make
sure you checked the GPG signature of ‘guix-1.0.1.17089-7e269.tar.gz’,
which contains this public key file.  Then, you can run something like
this:

     # guix archive --authorize < PREFIX/share/guix/ci.guix.gnu.org.pub

   Once this is in place, the output of a command like ‘guix build’
should change from something like:

     $ guix build emacs --dry-run
     The following derivations would be built:
        /gnu/store/yr7bnx8xwcayd6j95r2clmkdl1qh688w-emacs-24.3.drv
        /gnu/store/x8qsh1hlhgjx6cwsjyvybnfv2i37z23w-dbus-1.6.4.tar.gz.drv
        /gnu/store/1ixwp12fl950d15h2cj11c73733jay0z-alsa-lib-1.0.27.1.tar.bz2.drv
        /gnu/store/nlma1pw0p603fpfiqy7kn4zm105r5dmw-util-linux-2.21.drv
     ...

to something like:

     $ guix build emacs --dry-run
     112.3 MB would be downloaded:
        /gnu/store/pk3n22lbq6ydamyymqkkz7i69wiwjiwi-emacs-24.3
        /gnu/store/2ygn4ncnhrpr61rssa6z0d9x22si0va3-libjpeg-8d
        /gnu/store/71yz6lgx4dazma9dwn2mcjxaah9w77jq-cairo-1.12.16
        /gnu/store/7zdhgp0n1518lvfn8mb96sxqfmvqrl7v-libxrender-0.9.7
     ...

The text changed from “The following derivations would be built” to
“112.3 MB would be downloaded”.  This indicates that substitutes from
‘ci.guix.gnu.org’ are usable and will be downloaded, when possible, for
future builds.

   The substitute mechanism can be disabled globally by running
‘guix-daemon’ with ‘--no-substitutes’ (*note Invoking guix-daemon::).
It can also be disabled temporarily by passing the ‘--no-substitutes’
option to ‘guix package’, ‘guix build’, and other command-line tools.


File: guix.info,  Node: Substitute Authentication,  Next: Proxy Settings,  Prev: Substitute Server Authorization,  Up: Substitutes

4.3.3 Substitute Authentication
-------------------------------

Guix detects and raises an error when attempting to use a substitute
that has been tampered with.  Likewise, it ignores substitutes that are
not signed, or that are not signed by one of the keys listed in the ACL.

   There is one exception though: if an unauthorized server provides
substitutes that are _bit-for-bit identical_ to those provided by an
authorized server, then the unauthorized server becomes eligible for
downloads.  For example, assume we have chosen two substitute servers
with this option:

     --substitute-urls="https://a.example.org https://b.example.org"

If the ACL contains only the key for ‘b.example.org’, and if
‘a.example.org’ happens to serve the _exact same_ substitutes, then Guix
will download substitutes from ‘a.example.org’ because it comes first in
the list and can be considered a mirror of ‘b.example.org’.  In
practice, independent build machines usually produce the same binaries,
thanks to bit-reproducible builds (see below).

   When using HTTPS, the server’s X.509 certificate is _not_ validated
(in other words, the server is not authenticated), contrary to what
HTTPS clients such as Web browsers usually do.  This is because Guix
authenticates substitute information itself, as explained above, which
is what we care about (whereas X.509 certificates are about
authenticating bindings between domain names and public keys).


File: guix.info,  Node: Proxy Settings,  Next: Substitution Failure,  Prev: Substitute Authentication,  Up: Substitutes

4.3.4 Proxy Settings
--------------------

Substitutes are downloaded over HTTP or HTTPS. The ‘http_proxy’ and
‘https_proxy’ environment variables can be set in the environment of
‘guix-daemon’ and are honored for downloads of substitutes.  Note that
the value of those environment variables in the environment where ‘guix
build’, ‘guix package’, and other client commands are run has
_absolutely no effect_.


File: guix.info,  Node: Substitution Failure,  Next: On Trusting Binaries,  Prev: Proxy Settings,  Up: Substitutes

4.3.5 Substitution Failure
--------------------------

Even when a substitute for a derivation is available, sometimes the
substitution attempt will fail.  This can happen for a variety of
reasons: the substitute server might be offline, the substitute may
recently have been deleted, the connection might have been interrupted,
etc.

   When substitutes are enabled and a substitute for a derivation is
available, but the substitution attempt fails, Guix will attempt to
build the derivation locally depending on whether or not ‘--fallback’
was given (*note common build option ‘--fallback’: fallback-option.).
Specifically, if ‘--fallback’ was omitted, then no local build will be
performed, and the derivation is considered to have failed.  However, if
‘--fallback’ was given, then Guix will attempt to build the derivation
locally, and the success or failure of the derivation depends on the
success or failure of the local build.  Note that when substitutes are
disabled or no substitute is available for the derivation in question, a
local build will _always_ be performed, regardless of whether or not
‘--fallback’ was given.

   To get an idea of how many substitutes are available right now, you
can try running the ‘guix weather’ command (*note Invoking guix
weather::).  This command provides statistics on the substitutes
provided by a server.


File: guix.info,  Node: On Trusting Binaries,  Prev: Substitution Failure,  Up: Substitutes

4.3.6 On Trusting Binaries
--------------------------

Today, each individual’s control over their own computing is at the
mercy of institutions, corporations, and groups with enough power and
determination to subvert the computing infrastructure and exploit its
weaknesses.  While using ‘ci.guix.gnu.org’ substitutes can be
convenient, we encourage users to also build on their own, or even run
their own build farm, such that ‘ci.guix.gnu.org’ is less of an
interesting target.  One way to help is by publishing the software you
build using ‘guix publish’ so that others have one more choice of server
to download substitutes from (*note Invoking guix publish::).

   Guix has the foundations to maximize build reproducibility (*note
Features::).  In most cases, independent builds of a given package or
derivation should yield bit-identical results.  Thus, through a diverse
set of independent package builds, we can strengthen the integrity of
our systems.  The ‘guix challenge’ command aims to help users assess
substitute servers, and to assist developers in finding out about
non-deterministic package builds (*note Invoking guix challenge::).
Similarly, the ‘--check’ option of ‘guix build’ allows users to check
whether previously-installed substitutes are genuine by rebuilding them
locally (*note ‘guix build --check’: build-check.).

   In the future, we want Guix to have support to publish and retrieve
binaries to/from other users, in a peer-to-peer fashion.  If you would
like to discuss this project, join us on <guix-devel@gnu.org>.


File: guix.info,  Node: Packages with Multiple Outputs,  Next: Invoking guix gc,  Prev: Substitutes,  Up: Package Management

4.4 Packages with Multiple Outputs
==================================

Often, packages defined in Guix have a single “output”—i.e., the source
package leads to exactly one directory in the store.  When running ‘guix
install glibc’, one installs the default output of the GNU libc package;
the default output is called ‘out’, but its name can be omitted as shown
in this command.  In this particular case, the default output of ‘glibc’
contains all the C header files, shared libraries, static libraries,
Info documentation, and other supporting files.

   Sometimes it is more appropriate to separate the various types of
files produced from a single source package into separate outputs.  For
instance, the GLib C library (used by GTK+ and related packages)
installs more than 20 MiB of reference documentation as HTML pages.  To
save space for users who do not need it, the documentation goes to a
separate output, called ‘doc’.  To install the main GLib output, which
contains everything but the documentation, one would run:

     guix install glib

   The command to install its documentation is:

     guix install glib:doc

   Some packages install programs with different “dependency
footprints”.  For instance, the WordNet package installs both
command-line tools and graphical user interfaces (GUIs).  The former
depend solely on the C library, whereas the latter depend on Tcl/Tk and
the underlying X libraries.  In this case, we leave the command-line
tools in the default output, whereas the GUIs are in a separate output.
This allows users who do not need the GUIs to save space.  The ‘guix
size’ command can help find out about such situations (*note Invoking
guix size::).  ‘guix graph’ can also be helpful (*note Invoking guix
graph::).

   There are several such multiple-output packages in the GNU
distribution.  Other conventional output names include ‘lib’ for
libraries and possibly header files, ‘bin’ for stand-alone programs, and
‘debug’ for debugging information (*note Installing Debugging Files::).
The outputs of a packages are listed in the third column of the output
of ‘guix package --list-available’ (*note Invoking guix package::).


File: guix.info,  Node: Invoking guix gc,  Next: Invoking guix pull,  Prev: Packages with Multiple Outputs,  Up: Package Management

4.5 Invoking ‘guix gc’
======================

Packages that are installed, but not used, may be “garbage-collected”.
The ‘guix gc’ command allows users to explicitly run the garbage
collector to reclaim space from the ‘/gnu/store’ directory.  It is the
_only_ way to remove files from ‘/gnu/store’—removing files or
directories manually may break it beyond repair!

   The garbage collector has a set of known “roots”: any file under
‘/gnu/store’ reachable from a root is considered “live” and cannot be
deleted; any other file is considered “dead” and may be deleted.  The
set of garbage collector roots (“GC roots” for short) includes default
user profiles; by default, the symlinks under ‘/var/guix/gcroots’
represent these GC roots.  New GC roots can be added with ‘guix build
--root’, for example (*note Invoking guix build::).  The ‘guix gc
--list-roots’ command lists them.

   Prior to running ‘guix gc --collect-garbage’ to make space, it is
often useful to remove old generations from user profiles; that way, old
package builds referenced by those generations can be reclaimed.  This
is achieved by running ‘guix package --delete-generations’ (*note
Invoking guix package::).

   Our recommendation is to run a garbage collection periodically, or
when you are short on disk space.  For instance, to guarantee that at
least 5 GB are available on your disk, simply run:

     guix gc -F 5G

   It is perfectly safe to run as a non-interactive periodic job (*note
Scheduled Job Execution::, for how to set up such a job).  Running ‘guix
gc’ with no arguments will collect as much garbage as it can, but that
is often inconvenient: you may find yourself having to rebuild or
re-download software that is “dead” from the GC viewpoint but that is
necessary to build other pieces of software—e.g., the compiler tool
chain.

   The ‘guix gc’ command has three modes of operation: it can be used to
garbage-collect any dead files (the default), to delete specific files
(the ‘--delete’ option), to print garbage-collector information, or for
more advanced queries.  The garbage collection options are as follows:

‘--collect-garbage[=MIN]’
‘-C [MIN]’
     Collect garbage—i.e., unreachable ‘/gnu/store’ files and
     sub-directories.  This is the default operation when no option is
     specified.

     When MIN is given, stop once MIN bytes have been collected.  MIN
     may be a number of bytes, or it may include a unit as a suffix,
     such as ‘MiB’ for mebibytes and ‘GB’ for gigabytes (*note size
     specifications: (coreutils)Block size.).

     When MIN is omitted, collect all the garbage.

‘--free-space=FREE’
‘-F FREE’
     Collect garbage until FREE space is available under ‘/gnu/store’,
     if possible; FREE denotes storage space, such as ‘500MiB’, as
     described above.

     When FREE or more is already available in ‘/gnu/store’, do nothing
     and exit immediately.

‘--delete-generations[=DURATION]’
‘-d [DURATION]’
     Before starting the garbage collection process, delete all the
     generations older than DURATION, for all the user profiles; when
     run as root, this applies to all the profiles _of all the users_.

     For example, this command deletes all the generations of all your
     profiles that are older than 2 months (except generations that are
     current), and then proceeds to free space until at least 10 GiB are
     available:

          guix gc -d 2m -F 10G

‘--delete’
‘-D’
     Attempt to delete all the store files and directories specified as
     arguments.  This fails if some of the files are not in the store,
     or if they are still live.

‘--list-failures’
     List store items corresponding to cached build failures.

     This prints nothing unless the daemon was started with
     ‘--cache-failures’ (*note ‘--cache-failures’: Invoking
     guix-daemon.).

‘--list-roots’
     List the GC roots owned by the user; when run as root, list _all_
     the GC roots.

‘--list-busy’
     List store items in use by currently running processes.  These
     store items are effectively considered GC roots: they cannot be
     deleted.

‘--clear-failures’
     Remove the specified store items from the failed-build cache.

     Again, this option only makes sense when the daemon is started with
     ‘--cache-failures’.  Otherwise, it does nothing.

‘--list-dead’
     Show the list of dead files and directories still present in the
     store—i.e., files and directories no longer reachable from any
     root.

‘--list-live’
     Show the list of live store files and directories.

   In addition, the references among existing store files can be
queried:

‘--references’
‘--referrers’
     List the references (respectively, the referrers) of store files
     given as arguments.

‘--requisites’
‘-R’
     List the requisites of the store files passed as arguments.
     Requisites include the store files themselves, their references,
     and the references of these, recursively.  In other words, the
     returned list is the “transitive closure” of the store files.

     *Note Invoking guix size::, for a tool to profile the size of the
     closure of an element.  *Note Invoking guix graph::, for a tool to
     visualize the graph of references.

‘--derivers’
     Return the derivation(s) leading to the given store items (*note
     Derivations::).

     For example, this command:

          guix gc --derivers `guix package -I ^emacs$ | cut -f4`

     returns the ‘.drv’ file(s) leading to the ‘emacs’ package installed
     in your profile.

     Note that there may be zero matching ‘.drv’ files, for instance
     because these files have been garbage-collected.  There can also be
     more than one matching ‘.drv’ due to fixed-output derivations.

   Lastly, the following options allow you to check the integrity of the
store and to control disk usage.

‘--verify[=OPTIONS]’
     Verify the integrity of the store.

     By default, make sure that all the store items marked as valid in
     the database of the daemon actually exist in ‘/gnu/store’.

     When provided, OPTIONS must be a comma-separated list containing
     one or more of ‘contents’ and ‘repair’.

     When passing ‘--verify=contents’, the daemon computes the content
     hash of each store item and compares it against its hash in the
     database.  Hash mismatches are reported as data corruptions.
     Because it traverses _all the files in the store_, this command can
     take a long time, especially on systems with a slow disk drive.

     Using ‘--verify=repair’ or ‘--verify=contents,repair’ causes the
     daemon to try to repair corrupt store items by fetching substitutes
     for them (*note Substitutes::).  Because repairing is not atomic,
     and thus potentially dangerous, it is available only to the system
     administrator.  A lightweight alternative, when you know exactly
     which items in the store are corrupt, is ‘guix build --repair’
     (*note Invoking guix build::).

‘--optimize’
     Optimize the store by hard-linking identical files—this is
     “deduplication”.

     The daemon performs deduplication after each successful build or
     archive import, unless it was started with
     ‘--disable-deduplication’ (*note ‘--disable-deduplication’:
     Invoking guix-daemon.).  Thus, this option is primarily useful when
     the daemon was running with ‘--disable-deduplication’.


File: guix.info,  Node: Invoking guix pull,  Next: Channels,  Prev: Invoking guix gc,  Up: Package Management

4.6 Invoking ‘guix pull’
========================

Packages are installed or upgraded to the latest version available in
the distribution currently available on your local machine.  To update
that distribution, along with the Guix tools, you must run ‘guix pull’:
the command downloads the latest Guix source code and package
descriptions, and deploys it.  Source code is downloaded from a Git
(https://git-scm.com) repository, by default the official GNU Guix
repository, though this can be customized.

   Specifically, ‘guix pull’ downloads code from the “channels” (*note
Channels::) specified by one of the followings, in this order:

  1. the ‘--channels’ option;
  2. the user’s ‘~/.config/guix/channels.scm’ file;
  3. the system-wide ‘/etc/guix/channels.scm’ file;
  4. the built-in default channels specified in the ‘%default-channels’
     variable.

   On completion, ‘guix package’ will use packages and package versions
from this just-retrieved copy of Guix.  Not only that, but all the Guix
commands and Scheme modules will also be taken from that latest version.
New ‘guix’ sub-commands added by the update also become available.

   Any user can update their Guix copy using ‘guix pull’, and the effect
is limited to the user who ran ‘guix pull’.  For instance, when user
‘root’ runs ‘guix pull’, this has no effect on the version of Guix that
user ‘alice’ sees, and vice versa.

   The result of running ‘guix pull’ is a “profile” available under
‘~/.config/guix/current’ containing the latest Guix.  Thus, make sure to
add it to the beginning of your search path so that you use the latest
version, and similarly for the Info manual (*note Documentation::):

     export PATH="$HOME/.config/guix/current/bin:$PATH"
     export INFOPATH="$HOME/.config/guix/current/share/info:$INFOPATH"

   The ‘--list-generations’ or ‘-l’ option lists past generations
produced by ‘guix pull’, along with details about their provenance:

     $ guix pull -l
     Generation 1	Jun 10 2018 00:18:18
       guix 65956ad
         repository URL: https://git.savannah.gnu.org/git/guix.git
         branch: origin/master
         commit: 65956ad3526ba09e1f7a40722c96c6ef7c0936fe

     Generation 2	Jun 11 2018 11:02:49
       guix e0cc7f6
         repository URL: https://git.savannah.gnu.org/git/guix.git
         branch: origin/master
         commit: e0cc7f669bec22c37481dd03a7941c7d11a64f1d
       2 new packages: keepalived, libnfnetlink
       6 packages upgraded: emacs-nix-mode@2.0.4,
         guile2.0-guix@0.14.0-12.77a1aac, guix@0.14.0-12.77a1aac,
         heimdal@7.5.0, milkytracker@1.02.00, nix@2.0.4

     Generation 3	Jun 13 2018 23:31:07	(current)
       guix 844cc1c
         repository URL: https://git.savannah.gnu.org/git/guix.git
         branch: origin/master
         commit: 844cc1c8f394f03b404c5bb3aee086922373490c
       28 new packages: emacs-helm-ls-git, emacs-helm-mu, ...
       69 packages upgraded: borg@1.1.6, cheese@3.28.0, ...

   *Note ‘guix describe’: Invoking guix describe, for other ways to
describe the current status of Guix.

   This ‘~/.config/guix/current’ profile works exactly like the profiles
created by ‘guix package’ (*note Invoking guix package::).  That is, you
can list generations, roll back to the previous generation—i.e., the
previous Guix—and so on:

     $ guix pull --roll-back
     switched from generation 3 to 2
     $ guix pull --delete-generations=1
     deleting /var/guix/profiles/per-user/charlie/current-guix-1-link

   You can also use ‘guix package’ (*note Invoking guix package::) to
manage the profile by naming it explicitly:
     $ guix package -p ~/.config/guix/current --roll-back
     switched from generation 3 to 2
     $ guix package -p ~/.config/guix/current --delete-generations=1
     deleting /var/guix/profiles/per-user/charlie/current-guix-1-link

   The ‘guix pull’ command is usually invoked with no arguments, but it
supports the following options:

‘--url=URL’
‘--commit=COMMIT’
‘--branch=BRANCH’
     Download code for the ‘guix’ channel from the specified URL, at the
     given COMMIT (a valid Git commit ID represented as a hexadecimal
     string), or BRANCH.

     These options are provided for convenience, but you can also
     specify your configuration in the ‘~/.config/guix/channels.scm’
     file or using the ‘--channels’ option (see below).

‘--channels=FILE’
‘-C FILE’
     Read the list of channels from FILE instead of
     ‘~/.config/guix/channels.scm’ or ‘/etc/guix/channels.scm’.  FILE
     must contain Scheme code that evaluates to a list of channel
     objects.  *Note Channels::, for more information.

‘--news’
‘-N’
     Display the list of packages added or upgraded since the previous
     generation, as well as, occasionally, news written by channel
     authors for their users (*note Writing Channel News: Channels.).

     The package information is the same as displayed upon ‘guix pull’
     completion, but without ellipses; it is also similar to the output
     of ‘guix pull -l’ for the last generation (see below).

‘--list-generations[=PATTERN]’
‘-l [PATTERN]’
     List all the generations of ‘~/.config/guix/current’ or, if PATTERN
     is provided, the subset of generations that match PATTERN.  The
     syntax of PATTERN is the same as with ‘guix package
     --list-generations’ (*note Invoking guix package::).

‘--roll-back’
     Roll back to the previous “generation” of
     ‘~/.config/guix/current’—i.e., undo the last transaction.

‘--switch-generation=PATTERN’
‘-S PATTERN’
     Switch to a particular generation defined by PATTERN.

     PATTERN may be either a generation number or a number prefixed with
     “+” or “-”.  The latter means: move forward/backward by a specified
     number of generations.  For example, if you want to return to the
     latest generation after ‘--roll-back’, use
     ‘--switch-generation=+1’.

‘--delete-generations[=PATTERN]’
‘-d [PATTERN]’
     When PATTERN is omitted, delete all generations except the current
     one.

     This command accepts the same patterns as ‘--list-generations’.
     When PATTERN is specified, delete the matching generations.  When
     PATTERN specifies a duration, generations _older_ than the
     specified duration match.  For instance, ‘--delete-generations=1m’
     deletes generations that are more than one month old.

     If the current generation matches, it is _not_ deleted.

     Note that deleting generations prevents rolling back to them.
     Consequently, this command must be used with care.

     *Note Invoking guix describe::, for a way to display information
     about the current generation only.

‘--profile=PROFILE’
‘-p PROFILE’
     Use PROFILE instead of ‘~/.config/guix/current’.

‘--dry-run’
‘-n’
     Show which channel commit(s) would be used and what would be built
     or substituted but do not actually do it.

‘--allow-downgrades’
     Allow pulling older or unrelated revisions of channels than those
     currently in use.

     By default, ‘guix pull’ protects against so-called “downgrade
     attacks” whereby the Git repository of a channel would be reset to
     an earlier or unrelated revision of itself, potentially leading you
     to install older, known-vulnerable versions of software packages.

          Note: Make sure you understand its security implications
          before using ‘--allow-downgrades’.

‘--system=SYSTEM’
‘-s SYSTEM’
     Attempt to build for SYSTEM—e.g., ‘i686-linux’—instead of the
     system type of the build host.

‘--verbose’
     Produce verbose output, writing build logs to the standard error
     output.

‘--bootstrap’
     Use the bootstrap Guile to build the latest Guix.  This option is
     only useful to Guix developers.

   The “channel” mechanism allows you to instruct ‘guix pull’ which
repository and branch to pull from, as well as _additional_ repositories
containing package modules that should be deployed.  *Note Channels::,
for more information.

   In addition, ‘guix pull’ supports all the common build options (*note
Common Build Options::).


File: guix.info,  Node: Channels,  Next: Invoking guix time-machine,  Prev: Invoking guix pull,  Up: Package Management

4.7 Channels
============

Guix and its package collection are updated by running ‘guix pull’
(*note Invoking guix pull::).  By default ‘guix pull’ downloads and
deploys Guix itself from the official GNU Guix repository.  This can be
customized by defining “channels” in the ‘~/.config/guix/channels.scm’
file.  A channel specifies a URL and branch of a Git repository to be
deployed, and ‘guix pull’ can be instructed to pull from one or more
channels.  In other words, channels can be used to _customize_ and to
_extend_ Guix, as we will see below.

4.7.1 Using a Custom Guix Channel
---------------------------------

The channel called ‘guix’ specifies where Guix itself—its command-line
tools as well as its package collection—should be downloaded.  For
instance, suppose you want to update from your own copy of the Guix
repository at ‘example.org’, and specifically the ‘super-hacks’ branch,
you can write in ‘~/.config/guix/channels.scm’ this specification:

     ;; Tell 'guix pull' to use my own repo.
     (list (channel
             (name 'guix)
             (url "https://example.org/my-guix.git")
             (branch "super-hacks")))

From there on, ‘guix pull’ will fetch code from the ‘super-hacks’ branch
of the repository at ‘example.org’.

4.7.2 Specifying Additional Channels
------------------------------------

You can also specify _additional channels_ to pull from.  Let’s say you
have a bunch of custom package variants or personal packages that you
think would make little sense to contribute to the Guix project, but
would like to have these packages transparently available to you at the
command line.  You would first write modules containing those package
definitions (*note Package Modules::), maintain them in a Git
repository, and then you and anyone else can use it as an additional
channel to get packages from.  Neat, no?

     Warning: Before you, dear user, shout—“woow this is _soooo
     coool_!”—and publish your personal channel to the world, we would
     like to share a few words of caution:

        • Before publishing a channel, please consider contributing your
          package definitions to Guix proper (*note Contributing::).
          Guix as a project is open to free software of all sorts, and
          packages in Guix proper are readily available to all Guix
          users and benefit from the project’s quality assurance
          process.

        • When you maintain package definitions outside Guix, we, Guix
          developers, consider that _the compatibility burden is on
          you_.  Remember that package modules and package definitions
          are just Scheme code that uses various programming interfaces
          (APIs).  We want to remain free to change these APIs to keep
          improving Guix, possibly in ways that break your channel.  We
          never change APIs gratuitously, but we will _not_ commit to
          freezing APIs either.

        • Corollary: if you’re using an external channel and that
          channel breaks, please _report the issue to the channel
          authors_, not to the Guix project.

     You’ve been warned!  Having said this, we believe external channels
     are a practical way to exert your freedom to augment Guix’ package
     collection and to share your improvements, which are basic tenets
     of free software (https://www.gnu.org/philosophy/free-sw.html).
     Please email us at <guix-devel@gnu.org> if you’d like to discuss
     this.

   To use a channel, write ‘~/.config/guix/channels.scm’ to instruct
‘guix pull’ to pull from it _in addition_ to the default Guix
channel(s):

     ;; Add my personal packages to those Guix provides.
     (cons (channel
             (name 'my-personal-packages)
             (url "https://example.org/personal-packages.git"))
           %default-channels)

Note that the snippet above is (as always!) Scheme code; we use ‘cons’
to add a channel the list of channels that the variable
‘%default-channels’ is bound to (*note ‘cons’ and lists: (guile)Pairs.).
With this file in place, ‘guix pull’ builds not only Guix but also the
package modules from your own repository.  The result in
‘~/.config/guix/current’ is the union of Guix with your own package
modules:

     $ guix pull --list-generations
     ...
     Generation 19	Aug 27 2018 16:20:48
       guix d894ab8
         repository URL: https://git.savannah.gnu.org/git/guix.git
         branch: master
         commit: d894ab8e9bfabcefa6c49d9ba2e834dd5a73a300
       my-personal-packages dd3df5e
         repository URL: https://example.org/personal-packages.git
         branch: master
         commit: dd3df5e2c8818760a8fc0bd699e55d3b69fef2bb
       11 new packages: my-gimp, my-emacs-with-cool-features, ...
       4 packages upgraded: emacs-racket-mode@0.0.2-2.1b78827, ...

The output of ‘guix pull’ above shows that Generation 19 includes both
Guix and packages from the ‘my-personal-packages’ channel.  Among the
new and upgraded packages that are listed, some like ‘my-gimp’ and
‘my-emacs-with-cool-features’ might come from ‘my-personal-packages’,
while others come from the Guix default channel.

   To create a channel, create a Git repository containing your own
package modules and make it available.  The repository can contain
anything, but a useful channel will contain Guile modules that export
packages.  Once you start using a channel, Guix will behave as if the
root directory of that channel’s Git repository has been added to the
Guile load path (*note (guile)Load Paths::).  For example, if your
channel contains a file at ‘my-packages/my-tools.scm’ that defines a
Guile module, then the module will be available under the name
‘(my-packages my-tools)’, and you will be able to use it like any other
module (*note (guile)Modules::).

4.7.3 Declaring Channel Dependencies
------------------------------------

Channel authors may decide to augment a package collection provided by
other channels.  They can declare their channel to be dependent on other
channels in a meta-data file ‘.guix-channel’, which is to be placed in
the root of the channel repository.

   The meta-data file should contain a simple S-expression like this:

     (channel
      (version 0)
      (dependencies
       (channel
        (name some-collection)
        (url "https://example.org/first-collection.git"))
       (channel
        (name some-other-collection)
        (url "https://example.org/second-collection.git")
        (branch "testing"))))

   In the above example this channel is declared to depend on two other
channels, which will both be fetched automatically.  The modules
provided by the channel will be compiled in an environment where the
modules of all these declared channels are available.

   For the sake of reliability and maintainability, you should avoid
dependencies on channels that you don’t control, and you should aim to
keep the number of dependencies to a minimum.

4.7.4 Package Modules in a Sub-directory
----------------------------------------

As a channel author, you may want to keep your channel modules in a
sub-directory.  If your modules are in the sub-directory ‘guix’, you
must add a meta-data file ‘.guix-channel’ that contains:

     (channel
       (version 0)
       (directory "guix"))

4.7.5 Writing Channel News
--------------------------

Channel authors may occasionally want to communicate to their users
information about important changes in the channel.  You’d send them all
an email, but that’s not convenient.

   Instead, channels can provide a “news file”; when the channel users
run ‘guix pull’, that news file is automatically read and ‘guix pull
--news’ can display the announcements that correspond to the new commits
that have been pulled, if any.

   To do that, channel authors must first declare the name of the news
file in their ‘.guix-channel’ file:

     (channel
       (version 0)
       (news-file "etc/news.txt"))

   The news file itself, ‘etc/news.txt’ in this example, must look
something like this:

     (channel-news
       (version 0)
       (entry (tag "the-bug-fix")
              (title (en "Fixed terrible bug")
                     (fr "Oh la la"))
              (body (en "@emph{Good news}!  It's fixed!")
                    (eo "Certe ĝi pli bone funkcias nun!")))
       (entry (commit "bdcabe815cd28144a2d2b4bc3c5057b051fa9906")
              (title (en "Added a great package")
                     (ca "Què vol dir guix?"))
              (body (en "Don't miss the @code{hello} package!"))))

   The file consists of a list of “news entries”.  Each entry is
associated with a commit or tag: it describes changes made in this
commit, possibly in preceding commits as well.  Users see entries only
the first time they obtain the commit the entry refers to.

   The ‘title’ field should be a one-line summary while ‘body’ can be
arbitrarily long, and both can contain Texinfo markup (*note
(texinfo)Overview::).  Both the title and body are a list of language
tag/message tuples, which allows ‘guix pull’ to display news in the
language that corresponds to the user’s locale.

   If you want to translate news using a gettext-based workflow, you can
extract translatable strings with ‘xgettext’ (*note (gettext)xgettext
Invocation::).  For example, assuming you write news entries in English
first, the command below creates a PO file containing the strings to
translate:

     xgettext -o news.po -l scheme -ken etc/news.scm

   To sum up, yes, you could use your channel as a blog.  But beware,
this is _not quite_ what your users might expect.

4.7.6 Replicating Guix
----------------------

The ‘guix pull --list-generations’ output above shows precisely which
commits were used to build this instance of Guix.  We can thus replicate
it, say, on another machine, by providing a channel specification in
‘~/.config/guix/channels.scm’ that is “pinned” to these commits:

     ;; Deploy specific commits of my channels of interest.
     (list (channel
            (name 'guix)
            (url "https://git.savannah.gnu.org/git/guix.git")
            (commit "d894ab8e9bfabcefa6c49d9ba2e834dd5a73a300"))
           (channel
            (name 'my-personal-packages)
            (url "https://example.org/personal-packages.git")
            (commit "dd3df5e2c8818760a8fc0bd699e55d3b69fef2bb")))

   The ‘guix describe --format=channels’ command can even generate this
list of channels directly (*note Invoking guix describe::).  The
resulting file can be used with the -C options of ‘guix pull’ (*note
Invoking guix pull::) or ‘guix time-machine’ (*note Invoking guix
time-machine::).

   At this point the two machines run the _exact same Guix_, with access
to the _exact same packages_.  The output of ‘guix build gimp’ on one
machine will be exactly the same, bit for bit, as the output of the same
command on the other machine.  It also means both machines have access
to all the source code of Guix and, transitively, to all the source code
of every package it defines.

   This gives you super powers, allowing you to track the provenance of
binary artifacts with very fine grain, and to reproduce software
environments at will—some sort of “meta reproducibility” capabilities,
if you will.  *Note Inferiors::, for another way to take advantage of
these super powers.


File: guix.info,  Node: Invoking guix time-machine,  Next: Inferiors,  Prev: Channels,  Up: Package Management

4.8 Invoking ‘guix time-machine’
================================

The ‘guix time-machine’ command provides access to other revisions of
Guix, for example to install older versions of packages, or to reproduce
a computation in an identical environment.  The revision of Guix to be
used is defined by a commit or by a channel description file created by
‘guix describe’ (*note Invoking guix describe::).

   The general syntax is:

     guix time-machine OPTIONS... -- COMMAND ARG...

   where COMMAND and ARG... are passed unmodified to the ‘guix’ command
of the specified revision.  The OPTIONS that define this revision are
the same as for ‘guix pull’ (*note Invoking guix pull::):

‘--url=URL’
‘--commit=COMMIT’
‘--branch=BRANCH’
     Use the ‘guix’ channel from the specified URL, at the given COMMIT
     (a valid Git commit ID represented as a hexadecimal string), or
     BRANCH.

‘--channels=FILE’
‘-C FILE’
     Read the list of channels from FILE.  FILE must contain Scheme code
     that evaluates to a list of channel objects.  *Note Channels:: for
     more information.

   As for ‘guix pull’, the absence of any options means that the the
latest commit on the master branch will be used.  The command

     guix time-machine -- build hello

   will thus build the package ‘hello’ as defined in the master branch,
which is in general a newer revision of Guix than you have installed.
Time travel works in both directions!

   Note that ‘guix time-machine’ can trigger builds of channels and
their dependencies, and these are controlled by the standard build
options (*note Common Build Options::).


File: guix.info,  Node: Inferiors,  Next: Invoking guix describe,  Prev: Invoking guix time-machine,  Up: Package Management

4.9 Inferiors
=============

     Note: The functionality described here is a “technology preview” as
     of version 1.0.1.17089-7e269.  As such, the interface is subject to
     change.

   Sometimes you might need to mix packages from the revision of Guix
you’re currently running with packages available in a different revision
of Guix.  Guix “inferiors” allow you to achieve that by composing
different Guix revisions in arbitrary ways.

   Technically, an “inferior” is essentially a separate Guix process
connected to your main Guix process through a REPL (*note Invoking guix
repl::).  The ‘(guix inferior)’ module allows you to create inferiors
and to communicate with them.  It also provides a high-level interface
to browse and manipulate the packages that an inferior
provides—“inferior packages”.

   When combined with channels (*note Channels::), inferiors provide a
simple way to interact with a separate revision of Guix.  For example,
let’s assume you want to install in your profile the current ‘guile’
package, along with the ‘guile-json’ as it existed in an older revision
of Guix—perhaps because the newer ‘guile-json’ has an incompatible API
and you want to run your code against the old API.  To do that, you
could write a manifest for use by ‘guix package --manifest’ (*note
Invoking guix package::); in that manifest, you would create an inferior
for that old Guix revision you care about, and you would look up the
‘guile-json’ package in the inferior:

     (use-modules (guix inferior) (guix channels)
                  (srfi srfi-1))   ;for 'first'

     (define channels
       ;; This is the old revision from which we want to
       ;; extract guile-json.
       (list (channel
              (name 'guix)
              (url "https://git.savannah.gnu.org/git/guix.git")
              (commit
               "65956ad3526ba09e1f7a40722c96c6ef7c0936fe"))))

     (define inferior
       ;; An inferior representing the above revision.
       (inferior-for-channels channels))

     ;; Now create a manifest with the current "guile" package
     ;; and the old "guile-json" package.
     (packages->manifest
      (list (first (lookup-inferior-packages inferior "guile-json"))
            (specification->package "guile")))

   On its first run, ‘guix package --manifest’ might have to build the
channel you specified before it can create the inferior; subsequent runs
will be much faster because the Guix revision will be cached.

   The ‘(guix inferior)’ module provides the following procedures to
open an inferior:

 -- Scheme Procedure: inferior-for-channels CHANNELS [#:cache-directory]
          [#:ttl]
     Return an inferior for CHANNELS, a list of channels.  Use the cache
     at CACHE-DIRECTORY, where entries can be reclaimed after TTL
     seconds.  This procedure opens a new connection to the build
     daemon.

     As a side effect, this procedure may build or substitute binaries
     for CHANNELS, which can take time.

 -- Scheme Procedure: open-inferior DIRECTORY [#:command "bin/guix"]
     Open the inferior Guix in DIRECTORY, running ‘DIRECTORY/COMMAND
     repl’ or equivalent.  Return ‘#f’ if the inferior could not be
     launched.

   The procedures listed below allow you to obtain and manipulate
inferior packages.

 -- Scheme Procedure: inferior-packages INFERIOR
     Return the list of packages known to INFERIOR.

 -- Scheme Procedure: lookup-inferior-packages INFERIOR NAME [VERSION]
     Return the sorted list of inferior packages matching NAME in
     INFERIOR, with highest version numbers first.  If VERSION is true,
     return only packages with a version number prefixed by VERSION.

 -- Scheme Procedure: inferior-package? OBJ
     Return true if OBJ is an inferior package.

 -- Scheme Procedure: inferior-package-name PACKAGE
 -- Scheme Procedure: inferior-package-version PACKAGE
 -- Scheme Procedure: inferior-package-synopsis PACKAGE
 -- Scheme Procedure: inferior-package-description PACKAGE
 -- Scheme Procedure: inferior-package-home-page PACKAGE
 -- Scheme Procedure: inferior-package-location PACKAGE
 -- Scheme Procedure: inferior-package-inputs PACKAGE
 -- Scheme Procedure: inferior-package-native-inputs PACKAGE
 -- Scheme Procedure: inferior-package-propagated-inputs PACKAGE
 -- Scheme Procedure: inferior-package-transitive-propagated-inputs
          PACKAGE
 -- Scheme Procedure: inferior-package-native-search-paths PACKAGE
 -- Scheme Procedure: inferior-package-transitive-native-search-paths
          PACKAGE
 -- Scheme Procedure: inferior-package-search-paths PACKAGE
     These procedures are the counterpart of package record accessors
     (*note package Reference::).  Most of them work by querying the
     inferior PACKAGE comes from, so the inferior must still be live
     when you call these procedures.

   Inferior packages can be used transparently like any other package or
file-like object in G-expressions (*note G-Expressions::).  They are
also transparently handled by the ‘packages->manifest’ procedure, which
is commonly use in manifests (*note the ‘--manifest’ option of ‘guix
package’: Invoking guix package.).  Thus you can insert an inferior
package pretty much anywhere you would insert a regular package: in
manifests, in the ‘packages’ field of your ‘operating-system’
declaration, and so on.


File: guix.info,  Node: Invoking guix describe,  Next: Invoking guix archive,  Prev: Inferiors,  Up: Package Management

4.10 Invoking ‘guix describe’
=============================

Often you may want to answer questions like: “Which revision of Guix am
I using?” or “Which channels am I using?” This is useful information in
many situations: if you want to _replicate_ an environment on a
different machine or user account, if you want to report a bug or to
determine what change in the channels you are using caused it, or if you
want to record your system state for reproducibility purposes.  The
‘guix describe’ command answers these questions.

   When run from a ‘guix pull’ed ‘guix’, ‘guix describe’ displays the
channel(s) that it was built from, including their repository URL and
commit IDs (*note Channels::):

     $ guix describe
     Generation 10	Sep 03 2018 17:32:44	(current)
       guix e0fa68c
         repository URL: https://git.savannah.gnu.org/git/guix.git
         branch: master
         commit: e0fa68c7718fffd33d81af415279d6ddb518f727

   If you’re familiar with the Git version control system, this is
similar in spirit to ‘git describe’; the output is also similar to that
of ‘guix pull --list-generations’, but limited to the current generation
(*note the ‘--list-generations’ option: Invoking guix pull.).  Because
the Git commit ID shown above unambiguously refers to a snapshot of
Guix, this information is all it takes to describe the revision of Guix
you’re using, and also to replicate it.

   To make it easier to replicate Guix, ‘guix describe’ can also be
asked to return a list of channels instead of the human-readable
description above:

     $ guix describe -f channels
     (list (channel
             (name 'guix)
             (url "https://git.savannah.gnu.org/git/guix.git")
             (commit
               "e0fa68c7718fffd33d81af415279d6ddb518f727")))

You can save this to a file and feed it to ‘guix pull -C’ on some other
machine or at a later point in time, which will instantiate _this exact
Guix revision_ (*note the ‘-C’ option: Invoking guix pull.).  From there
on, since you’re able to deploy the same revision of Guix, you can just
as well _replicate a complete software environment_.  We humbly think
that this is _awesome_, and we hope you’ll like it too!

   The details of the options supported by ‘guix describe’ are as
follows:

‘--format=FORMAT’
‘-f FORMAT’
     Produce output in the specified FORMAT, one of:

     ‘human’
          produce human-readable output;
     ‘channels’
          produce a list of channel specifications that can be passed to
          ‘guix pull -C’ or installed as ‘~/.config/guix/channels.scm’
          (*note Invoking guix pull::);
     ‘json’
          produce a list of channel specifications in JSON format;
     ‘recutils’
          produce a list of channel specifications in Recutils format.

‘--list-formats’
     Display available formats for ‘--format’ option.

‘--profile=PROFILE’
‘-p PROFILE’
     Display information about PROFILE.


File: guix.info,  Node: Invoking guix archive,  Prev: Invoking guix describe,  Up: Package Management

4.11 Invoking ‘guix archive’
============================

The ‘guix archive’ command allows users to “export” files from the store
into a single archive, and to later “import” them on a machine that runs
Guix.  In particular, it allows store files to be transferred from one
machine to the store on another machine.

     Note: If you’re looking for a way to produce archives in a format
     suitable for tools other than Guix, *note Invoking guix pack::.

   To export store files as an archive to standard output, run:

     guix archive --export OPTIONS SPECIFICATIONS...

   SPECIFICATIONS may be either store file names or package
specifications, as for ‘guix package’ (*note Invoking guix package::).
For instance, the following command creates an archive containing the
‘gui’ output of the ‘git’ package and the main output of ‘emacs’:

     guix archive --export git:gui /gnu/store/...-emacs-24.3 > great.nar

   If the specified packages are not built yet, ‘guix archive’
automatically builds them.  The build process may be controlled with the
common build options (*note Common Build Options::).

   To transfer the ‘emacs’ package to a machine connected over SSH, one
would run:

     guix archive --export -r emacs | ssh the-machine guix archive --import

Similarly, a complete user profile may be transferred from one machine
to another like this:

     guix archive --export -r $(readlink -f ~/.guix-profile) | \
       ssh the-machine guix archive --import

However, note that, in both examples, all of ‘emacs’ and the profile as
well as all of their dependencies are transferred (due to ‘-r’),
regardless of what is already available in the store on the target
machine.  The ‘--missing’ option can help figure out which items are
missing from the target store.  The ‘guix copy’ command simplifies and
optimizes this whole process, so this is probably what you should use in
this case (*note Invoking guix copy::).

   Archives are stored in the “normalized archive” or “nar” format,
which is comparable in spirit to ‘tar’, but with differences that make
it more appropriate for our purposes.  First, rather than recording all
Unix metadata for each file, the nar format only mentions the file type
(regular, directory, or symbolic link); Unix permissions and owner/group
are dismissed.  Second, the order in which directory entries are stored
always follows the order of file names according to the C locale
collation order.  This makes archive production fully deterministic.

   When exporting, the daemon digitally signs the contents of the
archive, and that digital signature is appended.  When importing, the
daemon verifies the signature and rejects the import in case of an
invalid signature or if the signing key is not authorized.

   The main options are:

‘--export’
     Export the specified store files or packages (see below).  Write
     the resulting archive to the standard output.

     Dependencies are _not_ included in the output, unless ‘--recursive’
     is passed.

‘-r’
‘--recursive’
     When combined with ‘--export’, this instructs ‘guix archive’ to
     include dependencies of the given items in the archive.  Thus, the
     resulting archive is self-contained: it contains the closure of the
     exported store items.

‘--import’
     Read an archive from the standard input, and import the files
     listed therein into the store.  Abort if the archive has an invalid
     digital signature, or if it is signed by a public key not among the
     authorized keys (see ‘--authorize’ below).

‘--missing’
     Read a list of store file names from the standard input, one per
     line, and write on the standard output the subset of these files
     missing from the store.

‘--generate-key[=PARAMETERS]’
     Generate a new key pair for the daemon.  This is a prerequisite
     before archives can be exported with ‘--export’.  Note that this
     operation usually takes time, because it needs to gather enough
     entropy to generate the key pair.

     The generated key pair is typically stored under ‘/etc/guix’, in
     ‘signing-key.pub’ (public key) and ‘signing-key.sec’ (private key,
     which must be kept secret).  When PARAMETERS is omitted, an ECDSA
     key using the Ed25519 curve is generated, or, for Libgcrypt
     versions before 1.6.0, it is a 4096-bit RSA key.  Alternatively,
     PARAMETERS can specify ‘genkey’ parameters suitable for Libgcrypt
     (*note ‘gcry_pk_genkey’: (gcrypt)General public-key related
     Functions.).

‘--authorize’
     Authorize imports signed by the public key passed on standard
     input.  The public key must be in “s-expression advanced
     format”—i.e., the same format as the ‘signing-key.pub’ file.

     The list of authorized keys is kept in the human-editable file
     ‘/etc/guix/acl’.  The file contains “advanced-format s-expressions”
     (https://people.csail.mit.edu/rivest/Sexp.txt) and is structured as
     an access-control list in the Simple Public-Key Infrastructure
     (SPKI) (https://theworld.com/~cme/spki.txt).

‘--extract=DIRECTORY’
‘-x DIRECTORY’
     Read a single-item archive as served by substitute servers (*note
     Substitutes::) and extract it to DIRECTORY.  This is a low-level
     operation needed in only very narrow use cases; see below.

     For example, the following command extracts the substitute for
     Emacs served by ‘ci.guix.gnu.org’ to ‘/tmp/emacs’:

          $ wget -O - \
            https://ci.guix.gnu.org/nar/gzip/...-emacs-24.5 \
            | gunzip | guix archive -x /tmp/emacs

     Single-item archives are different from multiple-item archives
     produced by ‘guix archive --export’; they contain a single store
     item, and they do _not_ embed a signature.  Thus this operation
     does _no_ signature verification and its output should be
     considered unsafe.

     The primary purpose of this operation is to facilitate inspection
     of archive contents coming from possibly untrusted substitute
     servers (*note Invoking guix challenge::).

‘--list’
‘-t’
     Read a single-item archive as served by substitute servers (*note
     Substitutes::) and print the list of files it contains, as in this
     example:

          $ wget -O - \
            https://ci.guix.gnu.org/nar/lzip/...-emacs-26.3 \
            | lzip -d | guix archive -t


File: guix.info,  Node: Development,  Next: Programming Interface,  Prev: Package Management,  Up: Top

5 Development
*************

If you are a software developer, Guix provides tools that you should
find helpful—independently of the language you’re developing in.  This
is what this chapter is about.

   The ‘guix environment’ command provides a convenient way to set up
“development environments” containing all the dependencies and tools
necessary to work on the software package of your choice.  The ‘guix
pack’ command allows you to create “application bundles” that can be
easily distributed to users who do not run Guix.

* Menu:

* Invoking guix environment::  Setting up development environments.
* Invoking guix pack::         Creating software bundles.
* The GCC toolchain::          Working with languages supported by GCC.


File: guix.info,  Node: Invoking guix environment,  Next: Invoking guix pack,  Up: Development

5.1 Invoking ‘guix environment’
===============================

The purpose of ‘guix environment’ is to assist hackers in creating
reproducible development environments without polluting their package
profile.  The ‘guix environment’ tool takes one or more packages, builds
all of their inputs, and creates a shell environment to use them.

   The general syntax is:

     guix environment OPTIONS PACKAGE...

   The following example spawns a new shell set up for the development
of GNU Guile:

     guix environment guile

   If the needed dependencies are not built yet, ‘guix environment’
automatically builds them.  The environment of the new shell is an
augmented version of the environment that ‘guix environment’ was run in.
It contains the necessary search paths for building the given package
added to the existing environment variables.  To create a “pure”
environment, in which the original environment variables have been
unset, use the ‘--pure’ option(1).

   ‘guix environment’ defines the ‘GUIX_ENVIRONMENT’ variable in the
shell it spawns; its value is the file name of the profile of this
environment.  This allows users to, say, define a specific prompt for
development environments in their ‘.bashrc’ (*note (bash)Bash Startup
Files::):

     if [ -n "$GUIX_ENVIRONMENT" ]
     then
         export PS1="\u@\h \w [dev]\$ "
     fi

... or to browse the profile:

     $ ls "$GUIX_ENVIRONMENT/bin"

   Additionally, more than one package may be specified, in which case
the union of the inputs for the given packages are used.  For example,
the command below spawns a shell where all of the dependencies of both
Guile and Emacs are available:

     guix environment guile emacs

   Sometimes an interactive shell session is not desired.  An arbitrary
command may be invoked by placing the ‘--’ token to separate the command
from the rest of the arguments:

     guix environment guile -- make -j4

   In other situations, it is more convenient to specify the list of
packages needed in the environment.  For example, the following command
runs ‘python’ from an environment containing Python 2.7 and NumPy:

     guix environment --ad-hoc python2-numpy python-2.7 -- python

   Furthermore, one might want the dependencies of a package and also
some additional packages that are not build-time or runtime
dependencies, but are useful when developing nonetheless.  Because of
this, the ‘--ad-hoc’ flag is positional.  Packages appearing before
‘--ad-hoc’ are interpreted as packages whose dependencies will be added
to the environment.  Packages appearing after are interpreted as
packages that will be added to the environment directly.  For example,
the following command creates a Guix development environment that
additionally includes Git and strace:

     guix environment --pure guix --ad-hoc git strace

   Sometimes it is desirable to isolate the environment as much as
possible, for maximal purity and reproducibility.  In particular, when
using Guix on a host distro that is not Guix System, it is desirable to
prevent access to ‘/usr/bin’ and other system-wide resources from the
development environment.  For example, the following command spawns a
Guile REPL in a “container” where only the store and the current working
directory are mounted:

     guix environment --ad-hoc --container guile -- guile

     Note: The ‘--container’ option requires Linux-libre 3.19 or newer.

   Another typical use case for containers is to run security-sensitive
applications such as a web browser.  To run Eolie, we must expose and
share some files and directories; we include ‘nss-certs’ and expose
‘/etc/ssl/certs/’ for HTTPS authentication; finally we preserve the the
‘DISPLAY’ environment variable since containerized graphical
applications won’t display without it.

     guix environment --preserve='^DISPLAY$' --container --network \
       --expose=/etc/machine-id \
       --expose=/etc/ssl/certs/ \
       --share=$HOME/.local/share/eolie/=$HOME/.local/share/eolie/ \
       --ad-hoc eolie nss-certs dbus --  eolie

   The available options are summarized below.

‘--root=FILE’
‘-r FILE’
     Make FILE a symlink to the profile for this environment, and
     register it as a garbage collector root.

     This is useful if you want to protect your environment from garbage
     collection, to make it “persistent”.

     When this option is omitted, the environment is protected from
     garbage collection only for the duration of the ‘guix environment’
     session.  This means that next time you recreate the same
     environment, you could have to rebuild or re-download packages.
     *Note Invoking guix gc::, for more on GC roots.

‘--expression=EXPR’
‘-e EXPR’
     Create an environment for the package or list of packages that EXPR
     evaluates to.

     For example, running:

          guix environment -e '(@ (gnu packages maths) petsc-openmpi)'

     starts a shell with the environment for this specific variant of
     the PETSc package.

     Running:

          guix environment --ad-hoc -e '(@ (gnu) %base-packages)'

     starts a shell with all the base system packages available.

     The above commands only use the default output of the given
     packages.  To select other outputs, two element tuples can be
     specified:

          guix environment --ad-hoc -e '(list (@ (gnu packages bash) bash) "include")'

‘--load=FILE’
‘-l FILE’
     Create an environment for the package or list of packages that the
     code within FILE evaluates to.

     As an example, FILE might contain a definition like this (*note
     Defining Packages::):

          (use-modules (guix)
                       (gnu packages gdb)
                       (gnu packages autotools)
                       (gnu packages texinfo))
          
          ;; Augment the package definition of GDB with the build tools
          ;; needed when developing GDB (and which are not needed when
          ;; simply installing it.)
          (package (inherit gdb)
            (native-inputs `(("autoconf" ,autoconf-2.64)
                             ("automake" ,automake)
                             ("texinfo" ,texinfo)
                             ,@(package-native-inputs gdb))))

‘--manifest=FILE’
‘-m FILE’
     Create an environment for the packages contained in the manifest
     object returned by the Scheme code in FILE.  This option can be
     repeated several times, in which case the manifests are
     concatenated.

     This is similar to the same-named option in ‘guix package’ (*note
     ‘--manifest’: profile-manifest.) and uses the same manifest files.

‘--ad-hoc’
     Include all specified packages in the resulting environment, as if
     an ad hoc package were defined with them as inputs.  This option is
     useful for quickly creating an environment without having to write
     a package expression to contain the desired inputs.

     For instance, the command:

          guix environment --ad-hoc guile guile-sdl -- guile

     runs ‘guile’ in an environment where Guile and Guile-SDL are
     available.

     Note that this example implicitly asks for the default output of
     ‘guile’ and ‘guile-sdl’, but it is possible to ask for a specific
     output—e.g., ‘glib:bin’ asks for the ‘bin’ output of ‘glib’ (*note
     Packages with Multiple Outputs::).

     This option may be composed with the default behavior of ‘guix
     environment’.  Packages appearing before ‘--ad-hoc’ are interpreted
     as packages whose dependencies will be added to the environment,
     the default behavior.  Packages appearing after are interpreted as
     packages that will be added to the environment directly.

‘--pure’
     Unset existing environment variables when building the new
     environment, except those specified with ‘--preserve’ (see below).
     This has the effect of creating an environment in which search
     paths only contain package inputs.

‘--preserve=REGEXP’
‘-E REGEXP’
     When used alongside ‘--pure’, preserve the environment variables
     matching REGEXP—in other words, put them on a “white list” of
     environment variables that must be preserved.  This option can be
     repeated several times.

          guix environment --pure --preserve=^SLURM --ad-hoc openmpi ... \
            -- mpirun ...

     This example runs ‘mpirun’ in a context where the only environment
     variables defined are ‘PATH’, environment variables whose name
     starts with ‘SLURM’, as well as the usual “precious” variables
     (‘HOME’, ‘USER’, etc.).

‘--search-paths’
     Display the environment variable definitions that make up the
     environment.

‘--system=SYSTEM’
‘-s SYSTEM’
     Attempt to build for SYSTEM—e.g., ‘i686-linux’.

‘--container’
‘-C’
     Run COMMAND within an isolated container.  The current working
     directory outside the container is mapped inside the container.
     Additionally, unless overridden with ‘--user’, a dummy home
     directory is created that matches the current user’s home
     directory, and ‘/etc/passwd’ is configured accordingly.

     The spawned process runs as the current user outside the container.
     Inside the container, it has the same UID and GID as the current
     user, unless ‘--user’ is passed (see below).

‘--network’
‘-N’
     For containers, share the network namespace with the host system.
     Containers created without this flag only have access to the
     loopback device.

‘--link-profile’
‘-P’
     For containers, link the environment profile to ‘~/.guix-profile’
     within the container.  This is equivalent to running the command
     ‘ln -s $GUIX_ENVIRONMENT ~/.guix-profile’ within the container.
     Linking will fail and abort the environment if the directory
     already exists, which will certainly be the case if ‘guix
     environment’ was invoked in the user’s home directory.

     Certain packages are configured to look in ‘~/.guix-profile’ for
     configuration files and data;(2) ‘--link-profile’ allows these
     programs to behave as expected within the environment.

‘--user=USER’
‘-u USER’
     For containers, use the username USER in place of the current user.
     The generated ‘/etc/passwd’ entry within the container will contain
     the name USER, the home directory will be ‘/home/USER’, and no user
     GECOS data will be copied.  Furthermore, the UID and GID inside the
     container are 1000.  USER need not exist on the system.

     Additionally, any shared or exposed path (see ‘--share’ and
     ‘--expose’ respectively) whose target is within the current user’s
     home directory will be remapped relative to ‘/home/USER’; this
     includes the automatic mapping of the current working directory.

          # will expose paths as /home/foo/wd, /home/foo/test, and /home/foo/target
          cd $HOME/wd
          guix environment --container --user=foo \
               --expose=$HOME/test \
               --expose=/tmp/target=$HOME/target

     While this will limit the leaking of user identity through home
     paths and each of the user fields, this is only one useful
     component of a broader privacy/anonymity solution—not one in and of
     itself.

‘--no-cwd’
     For containers, the default behavior is to share the current
     working directory with the isolated container and immediately
     change to that directory within the container.  If this is
     undesirable, ‘--no-cwd’ will cause the current working directory to
     _not_ be automatically shared and will change to the user’s home
     directory within the container instead.  See also ‘--user’.

‘--expose=SOURCE[=TARGET]’
‘--share=SOURCE[=TARGET]’
     For containers, ‘--expose’ (resp.  ‘--share’) exposes the file
     system SOURCE from the host system as the read-only (resp.
     writable) file system TARGET within the container.  If TARGET is
     not specified, SOURCE is used as the target mount point in the
     container.

     The example below spawns a Guile REPL in a container in which the
     user’s home directory is accessible read-only via the ‘/exchange’
     directory:

          guix environment --container --expose=$HOME=/exchange --ad-hoc guile -- guile

   ‘guix environment’ also supports all of the common build options that
‘guix build’ supports (*note Common Build Options::) as well as package
transformation options (*note Package Transformation Options::).

   ---------- Footnotes ----------

   (1) Users sometimes wrongfully augment environment variables such as
‘PATH’ in their ‘~/.bashrc’ file.  As a consequence, when ‘guix
environment’ launches it, Bash may read ‘~/.bashrc’, thereby introducing
“impurities” in these environment variables.  It is an error to define
such environment variables in ‘.bashrc’; instead, they should be defined
in ‘.bash_profile’, which is sourced only by log-in shells.  *Note
(bash)Bash Startup Files::, for details on Bash start-up files.

   (2) For example, the ‘fontconfig’ package inspects
‘~/.guix-profile/share/fonts’ for additional fonts.


File: guix.info,  Node: Invoking guix pack,  Next: The GCC toolchain,  Prev: Invoking guix environment,  Up: Development

5.2 Invoking ‘guix pack’
========================

Occasionally you want to pass software to people who are not (yet!)
lucky enough to be using Guix.  You’d tell them to run ‘guix package -i
SOMETHING’, but that’s not possible in this case.  This is where ‘guix
pack’ comes in.

     Note: If you are looking for ways to exchange binaries among
     machines that already run Guix, *note Invoking guix copy::, *note
     Invoking guix publish::, and *note Invoking guix archive::.

   The ‘guix pack’ command creates a shrink-wrapped “pack” or “software
bundle”: it creates a tarball or some other archive containing the
binaries of the software you’re interested in, and all its dependencies.
The resulting archive can be used on any machine that does not have
Guix, and people can run the exact same binaries as those you have with
Guix.  The pack itself is created in a bit-reproducible fashion, so
anyone can verify that it really contains the build results that you
pretend to be shipping.

   For example, to create a bundle containing Guile, Emacs, Geiser, and
all their dependencies, you can run:

     $ guix pack guile emacs geiser
     ...
     /gnu/store/...-pack.tar.gz

   The result here is a tarball containing a ‘/gnu/store’ directory with
all the relevant packages.  The resulting tarball contains a “profile”
with the three packages of interest; the profile is the same as would be
created by ‘guix package -i’.  It is this mechanism that is used to
create Guix’s own standalone binary tarball (*note Binary
Installation::).

   Users of this pack would have to run
‘/gnu/store/...-profile/bin/guile’ to run Guile, which you may find
inconvenient.  To work around it, you can create, say, a ‘/opt/gnu/bin’
symlink to the profile:

     guix pack -S /opt/gnu/bin=bin guile emacs geiser

That way, users can happily type ‘/opt/gnu/bin/guile’ and enjoy.

   What if the recipient of your pack does not have root privileges on
their machine, and thus cannot unpack it in the root file system?  In
that case, you will want to use the ‘--relocatable’ option (see below).
This option produces “relocatable binaries”, meaning they they can be
placed anywhere in the file system hierarchy: in the example above,
users can unpack your tarball in their home directory and directly run
‘./opt/gnu/bin/guile’.

   Alternatively, you can produce a pack in the Docker image format
using the following command:

     guix pack -f docker -S /bin=bin guile guile-readline

The result is a tarball that can be passed to the ‘docker load’ command,
followed by ‘docker run’:

     docker load < FILE
     docker run -ti guile-guile-readline /bin/guile

where FILE is the image returned by GUIX PACK, and
‘guile-guile-readline’ is its “image tag”.  See the Docker documentation
(https://docs.docker.com/engine/reference/commandline/load/) for more
information.

   Yet another option is to produce a SquashFS image with the following
command:

     guix pack -f squashfs bash guile emacs geiser

The result is a SquashFS file system image that can either be mounted or
directly be used as a file system container image with the Singularity
container execution environment (https://www.sylabs.io/docs/), using
commands like ‘singularity shell’ or ‘singularity exec’.

   Several command-line options allow you to customize your pack:

‘--format=FORMAT’
‘-f FORMAT’
     Produce a pack in the given FORMAT.

     The available formats are:

     ‘tarball’
          This is the default format.  It produces a tarball containing
          all the specified binaries and symlinks.

     ‘docker’
          This produces a tarball that follows the Docker Image
          Specification
          (https://github.com/docker/docker/blob/master/image/spec/v1.2.md).
          The “repository name” as it appears in the output of the
          ‘docker images’ command is computed from package names passed
          on the command line or in the manifest file.

     ‘squashfs’
          This produces a SquashFS image containing all the specified
          binaries and symlinks, as well as empty mount points for
          virtual file systems like procfs.

               Note: Singularity _requires_ you to provide ‘/bin/sh’ in
               the image.  For that reason, ‘guix pack -f squashfs’
               always implies ‘-S /bin=bin’.  Thus, your ‘guix pack’
               invocation must always start with something like:

                    guix pack -f squashfs bash ...

               If you forget the ‘bash’ (or similar) package,
               ‘singularity run’ and ‘singularity exec’ will fail with
               an unhelpful “no such file or directory” message.

‘--relocatable’
‘-R’
     Produce “relocatable binaries”—i.e., binaries that can be placed
     anywhere in the file system hierarchy and run from there.

     When this option is passed once, the resulting binaries require
     support for “user namespaces” in the kernel Linux; when passed
     _twice_(1), relocatable binaries fall to back to other techniques
     if user namespaces are unavailable, and essentially work
     anywhere—see below for the implications.

     For example, if you create a pack containing Bash with:

          guix pack -RR -S /mybin=bin bash

     ... you can copy that pack to a machine that lacks Guix, and from
     your home directory as a normal user, run:

          tar xf pack.tar.gz
          ./mybin/sh

     In that shell, if you type ‘ls /gnu/store’, you’ll notice that
     ‘/gnu/store’ shows up and contains all the dependencies of ‘bash’,
     even though the machine actually lacks ‘/gnu/store’ altogether!
     That is probably the simplest way to deploy Guix-built software on
     a non-Guix machine.

          Note: By default, relocatable binaries rely on the “user
          namespace” feature of the kernel Linux, which allows
          unprivileged users to mount or change root.  Old versions of
          Linux did not support it, and some GNU/Linux distributions
          turn it off.

          To produce relocatable binaries that work even in the absence
          of user namespaces, pass ‘--relocatable’ or ‘-R’ _twice_.  In
          that case, binaries will try user namespace support and fall
          back to another “execution engine” if user namespaces are not
          supported.  The following execution engines are supported:

          ‘default’
               Try user namespaces and fall back to PRoot if user
               namespaces are not supported (see below).

          ‘performance’
               Try user namespaces and fall back to Fakechroot if user
               namespaces are not supported (see below).

          ‘userns’
               Run the program through user namespaces and abort if they
               are not supported.

          ‘proot’
               Run through PRoot.  The PRoot
               (https://proot-me.github.io/) program provides the
               necessary support for file system virtualization.  It
               achieves that by using the ‘ptrace’ system call on the
               running program.  This approach has the advantage to work
               without requiring special kernel support, but it incurs
               run-time overhead every time a system call is made.

          ‘fakechroot’
               Run through Fakechroot.  Fakechroot
               (https://github.com/dex4er/fakechroot/) virtualizes file
               system accesses by intercepting calls to C library
               functions such as ‘open’, ‘stat’, ‘exec’, and so on.
               Unlike PRoot, it incurs very little overhead.  However,
               it does not always work: for example, some file system
               accesses made from within the C library are not
               intercepted, and file system accesses made via direct
               syscalls are not intercepted either, leading to erratic
               behavior.

          When running a wrapped program, you can explicitly request one
          of the execution engines listed above by setting the
          ‘GUIX_EXECUTION_ENGINE’ environment variable accordingly.

‘--entry-point=COMMAND’
     Use COMMAND as the “entry point” of the resulting pack, if the pack
     format supports it—currently ‘docker’ and ‘squashfs’ (Singularity)
     support it.  COMMAND must be relative to the profile contained in
     the pack.

     The entry point specifies the command that tools like ‘docker run’
     or ‘singularity run’ automatically start by default.  For example,
     you can do:

          guix pack -f docker --entry-point=bin/guile guile

     The resulting pack can easily be loaded and ‘docker run’ with no
     extra arguments will spawn ‘bin/guile’:

          docker load -i pack.tar.gz
          docker run IMAGE-ID

‘--expression=EXPR’
‘-e EXPR’
     Consider the package EXPR evaluates to.

     This has the same purpose as the same-named option in ‘guix build’
     (*note ‘--expression’ in ‘guix build’: Additional Build Options.).

‘--manifest=FILE’
‘-m FILE’
     Use the packages contained in the manifest object returned by the
     Scheme code in FILE.  This option can be repeated several times, in
     which case the manifests are concatenated.

     This has a similar purpose as the same-named option in ‘guix
     package’ (*note ‘--manifest’: profile-manifest.) and uses the same
     manifest files.  It allows you to define a collection of packages
     once and use it both for creating profiles and for creating
     archives for use on machines that do not have Guix installed.  Note
     that you can specify _either_ a manifest file _or_ a list of
     packages, but not both.

‘--system=SYSTEM’
‘-s SYSTEM’
     Attempt to build for SYSTEM—e.g., ‘i686-linux’—instead of the
     system type of the build host.

‘--target=TRIPLET’
     Cross-build for TRIPLET, which must be a valid GNU triplet, such as
     ‘"aarch64-linux-gnu"’ (*note GNU configuration triplets:
     (autoconf)Specifying target triplets.).

‘--compression=TOOL’
‘-C TOOL’
     Compress the resulting tarball using TOOL—one of ‘gzip’, ‘bzip2’,
     ‘xz’, ‘lzip’, or ‘none’ for no compression.

‘--symlink=SPEC’
‘-S SPEC’
     Add the symlinks specified by SPEC to the pack.  This option can
     appear several times.

     SPEC has the form ‘SOURCE=TARGET’, where SOURCE is the symlink that
     will be created and TARGET is the symlink target.

     For instance, ‘-S /opt/gnu/bin=bin’ creates a ‘/opt/gnu/bin’
     symlink pointing to the ‘bin’ sub-directory of the profile.

‘--save-provenance’
     Save provenance information for the packages passed on the command
     line.  Provenance information includes the URL and commit of the
     channels in use (*note Channels::).

     Provenance information is saved in the
     ‘/gnu/store/...-profile/manifest’ file in the pack, along with the
     usual package metadata—the name and version of each package, their
     propagated inputs, and so on.  It is useful information to the
     recipient of the pack, who then knows how the pack was (supposedly)
     obtained.

     This option is not enabled by default because, like timestamps,
     provenance information contributes nothing to the build process.
     In other words, there is an infinity of channel URLs and commit IDs
     that can lead to the same pack.  Recording such “silent” metadata
     in the output thus potentially breaks the source-to-binary bitwise
     reproducibility property.

‘--root=FILE’
‘-r FILE’
     Make FILE a symlink to the resulting pack, and register it as a
     garbage collector root.

‘--localstatedir’
‘--profile-name=NAME’
     Include the “local state directory”, ‘/var/guix’, in the resulting
     pack, and notably the ‘/var/guix/profiles/per-user/root/NAME’
     profile—by default NAME is ‘guix-profile’, which corresponds to
     ‘~root/.guix-profile’.

     ‘/var/guix’ contains the store database (*note The Store::) as well
     as garbage-collector roots (*note Invoking guix gc::).  Providing
     it in the pack means that the store is “complete” and manageable by
     Guix; not providing it pack means that the store is “dead”: items
     cannot be added to it or removed from it after extraction of the
     pack.

     One use case for this is the Guix self-contained binary tarball
     (*note Binary Installation::).

‘--derivation’
‘-d’
     Print the name of the derivation that builds the pack.

‘--bootstrap’
     Use the bootstrap binaries to build the pack.  This option is only
     useful to Guix developers.

   In addition, ‘guix pack’ supports all the common build options (*note
Common Build Options::) and all the package transformation options
(*note Package Transformation Options::).

   ---------- Footnotes ----------

   (1) Here’s a trick to memorize it: ‘-RR’, which adds PRoot support,
can be thought of as the abbreviation of “Really Relocatable”.  Neat,
isn’t it?


File: guix.info,  Node: The GCC toolchain,  Prev: Invoking guix pack,  Up: Development

5.3 The GCC toolchain
=====================

If you need a complete toolchain for compiling and linking C or C++
source code, use the ‘gcc-toolchain’ package.  This package provides a
complete GCC toolchain for C/C++ development, including GCC itself, the
GNU C Library (headers and binaries, plus debugging symbols in the
‘debug’ output), Binutils, and a linker wrapper.

   The wrapper’s purpose is to inspect the ‘-L’ and ‘-l’ switches passed
to the linker, add corresponding ‘-rpath’ arguments, and invoke the
actual linker with this new set of arguments.  You can instruct the
wrapper to refuse to link against libraries not in the store by setting
the ‘GUIX_LD_WRAPPER_ALLOW_IMPURITIES’ environment variable to ‘no’.

   The package ‘gfortran-toolchain’ provides a complete GCC toolchain
for Fortran development.  For other languages, please use ‘guix search
gcc toolchain’ (*note Invoking guix package: guix-search.).


File: guix.info,  Node: Programming Interface,  Next: Utilities,  Prev: Development,  Up: Top

6 Programming Interface
***********************

GNU Guix provides several Scheme programming interfaces (APIs) to
define, build, and query packages.  The first interface allows users to
write high-level package definitions.  These definitions refer to
familiar packaging concepts, such as the name and version of a package,
its build system, and its dependencies.  These definitions can then be
turned into concrete build actions.

   Build actions are performed by the Guix daemon, on behalf of users.
In a standard setup, the daemon has write access to the store—the
‘/gnu/store’ directory—whereas users do not.  The recommended setup also
has the daemon perform builds in chroots, under a specific build users,
to minimize interference with the rest of the system.

   Lower-level APIs are available to interact with the daemon and the
store.  To instruct the daemon to perform a build action, users actually
provide it with a “derivation”.  A derivation is a low-level
representation of the build actions to be taken, and the environment in
which they should occur—derivations are to package definitions what
assembly is to C programs.  The term “derivation” comes from the fact
that build results _derive_ from them.

   This chapter describes all these APIs in turn, starting from
high-level package definitions.

* Menu:

* Package Modules::             Packages from the programmer’s viewpoint.
* Defining Packages::           Defining new packages.
* Build Systems::               Specifying how packages are built.
* The Store::                   Manipulating the package store.
* Derivations::                 Low-level interface to package derivations.
* The Store Monad::             Purely functional interface to the store.
* G-Expressions::               Manipulating build expressions.
* Invoking guix repl::          Fiddling with Guix interactively.


File: guix.info,  Node: Package Modules,  Next: Defining Packages,  Up: Programming Interface

6.1 Package Modules
===================

From a programming viewpoint, the package definitions of the GNU
distribution are provided by Guile modules in the ‘(gnu packages ...)’
name space(1) (*note Guile modules: (guile)Modules.).  For instance, the
‘(gnu packages emacs)’ module exports a variable named ‘emacs’, which is
bound to a ‘<package>’ object (*note Defining Packages::).

   The ‘(gnu packages ...)’ module name space is automatically scanned
for packages by the command-line tools.  For instance, when running
‘guix install emacs’, all the ‘(gnu packages ...)’ modules are scanned
until one that exports a package object whose name is ‘emacs’ is found.
This package search facility is implemented in the ‘(gnu packages)’
module.

   Users can store package definitions in modules with different
names—e.g., ‘(my-packages emacs)’(2).  There are two ways to make these
package definitions visible to the user interfaces:

  1. By adding the directory containing your package modules to the
     search path with the ‘-L’ flag of ‘guix package’ and other commands
     (*note Common Build Options::), or by setting the
     ‘GUIX_PACKAGE_PATH’ environment variable described below.

  2. By defining a “channel” and configuring ‘guix pull’ so that it
     pulls from it.  A channel is essentially a Git repository
     containing package modules.  *Note Channels::, for more information
     on how to define and use channels.

   ‘GUIX_PACKAGE_PATH’ works similarly to other search path variables:

 -- Environment Variable: GUIX_PACKAGE_PATH
     This is a colon-separated list of directories to search for
     additional package modules.  Directories listed in this variable
     take precedence over the own modules of the distribution.

   The distribution is fully “bootstrapped” and “self-contained”: each
package is built based solely on other packages in the distribution.
The root of this dependency graph is a small set of “bootstrap
binaries”, provided by the ‘(gnu packages bootstrap)’ module.  For more
information on bootstrapping, *note Bootstrapping::.

   ---------- Footnotes ----------

   (1) Note that packages under the ‘(gnu packages ...)’ module name
space are not necessarily “GNU packages”.  This module naming scheme
follows the usual Guile module naming convention: ‘gnu’ means that these
modules are distributed as part of the GNU system, and ‘packages’
identifies modules that define packages.

   (2) Note that the file name and module name must match.  For
instance, the ‘(my-packages emacs)’ module must be stored in a
‘my-packages/emacs.scm’ file relative to the load path specified with
‘--load-path’ or ‘GUIX_PACKAGE_PATH’.  *Note (guile)Modules and the File
System::, for details.


File: guix.info,  Node: Defining Packages,  Next: Build Systems,  Prev: Package Modules,  Up: Programming Interface

6.2 Defining Packages
=====================

The high-level interface to package definitions is implemented in the
‘(guix packages)’ and ‘(guix build-system)’ modules.  As an example, the
package definition, or “recipe”, for the GNU Hello package looks like
this:

     (define-module (gnu packages hello)
       #:use-module (guix packages)
       #:use-module (guix download)
       #:use-module (guix build-system gnu)
       #:use-module (guix licenses)
       #:use-module (gnu packages gawk))

     (define-public hello
       (package
         (name "hello")
         (version "2.10")
         (source (origin
                   (method url-fetch)
                   (uri (string-append "mirror://gnu/hello/hello-" version
                                       ".tar.gz"))
                   (sha256
                    (base32
                     "0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i"))))
         (build-system gnu-build-system)
         (arguments '(#:configure-flags '("--enable-silent-rules")))
         (inputs `(("gawk" ,gawk)))
         (synopsis "Hello, GNU world: An example GNU package")
         (description "Guess what GNU Hello prints!")
         (home-page "https://www.gnu.org/software/hello/")
         (license gpl3+)))

Without being a Scheme expert, the reader may have guessed the meaning
of the various fields here.  This expression binds the variable ‘hello’
to a ‘<package>’ object, which is essentially a record (*note Scheme
records: (guile)SRFI-9.).  This package object can be inspected using
procedures found in the ‘(guix packages)’ module; for instance,
‘(package-name hello)’ returns—surprise!—‘"hello"’.

   With luck, you may be able to import part or all of the definition of
the package you are interested in from another repository, using the
‘guix import’ command (*note Invoking guix import::).

   In the example above, HELLO is defined in a module of its own, ‘(gnu
packages hello)’.  Technically, this is not strictly necessary, but it
is convenient to do so: all the packages defined in modules under ‘(gnu
packages ...)’ are automatically known to the command-line tools (*note
Package Modules::).

   There are a few points worth noting in the above package definition:

   • The ‘source’ field of the package is an ‘<origin>’ object (*note
     origin Reference::, for the complete reference).  Here, the
     ‘url-fetch’ method from ‘(guix download)’ is used, meaning that the
     source is a file to be downloaded over FTP or HTTP.

     The ‘mirror://gnu’ prefix instructs ‘url-fetch’ to use one of the
     GNU mirrors defined in ‘(guix download)’.

     The ‘sha256’ field specifies the expected SHA256 hash of the file
     being downloaded.  It is mandatory, and allows Guix to check the
     integrity of the file.  The ‘(base32 ...)’ form introduces the
     base32 representation of the hash.  You can obtain this information
     with ‘guix download’ (*note Invoking guix download::) and ‘guix
     hash’ (*note Invoking guix hash::).

     When needed, the ‘origin’ form can also have a ‘patches’ field
     listing patches to be applied, and a ‘snippet’ field giving a
     Scheme expression to modify the source code.

   • The ‘build-system’ field specifies the procedure to build the
     package (*note Build Systems::).  Here, GNU-BUILD-SYSTEM represents
     the familiar GNU Build System, where packages may be configured,
     built, and installed with the usual ‘./configure && make && make
     check && make install’ command sequence.

   • The ‘arguments’ field specifies options for the build system (*note
     Build Systems::).  Here it is interpreted by GNU-BUILD-SYSTEM as a
     request run ‘configure’ with the ‘--enable-silent-rules’ flag.

     What about these quote (‘'’) characters?  They are Scheme syntax to
     introduce a literal list; ‘'’ is synonymous with ‘quote’.  *Note
     quoting: (guile)Expression Syntax, for details.  Here the value of
     the ‘arguments’ field is a list of arguments passed to the build
     system down the road, as with ‘apply’ (*note ‘apply’: (guile)Fly
     Evaluation.).

     The hash-colon (‘#:’) sequence defines a Scheme “keyword” (*note
     (guile)Keywords::), and ‘#:configure-flags’ is a keyword used to
     pass a keyword argument to the build system (*note (guile)Coding
     With Keywords::).

   • The ‘inputs’ field specifies inputs to the build process—i.e.,
     build-time or run-time dependencies of the package.  Here, we
     define an input called ‘"gawk"’ whose value is that of the GAWK
     variable; GAWK is itself bound to a ‘<package>’ object.

     Again, ‘`’ (a backquote, synonymous with ‘quasiquote’) allows us to
     introduce a literal list in the ‘inputs’ field, while ‘,’ (a comma,
     synonymous with ‘unquote’) allows us to insert a value in that list
     (*note unquote: (guile)Expression Syntax.).

     Note that GCC, Coreutils, Bash, and other essential tools do not
     need to be specified as inputs here.  Instead, GNU-BUILD-SYSTEM
     takes care of ensuring that they are present (*note Build
     Systems::).

     However, any other dependencies need to be specified in the
     ‘inputs’ field.  Any dependency not specified here will simply be
     unavailable to the build process, possibly leading to a build
     failure.

   *Note package Reference::, for a full description of possible fields.

   Once a package definition is in place, the package may actually be
built using the ‘guix build’ command-line tool (*note Invoking guix
build::), troubleshooting any build failures you encounter (*note
Debugging Build Failures::).  You can easily jump back to the package
definition using the ‘guix edit’ command (*note Invoking guix edit::).
*Note Packaging Guidelines::, for more information on how to test
package definitions, and *note Invoking guix lint::, for information on
how to check a definition for style conformance.  Lastly, *note
Channels::, for information on how to extend the distribution by adding
your own package definitions in a “channel”.

   Finally, updating the package definition to a new upstream version
can be partly automated by the ‘guix refresh’ command (*note Invoking
guix refresh::).

   Behind the scenes, a derivation corresponding to the ‘<package>’
object is first computed by the ‘package-derivation’ procedure.  That
derivation is stored in a ‘.drv’ file under ‘/gnu/store’.  The build
actions it prescribes may then be realized by using the
‘build-derivations’ procedure (*note The Store::).

 -- Scheme Procedure: package-derivation STORE PACKAGE [SYSTEM]
     Return the ‘<derivation>’ object of PACKAGE for SYSTEM (*note
     Derivations::).

     PACKAGE must be a valid ‘<package>’ object, and SYSTEM must be a
     string denoting the target system type—e.g., ‘"x86_64-linux"’ for
     an x86_64 Linux-based GNU system.  STORE must be a connection to
     the daemon, which operates on the store (*note The Store::).

Similarly, it is possible to compute a derivation that cross-builds a
package for some other system:

 -- Scheme Procedure: package-cross-derivation STORE PACKAGE TARGET
          [SYSTEM]
     Return the ‘<derivation>’ object of PACKAGE cross-built from SYSTEM
     to TARGET.

     TARGET must be a valid GNU triplet denoting the target hardware and
     operating system, such as ‘"aarch64-linux-gnu"’ (*note
     (autoconf)Specifying Target Triplets::).

   Packages can be manipulated in arbitrary ways.  An example of a
useful transformation is “input rewriting”, whereby the dependency tree
of a package is rewritten by replacing specific inputs by others:

 -- Scheme Procedure: package-input-rewriting REPLACEMENTS
          [REWRITE-NAME]
     Return a procedure that, when passed a package, replaces its direct
     and indirect dependencies (but not its implicit inputs) according
     to REPLACEMENTS.  REPLACEMENTS is a list of package pairs; the
     first element of each pair is the package to replace, and the
     second one is the replacement.

     Optionally, REWRITE-NAME is a one-argument procedure that takes the
     name of a package and returns its new name after rewrite.

Consider this example:

     (define libressl-instead-of-openssl
       ;; This is a procedure to replace OPENSSL by LIBRESSL,
       ;; recursively.
       (package-input-rewriting `((,openssl . ,libressl))))

     (define git-with-libressl
       (libressl-instead-of-openssl git))

Here we first define a rewriting procedure that replaces OPENSSL with
LIBRESSL.  Then we use it to define a “variant” of the GIT package that
uses LIBRESSL instead of OPENSSL.  This is exactly what the
‘--with-input’ command-line option does (*note ‘--with-input’: Package
Transformation Options.).

   The following variant of ‘package-input-rewriting’ can match packages
to be replaced by name rather than by identity.

 -- Scheme Procedure: package-input-rewriting/spec REPLACEMENTS
     Return a procedure that, given a package, applies the given
     REPLACEMENTS to all the package graph (excluding implicit inputs).
     REPLACEMENTS is a list of spec/procedures pair; each spec is a
     package specification such as ‘"gcc"’ or ‘"guile@2"’, and each
     procedure takes a matching package and returns a replacement for
     that package.

   The example above could be rewritten this way:

     (define libressl-instead-of-openssl
       ;; Replace all the packages called "openssl" with LibreSSL.
       (package-input-rewriting/spec `(("openssl" . ,(const libressl)))))

   The key difference here is that, this time, packages are matched by
spec and not by identity.  In other words, any package in the graph that
is called ‘openssl’ will be replaced.

   A more generic procedure to rewrite a package dependency graph is
‘package-mapping’: it supports arbitrary changes to nodes in the graph.

 -- Scheme Procedure: package-mapping PROC [CUT?]
     Return a procedure that, given a package, applies PROC to all the
     packages depended on and returns the resulting package.  The
     procedure stops recursion when CUT? returns true for a given
     package.

* Menu:

* package Reference::           The package data type.
* origin Reference::            The origin data type.


File: guix.info,  Node: package Reference,  Next: origin Reference,  Up: Defining Packages

6.2.1 ‘package’ Reference
-------------------------

This section summarizes all the options available in ‘package’
declarations (*note Defining Packages::).

 -- Data Type: package
     This is the data type representing a package recipe.

     ‘name’
          The name of the package, as a string.

     ‘version’
          The version of the package, as a string.

     ‘source’
          An object telling how the source code for the package should
          be acquired.  Most of the time, this is an ‘origin’ object,
          which denotes a file fetched from the Internet (*note origin
          Reference::).  It can also be any other “file-like” object
          such as a ‘local-file’, which denotes a file from the local
          file system (*note ‘local-file’: G-Expressions.).

     ‘build-system’
          The build system that should be used to build the package
          (*note Build Systems::).

     ‘arguments’ (default: ‘'()’)
          The arguments that should be passed to the build system.  This
          is a list, typically containing sequential keyword-value
          pairs.

     ‘inputs’ (default: ‘'()’)
     ‘native-inputs’ (default: ‘'()’)
     ‘propagated-inputs’ (default: ‘'()’)
          These fields list dependencies of the package.  Each one is a
          list of tuples, where each tuple has a label for the input (a
          string) as its first element, a package, origin, or derivation
          as its second element, and optionally the name of the output
          thereof that should be used, which defaults to ‘"out"’ (*note
          Packages with Multiple Outputs::, for more on package
          outputs).  For example, the list below specifies three inputs:

               `(("libffi" ,libffi)
                 ("libunistring" ,libunistring)
                 ("glib:bin" ,glib "bin"))  ;the "bin" output of Glib

          The distinction between ‘native-inputs’ and ‘inputs’ is
          necessary when considering cross-compilation.  When
          cross-compiling, dependencies listed in ‘inputs’ are built for
          the _target_ architecture; conversely, dependencies listed in
          ‘native-inputs’ are built for the architecture of the _build_
          machine.

          ‘native-inputs’ is typically used to list tools needed at
          build time, but not at run time, such as Autoconf, Automake,
          pkg-config, Gettext, or Bison.  ‘guix lint’ can report likely
          mistakes in this area (*note Invoking guix lint::).

          Lastly, ‘propagated-inputs’ is similar to ‘inputs’, but the
          specified packages will be automatically installed alongside
          the package they belong to (*note ‘guix package’:
          package-cmd-propagated-inputs, for information on how ‘guix
          package’ deals with propagated inputs).

          For example this is necessary when a C/C++ library needs
          headers of another library to compile, or when a pkg-config
          file refers to another one via its ‘Requires’ field.

          Another example where ‘propagated-inputs’ is useful is for
          languages that lack a facility to record the run-time search
          path akin to the ‘RUNPATH’ of ELF files; this includes Guile,
          Python, Perl, and more.  To ensure that libraries written in
          those languages can find library code they depend on at run
          time, run-time dependencies must be listed in
          ‘propagated-inputs’ rather than ‘inputs’.

     ‘outputs’ (default: ‘'("out")’)
          The list of output names of the package.  *Note Packages with
          Multiple Outputs::, for typical uses of additional outputs.

     ‘native-search-paths’ (default: ‘'()’)
     ‘search-paths’ (default: ‘'()’)
          A list of ‘search-path-specification’ objects describing
          search-path environment variables honored by the package.

     ‘replacement’ (default: ‘#f’)
          This must be either ‘#f’ or a package object that will be used
          as a “replacement” for this package.  *Note grafts: Security
          Updates, for details.

     ‘synopsis’
          A one-line description of the package.

     ‘description’
          A more elaborate description of the package.

     ‘license’
          The license of the package; a value from ‘(guix licenses)’, or
          a list of such values.

     ‘home-page’
          The URL to the home-page of the package, as a string.

     ‘supported-systems’ (default: ‘%supported-systems’)
          The list of systems supported by the package, as strings of
          the form ‘architecture-kernel’, for example ‘"x86_64-linux"’.

     ‘location’ (default: source location of the ‘package’ form)
          The source location of the package.  It is useful to override
          this when inheriting from another package, in which case this
          field is not automatically corrected.

 -- Scheme Syntax: this-package
     When used in the _lexical scope_ of a package field definition,
     this identifier resolves to the package being defined.

     The example below shows how to add a package as a native input of
     itself when cross-compiling:

          (package
            (name "guile")
            ;; ...

            ;; When cross-compiled, Guile, for example, depends on
            ;; a native version of itself.  Add it here.
            (native-inputs (if (%current-target-system)
                               `(("self" ,this-package))
                               '())))

     It is an error to refer to ‘this-package’ outside a package
     definition.


File: guix.info,  Node: origin Reference,  Prev: package Reference,  Up: Defining Packages

6.2.2 ‘origin’ Reference
------------------------

This section summarizes all the options available in ‘origin’
declarations (*note Defining Packages::).

 -- Data Type: origin
     This is the data type representing a source code origin.

     ‘uri’
          An object containing the URI of the source.  The object type
          depends on the ‘method’ (see below).  For example, when using
          the URL-FETCH method of ‘(guix download)’, the valid ‘uri’
          values are: a URL represented as a string, or a list thereof.

     ‘method’
          A procedure that handles the URI.

          Examples include:

          URL-FETCH from ‘(guix download)’
               download a file from the HTTP, HTTPS, or FTP URL
               specified in the ‘uri’ field;

          GIT-FETCH from ‘(guix git-download)’
               clone the Git version control repository, and check out
               the revision specified in the ‘uri’ field as a
               ‘git-reference’ object; a ‘git-reference’ looks like
               this:

                    (git-reference
                      (url "https://git.savannah.gnu.org/git/hello.git")
                      (commit "v2.10"))

     ‘sha256’
          A bytevector containing the SHA-256 hash of the source.  This
          is equivalent to providing a ‘content-hash’ SHA256 object in
          the ‘hash’ field described below.

     ‘hash’
          The ‘content-hash’ object of the source—see below for how to
          use ‘content-hash’.

          You can obtain this information using ‘guix download’ (*note
          Invoking guix download::) or ‘guix hash’ (*note Invoking guix
          hash::).

     ‘file-name’ (default: ‘#f’)
          The file name under which the source code should be saved.
          When this is ‘#f’, a sensible default value will be used in
          most cases.  In case the source is fetched from a URL, the
          file name from the URL will be used.  For version control
          checkouts, it is recommended to provide the file name
          explicitly because the default is not very descriptive.

     ‘patches’ (default: ‘'()’)
          A list of file names, origins, or file-like objects (*note
          file-like objects: G-Expressions.) pointing to patches to be
          applied to the source.

          This list of patches must be unconditional.  In particular, it
          cannot depend on the value of ‘%current-system’ or
          ‘%current-target-system’.

     ‘snippet’ (default: ‘#f’)
          A G-expression (*note G-Expressions::) or S-expression that
          will be run in the source directory.  This is a convenient way
          to modify the source, sometimes more convenient than a patch.

     ‘patch-flags’ (default: ‘'("-p1")’)
          A list of command-line flags that should be passed to the
          ‘patch’ command.

     ‘patch-inputs’ (default: ‘#f’)
          Input packages or derivations to the patching process.  When
          this is ‘#f’, the usual set of inputs necessary for patching
          are provided, such as GNU Patch.

     ‘modules’ (default: ‘'()’)
          A list of Guile modules that should be loaded during the
          patching process and while running the code in the ‘snippet’
          field.

     ‘patch-guile’ (default: ‘#f’)
          The Guile package that should be used in the patching process.
          When this is ‘#f’, a sensible default is used.

 -- Data Type: content-hash VALUE [ALGORITHM]
     Construct a content hash object for the given ALGORITHM, and with
     VALUE as its hash value.  When ALGORITHM is omitted, assume it is
     ‘sha256’.

     VALUE can be a literal string, in which case it is base32-decoded,
     or it can be a bytevector.

     The following forms are all equivalent:

          (content-hash "05zxkyz9bv3j9h0xyid1rhvh3klhsmrpkf3bcs6frvlgyr2gwilj")
          (content-hash "05zxkyz9bv3j9h0xyid1rhvh3klhsmrpkf3bcs6frvlgyr2gwilj"
                        sha256)
          (content-hash (base32
                         "05zxkyz9bv3j9h0xyid1rhvh3klhsmrpkf3bcs6frvlgyr2gwilj"))
          (content-hash (base64 "kkb+RPaP7uyMZmu4eXPVkM4BN8yhRd8BTHLslb6f/Rc=")
                        sha256)

     Technically, ‘content-hash’ is currently implemented as a macro.
     It performs sanity checks at macro-expansion time, when possible,
     such as ensuring that VALUE has the right size for ALGORITHM.


File: guix.info,  Node: Build Systems,  Next: The Store,  Prev: Defining Packages,  Up: Programming Interface

6.3 Build Systems
=================

Each package definition specifies a “build system” and arguments for
that build system (*note Defining Packages::).  This ‘build-system’
field represents the build procedure of the package, as well as implicit
dependencies of that build procedure.

   Build systems are ‘<build-system>’ objects.  The interface to create
and manipulate them is provided by the ‘(guix build-system)’ module, and
actual build systems are exported by specific modules.

   Under the hood, build systems first compile package objects to
“bags”.  A “bag” is like a package, but with less ornamentation—in other
words, a bag is a lower-level representation of a package, which
includes all the inputs of that package, including some that were
implicitly added by the build system.  This intermediate representation
is then compiled to a derivation (*note Derivations::).

   Build systems accept an optional list of “arguments”.  In package
definitions, these are passed via the ‘arguments’ field (*note Defining
Packages::).  They are typically keyword arguments (*note keyword
arguments in Guile: (guile)Optional Arguments.).  The value of these
arguments is usually evaluated in the “build stratum”—i.e., by a Guile
process launched by the daemon (*note Derivations::).

   The main build system is ‘gnu-build-system’, which implements the
standard build procedure for GNU and many other packages.  It is
provided by the ‘(guix build-system gnu)’ module.

 -- Scheme Variable: gnu-build-system
     ‘gnu-build-system’ represents the GNU Build System, and variants
     thereof (*note configuration and makefile conventions:
     (standards)Configuration.).

     In a nutshell, packages using it are configured, built, and
     installed with the usual ‘./configure && make && make check && make
     install’ command sequence.  In practice, a few additional steps are
     often needed.  All these steps are split up in separate “phases”,
     notably(1):

     ‘unpack’
          Unpack the source tarball, and change the current directory to
          the extracted source tree.  If the source is actually a
          directory, copy it to the build tree, and enter that
          directory.

     ‘patch-source-shebangs’
          Patch shebangs encountered in source files so they refer to
          the right store file names.  For instance, this changes
          ‘#!/bin/sh’ to ‘#!/gnu/store/...-bash-4.3/bin/sh’.

     ‘configure’
          Run the ‘configure’ script with a number of default options,
          such as ‘--prefix=/gnu/store/...’, as well as the options
          specified by the ‘#:configure-flags’ argument.

     ‘build’
          Run ‘make’ with the list of flags specified with
          ‘#:make-flags’.  If the ‘#:parallel-build?’ argument is true
          (the default), build with ‘make -j’.

     ‘check’
          Run ‘make check’, or some other target specified with
          ‘#:test-target’, unless ‘#:tests? #f’ is passed.  If the
          ‘#:parallel-tests?’ argument is true (the default), run ‘make
          check -j’.

     ‘install’
          Run ‘make install’ with the flags listed in ‘#:make-flags’.

     ‘patch-shebangs’
          Patch shebangs on the installed executable files.

     ‘strip’
          Strip debugging symbols from ELF files (unless
          ‘#:strip-binaries?’ is false), copying them to the ‘debug’
          output when available (*note Installing Debugging Files::).

     The build-side module ‘(guix build gnu-build-system)’ defines
     ‘%standard-phases’ as the default list of build phases.
     ‘%standard-phases’ is a list of symbol/procedure pairs, where the
     procedure implements the actual phase.

     The list of phases used for a particular package can be changed
     with the ‘#:phases’ parameter.  For instance, passing:

          #:phases (modify-phases %standard-phases (delete 'configure))

     means that all the phases described above will be used, except the
     ‘configure’ phase.

     In addition, this build system ensures that the “standard”
     environment for GNU packages is available.  This includes tools
     such as GCC, libc, Coreutils, Bash, Make, Diffutils, grep, and sed
     (see the ‘(guix build-system gnu)’ module for a complete list).  We
     call these the “implicit inputs” of a package, because package
     definitions do not have to mention them.

   Other ‘<build-system>’ objects are defined to support other
conventions and tools used by free software packages.  They inherit most
of ‘gnu-build-system’, and differ mainly in the set of inputs implicitly
added to the build process, and in the list of phases executed.  Some of
these build systems are listed below.

 -- Scheme Variable: ant-build-system
     This variable is exported by ‘(guix build-system ant)’.  It
     implements the build procedure for Java packages that can be built
     with Ant build tool (https://ant.apache.org/).

     It adds both ‘ant’ and the “Java Development Kit” (JDK) as provided
     by the ‘icedtea’ package to the set of inputs.  Different packages
     can be specified with the ‘#:ant’ and ‘#:jdk’ parameters,
     respectively.

     When the original package does not provide a suitable Ant build
     file, the parameter ‘#:jar-name’ can be used to generate a minimal
     Ant build file ‘build.xml’ with tasks to build the specified jar
     archive.  In this case the parameter ‘#:source-dir’ can be used to
     specify the source sub-directory, defaulting to “src”.

     The ‘#:main-class’ parameter can be used with the minimal ant
     buildfile to specify the main class of the resulting jar.  This
     makes the jar file executable.  The ‘#:test-include’ parameter can
     be used to specify the list of junit tests to run.  It defaults to
     ‘(list "**/*Test.java")’.  The ‘#:test-exclude’ can be used to
     disable some tests.  It defaults to ‘(list "**/Abstract*.java")’,
     because abstract classes cannot be run as tests.

     The parameter ‘#:build-target’ can be used to specify the Ant task
     that should be run during the ‘build’ phase.  By default the “jar”
     task will be run.

 -- Scheme Variable: android-ndk-build-system
     This variable is exported by ‘(guix build-system android-ndk)’.  It
     implements a build procedure for Android NDK (native development
     kit) packages using a Guix-specific build process.

     The build system assumes that packages install their public
     interface (header) files to the subdirectory ‘include’ of the ‘out’
     output and their libraries to the subdirectory ‘lib’ the ‘out’
     output.

     It’s also assumed that the union of all the dependencies of a
     package has no conflicting files.

     For the time being, cross-compilation is not supported - so right
     now the libraries and header files are assumed to be host tools.

 -- Scheme Variable: asdf-build-system/source
 -- Scheme Variable: asdf-build-system/sbcl
 -- Scheme Variable: asdf-build-system/ecl

     These variables, exported by ‘(guix build-system asdf)’, implement
     build procedures for Common Lisp packages using “ASDF”
     (https://common-lisp.net/project/asdf/).  ASDF is a system
     definition facility for Common Lisp programs and libraries.

     The ‘asdf-build-system/source’ system installs the packages in
     source form, and can be loaded using any common lisp
     implementation, via ASDF. The others, such as
     ‘asdf-build-system/sbcl’, install binary systems in the format
     which a particular implementation understands.  These build systems
     can also be used to produce executable programs, or lisp images
     which contain a set of packages pre-loaded.

     The build system uses naming conventions.  For binary packages, the
     package name should be prefixed with the lisp implementation, such
     as ‘sbcl-’ for ‘asdf-build-system/sbcl’.

     Additionally, the corresponding source package should be labeled
     using the same convention as python packages (see *note Python
     Modules::), using the ‘cl-’ prefix.

     For binary packages, each system should be defined as a Guix
     package.  If one package ‘origin’ contains several systems, package
     variants can be created in order to build all the systems.  Source
     packages, which use ‘asdf-build-system/source’, may contain several
     systems.

     In order to create executable programs and images, the build-side
     procedures ‘build-program’ and ‘build-image’ can be used.  They
     should be called in a build phase after the ‘create-symlinks’
     phase, so that the system which was just built can be used within
     the resulting image.  ‘build-program’ requires a list of Common
     Lisp expressions to be passed as the ‘#:entry-program’ argument.

     If the system is not defined within its own ‘.asd’ file of the same
     name, then the ‘#:asd-file’ parameter should be used to specify
     which file the system is defined in.  Furthermore, if the package
     defines a system for its tests in a separate file, it will be
     loaded before the tests are run if it is specified by the
     ‘#:test-asd-file’ parameter.  If it is not set, the files
     ‘<system>-tests.asd’, ‘<system>-test.asd’, ‘tests.asd’, and
     ‘test.asd’ will be tried if they exist.

     If for some reason the package must be named in a different way
     than the naming conventions suggest, the ‘#:asd-system-name’
     parameter can be used to specify the name of the system.

 -- Scheme Variable: cargo-build-system
     This variable is exported by ‘(guix build-system cargo)’.  It
     supports builds of packages using Cargo, the build tool of the Rust
     programming language (https://www.rust-lang.org).

     It adds ‘rustc’ and ‘cargo’ to the set of inputs.  A different Rust
     package can be specified with the ‘#:rust’ parameter.

     Regular cargo dependencies should be added to the package
     definition via the ‘#:cargo-inputs’ parameter as a list of name and
     spec pairs, where the spec can be a package or a source definition.
     Note that the spec must evaluate to a path to a gzipped tarball
     which includes a ‘Cargo.toml’ file at its root, or it will be
     ignored.  Similarly, cargo dev-dependencies should be added to the
     package definition via the ‘#:cargo-development-inputs’ parameter.

     In its ‘configure’ phase, this build system will make any source
     inputs specified in the ‘#:cargo-inputs’ and
     ‘#:cargo-development-inputs’ parameters available to cargo.  It
     will also remove an included ‘Cargo.lock’ file to be recreated by
     ‘cargo’ during the ‘build’ phase.  The ‘install’ phase installs any
     crate the binaries if they are defined by the crate.

 -- Scheme Variable: copy-build-system
     This variable is exported by ‘(guix build-system copy)’.  It
     supports builds of simple packages that don’t require much
     compiling, mostly just moving files around.

     It adds much of the ‘gnu-build-system’ packages to the set of
     inputs.  Because of this, the ‘copy-build-system’ does not require
     all the boilerplate code often needed for the
     ‘trivial-build-system’.

     To further simplify the file installation process, an
     ‘#:install-plan’ argument is exposed to let the packager specify
     which files go where.  The install plan is a list of ‘(SOURCE
     TARGET [FILTERS])’.  FILTERS are optional.

        • When SOURCE matches a file or directory without trailing
          slash, install it to TARGET.
             • If TARGET has a trailing slash, install SOURCE basename
               beneath TARGET.
             • Otherwise install SOURCE as TARGET.

        • When SOURCE is a directory with a trailing slash, or when
          FILTERS are used, the trailing slash of TARGET is implied with
          the same meaning as above.
             • Without FILTERS, install the full SOURCE _content_ to
               TARGET.
             • With FILTERS among ‘#:include’, ‘#:include-regexp’,
               ‘#:exclude’, ‘#:exclude-regexp’, only select files are
               installed depending on the filters.  Each filters is
               specified by a list of strings.
                  • With ‘#:include’, install all the files which the
                    path suffix matches at least one of the elements in
                    the given list.
                  • With ‘#:include-regexp’, install all the files which
                    the subpaths match at least one of the regular
                    expressions in the given list.
                  • The ‘#:exclude’ and ‘#:exclude-regexp’ filters are
                    the complement of their inclusion counterpart.
                    Without ‘#:include’ flags, install all files but
                    those matching the exclusion filters.  If both
                    inclusions and exclusions are specified, the
                    exclusions are done on top of the inclusions.
          In all cases, the paths relative to SOURCE are preserved
          within TARGET.

     Examples:

        • ‘("foo/bar" "share/my-app/")’: Install ‘bar’ to
          ‘share/my-app/bar’.
        • ‘("foo/bar" "share/my-app/baz")’: Install ‘bar’ to
          ‘share/my-app/baz’.
        • ‘("foo/" "share/my-app")’: Install the content of ‘foo’ inside
          ‘share/my-app’, e.g., install ‘foo/sub/file’ to
          ‘share/my-app/sub/file’.
        • ‘("foo/" "share/my-app" #:include ("sub/file"))’: Install only
          ‘foo/sub/file’ to ‘share/my-app/sub/file’.
        • ‘("foo/sub" "share/my-app" #:include ("file"))’: Install
          ‘foo/sub/file’ to ‘share/my-app/file’.

 -- Scheme Variable: clojure-build-system
     This variable is exported by ‘(guix build-system clojure)’.  It
     implements a simple build procedure for Clojure
     (https://clojure.org/) packages using plain old ‘compile’ in
     Clojure.  Cross-compilation is not supported yet.

     It adds ‘clojure’, ‘icedtea’ and ‘zip’ to the set of inputs.
     Different packages can be specified with the ‘#:clojure’, ‘#:jdk’
     and ‘#:zip’ parameters, respectively.

     A list of source directories, test directories and jar names can be
     specified with the ‘#:source-dirs’, ‘#:test-dirs’ and ‘#:jar-names’
     parameters, respectively.  Compile directory and main class can be
     specified with the ‘#:compile-dir’ and ‘#:main-class’ parameters,
     respectively.  Other parameters are documented below.

     This build system is an extension of ‘ant-build-system’, but with
     the following phases changed:

     ‘build’
          This phase calls ‘compile’ in Clojure to compile source files
          and runs ‘jar’ to create jars from both source files and
          compiled files according to the include list and exclude list
          specified in ‘#:aot-include’ and ‘#:aot-exclude’,
          respectively.  The exclude list has priority over the include
          list.  These lists consist of symbols representing Clojure
          libraries or the special keyword ‘#:all’ representing all
          Clojure libraries found under the source directories.  The
          parameter ‘#:omit-source?’ decides if source should be
          included into the jars.

     ‘check’
          This phase runs tests according to the include list and
          exclude list specified in ‘#:test-include’ and
          ‘#:test-exclude’, respectively.  Their meanings are analogous
          to that of ‘#:aot-include’ and ‘#:aot-exclude’, except that
          the special keyword ‘#:all’ now stands for all Clojure
          libraries found under the test directories.  The parameter
          ‘#:tests?’ decides if tests should be run.

     ‘install’
          This phase installs all jars built previously.

     Apart from the above, this build system also contains an additional
     phase:

     ‘install-doc’
          This phase installs all top-level files with base name
          matching ‘%doc-regex’.  A different regex can be specified
          with the ‘#:doc-regex’ parameter.  All files (recursively)
          inside the documentation directories specified in ‘#:doc-dirs’
          are installed as well.

 -- Scheme Variable: cmake-build-system
     This variable is exported by ‘(guix build-system cmake)’.  It
     implements the build procedure for packages using the CMake build
     tool (https://www.cmake.org).

     It automatically adds the ‘cmake’ package to the set of inputs.
     Which package is used can be specified with the ‘#:cmake’
     parameter.

     The ‘#:configure-flags’ parameter is taken as a list of flags
     passed to the ‘cmake’ command.  The ‘#:build-type’ parameter
     specifies in abstract terms the flags passed to the compiler; it
     defaults to ‘"RelWithDebInfo"’ (short for “release mode with
     debugging information”), which roughly means that code is compiled
     with ‘-O2 -g’, as is the case for Autoconf-based packages by
     default.

 -- Scheme Variable: dune-build-system
     This variable is exported by ‘(guix build-system dune)’.  It
     supports builds of packages using Dune (https://dune.build/), a
     build tool for the OCaml programming language.  It is implemented
     as an extension of the ‘ocaml-build-system’ which is described
     below.  As such, the ‘#:ocaml’ and ‘#:findlib’ parameters can be
     passed to this build system.

     It automatically adds the ‘dune’ package to the set of inputs.
     Which package is used can be specified with the ‘#:dune’ parameter.

     There is no ‘configure’ phase because dune packages typically don’t
     need to be configured.  The ‘#:build-flags’ parameter is taken as a
     list of flags passed to the ‘dune’ command during the build.

     The ‘#:jbuild?’ parameter can be passed to use the ‘jbuild’ command
     instead of the more recent ‘dune’ command while building a package.
     Its default value is ‘#f’.

     The ‘#:package’ parameter can be passed to specify a package name,
     which is useful when a package contains multiple packages and you
     want to build only one of them.  This is equivalent to passing the
     ‘-p’ argument to ‘dune’.

 -- Scheme Variable: go-build-system
     This variable is exported by ‘(guix build-system go)’.  It
     implements a build procedure for Go packages using the standard Go
     build mechanisms
     (https://golang.org/cmd/go/#hdr-Compile_packages_and_dependencies).

     The user is expected to provide a value for the key ‘#:import-path’
     and, in some cases, ‘#:unpack-path’.  The import path
     (https://golang.org/doc/code.html#ImportPaths) corresponds to the
     file system path expected by the package’s build scripts and any
     referring packages, and provides a unique way to refer to a Go
     package.  It is typically based on a combination of the package
     source code’s remote URI and file system hierarchy structure.  In
     some cases, you will need to unpack the package’s source code to a
     different directory structure than the one indicated by the import
     path, and ‘#:unpack-path’ should be used in such cases.

     Packages that provide Go libraries should install their source code
     into the built output.  The key ‘#:install-source?’, which defaults
     to ‘#t’, controls whether or not the source code is installed.  It
     can be set to ‘#f’ for packages that only provide executable files.

 -- Scheme Variable: glib-or-gtk-build-system
     This variable is exported by ‘(guix build-system glib-or-gtk)’.  It
     is intended for use with packages making use of GLib or GTK+.

     This build system adds the following two phases to the ones defined
     by ‘gnu-build-system’:

     ‘glib-or-gtk-wrap’
          The phase ‘glib-or-gtk-wrap’ ensures that programs in ‘bin/’
          are able to find GLib “schemas” and GTK+ modules
          (https://developer.gnome.org/gtk3/stable/gtk-running.html).
          This is achieved by wrapping the programs in launch scripts
          that appropriately set the ‘XDG_DATA_DIRS’ and ‘GTK_PATH’
          environment variables.

          It is possible to exclude specific package outputs from that
          wrapping process by listing their names in the
          ‘#:glib-or-gtk-wrap-excluded-outputs’ parameter.  This is
          useful when an output is known not to contain any GLib or GTK+
          binaries, and where wrapping would gratuitously add a
          dependency of that output on GLib and GTK+.

     ‘glib-or-gtk-compile-schemas’
          The phase ‘glib-or-gtk-compile-schemas’ makes sure that all
          GSettings schemas
          (https://developer.gnome.org/gio/stable/glib-compile-schemas.html)
          of GLib are compiled.  Compilation is performed by the
          ‘glib-compile-schemas’ program.  It is provided by the package
          ‘glib:bin’ which is automatically imported by the build
          system.  The ‘glib’ package providing ‘glib-compile-schemas’
          can be specified with the ‘#:glib’ parameter.

     Both phases are executed after the ‘install’ phase.

 -- Scheme Variable: guile-build-system
     This build system is for Guile packages that consist exclusively of
     Scheme code and that are so lean that they don’t even have a
     makefile, let alone a ‘configure’ script.  It compiles Scheme code
     using ‘guild compile’ (*note (guile)Compilation::) and installs the
     ‘.scm’ and ‘.go’ files in the right place.  It also installs
     documentation.

     This build system supports cross-compilation by using the
     ‘--target’ option of ‘guild compile’.

     Packages built with ‘guile-build-system’ must provide a Guile
     package in their ‘native-inputs’ field.

 -- Scheme Variable: julia-build-system
     This variable is exported by ‘(guix build-system julia)’.  It
     implements the build procedure used by julia
     (https://julialang.org/) packages, which essentially is similar to
     running ‘julia -e 'using Pkg; Pkg.add(package)'’ in an environment
     where ‘JULIA_LOAD_PATH’ contains the paths to all Julia package
     inputs.  Tests are run not run.

     Julia packages require the source ‘file-name’ to be the real name
     of the package, correctly capitalized.

     For packages requiring shared library dependencies, you may need to
     write the ‘/deps/deps.jl’ file manually.  It’s usually a line of
     ‘const variable = /gnu/store/library.so’ for each dependency, plus
     a void function ‘check_deps() = nothing’.

     Some older packages that aren’t using ‘Package.toml’ yet, will
     require this file to be created, too.  The function
     ‘julia-create-package-toml’ helps creating the file.  You need to
     pass the outputs and the source of the package, it’s name (the same
     as the ‘file-name’ parameter), the package uuid, the package
     version, and a list of dependencies specified by their name and
     their uuid.

 -- Scheme Variable: minify-build-system
     This variable is exported by ‘(guix build-system minify)’.  It
     implements a minification procedure for simple JavaScript packages.

     It adds ‘uglify-js’ to the set of inputs and uses it to compress
     all JavaScript files in the ‘src’ directory.  A different minifier
     package can be specified with the ‘#:uglify-js’ parameter, but it
     is expected that the package writes the minified code to the
     standard output.

     When the input JavaScript files are not all located in the ‘src’
     directory, the parameter ‘#:javascript-files’ can be used to
     specify a list of file names to feed to the minifier.

 -- Scheme Variable: ocaml-build-system
     This variable is exported by ‘(guix build-system ocaml)’.  It
     implements a build procedure for OCaml (https://ocaml.org)
     packages, which consists of choosing the correct set of commands to
     run for each package.  OCaml packages can expect many different
     commands to be run.  This build system will try some of them.

     When the package has a ‘setup.ml’ file present at the top-level, it
     will run ‘ocaml setup.ml -configure’, ‘ocaml setup.ml -build’ and
     ‘ocaml setup.ml -install’.  The build system will assume that this
     file was generated by OASIS (http://oasis.forge.ocamlcore.org/) and
     will take care of setting the prefix and enabling tests if they are
     not disabled.  You can pass configure and build flags with the
     ‘#:configure-flags’ and ‘#:build-flags’.  The ‘#:test-flags’ key
     can be passed to change the set of flags used to enable tests.  The
     ‘#:use-make?’ key can be used to bypass this system in the build
     and install phases.

     When the package has a ‘configure’ file, it is assumed that it is a
     hand-made configure script that requires a different argument
     format than in the ‘gnu-build-system’.  You can add more flags with
     the ‘#:configure-flags’ key.

     When the package has a ‘Makefile’ file (or ‘#:use-make?’ is ‘#t’),
     it will be used and more flags can be passed to the build and
     install phases with the ‘#:make-flags’ key.

     Finally, some packages do not have these files and use a somewhat
     standard location for its build system.  In that case, the build
     system will run ‘ocaml pkg/pkg.ml’ or ‘ocaml pkg/build.ml’ and take
     care of providing the path to the required findlib module.
     Additional flags can be passed via the ‘#:build-flags’ key.
     Install is taken care of by ‘opam-installer’.  In this case, the
     ‘opam’ package must be added to the ‘native-inputs’ field of the
     package definition.

     Note that most OCaml packages assume they will be installed in the
     same directory as OCaml, which is not what we want in guix.  In
     particular, they will install ‘.so’ files in their module’s
     directory, which is usually fine because it is in the OCaml
     compiler directory.  In guix though, these libraries cannot be
     found and we use ‘CAML_LD_LIBRARY_PATH’.  This variable points to
     ‘lib/ocaml/site-lib/stubslibs’ and this is where ‘.so’ libraries
     should be installed.

 -- Scheme Variable: python-build-system
     This variable is exported by ‘(guix build-system python)’.  It
     implements the more or less standard build procedure used by Python
     packages, which consists in running ‘python setup.py build’ and
     then ‘python setup.py install --prefix=/gnu/store/...’.

     For packages that install stand-alone Python programs under ‘bin/’,
     it takes care of wrapping these programs so that their ‘PYTHONPATH’
     environment variable points to all the Python libraries they depend
     on.

     Which Python package is used to perform the build can be specified
     with the ‘#:python’ parameter.  This is a useful way to force a
     package to be built for a specific version of the Python
     interpreter, which might be necessary if the package is only
     compatible with a single interpreter version.

     By default guix calls ‘setup.py’ under control of ‘setuptools’,
     much like ‘pip’ does.  Some packages are not compatible with
     setuptools (and pip), thus you can disable this by setting the
     ‘#:use-setuptools?’ parameter to ‘#f’.

 -- Scheme Variable: perl-build-system
     This variable is exported by ‘(guix build-system perl)’.  It
     implements the standard build procedure for Perl packages, which
     either consists in running ‘perl Build.PL --prefix=/gnu/store/...’,
     followed by ‘Build’ and ‘Build install’; or in running ‘perl
     Makefile.PL PREFIX=/gnu/store/...’, followed by ‘make’ and ‘make
     install’, depending on which of ‘Build.PL’ or ‘Makefile.PL’ is
     present in the package distribution.  Preference is given to the
     former if both ‘Build.PL’ and ‘Makefile.PL’ exist in the package
     distribution.  This preference can be reversed by specifying ‘#t’
     for the ‘#:make-maker?’ parameter.

     The initial ‘perl Makefile.PL’ or ‘perl Build.PL’ invocation passes
     flags specified by the ‘#:make-maker-flags’ or
     ‘#:module-build-flags’ parameter, respectively.

     Which Perl package is used can be specified with ‘#:perl’.

 -- Scheme Variable: qt-build-system
     This variable is exported by ‘(guix build-system qt)’.  It is
     intended for use with applications using Qt or KDE.

     This build system adds the following two phases to the ones defined
     by ‘cmake-build-system’:

     ‘check-setup’
          The phase ‘check-setup’ prepares the environment for running
          the checks as commonly used by Qt test programs.  For now this
          only sets some environment variables:
          ‘QT_QPA_PLATFORM=offscreen’, ‘DBUS_FATAL_WARNINGS=0’ and
          ‘CTEST_OUTPUT_ON_FAILURE=1’.

          This phase is added before the ‘check’ phase.  It’s a separate
          phase to ease adjusting if necessary.

     ‘qt-wrap’
          The phase ‘qt-wrap’ searches for Qt5 plugin paths, QML paths
          and some XDG in the inputs and output.  In case some path is
          found, all programs in the output’s ‘bin/’, ‘sbin/’,
          ‘libexec/’ and ‘lib/libexec/’ directories are wrapped in
          scripts defining the necessary environment variables.

          It is possible to exclude specific package outputs from that
          wrapping process by listing their names in the
          ‘#:qt-wrap-excluded-outputs’ parameter.  This is useful when
          an output is known not to contain any Qt binaries, and where
          wrapping would gratuitously add a dependency of that output on
          Qt, KDE, or such.

          This phase is added after the ‘install’ phase.

 -- Scheme Variable: r-build-system
     This variable is exported by ‘(guix build-system r)’.  It
     implements the build procedure used by R (https://r-project.org)
     packages, which essentially is little more than running ‘R CMD
     INSTALL --library=/gnu/store/...’ in an environment where
     ‘R_LIBS_SITE’ contains the paths to all R package inputs.  Tests
     are run after installation using the R function
     ‘tools::testInstalledPackage’.

 -- Scheme Variable: rakudo-build-system
     This variable is exported by ‘(guix build-system rakudo)’.  It
     implements the build procedure used by Rakudo (https://rakudo.org/)
     for Perl6 (https://perl6.org/) packages.  It installs the package
     to ‘/gnu/store/.../NAME-VERSION/share/perl6’ and installs the
     binaries, library files and the resources, as well as wrap the
     files under the ‘bin/’ directory.  Tests can be skipped by passing
     ‘#f’ to the ‘tests?’ parameter.

     Which rakudo package is used can be specified with ‘rakudo’.  Which
     perl6-tap-harness package used for the tests can be specified with
     ‘#:prove6’ or removed by passing ‘#f’ to the ‘with-prove6?’
     parameter.  Which perl6-zef package used for tests and installing
     can be specified with ‘#:zef’ or removed by passing ‘#f’ to the
     ‘with-zef?’ parameter.

 -- Scheme Variable: texlive-build-system
     This variable is exported by ‘(guix build-system texlive)’.  It is
     used to build TeX packages in batch mode with a specified engine.
     The build system sets the ‘TEXINPUTS’ variable to find all TeX
     source files in the inputs.

     By default it runs ‘luatex’ on all files ending on ‘ins’.  A
     different engine and format can be specified with the
     ‘#:tex-format’ argument.  Different build targets can be specified
     with the ‘#:build-targets’ argument, which expects a list of file
     names.  The build system adds only ‘texlive-bin’ and
     ‘texlive-latex-base’ (both from ‘(gnu packages tex’) to the inputs.
     Both can be overridden with the arguments ‘#:texlive-bin’ and
     ‘#:texlive-latex-base’, respectively.

     The ‘#:tex-directory’ parameter tells the build system where to
     install the built files under the texmf tree.

 -- Scheme Variable: ruby-build-system
     This variable is exported by ‘(guix build-system ruby)’.  It
     implements the RubyGems build procedure used by Ruby packages,
     which involves running ‘gem build’ followed by ‘gem install’.

     The ‘source’ field of a package that uses this build system
     typically references a gem archive, since this is the format that
     Ruby developers use when releasing their software.  The build
     system unpacks the gem archive, potentially patches the source,
     runs the test suite, repackages the gem, and installs it.
     Additionally, directories and tarballs may be referenced to allow
     building unreleased gems from Git or a traditional source release
     tarball.

     Which Ruby package is used can be specified with the ‘#:ruby’
     parameter.  A list of additional flags to be passed to the ‘gem’
     command can be specified with the ‘#:gem-flags’ parameter.

 -- Scheme Variable: waf-build-system
     This variable is exported by ‘(guix build-system waf)’.  It
     implements a build procedure around the ‘waf’ script.  The common
     phases—‘configure’, ‘build’, and ‘install’—are implemented by
     passing their names as arguments to the ‘waf’ script.

     The ‘waf’ script is executed by the Python interpreter.  Which
     Python package is used to run the script can be specified with the
     ‘#:python’ parameter.

 -- Scheme Variable: scons-build-system
     This variable is exported by ‘(guix build-system scons)’.  It
     implements the build procedure used by the SCons software
     construction tool.  This build system runs ‘scons’ to build the
     package, ‘scons test’ to run tests, and then ‘scons install’ to
     install the package.

     Additional flags to be passed to ‘scons’ can be specified with the
     ‘#:scons-flags’ parameter.  The default build and install targets
     can be overridden with ‘#:build-targets’ and ‘#:install-targets’
     respectively.  The version of Python used to run SCons can be
     specified by selecting the appropriate SCons package with the
     ‘#:scons’ parameter.

 -- Scheme Variable: haskell-build-system
     This variable is exported by ‘(guix build-system haskell)’.  It
     implements the Cabal build procedure used by Haskell packages,
     which involves running ‘runhaskell Setup.hs configure
     --prefix=/gnu/store/...’ and ‘runhaskell Setup.hs build’.  Instead
     of installing the package by running ‘runhaskell Setup.hs install’,
     to avoid trying to register libraries in the read-only compiler
     store directory, the build system uses ‘runhaskell Setup.hs copy’,
     followed by ‘runhaskell Setup.hs register’.  In addition, the build
     system generates the package documentation by running ‘runhaskell
     Setup.hs haddock’, unless ‘#:haddock? #f’ is passed.  Optional
     Haddock parameters can be passed with the help of the
     ‘#:haddock-flags’ parameter.  If the file ‘Setup.hs’ is not found,
     the build system looks for ‘Setup.lhs’ instead.

     Which Haskell compiler is used can be specified with the
     ‘#:haskell’ parameter which defaults to ‘ghc’.

 -- Scheme Variable: dub-build-system
     This variable is exported by ‘(guix build-system dub)’.  It
     implements the Dub build procedure used by D packages, which
     involves running ‘dub build’ and ‘dub run’.  Installation is done
     by copying the files manually.

     Which D compiler is used can be specified with the ‘#:ldc’
     parameter which defaults to ‘ldc’.

 -- Scheme Variable: emacs-build-system
     This variable is exported by ‘(guix build-system emacs)’.  It
     implements an installation procedure similar to the packaging
     system of Emacs itself (*note (emacs)Packages::).

     It first creates the ‘package-autoloads.el’ file, then it byte
     compiles all Emacs Lisp files.  Differently from the Emacs
     packaging system, the Info documentation files are moved to the
     standard documentation directory and the ‘dir’ file is deleted.
     The Elisp package files are installed directly under
     ‘share/emacs/site-lisp’.

 -- Scheme Variable: font-build-system
     This variable is exported by ‘(guix build-system font)’.  It
     implements an installation procedure for font packages where
     upstream provides pre-compiled TrueType, OpenType, etc. font files
     that merely need to be copied into place.  It copies font files to
     standard locations in the output directory.

 -- Scheme Variable: meson-build-system
     This variable is exported by ‘(guix build-system meson)’.  It
     implements the build procedure for packages that use Meson
     (https://mesonbuild.com) as their build system.

     It adds both Meson and Ninja (https://ninja-build.org/) to the set
     of inputs, and they can be changed with the parameters ‘#:meson’
     and ‘#:ninja’ if needed.  The default Meson is ‘meson-for-build’,
     which is special because it doesn’t clear the ‘RUNPATH’ of binaries
     and libraries when they are installed.

     This build system is an extension of ‘gnu-build-system’, but with
     the following phases changed to some specific for Meson:

     ‘configure’
          The phase runs ‘meson’ with the flags specified in
          ‘#:configure-flags’.  The flag ‘--buildtype’ is always set to
          ‘debugoptimized’ unless something else is specified in
          ‘#:build-type’.

     ‘build’
          The phase runs ‘ninja’ to build the package in parallel by
          default, but this can be changed with ‘#:parallel-build?’.

     ‘check’
          The phase runs ‘ninja’ with the target specified in
          ‘#:test-target’, which is ‘"test"’ by default.

     ‘install’
          The phase runs ‘ninja install’ and can not be changed.

     Apart from that, the build system also adds the following phases:

     ‘fix-runpath’
          This phase ensures that all binaries can find the libraries
          they need.  It searches for required libraries in
          subdirectories of the package being built, and adds those to
          ‘RUNPATH’ where needed.  It also removes references to
          libraries left over from the build phase by ‘meson-for-build’,
          such as test dependencies, that aren’t actually required for
          the program to run.

     ‘glib-or-gtk-wrap’
          This phase is the phase provided by
          ‘glib-or-gtk-build-system’, and it is not enabled by default.
          It can be enabled with ‘#:glib-or-gtk?’.

     ‘glib-or-gtk-compile-schemas’
          This phase is the phase provided by
          ‘glib-or-gtk-build-system’, and it is not enabled by default.
          It can be enabled with ‘#:glib-or-gtk?’.

 -- Scheme Variable: linux-module-build-system
     ‘linux-module-build-system’ allows building Linux kernel modules.

     This build system is an extension of ‘gnu-build-system’, but with
     the following phases changed:

     ‘configure’
          This phase configures the environment so that the Linux
          kernel’s Makefile can be used to build the external kernel
          module.

     ‘build’
          This phase uses the Linux kernel’s Makefile in order to build
          the external kernel module.

     ‘install’
          This phase uses the Linux kernel’s Makefile in order to
          install the external kernel module.

     It is possible and useful to specify the Linux kernel to use for
     building the module (in the ‘arguments’ form of a package using the
     ‘linux-module-build-system’, use the key ‘#:linux’ to specify it).

 -- Scheme Variable: node-build-system
     This variable is exported by ‘(guix build-system node)’.  It
     implements the build procedure used by Node.js
     (https://nodejs.org), which implements an approximation of the ‘npm
     install’ command, followed by an ‘npm test’ command.

     Which Node.js package is used to interpret the ‘npm’ commands can
     be specified with the ‘#:node’ parameter which defaults to ‘node’.

   Lastly, for packages that do not need anything as sophisticated, a
“trivial” build system is provided.  It is trivial in the sense that it
provides basically no support: it does not pull any implicit inputs, and
does not have a notion of build phases.

 -- Scheme Variable: trivial-build-system
     This variable is exported by ‘(guix build-system trivial)’.

     This build system requires a ‘#:builder’ argument.  This argument
     must be a Scheme expression that builds the package output(s)—as
     with ‘build-expression->derivation’ (*note
     ‘build-expression->derivation’: Derivations.).

   ---------- Footnotes ----------

   (1) Please see the ‘(guix build gnu-build-system)’ modules for more
details about the build phases.


File: guix.info,  Node: The Store,  Next: Derivations,  Prev: Build Systems,  Up: Programming Interface

6.4 The Store
=============

Conceptually, the “store” is the place where derivations that have been
built successfully are stored—by default, ‘/gnu/store’.  Sub-directories
in the store are referred to as “store items” or sometimes “store
paths”.  The store has an associated database that contains information
such as the store paths referred to by each store path, and the list of
_valid_ store items—results of successful builds.  This database resides
in ‘LOCALSTATEDIR/guix/db’, where LOCALSTATEDIR is the state directory
specified via ‘--localstatedir’ at configure time, usually ‘/var’.

   The store is _always_ accessed by the daemon on behalf of its clients
(*note Invoking guix-daemon::).  To manipulate the store, clients
connect to the daemon over a Unix-domain socket, send requests to it,
and read the result—these are remote procedure calls, or RPCs.

     Note: Users must _never_ modify files under ‘/gnu/store’ directly.
     This would lead to inconsistencies and break the immutability
     assumptions of Guix’s functional model (*note Introduction::).

     *Note ‘guix gc --verify’: Invoking guix gc, for information on how
     to check the integrity of the store and attempt recovery from
     accidental modifications.

   The ‘(guix store)’ module provides procedures to connect to the
daemon, and to perform RPCs.  These are described below.  By default,
‘open-connection’, and thus all the ‘guix’ commands, connect to the
local daemon or to the URI specified by the ‘GUIX_DAEMON_SOCKET’
environment variable.

 -- Environment Variable: GUIX_DAEMON_SOCKET
     When set, the value of this variable should be a file name or a URI
     designating the daemon endpoint.  When it is a file name, it
     denotes a Unix-domain socket to connect to.  In addition to file
     names, the supported URI schemes are:

     ‘file’
     ‘unix’
          These are for Unix-domain sockets.
          ‘file:///var/guix/daemon-socket/socket’ is equivalent to
          ‘/var/guix/daemon-socket/socket’.

     ‘guix’
          These URIs denote connections over TCP/IP, without encryption
          nor authentication of the remote host.  The URI must specify
          the host name and optionally a port number (by default port
          44146 is used):

               guix://master.guix.example.org:1234

          This setup is suitable on local networks, such as clusters,
          where only trusted nodes may connect to the build daemon at
          ‘master.guix.example.org’.

          The ‘--listen’ option of ‘guix-daemon’ can be used to instruct
          it to listen for TCP connections (*note ‘--listen’: Invoking
          guix-daemon.).

     ‘ssh’
          These URIs allow you to connect to a remote daemon over SSH.
          This feature requires Guile-SSH (*note Requirements::) and a
          working ‘guile’ binary in ‘PATH’ on the destination machine.
          It supports public key and GSSAPI authentication.  A typical
          URL might look like this:

               ssh://charlie@guix.example.org:22

          As for ‘guix copy’, the usual OpenSSH client configuration
          files are honored (*note Invoking guix copy::).

     Additional URI schemes may be supported in the future.

          Note: The ability to connect to remote build daemons is
          considered experimental as of 1.0.1.17089-7e269.  Please get
          in touch with us to share any problems or suggestions you may
          have (*note Contributing::).

 -- Scheme Procedure: open-connection [URI] [#:reserve-space? #t]
     Connect to the daemon over the Unix-domain socket at URI (a
     string).  When RESERVE-SPACE? is true, instruct it to reserve a
     little bit of extra space on the file system so that the garbage
     collector can still operate should the disk become full.  Return a
     server object.

     FILE defaults to ‘%default-socket-path’, which is the normal
     location given the options that were passed to ‘configure’.

 -- Scheme Procedure: close-connection SERVER
     Close the connection to SERVER.

 -- Scheme Variable: current-build-output-port
     This variable is bound to a SRFI-39 parameter, which refers to the
     port where build and error logs sent by the daemon should be
     written.

   Procedures that make RPCs all take a server object as their first
argument.

 -- Scheme Procedure: valid-path? SERVER PATH
     Return ‘#t’ when PATH designates a valid store item and ‘#f’
     otherwise (an invalid item may exist on disk but still be invalid,
     for instance because it is the result of an aborted or failed
     build).

     A ‘&store-protocol-error’ condition is raised if PATH is not
     prefixed by the store directory (‘/gnu/store’).

 -- Scheme Procedure: add-text-to-store SERVER NAME TEXT [REFERENCES]
     Add TEXT under file NAME in the store, and return its store path.
     REFERENCES is the list of store paths referred to by the resulting
     store path.

 -- Scheme Procedure: build-derivations STORE DERIVATIONS [MODE]
     Build DERIVATIONS, a list of ‘<derivation>’ objects, ‘.drv’ file
     names, or derivation/output pairs, using the specified
     MODE—‘(build-mode normal)’ by default.

   Note that the ‘(guix monads)’ module provides a monad as well as
monadic versions of the above procedures, with the goal of making it
more convenient to work with code that accesses the store (*note The
Store Monad::).

   This section is currently incomplete.


File: guix.info,  Node: Derivations,  Next: The Store Monad,  Prev: The Store,  Up: Programming Interface

6.5 Derivations
===============

Low-level build actions and the environment in which they are performed
are represented by “derivations”.  A derivation contains the following
pieces of information:

   • The outputs of the derivation—derivations produce at least one file
     or directory in the store, but may produce more.

   • The inputs of the derivations—i.e., its build-time
     dependencies—which may be other derivations or plain files in the
     store (patches, build scripts, etc.).

   • The system type targeted by the derivation—e.g., ‘x86_64-linux’.

   • The file name of a build script in the store, along with the
     arguments to be passed.

   • A list of environment variables to be defined.

   Derivations allow clients of the daemon to communicate build actions
to the store.  They exist in two forms: as an in-memory representation,
both on the client- and daemon-side, and as files in the store whose
name end in ‘.drv’—these files are referred to as “derivation paths”.
Derivations paths can be passed to the ‘build-derivations’ procedure to
perform the build actions they prescribe (*note The Store::).

   Operations such as file downloads and version-control checkouts for
which the expected content hash is known in advance are modeled as
“fixed-output derivations”.  Unlike regular derivations, the outputs of
a fixed-output derivation are independent of its inputs—e.g., a source
code download produces the same result regardless of the download method
and tools being used.

   The outputs of derivations—i.e., the build results—have a set of
“references”, as reported by the ‘references’ RPC or the ‘guix gc
--references’ command (*note Invoking guix gc::).  References are the
set of run-time dependencies of the build results.  References are a
subset of the inputs of the derivation; this subset is automatically
computed by the build daemon by scanning all the files in the outputs.

   The ‘(guix derivations)’ module provides a representation of
derivations as Scheme objects, along with procedures to create and
otherwise manipulate derivations.  The lowest-level primitive to create
a derivation is the ‘derivation’ procedure:

 -- Scheme Procedure: derivation STORE NAME BUILDER ARGS [#:outputs
          '("out")] [#:hash #f] [#:hash-algo #f] [#:recursive? #f]
          [#:inputs '()] [#:env-vars '()] [#:system (%current-system)]
          [#:references-graphs #f] [#:allowed-references #f]
          [#:disallowed-references #f] [#:leaked-env-vars #f]
          [#:local-build? #f] [#:substitutable? #t] [#:properties '()]
     Build a derivation with the given arguments, and return the
     resulting ‘<derivation>’ object.

     When HASH and HASH-ALGO are given, a “fixed-output derivation” is
     created—i.e., one whose result is known in advance, such as a file
     download.  If, in addition, RECURSIVE? is true, then that fixed
     output may be an executable file or a directory and HASH must be
     the hash of an archive containing this output.

     When REFERENCES-GRAPHS is true, it must be a list of file
     name/store path pairs.  In that case, the reference graph of each
     store path is exported in the build environment in the
     corresponding file, in a simple text format.

     When ALLOWED-REFERENCES is true, it must be a list of store items
     or outputs that the derivation’s output may refer to.  Likewise,
     DISALLOWED-REFERENCES, if true, must be a list of things the
     outputs may _not_ refer to.

     When LEAKED-ENV-VARS is true, it must be a list of strings denoting
     environment variables that are allowed to “leak” from the daemon’s
     environment to the build environment.  This is only applicable to
     fixed-output derivations—i.e., when HASH is true.  The main use is
     to allow variables such as ‘http_proxy’ to be passed to derivations
     that download files.

     When LOCAL-BUILD? is true, declare that the derivation is not a
     good candidate for offloading and should rather be built locally
     (*note Daemon Offload Setup::).  This is the case for small
     derivations where the costs of data transfers would outweigh the
     benefits.

     When SUBSTITUTABLE? is false, declare that substitutes of the
     derivation’s output should not be used (*note Substitutes::).  This
     is useful, for instance, when building packages that capture
     details of the host CPU instruction set.

     PROPERTIES must be an association list describing “properties” of
     the derivation.  It is kept as-is, uninterpreted, in the
     derivation.

Here’s an example with a shell script as its builder, assuming STORE is
an open connection to the daemon, and BASH points to a Bash executable
in the store:

     (use-modules (guix utils)
                  (guix store)
                  (guix derivations))

     (let ((builder   ; add the Bash script to the store
             (add-text-to-store store "my-builder.sh"
                                "echo hello world > $out\n" '())))
       (derivation store "foo"
                   bash `("-e" ,builder)
                   #:inputs `((,bash) (,builder))
                   #:env-vars '(("HOME" . "/homeless"))))
     ⇒ #<derivation /gnu/store/...-foo.drv => /gnu/store/...-foo>

   As can be guessed, this primitive is cumbersome to use directly.  A
better approach is to write build scripts in Scheme, of course!  The
best course of action for that is to write the build code as a
“G-expression”, and to pass it to ‘gexp->derivation’.  For more
information, *note G-Expressions::.

   Once upon a time, ‘gexp->derivation’ did not exist and constructing
derivations with build code written in Scheme was achieved with
‘build-expression->derivation’, documented below.  This procedure is now
deprecated in favor of the much nicer ‘gexp->derivation’.

 -- Scheme Procedure: build-expression->derivation STORE NAME EXP
          [#:system (%current-system)] [#:inputs '()] [#:outputs
          '("out")] [#:hash #f] [#:hash-algo #f] [#:recursive? #f]
          [#:env-vars '()] [#:modules '()] [#:references-graphs #f]
          [#:allowed-references #f] [#:disallowed-references #f]
          [#:local-build? #f] [#:substitutable? #t] [#:guile-for-build
          #f]
     Return a derivation that executes Scheme expression EXP as a
     builder for derivation NAME.  INPUTS must be a list of ‘(name
     drv-path sub-drv)’ tuples; when SUB-DRV is omitted, ‘"out"’ is
     assumed.  MODULES is a list of names of Guile modules from the
     current search path to be copied in the store, compiled, and made
     available in the load path during the execution of EXP—e.g.,
     ‘((guix build utils) (guix build gnu-build-system))’.

     EXP is evaluated in an environment where ‘%outputs’ is bound to a
     list of output/path pairs, and where ‘%build-inputs’ is bound to a
     list of string/output-path pairs made from INPUTS.  Optionally,
     ENV-VARS is a list of string pairs specifying the name and value of
     environment variables visible to the builder.  The builder
     terminates by passing the result of EXP to ‘exit’; thus, when EXP
     returns ‘#f’, the build is considered to have failed.

     EXP is built using GUILE-FOR-BUILD (a derivation).  When
     GUILE-FOR-BUILD is omitted or is ‘#f’, the value of the
     ‘%guile-for-build’ fluid is used instead.

     See the ‘derivation’ procedure for the meaning of
     REFERENCES-GRAPHS, ALLOWED-REFERENCES, DISALLOWED-REFERENCES,
     LOCAL-BUILD?, and SUBSTITUTABLE?.

Here’s an example of a single-output derivation that creates a directory
containing one file:

     (let ((builder '(let ((out (assoc-ref %outputs "out")))
                       (mkdir out)    ; create /gnu/store/...-goo
                       (call-with-output-file (string-append out "/test")
                         (lambda (p)
                           (display '(hello guix) p))))))
       (build-expression->derivation store "goo" builder))

     ⇒ #<derivation /gnu/store/...-goo.drv => ...>


File: guix.info,  Node: The Store Monad,  Next: G-Expressions,  Prev: Derivations,  Up: Programming Interface

6.6 The Store Monad
===================

The procedures that operate on the store described in the previous
sections all take an open connection to the build daemon as their first
argument.  Although the underlying model is functional, they either have
side effects or depend on the current state of the store.

   The former is inconvenient: the connection to the build daemon has to
be carried around in all those functions, making it impossible to
compose functions that do not take that parameter with functions that
do.  The latter can be problematic: since store operations have side
effects and/or depend on external state, they have to be properly
sequenced.

   This is where the ‘(guix monads)’ module comes in.  This module
provides a framework for working with “monads”, and a particularly
useful monad for our uses, the “store monad”.  Monads are a construct
that allows two things: associating “context” with values (in our case,
the context is the store), and building sequences of computations (here
computations include accesses to the store).  Values in a monad—values
that carry this additional context—are called “monadic values”;
procedures that return such values are called “monadic procedures”.

   Consider this “normal” procedure:

     (define (sh-symlink store)
       ;; Return a derivation that symlinks the 'bash' executable.
       (let* ((drv (package-derivation store bash))
              (out (derivation->output-path drv))
              (sh  (string-append out "/bin/bash")))
         (build-expression->derivation store "sh"
                                       `(symlink ,sh %output))))

   Using ‘(guix monads)’ and ‘(guix gexp)’, it may be rewritten as a
monadic function:

     (define (sh-symlink)
       ;; Same, but return a monadic value.
       (mlet %store-monad ((drv (package->derivation bash)))
         (gexp->derivation "sh"
                           #~(symlink (string-append #$drv "/bin/bash")
                                      #$output))))

   There are several things to note in the second version: the ‘store’
parameter is now implicit and is “threaded” in the calls to the
‘package->derivation’ and ‘gexp->derivation’ monadic procedures, and the
monadic value returned by ‘package->derivation’ is “bound” using ‘mlet’
instead of plain ‘let’.

   As it turns out, the call to ‘package->derivation’ can even be
omitted since it will take place implicitly, as we will see later (*note
G-Expressions::):

     (define (sh-symlink)
       (gexp->derivation "sh"
                         #~(symlink (string-append #$bash "/bin/bash")
                                    #$output)))

   Calling the monadic ‘sh-symlink’ has no effect.  As someone once
said, “you exit a monad like you exit a building on fire: by running”.
So, to exit the monad and get the desired effect, one must use
‘run-with-store’:

     (run-with-store (open-connection) (sh-symlink))
     ⇒ /gnu/store/...-sh-symlink

   Note that the ‘(guix monad-repl)’ module extends the Guile REPL with
new “meta-commands” to make it easier to deal with monadic procedures:
‘run-in-store’, and ‘enter-store-monad’.  The former is used to “run” a
single monadic value through the store:

     scheme@(guile-user)> ,run-in-store (package->derivation hello)
     $1 = #<derivation /gnu/store/...-hello-2.9.drv => ...>

   The latter enters a recursive REPL, where all the return values are
automatically run through the store:

     scheme@(guile-user)> ,enter-store-monad
     store-monad@(guile-user) [1]> (package->derivation hello)
     $2 = #<derivation /gnu/store/...-hello-2.9.drv => ...>
     store-monad@(guile-user) [1]> (text-file "foo" "Hello!")
     $3 = "/gnu/store/...-foo"
     store-monad@(guile-user) [1]> ,q
     scheme@(guile-user)>

Note that non-monadic values cannot be returned in the ‘store-monad’
REPL.

   The main syntactic forms to deal with monads in general are provided
by the ‘(guix monads)’ module and are described below.

 -- Scheme Syntax: with-monad MONAD BODY ...
     Evaluate any ‘>>=’ or ‘return’ forms in BODY as being in MONAD.

 -- Scheme Syntax: return VAL
     Return a monadic value that encapsulates VAL.

 -- Scheme Syntax: >>= MVAL MPROC ...
     “Bind” monadic value MVAL, passing its “contents” to monadic
     procedures MPROC...(1).  There can be one MPROC or several of them,
     as in this example:

          (run-with-state
              (with-monad %state-monad
                (>>= (return 1)
                     (lambda (x) (return (+ 1 x)))
                     (lambda (x) (return (* 2 x)))))
            'some-state)

          ⇒ 4
          ⇒ some-state

 -- Scheme Syntax: mlet MONAD ((VAR MVAL) ...) BODY ...
 -- Scheme Syntax: mlet* MONAD ((VAR MVAL) ...) BODY ...
     Bind the variables VAR to the monadic values MVAL in BODY, which is
     a sequence of expressions.  As with the bind operator, this can be
     thought of as “unpacking” the raw, non-monadic value “contained” in
     MVAL and making VAR refer to that raw, non-monadic value within the
     scope of the BODY.  The form (VAR -> VAL) binds VAR to the “normal”
     value VAL, as per ‘let’.  The binding operations occur in sequence
     from left to right.  The last expression of BODY must be a monadic
     expression, and its result will become the result of the ‘mlet’ or
     ‘mlet*’ when run in the MONAD.

     ‘mlet*’ is to ‘mlet’ what ‘let*’ is to ‘let’ (*note (guile)Local
     Bindings::).

 -- Scheme System: mbegin MONAD MEXP ...
     Bind MEXP and the following monadic expressions in sequence,
     returning the result of the last expression.  Every expression in
     the sequence must be a monadic expression.

     This is akin to ‘mlet’, except that the return values of the
     monadic expressions are ignored.  In that sense, it is analogous to
     ‘begin’, but applied to monadic expressions.

 -- Scheme System: mwhen CONDITION MEXP0 MEXP* ...
     When CONDITION is true, evaluate the sequence of monadic
     expressions MEXP0..MEXP* as in an ‘mbegin’.  When CONDITION is
     false, return ‘*unspecified*’ in the current monad.  Every
     expression in the sequence must be a monadic expression.

 -- Scheme System: munless CONDITION MEXP0 MEXP* ...
     When CONDITION is false, evaluate the sequence of monadic
     expressions MEXP0..MEXP* as in an ‘mbegin’.  When CONDITION is
     true, return ‘*unspecified*’ in the current monad.  Every
     expression in the sequence must be a monadic expression.

   The ‘(guix monads)’ module provides the “state monad”, which allows
an additional value—the state—to be _threaded_ through monadic procedure
calls.

 -- Scheme Variable: %state-monad
     The state monad.  Procedures in the state monad can access and
     change the state that is threaded.

     Consider the example below.  The ‘square’ procedure returns a value
     in the state monad.  It returns the square of its argument, but
     also increments the current state value:

          (define (square x)
            (mlet %state-monad ((count (current-state)))
              (mbegin %state-monad
                (set-current-state (+ 1 count))
                (return (* x x)))))

          (run-with-state (sequence %state-monad (map square (iota 3))) 0)
          ⇒ (0 1 4)
          ⇒ 3

     When “run” through ‘%state-monad’, we obtain that additional state
     value, which is the number of ‘square’ calls.

 -- Monadic Procedure: current-state
     Return the current state as a monadic value.

 -- Monadic Procedure: set-current-state VALUE
     Set the current state to VALUE and return the previous state as a
     monadic value.

 -- Monadic Procedure: state-push VALUE
     Push VALUE to the current state, which is assumed to be a list, and
     return the previous state as a monadic value.

 -- Monadic Procedure: state-pop
     Pop a value from the current state and return it as a monadic
     value.  The state is assumed to be a list.

 -- Scheme Procedure: run-with-state MVAL [STATE]
     Run monadic value MVAL starting with STATE as the initial state.
     Return two values: the resulting value, and the resulting state.

   The main interface to the store monad, provided by the ‘(guix store)’
module, is as follows.

 -- Scheme Variable: %store-monad
     The store monad—an alias for ‘%state-monad’.

     Values in the store monad encapsulate accesses to the store.  When
     its effect is needed, a value of the store monad must be
     “evaluated” by passing it to the ‘run-with-store’ procedure (see
     below).

 -- Scheme Procedure: run-with-store STORE MVAL [#:guile-for-build]
          [#:system (%current-system)]
     Run MVAL, a monadic value in the store monad, in STORE, an open
     store connection.

 -- Monadic Procedure: text-file NAME TEXT [REFERENCES]
     Return as a monadic value the absolute file name in the store of
     the file containing TEXT, a string.  REFERENCES is a list of store
     items that the resulting text file refers to; it defaults to the
     empty list.

 -- Monadic Procedure: binary-file NAME DATA [REFERENCES]
     Return as a monadic value the absolute file name in the store of
     the file containing DATA, a bytevector.  REFERENCES is a list of
     store items that the resulting binary file refers to; it defaults
     to the empty list.

 -- Monadic Procedure: interned-file FILE [NAME] [#:recursive? #t]
          [#:select? (const #t)]
     Return the name of FILE once interned in the store.  Use NAME as
     its store name, or the basename of FILE if NAME is omitted.

     When RECURSIVE? is true, the contents of FILE are added
     recursively; if FILE designates a flat file and RECURSIVE? is true,
     its contents are added, and its permission bits are kept.

     When RECURSIVE? is true, call ‘(SELECT? FILE STAT)’ for each
     directory entry, where FILE is the entry’s absolute file name and
     STAT is the result of ‘lstat’; exclude entries for which SELECT?
     does not return true.

     The example below adds a file to the store, under two different
     names:

          (run-with-store (open-connection)
            (mlet %store-monad ((a (interned-file "README"))
                                (b (interned-file "README" "LEGU-MIN")))
              (return (list a b))))

          ⇒ ("/gnu/store/rwm...-README" "/gnu/store/44i...-LEGU-MIN")

   The ‘(guix packages)’ module exports the following package-related
monadic procedures:

 -- Monadic Procedure: package-file PACKAGE [FILE] [#:system
          (%current-system)] [#:target #f] [#:output "out"]
     Return as a monadic value in the absolute file name of FILE within
     the OUTPUT directory of PACKAGE.  When FILE is omitted, return the
     name of the OUTPUT directory of PACKAGE.  When TARGET is true, use
     it as a cross-compilation target triplet.

     Note that this procedure does _not_ build PACKAGE.  Thus, the
     result might or might not designate an existing file.  We recommend
     not using this procedure unless you know what you are doing.

 -- Monadic Procedure: package->derivation PACKAGE [SYSTEM]
 -- Monadic Procedure: package->cross-derivation PACKAGE TARGET [SYSTEM]
     Monadic version of ‘package-derivation’ and
     ‘package-cross-derivation’ (*note Defining Packages::).

   ---------- Footnotes ----------

   (1) This operation is commonly referred to as “bind”, but that name
denotes an unrelated procedure in Guile.  Thus we use this somewhat
cryptic symbol inherited from the Haskell language.

