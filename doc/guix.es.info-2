This is guix.es.info, produced by makeinfo version 6.7 from
guix.es.texi.

Copyright © 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020 Ludovic
Courtès
Copyright © 2013, 2014, 2016 Andreas Enge
Copyright © 2013 Nikita Karetnikov
Copyright © 2014, 2015, 2016 Alex Kost
Copyright © 2015, 2016 Mathieu Lirzin
Copyright © 2014 Pierre-Antoine Rault
Copyright © 2015 Taylan Ulrich Bayırlı/Kammer
Copyright © 2015, 2016, 2017, 2019, 2020 Leo Famulari
Copyright © 2015, 2016, 2017, 2018, 2019, 2020 Ricardo Wurmus
Copyright © 2016 Ben Woodcroft
Copyright © 2016, 2017, 2018 Chris Marusich
Copyright © 2016, 2017, 2018, 2019, 2020 Efraim Flashner
Copyright © 2016 John Darrington
Copyright © 2016, 2017 Nikita Gillmann
Copyright © 2016, 2017, 2018, 2019, 2020 Jan Nieuwenhuizen
Copyright © 2016, 2017, 2018, 2019, 2020 Julien Lepiller
Copyright © 2016 Alex ter Weele
Copyright © 2016, 2017, 2018, 2019 Christopher Baines
Copyright © 2017, 2018, 2019 Clément Lassieur
Copyright © 2017, 2018 Mathieu Othacehe
Copyright © 2017 Federico Beffa
Copyright © 2017, 2018 Carlo Zancanaro
Copyright © 2017 Thomas Danckaert
Copyright © 2017 humanitiesNerd
Copyright © 2017 Christopher Allan Webber
Copyright © 2017, 2018, 2019, 2020 Marius Bakke
Copyright © 2017, 2019, 2020 Hartmut Goebel
Copyright © 2017, 2019, 2020 Maxim Cournoyer
Copyright © 2017, 2018, 2019, 2020 Tobias Geerinckx-Rice
Copyright © 2017 George Clemmer
Copyright © 2017 Andy Wingo
Copyright © 2017, 2018, 2019 Arun Isaac
Copyright © 2017 nee
Copyright © 2018 Rutger Helling
Copyright © 2018 Oleg Pykhalov
Copyright © 2018 Mike Gerwitz
Copyright © 2018 Pierre-Antoine Rouby
Copyright © 2018, 2019 Gábor Boskovits
Copyright © 2018, 2019 Florian Pelz
Copyright © 2018 Laura Lazzati
Copyright © 2018 Alex Vong
Copyright © 2019 Josh Holland
Copyright © 2019, 2020 Diego Nicola Barbato
Copyright © 2019 Ivan Petkov
Copyright © 2019 Jakob L. Kreuze
Copyright © 2019 Kyle Andrews
Copyright © 2019 Alex Griffin
Copyright © 2019 Guillaume Le Vaillant
Copyright © 2020 Leo Prikler
Copyright © 2019, 2020 Simon Tournier
Copyright © 2020 Wiktor Żelazny
Copyright © 2020 Damien Cassou
Copyright © 2020 Jakub Kądziołka
Copyright © 2020 Jack Hill
Copyright © 2020 Naga Malleswari
Copyright © 2020 Brice Waegeneire
Copyright © 2020 R Veera Kumar
Copyright © 2020 Pierre Langlois
Copyright © 2020 pinoaffe

   Se garantiza el permiso de copia, distribución y/o modificación de
este documento bajo los términos de la licencia de documentación libre
de GNU (GNU Free Documentation License), versión 1.3 o cualquier versión
posterior publicada por la Free Software Foundation; sin secciones
invariantes, sin textos de cubierta delantera ni trasera. Una copia de
la licencia está incluida en la sección titulada “GNU Free Documentation
License”.
INFO-DIR-SECTION Administración del sistema
START-INFO-DIR-ENTRY
* Guix: (guix.es).           Gestión del software instalado y la
                               configuración del sistema.
* guix package: (guix.es)Invocación de guix package.  Instalación, borrado
                                                         y actualización de
                                                         paquetes.
* guix gc: (guix.es)Invocación de guix gc.  Recuperar espacio de disco sin
                                               usar.
* guix pull: (guix.es)Invocación de guix pull.  Actualización de la lista
                                                   disponible de paquetes.
* guix system: (guix.es)Invocación de guix system.  Gestión de la
                                                       configuración del
                                                       sistema operativo.
* guix deploy: (guix.es)Invocación de guix deploy.  Gestión de
                                                       configuraciones de
                                                       sistemas operativos en
                                                       máquinas remotas.
END-INFO-DIR-ENTRY

INFO-DIR-SECTION Desarrollo de software
START-INFO-DIR-ENTRY
* guix environment: (guix.es)Invocación de guix environment.  Construcción
                                                                 de entornos
                                                                 de desarrollo
                                                                 con Guix.
* guix build: (guix.es)Invocación de guix build.  Construcción de
                                                     paquetes.
* guix pack: (guix.es)Invocación de guix pack.  Creación de empaquetados
                                                   binarios.
END-INFO-DIR-ENTRY


File: guix.es.info,  Node: El almacén,  Next: Derivaciones,  Prev: Sistemas de construcción,  Up: Interfaz programática

6.4 El almacén
==============

Conceptualmente, el “almacén” es el lugar donde se almacenan las
derivaciones cuya construcción fue satisfactoria—por defecto,
‘/gnu/store’. Los subdirectorios en el almacén se denominan “elementos
del almacén” o “rutas del almacén” en ocasiones. El almacén tiene una
base de datos asociada que contiene información como las rutas del
almacén a las que referencia cada ruta del almacén, y la lista de
elementos _válidos_ del almacén—los resultados de las construcciones
satisfactorias. Esta base de datos reside en ‘LOCALSTATEDIR/guix/db’,
donde LOCALSTATEDIR es el directorio de estado especificado vía
‘--localstatedir’ en tiempo de configuración, normalmente ‘/var’.

   El almacén _siempre_ es accedido a través del daemon en delegación de
sus clientes (*note Invocación de guix-daemon::). Para manipular el
almacén, los clientes se conectan al daemon por un socket de dominio
Unix, le envían peticiones y leen el resultado—esto son llamadas a
procedimientos remotos, o RPC.

     Nota: Las usuarias _nunca_ deben modificar ficheros directamente
     bajo el directorio ‘/gnu/store’. Esto llevaría a inconsistencias y
     rompería las premisas de inmutabilidad del modelo funcional de Guix
     (*note Introducción::).

     *Note ‘guix gc --verify’: Invocación de guix gc, para información
     sobre cómo comprobar la integridad del almacén e intentar
     recuperarse de modificaciones accidentales.

   The ‘(guix store)’ module provides procedures to connect to the
daemon, and to perform RPCs. These are described below. By default,
‘open-connection’, and thus all the ‘guix’ commands, connect to the
local daemon or to the URI specified by the ‘GUIX_DAEMON_SOCKET’
environment variable.

 -- Variable de entorno: GUIX_DAEMON_SOCKET
     Cuando se ha definido, el valor de esta variable debe ser un nombre
     de fichero o una URI designando el punto de conexión del daemon.
     Cuando es un nombre de fichero, denota un socket de dominio Unix al
     que conectarse. Además de nombres de ficheros, los esquemas de URI
     aceptados son:

     ‘file’
     ‘unix’
          Estos son equivalentes a los sockets de dominio Unix.
          ‘file:///var/guix/daemon-socket/socket’ es equivalente a
          ‘/var/guix/daemon-socket/socket’.

     ‘guix’
          Estas URI denotan conexiones sobre TCP/IP, sin cifrado ni
          verificación de la máquina remota. La URI debe especificar el
          nombre de máquina y opcionalmente un número de puerto (por
          defecto se usa el puerto 44146):

               guix://principal.guix.example.org:1234

          Esta configuración es apropiada para redes locales, como
          clusters, donde únicamente los nodos de confianza pueden
          conectarse al daemon de construcción en
          ‘principal.guix.example.org’.

          The ‘--listen’ option of ‘guix-daemon’ can be used to instruct
          it to listen for TCP connections (*note ‘--listen’: Invocación
          de guix-daemon.).

     ‘ssh’
          These URIs allow you to connect to a remote daemon over SSH.
          This feature requires Guile-SSH (*note Requisitos::) and a
          working ‘guile’ binary in ‘PATH’ on the destination machine.
          It supports public key and GSSAPI authentication. A typical
          URL might look like this:

               ssh://carlos@guix.example.org:22

          Como con ‘guix copy’, se tienen en cuenta los ficheros
          habituales de configuración del cliente OpenSSH (*note
          Invocación de guix copy::).

     Esquemas URI adicionales pueden ser aceptados en el futuro.

          Nota: La conexión con daemon de construcción remotos se
          considera experimental en 1.0.1.17089-7e269. Por favor,
          contacte con nosotras para compartir cualquier problema o
          sugerencias que pueda tener (*note Contribuir::).

 -- Procedimiento Scheme: open-connection [URI] [#:reserve-space? #t]
     Abre una conexión al daemon a través del socket de dominio Unix
     apuntado por URI (una cadena). Cuando RESERVE-SPACE? es verdadero,
     le indica que reserve un poco de espacio extra en el sistema de
     ficheros de modo que el recolector de basura pueda operar incluso
     cuando el disco se llene. Devuelve un objeto servidor.

     El valor por defecto de URI es ‘%default-socket-path’, que ese la
     ruta esperada según las opciones proporcionadas a ‘configure’.

 -- Procedimiento Scheme: close-connection SERVIDOR
     Cierra la conexión al SERVIDOR.

 -- Variable Scheme: current-build-output-port
     Esta variable está enlazada a un parámetro SRFI-39, que referencia
     al puerto donde los logs de construcción y error enviados por el
     daemon deben escribirse.

   Los procedimientos que realizan RPCs toman todos como primer
parámetro un objeto servidor.

 -- Procedimiento Scheme: valid-path? SERVIDOR RUTA
     Return ‘#t’ when PATH designates a valid store item and ‘#f’
     otherwise (an invalid item may exist on disk but still be invalid,
     for instance because it is the result of an aborted or failed
     build).

     Una condición ‘&store-protocol-error’ se eleva si RUTA no contiene
     como prefijo el directorio del almacén (‘/gnu/store’).

 -- Procedimiento Scheme: add-text-to-store SERVIDOR NOMBRE TEXTO
          [REFERENCIAS]
     Añade TEXTO bajo el fichero NOMBRE en el almacén, y devuelve su
     ruta en el almacén. REFERENCIAS es la lista de rutas del almacén a
     las que hace referencia la ruta del almacén resultante.

 -- Procedimiento Scheme: build-derivations ALMACÉN DERIVACIONES [MODO]
     Construye DERIVACIONES, una lista de objetos ‘<derivation>’,
     nombres de fichero ‘.drv’, o pares derivación/salida, usando el
     MODO especificado—‘(build-mode normal)’ en caso de omisión.

   Fíjese que el módulo ‘(guix monads)’ proporciona una mónada así como
versiones monádicas de los procedimientos previos, con el objetivo de
hacer más conveniente el trabajo con código que accede al almacén (*note
La mónada del almacén::).

   Esta sección actualmente está incompleta.


File: guix.es.info,  Node: Derivaciones,  Next: La mónada del almacén,  Prev: El almacén,  Up: Interfaz programática

6.5 Derivaciones
================

Las acciones de construcción a bajo nivel y el entorno en el que se
realizan se representan mediante “derivaciones”. Una derivación contiene
las siguientes piezas de información:

   • Las salidas de la derivación—las derivaciones producen al menos un
     fichero o directorio en el almacén, pero pueden producir más.

   • The inputs of the derivations—i.e., its build-time
     dependencies—which may be other derivations or plain files in the
     store (patches, build scripts, etc.).

   • El tipo de sistema objetivo de la derivación—por ejemplo,
     ‘x86_64-linux’.

   • El nombre de fichero del guión de construcción en el almacén, junto
     a los parámetros que se le deben pasar.

   • Una lista de variables de entorno a ser definidas.

   Derivations allow clients of the daemon to communicate build actions
to the store. They exist in two forms: as an in-memory representation,
both on the client- and daemon-side, and as files in the store whose
name end in ‘.drv’—these files are referred to as “derivation paths”.
Derivations paths can be passed to the ‘build-derivations’ procedure to
perform the build actions they prescribe (*note El almacén::).

   Operaciones como la descarga de ficheros y las instantáneas de un
control de versiones para las cuales el hash del contenido esperado se
conoce previamente se modelan como “derivaciones de salida fija”. Al
contrario que las derivaciones normales, las salidas de una derivación
de salida fija son independientes de sus entradas—por ejemplo, la
descarga del código fuente produce el mismo resultado independientemente
del método de descarga y las herramientas usadas.

   Las derivaciones de salida—es decir, los resultados de
construcción—tienen un conjunto de “referencias”, del que informa la RPC
‘references’ o la orden ‘guix gc --references’ (*note Invocación de guix
gc::). Las referencias son el conjunto de dependencias en tiempo de
ejecución de los resultados de construcción. Las referencias son un
subconjunto de las entradas de la derivación; el daemon de construcción
calcula este subconjunto de forma automática mediante el procesado de
todos los ficheros en las salidas.

   El módulo ‘(guix derivations)’ proporciona una representación de
derivaciones como objetos Scheme, junto a procedimientos para crear y
manipular de otras formas derivaciones. La primitiva de más bajo nivel
para crear una derivación es el procedimiento ‘derivation’:

 -- Procedimiento Scheme: derivation ALMACÉN NOMBRE CONSTRUCTOR ARGS
          [#:outputs '("out")] [#:hash #f] [#:hash-algo #f]
          [#:recursive? #f] [#:inputs '()] [#:env-vars '()] [#:system
          (%current-system)] [#:references-graphs #f]
          [#:allowed-references #f] [#:disallowed-references #f]
          [#:leaked-env-vars #f] [#:local-build? #f] [#:substitutable?
          #t] [#:properties '()]
     Construye una derivación con los parámetros proporcionados, y
     devuelve el objeto ‘<derivation>’ resultante.

     Cuando se proporcionan HASH y HASH-ALGO, una “derivación de salida
     fija” se crea—es decir, una cuyo resultado se conoce de antemano,
     como la descarga de un fichero. Si, además, RECURSIVE? es
     verdadero, entonces la salida fijada puede ser un fichero
     ejecutable o un directorio y HASH debe ser el hash de un archivador
     que contenga esta salida.

     Cuando REFERENCES-GRAPHS es verdadero, debe ser una lista de pares
     de nombre de fichero/ruta del almacén. En ese caso, el grafo de
     referencias de cada ruta del almacén se exporta en el entorno de
     construcción del fichero correspondiente, en un formato de texto
     simple.

     Cuando ALLOWED-REFERENCES es verdadero, debe ser una lista de
     elementos del almacén o salidas a las que puede hacer referencia la
     salida de la derivación. Del mismo modo, DISALLOWED-REFERENCES, en
     caso de ser verdadero, debe ser una lista de cosas a las que las
     salidas _no_ pueden hacer referencia.

     Cuando LEAKED-ENV-VARS es verdadero, debe ser una lista de cadenas
     que denoten variables de entorno que se permite “escapar” del
     entorno del daemon al entorno de construcción. Esto es únicamente
     aplicable a derivaciones de salida fija—es decir, cuando HASH es
     verdadero. El uso principal es permitir que variables como
     ‘http_proxy’ sean pasadas a las derivaciones que descargan
     ficheros.

     Cuando LOCAL-BUILD? es verdadero, declara que la derivación no es
     una buena candidata para delegación y debe ser construida
     localmente (*note Configuración de delegación del daemon::). Este
     es el caso para pequeñas derivaciones donde los costes de
     transferencia de datos sobrepasarían los beneficios.

     Cuando SUBSTITUTABLE? es falso, declara que las sustituciones de la
     salida de la derivación no deben usarse (*note Sustituciones::).
     Esto es útil, por ejemplo, cuando se construyen paquetes que
     capturan detalles sobre el conjunto de instrucciones de la CPU
     anfitriona.

     PROPERTIES debe ser una lista asociada que describe “propiedades”
     de la derivación. Debe mantenerse tal cual, sin interpretar, en la
     derivación.

Esto es un ejemplo con un guión de shell como constructor, asumiendo que
ALMACÉN es una conexión abierta al daemon, BASH apunta al ejecutable
Bash en el almacén:

     (use-modules (guix utils)
                  (guix store)
                  (guix derivations))

     (let ((constructor   ; añade el guión de Bash al almacén
             (add-text-to-store store "mi-constructor.sh"
                                "echo hola mundo > $out\n" '())))
       (derivation almacen "foo"
                   bash `("-e" ,builder)
                   #:inputs `((,bash) (,constructor))
                   #:env-vars '(("HOME" . "/sindirectorio"))))
     ⇒ #<derivation /gnu/store/...-foo.drv => /gnu/store/...-foo>

   Como puede suponerse, el uso directo de esta primitiva es algo
enrevesado. Una mejor aproximación es escribir guiones de construcción
en Scheme, ¡por supuesto! La mejor forma de hacerlo es escribir el
código de construcción como una “expresión-G”, y pasarla a
‘gexp->derivation’. Para más información, *note Expresiones-G::.

   En otros tiempos, ‘gexp->derivation’ no existía y la creación de
derivaciones con código de construcción escrito en Scheme se conseguía
con ‘build-expression->derivation’, documentada más adelante. Este
procedimiento está ahora obsoleto en favor del procedimiento
‘gexp->derivation’ mucho más conveniente.

 -- Procedimiento Scheme: build-expression->derivation ALMACÉN NOMBRE
          EXP [#:system (%current-system)] [#:inputs '()] [#:outputs
          '("out")] [#:hash #f] [#:hash-algo #f] [#:recursive? #f]
          [#:env-vars '()] [#:modules '()] [#:references-graphs #f]
          [#:allowed-references #f] [#:disallowed-references #f]
          [#:local-build? #f] [#:substitutable? #t] [#:guile-for-build
          #f]
     Devuelve una derivación que ejecuta la expresión Scheme EXP como un
     constructor para la derivación NOMBRE. INPUTS debe ser una lista de
     tuplas ‘(nombre ruta-drv sub-drv)’; cuando SUB-DRV se omite, se
     asume ‘"out"’. MODULES es una lista de nombres de módulos Guile de
     la ruta actual de búsqueda a copiar en el almacén, compilados, y
     poner a disposición en la ruta de carga durante la ejecución de
     EXP—por ejemplo, ‘((guix build utils) (guix build
     gnu-build-system))’.

     EXP se evalúa en un entorno donde ‘%outputs’ está asociada a una
     lista de pares salida/ruta, y donde ‘%build-inputs’ está asociada a
     una lista de pares cadena/ruta-de-salida que provienen de INPUTS.
     De manera opcional, ENV-VARS es una lista de pares de cadenas que
     especifican el nombre y el valor de las variables de entorno
     visibles al constructor. El constructor termina pasando el
     resultado de EXP a ‘exit’; por tanto, cuando EXP devuelve ‘#f’, la
     construcción se considera fallida.

     EXP se construye usando GUILE-FOR-BUILD (una derivación). Cuando
     GUILE-FOR-BUILD se omite o es ‘#f’, el valor del fluido
     ‘%guile-for-build’ se usa en su lugar.

     Véase el procedimiento ‘derivation’ para el significado de
     REFERENCES-GRAPHS, ALLOWED-REFERENCES, DISALLOWED-REFERENCES,
     LOCAL-BUILD? y SUBSTITUTABLE?.

Aquí está un ejemplo de derivación de salida única que crea un
directorio que contiene un fichero:

     (let ((constructor '(let ((salida (assoc-ref %outputs "out")))
                           (mkdir salida)    ; crea /gnu/store/...-goo
                           (call-with-output-file (string-append salida "/prueba")
                             (lambda (p)
                               (display '(hola guix) p))))))
       (build-expression->derivation almacen "goo" constructor))

     ⇒ #<derivation /gnu/store/...-goo.drv => ...>


File: guix.es.info,  Node: La mónada del almacén,  Next: Expresiones-G,  Prev: Derivaciones,  Up: Interfaz programática

6.6 La mónada del almacén
=========================

Los procedimientos que operan en el almacén descritos en la sección
previa toman todos una conexión abierta al daemon de construcción en su
primer parámetro. Aunque el modelo subyacente es funcional, tienen o
bien efectos secundarios o dependen del estado actual del almacén.

   Lo anterior es inconveniente: la conexión al daemon de construcción
tiene que proporcionarse en todas estas funciones, haciendo imposible la
composición de funciones que no toman ese parámetro con funciones que sí
lo hacen. Lo último puede ser problemático: ya que las operaciones del
almacén tienen efectos secundarios y/o dependen del estado externo,
deben ser secuenciadas de manera adecuada.

   Aquí es donde entra en juego el módulo ‘(guix monads)’. Este módulo
proporciona un entorno para trabajar con “mónadas”, y una mónada
particularmente útil para nuestros usos, la “mónada del almacén”. Las
mónadas son una construcción que permite dos cosas: asociar “contexto”
con valores (en nuestro caso, el contexto es el almacén), y la
construcción de secuencias de computaciones (aquí computaciones incluye
accesos al almacén). Los valores en una mónada—valores que transportan
este contexto adicional—se llaman “valores monádicos”; los
procedimientos que devuelven dichos valores se llaman “procedimientos
monádicos”.

   Considere este procedimiento “normal”:

     (define (enlace-sh almacen)
       ;; Devuelve una derivación que enlaza el ejecutable 'bash'.
       (let* ((drv (package-derivation store bash))
              (out (derivation->output-path drv))
              (sh  (string-append out "/bin/bash")))
         (build-expression->derivation store "sh"
                                       `(symlink ,sh %output))))

   Mediante el uso de ‘(guix monads)’ y ‘(guix gexp)’, puede
reescribirse como una función monádica:

     (define (enlace-sh)
       ;; Lo mismo, pero devuelve un valor monádico.
       (mlet %store-monad ((drv (package->derivation bash)))
         (gexp->derivation "sh"
                           #~(symlink (string-append #$drv "/bin/bash")
                                      #$output))))

   Hay varias cosas a tener en cuenta en la segunda versión: el
parámetro ‘store’ ahora es implícito y es “hilado en las llamadas a los
procedimientos monádicos ‘package->derivation’ y ‘gexp->derivation’, y
el valor monádico devuelto por ‘package->derivation’ es “asociado”
mediante el uso de ‘mlet’ en vez de un simple ‘let’.

   Al final, la llamada a ‘package->derivation’ puede omitirse ya que
tendrá lugar implícitamente, como veremos más adelante (*note
Expresiones-G::):

     (define (enlace-sh)
       (gexp->derivation "sh"
                         #~(symlink (string-append #$bash "/bin/bash")
                                    #$output)))

   La ejecución del procedimiento monádico ‘enlace-para-sh’ no tiene
ningún efecto. Como alguien dijo una vez, “sales de una mónada como
sales de un edificio en llamas: corriendo” (run en inglés). Por tanto,
para salir de la mónada y obtener el efecto deseado se debe usar
‘run-with-store’:

     (run-with-store (open-connection) (enlace-sh))
     ⇒ /gnu/store/...-enlace-para-sh

   Fíjese que el módulo ‘(guix monad-repl)’ extiende la sesión
interactiva de Guile con nuevos “meta-comandos” para facilitar el
trabajo con procedimientos monádicos: ‘run-in-store’ y
‘enter-store-monad’. El primero se usa para “ejecutar” un valor monádico
único a través del almacén:

     scheme@(guile-user)> ,run-in-store (package->derivation hello)
     $1 = #<derivation /gnu/store/...-hello-2.9.drv => ...>

   El último entra en un entorno interactivo recursivo, donde todos los
valores devueltos se ejecutan automáticamente a través del almacén:

     scheme@(guile-user)> ,enter-store-monad
     store-monad@(guile-user) [1]> (package->derivation hello)
     $2 = #<derivation /gnu/store/...-hello-2.9.drv => ...>
     store-monad@(guile-user) [1]> (text-file "foo" "Hello!")
     $3 = "/gnu/store/...-foo"
     store-monad@(guile-user) [1]> ,q
     scheme@(guile-user)>

Fíjese que los valores no-monádicos no pueden devolverse en el entorno
interactivo ‘store-monad’.

   Las formas sintácticas principales para tratar con mónadas en general
se proporcionan por el módulo ‘(guix monads)’ y se describen a
continuación.

 -- Sintaxis Scheme: with-monad MÓNADA CUERPO ...
     Evalúa cualquier forma ‘>>=’ o ‘return’ en CUERPO como estando en
     MÓNADA.

 -- Sintaxis Scheme: return VAL
     Devuelve el valor monádico que encapsula VAL.

 -- Sintaxis Scheme: >>= MVAL MPROC ...
     “Asocia” el valor monádico MVAL, pasando su “contenido” a los
     procedimientos monádicos MPROC...(1). Puede haber un MPROC o
     varios, como en este ejemplo:

          (run-with-state
              (with-monad %state-monad
                (>>= (return 1)
                     (lambda (x) (return (+ 1 x)))
                     (lambda (x) (return (* 2 x)))))
            'un-estado)

          ⇒ 4
          ⇒ un-estado

 -- Sintaxis Scheme: mlet MÓNADA ((VAR MVAL) ...) CUERPO ...
 -- Sintaxis Scheme: mlet* MÓNADA ((VAR MVAL) ...) CUERPO ... Asocia las
          variables VAR a los valores monádicos
     MVAL en CUERPO, el cual es una secuencia de expresiones. Como con
     el operador bind, esto puede pensarse como el “desempaquetado” del
     valor crudo no-monádico dentro del ámbito del CUERPO. La forma (VAR
     -> VAL) asocia VAR al valor “normal” VAL, como en ‘let’. Las
     operaciones de asociación ocurren en secuencia de izquierda a
     derecha. La última expresión de CUERPO debe ser una expresión
     monádica, y su resultado se convertirá en el resultado de ‘mlet’ o
     ‘mlet*’ cuando se ejecute en la MÓNADA.

     ‘mlet*’ es a ‘mlet’ lo que ‘let*’ es a ‘let’ (*note (guile)Local
     Bindings::).

 -- Sistema Scheme: mbegin MÓNADA MEXP ...
     Asocia MEXP y las siguientes expresiones monádicas en secuencia,
     devolviendo el resultado de la última expresión. Cada expresión en
     la secuencia debe ser una expresión monádica.

     Esto es similar a ‘mlet’, excepto que los valores devueltos por las
     expresiones monádicas se ignoran. En ese sentido el funcionamiento
     es análogo a ‘begin’ pero aplicado a expresiones monádicas.

 -- Sistema Scheme: mwhen CONDICIÓN MEXP0 MEXP* ...
     Cuando CONDICIÓN es verdadero, evalúa la secuencia de expresiones
     monádicas MEXP0..MEXP* como dentro de ‘mbegin’. Cuando CONDICIÓN es
     falso, devuelve ‘*unespecified*’ en la mónada actual. Todas las
     expresiones en la secuencia deben ser expresiones monádicas.

 -- Sistema Scheme: munless CONDICIÓN MEXP0 MEXP* ...
     Cuando CONDICIÓN es falso, evalúa la secuencia de expresiones
     monádicas MEXP0..MEXP* como dentro de ‘mbegin’. Cuando CONDICIÓN es
     verdadero, devuelve ‘*unespecified*’ en la mónada actual. Todas las
     expresiones en la secuencia deben ser expresiones monádicas.

   El módulo ‘(guix monads)’ proporciona la “mónada de estado”, que
permite que un valor adicional—el estado—sea _hilado_ a través de las
llamadas a procedimientos monádicos.

 -- Variable Scheme: %state-monad
     La mónada de estado. Procedimientos en la mónada de estado pueden
     acceder y cambiar el estado hilado.

     Considere el siguiente ejemplo. El procedimiento ‘cuadrado’
     devuelve un valor en la mónada de estado.

          (define (cuadrado x)
            (mlet %state-monad ((count (current-state)))
              (mbegin %state-monad
                (set-current-state (+ 1 count))
                (return (* x x)))))

          (run-with-state (sequence %state-monad (map cuadrado (iota 3))) 0)
          ⇒ (0 1 4)
          ⇒ 3

     When “run” through ‘%state-monad’, we obtain that additional state
     value, which is the number of ‘square’ calls.

 -- Procedimiento monádico: current-state
     Devuelve el estado actual como un valor monádico.

 -- Procedimiento monádico: set-current-state VALOR
     Establece el estado actual a VALOR y devuelve el estado previo como
     un valor monádico.

 -- Procedimiento monádico: state-push VALOR
     Apila VALOR al estado actual, que se asume que es una lista, y
     devuelve el estado previo como un valor monádico.

 -- Procedimiento monádico: state-pop
     Extrae un valor del estado actual y lo devuelve como un valor
     monádico. Se asume que el estado es una lista.

 -- Procedimiento Scheme: run-with-state MVAL [ESTADO]
     Ejecuta un valor monádico MVAL comenzando con ESTADO como el estado
     inicial. Devuelve dos valores: el valor resultante y el estado
     resultante.

   La interfaz principal a la mónada del almacén, proporcionada por el
módulo ‘(guix store)’, es como sigue.

 -- Variable Scheme: %store-monad
     The store monad—an alias for ‘%state-monad’.

     Values in the store monad encapsulate accesses to the store. When
     its effect is needed, a value of the store monad must be
     “evaluated” by passing it to the ‘run-with-store’ procedure (see
     below).

 -- Procedimiento Scheme: run-with-store ALMACÉN MVAL
          [#:guile-for-build] [#:system (%current-system)]
     Ejecuta MVAL, un valor monádico en la mónada del almacén, en
     ALMACÉN, una conexión abierta al almacén.

 -- Procedimiento monádico: text-file NOMBRE TEXTO [REFERENCIAS]
     Devuelve como un valor monádico el nombre absoluto del fichero en
     el almacén del fichero que contiene ŦEXTO, una cadena. REFERENCIAS
     es una lista de elementos del almacén a los que el fichero de texto
     referencia; su valor predeterminado es la lista vacía.

 -- Procedimiento monádico: binary-file NOMBRE DATOS [REFERENCIAS]
     Devuelve como un valor monádico el nombre absoluto del fichero en
     el almacén del fichero que contiene DATOS, un vector de bytes.
     REFERENCIAS es una lista de elementos del almacén a los que el
     fichero binario referencia; su valor predeterminado es la lista
     vacía.

 -- Procedimiento monádico: interned-file FICHERO [NOMBRE] [#:recursive?
          #t] [#:select? (const #t)]
     Devuelve el nombre del FICHERO una vez internado en el almacén. Usa
     NOMBRE como su nombre del almacén, o el nombre base de FICHERO si
     NOMBRE se omite.

     Cuando RECURSIVE? es verdadero, los contenidos del FICHERO se
     añaden recursivamente; si FICHERO designa un fichero plano y
     RECURSIVE? es verdadero, sus contenidos se añaden, y sus bits de
     permisos se mantienen.

     Cuando RECURSIVE? es verdadero, llama a ‘(SELECT? FICHERO STAT)’
     por cada entrada del directorio, donde FICHERO es el nombre
     absoluto de fichero de la entrada y STAT es el resultado de
     ‘lstat’; excluyendo las entradas para las cuales SELECT? no
     devuelve verdadero.

     El ejemplo siguiente añade un fichero al almacén, bajo dos nombres
     diferentes:

          (run-with-store (open-connection)
            (mlet %store-monad ((a (interned-file "README"))
                                (b (interned-file "README" "LEGU-MIN")))
              (return (list a b))))

          ⇒ ("/gnu/store/rwm...-README" "/gnu/store/44i...-LEGU-MIN")

   El módulo ‘(guix packages)’ exporta los siguientes procedimientos
monádicos relacionados con paquetes:

 -- Procedimiento monádico: package-file PAQUETE [FICHERO] [#:system
          (%current-system)] [#:target #f] [#:output "out"]
     Devuelve como un valor monádico el nombre absoluto de fichero de
     FICHERO dentro del directorio de salida OUTPUT del PAQUETE. Cuando
     se omite FICHERO, devuelve el nombre del directorio de salida
     OUTPUT del PAQUETE. Cuando TARGET es verdadero, se usa como una
     tripleta de compilación cruzada.

     Note that this procedure does _not_ build PACKAGE. Thus, the result
     might or might not designate an existing file. We recommend not
     using this procedure unless you know what you are doing.

 -- Procedimiento monádico: package->derivation PAQUETE [SISTEMA]
 -- Procedimiento monádico: package->cross-derivation PAQUETE OBJETIVO
          [SISTEMA]
     Versión monádica de ‘package-derivation’ y
     ‘package-cross-derivation’ (*note Definición de paquetes::).

   ---------- Footnotes ----------

   (1) Esta operación es habitualmente conocida como “bind”
(asociación), pero ese nombre denota un procedimiento no relacionado en
Guile. Por tanto usamos este símbolo en cierto modo críptico heredado
del lenguaje Haskell.


File: guix.es.info,  Node: Expresiones-G,  Next: Invocación de guix repl,  Prev: La mónada del almacén,  Up: Interfaz programática

6.7 Expresiones-G
=================

Por tanto tenemos “derivaciones”, que representan una secuencia de
acciones de construcción a realizar para producir un elemento en el
almacén (*note Derivaciones::). Estas acciones de construcción se llevan
a cabo cuando se solicita al daemon construir realmente la derivación;
se ejecutan por el daemon en un contenedor (*note Invocación de
guix-daemon::).

   No debería ser ninguna sorpresa que nos guste escribir estas acciones
de construcción en Scheme. Cuando lo hacemos, terminamos con dos
“estratos” de código Scheme(1): el “código anfitrión”—código que define
paquetes, habla al daemon, etc.—y el “código de construcción”—código que
realmente realiza las acciones de construcción, como la creación de
directorios, la invocación de ‘make’, etc.

   Para describir una derivación y sus acciones de construcción,
típicamente se necesita embeber código de construcción dentro del código
anfitrión. Se resume en la manipulación de código de construcción como
datos, y la homoiconicidad de Scheme—el código tiene representación
directa como datos—es útil para ello. Pero necesitamos más que el
mecanismo normal de ‘quasiquote’ en Scheme para construir expresiones de
construcción.

   El módulo ‘(guix gexp)’ implementa las “expresiones-G”, una forma de
expresiones-S adaptada para expresiones de construcción. Las
expresiones-G, o “gexps”, consiste esencialmente en tres formas
sintácticas: ‘gexp’, ‘ungexp’ y ‘ungexp-splicing’ (o simplemente: ‘#~’,
‘#$’ y ‘#$@’), que son comparables a ‘quasiquote’, ‘unquote’ y
‘unquote-splicing’, respectivamente (*note ‘quasiquote’:
(guile)Expression Syntax.). No obstante, hay importantes diferencias:

   • Las expresiones-G están destinadas a escribirse en un fichero y ser
     ejecutadas o manipuladas por otros procesos.

   • Cuando un objeto de alto nivel como un paquete o una derivación se
     expande dentro de una expresión-G, el resultado es el mismo que la
     introducción de su nombre de fichero de salida.

   • Las expresiones-G transportan información acerca de los paquetes o
     derivaciones que referencian, y estas referencias se añaden
     automáticamente como entradas al proceso de construcción que las
     usa.

   This mechanism is not limited to package and derivation objects:
“compilers” able to “lower” other high-level objects to derivations or
files in the store can be defined, such that these objects can also be
inserted into gexps. For example, a useful type of high-level objects
that can be inserted in a gexp is “file-like objects”, which make it
easy to add files to the store and to refer to them in derivations and
such (see ‘local-file’ and ‘plain-file’ below).

   Para ilustrar la idea, aquí está un ejemplo de expresión-G:

     (define exp-construccion
       #~(begin
           (mkdir #$output)
           (chdir #$output)
           (symlink (string-append #$coreutils "/bin/ls")
                    "enumera-ficheros")))

   Esta expresión-G puede pasarse a ‘gexp->derivation’; obtenemos una
derivación que construye un directorio que contiene exactamente un
enlace simbólico a ‘/gnu/store/...-coreutils-8.22/bin/ls’:

     (gexp->derivation "la-cosa" exp-construccion)

   Como se puede esperar, la cadena ‘"/gnu/store/...-coreutils-8.22"’ se
sustituye por la referencia al paquete COREUTILS en el código de
construcción real, y COREUTILS se marca automáticamente como una entrada
a la derivación. Del mismo modo, ‘#$output’ (equivalente a ‘(ungexp
output)’) se reemplaza por una cadena que contiene el nombre del
directorio de la salida de la derivación.

   En un contexto de compilación cruzada, es útil distinguir entre
referencias a construcciones _nativas_ del paquete—que pueden ejecutarse
en el sistema anfitrión—de referencias de compilaciones cruzadas de un
paquete. Para dicho fin, ‘#+’ tiene el mismo papel que ‘#$’, pero es una
referencia a una construcción nativa del paquete:

     (gexp->derivation "vi"
        #~(begin
            (mkdir #$output)
            (mkdir (string-append #$output "/bin"))
            (system* (string-append #+coreutils "/bin/ln")
                     "-s"
                     (string-append #$emacs "/bin/emacs")
                     (string-append #$output "/bin/vi")))
        #:target "aarch64-linux-gnu")

En el ejemplo previo, se usa la construcción nativa de COREUTILS, de
modo que ‘ln’ pueda realmente ejecutarse en el anfitrión; pero se hace
referencia a la construcción de compilación cruzada de EMACS.

   Otra característica de las expresiones-G son los “módulos
importados”: a veces deseará ser capaz de usar determinados módulos
Guile del “entorno anfitrión” en la expresión-G, de modo que esos
módulos deban ser importados en el “entorno de construcción”. La forma
‘with-imported-modules’ le permite expresarlo:

     (let ((build (with-imported-modules '((guix build utils))
                    #~(begin
                        (use-modules (guix build utils))
                        (mkdir-p (string-append #$output "/bin"))))))
       (gexp->derivation "directorio-vacio"
                         #~(begin
                             #$build
                             (display "éxito!\n")
                             #t)))

En este ejemplo, el módulo ‘(guix build utils)’ se incorpora
automáticamente dentro del entorno de construcción aislado de nuestra
expresión-G, de modo que ‘(use-modules (guix build utils))’ funciona
como se espera.

   De manera habitual deseará que la _clausura_ del módulo se importe—es
decir, el módulo en sí y todos los módulos de los que depende—en vez del
módulo únicamente; si no se hace, cualquier intento de uso del módulo
fallará porque faltan módulos dependientes. El procedimiento
‘source-module-closure’ computa la clausura de un módulo mirando en las
cabeceras de sus ficheros de fuentes, lo que es útil en este caso:

     (use-modules (guix modules))   ;para 'source-module-closure'

     (with-imported-modules (source-module-closure
                              '((guix build utils)
                                (gnu build vm)))
       (gexp->derivation "algo-con-maq-virtuales"
                         #~(begin
                             (use-modules (guix build utils)
                                          (gnu build vm))
                             ...)))

   De la misma manera, a veces deseará importar no únicamente módulos
puros de Scheme, pero también “extensiones” como enlaces Guile a
bibliotecas C u otros paquetes “completos”. Si, digamos, necesitase el
paquete ‘guile-json’ disponible en el lado de construcción, esta sería
la forma de hacerlo:

     (use-modules (gnu packages guile))  ;para 'guile-json'

     (with-extensions (list guile-json)
       (gexp->derivation "algo-con-json"
                         #~(begin
                             (use-modules (json))
                             ...)))

   La forma sintáctica para construir expresiones-G se resume a
continuación.

 -- Sintaxis Scheme: #~EXP
 -- Sintaxis Scheme: (gexp EXP)
     Devuelve una expresión-G que contiene EXP. EXP puede contener una o
     más de las siguientes formas:

     ‘#$OBJ’
     ‘(ungexp OBJ)’
          Introduce una referencia a OBJ. OBJ puede tener uno de los
          tipos permitidos, por ejemplo un paquete o derivación, en cuyo
          caso la forma ‘ungexp’ se substituye por el nombre de fichero
          de su salida—por ejemplo, ‘"/gnu/store/...-coreutils-8.22’.

          Si OBJ es una lista, se recorre y las referencias a objetos
          permitidos se substituyen de manera similar.

          Si OBJ es otra expresión-G, su contenido se inserta y sus
          dependencias se añaden a aquellas de la expresión-G que la
          contiene.

          Si OBJ es otro tipo de objeto, se inserta tal cual es.

     ‘#$OBJ:SALIDA’
     ‘(ungexp OBJ SALIDA)’
          Como la forma previa, pero referenciando explícitamente la
          SALIDA de OBJ—esto es útil cuando OBJ produce múltiples
          salidas (*note Paquetes con múltiples salidas::).

     ‘#+OBJ’
     ‘#+OBJ:salida’
     ‘(ungexp-native OBJ)’
     ‘(ungexp-native OBJ SALIDA)’
          Igual que ‘ungexp’, pero produce una referencia a la
          construcción _nativa_ de OBJ cuando se usa en un contexto de
          compilación cruzada.

     ‘#$output[:SALIDA]’
     ‘(ungexp output [SALIDA])’
          Inserta una referencia a la salida de la derivación SALIDA, o
          a la salida principal cuando SALIDA se omite.

          Esto únicamente tiene sentido para expresiones-G pasadas a
          ‘gexp->derivation’.

     ‘#$@LST’
     ‘(ungexp-splicing LST)’
          Lo mismo que la forma previa, pero expande el contenido de la
          lista LST como parte de la lista que la contiene.

     ‘#+@LST’
     ‘(ungexp-native-splicing LST)’
          Lo mismo que la forma previa, pero hace referencia a las
          construcciones nativas de los objetos listados en LST.

     G-expressions created by ‘gexp’ or ‘#~’ are run-time objects of the
     ‘gexp?’ type (see below).

 -- Sintaxis Scheme: with-imported-modules MÓDULOS CUERPO...
     Marca las expresiones-G definidas en el CUERPO... como si
     requiriesen MÓDULOS en su entorno de ejecución.

     Cada elemento en MÓDULOS puede ser el nombre de un módulo, como
     ‘(guix build utils)’, o puede ser el nombre de un módulo, seguido
     de una flecha, seguido de un objeto tipo-fichero:

          `((guix build utils)
            (guix gcrypt)
            ((guix config) => ,(scheme-file "config.scm"
                                            #~(define-module ...))))

     En el ejemplo previo, los dos primeros módulos se toman de la ruta
     de búsqueda, y el último se crea desde el objeto tipo-fichero
     proporcionado.

     Esta forma tiene ámbito _léxico_: tiene efecto en las expresiones-G
     definidas en CUERPO..., pero no en aquellas definidas, digamos, en
     procedimientos llamados por CUERPO....

 -- Sintaxis Scheme: with-extensions EXTENSIONES CUERPO...
     Marca que las expresiones definidas en CUERPO... requieren
     EXTENSIONES en su entorno de construcción y ejecución. EXTENSIONES
     es típicamente una lista de objetos de paquetes como los que se
     definen en el módulo ‘(gnu packages guile)’.

     De manera concreta, los paquetes listados en EXTENSIONES se añaden
     a la ruta de carga mientras se compilan los módulos importados en
     CUERPO...; también se añaden a la ruta de carga en la expresión-G
     devuelta por CUERPO....

 -- Procedimiento Scheme: gexp? OBJ
     Devuelve ‘#t’ si OBJ es una expresión-G.

   G-expressions are meant to be written to disk, either as code
building some derivation, or as plain files in the store. The monadic
procedures below allow you to do that (*note La mónada del almacén::,
for more information about monads).

 -- Procedimiento monádico: gexp->derivation NOMBRE EXP [#:system
          (%current-system)] [#:target #f] [#:graft? #t]  [#:hash #f]
     [#:hash-algo #f]  [#:recursive? #f] [#:env-vars ’()] [#:modules
     ’()]  [#:module-path ‘%load-path’]  [#:effective-version "2.2"]
      [#:references-graphs #f] [#:allowed-references #f]
      [#:disallowed-references #f]  [#:leaked-env-vars #f]
      [#:script-name (string-append NAME "-builder")]
      [#:deprecation-warnings #f]  [#:local-build? #f] [#:substitutable?
     #t]  [#:properties ’()] [#:guile-for-build #f] Return a derivation
     NAME that runs EXP (a gexp) with GUILE-FOR-BUILD (a derivation) on
     SYSTEM; EXP is stored in a file called SCRIPT-NAME. When TARGET is
     true, it is used as the cross-compilation target triplet for
     packages referred to by EXP.

     MODULES está obsoleto en favor de ‘with-imported-modules’. Su
     significado es hacer que los módulos MODULES estén disponibles en
     el contexto de evaluación de EXP; MODULES es una lista de nombres
     de módulos Guile buscados en MODULE-PATH para ser copiados al
     almacén, compilados y disponibles en la ruta de carga durante la
     ejecución de EXP—por ejemplo, ‘((guix build utils) (gui build
     gnu-build-system))’.

     EFFECTIVE-VERSION determina la cadena usada cuando se añaden las
     extensiones de EXP (vea ‘with-extensions’) a la ruta de
     búsqueda—por ejemplo, ‘"2.2"’.

     GRAFT? determina si los paquetes a los que EXP hace referencia
     deben ser injertados cuando sea posible.

     Cuando REFERENCES-GRAPHS es verdadero, debe ser una lista de tuplas
     de una de las formas siguientes:

          (NOMBRE-FICHERO PAQUETE)
          (NOMBRE-FICHERO PAQUETE SALIDA)
          (NOMBRE-FICHERO DERIVACIÓN)
          (NOMBRE-FICHERO DERIVACIÓN SALIDA)
          (NOMBRE-FICHERO ELEMENTO-ALMACÉN)

     El lado derecho de cada elemento de REFERENCES-GRAPHS se convierte
     automáticamente en una entrada del proceso de construcción de EXP.
     En el entorno de construcción, cada NOMBRE-FICHERO contiene el
     grafo de referencias del elemento correspondiente, en un formato de
     texto simple.

     ALLOWED-REFERENCES debe ser o bien ‘#f’ o una lista de nombres y
     paquetes de salida. En el último caso, la lista denota elementos
     del almacén a los que el resultado puede hacer referencia.
     Cualquier referencia a otro elemento del almacén produce un error
     de construcción. De igual manera con DISALLOWED-REFERENCES, que
     enumera elementos a los que las salidas no deben hacer referencia.

     DEPRECATION-WARNINGS determina si mostrar avisos de obsolescencia
     durante la compilación de los módulos. Puede ser ‘#f’, ‘#t’ o
     ‘'detailed’.

     El resto de parámetros funcionan como en ‘derivation’ (*note
     Derivaciones::).

   Los procedimientos ‘local-file’, ‘plain-file’, ‘computed-file’,
‘program-file’ y ‘scheme-file’ a continuación devuelven “objetos
tipo-fichero”. Esto es, cuando se expanden en una expresión-G, estos
objetos dirigen a un fichero en el almacén. Considere esta expresión-G:

     #~(system* #$(file-append glibc "/sbin/nscd") "-f"
                #$(local-file "/tmp/mi-nscd.conf"))

   El efecto aquí es el “internamiento” de ‘/tmp/mi-nscd.conf’ mediante
su copia al almacén. Una vez expandida, por ejemplo vía
‘gexp->derivation’, la expresión-G hace referencia a la copia bajo
‘/gnu/store’; por tanto, la modificación o el borrado del fichero en
‘/tmp’ no tiene ningún efecto en lo que la expresión-G hace.
‘plain-file’ puede usarse de manera similar; se diferencia en que el
contenido del fichero se proporciona directamente como una cadena.

 -- Procedimiento Scheme: local-file FICHERO [NOMBRE] [#:recursive? #f]
          [#:select? (const #t)]
     Devuelve un objeto que representa el fichero local FICHERO a añadir
     al almacén; este objeto puede usarse en una expresión-G. Si FICHERO
     es un nombre de fichero relativo, se busca de forma relativa al
     fichero fuente donde esta forma aparece; si FICHERO no es una
     cadena literal, se buscará de manera relativa al directorio de
     trabajo durante la ejecución. FICHERO se añadirá al almacén bajo
     NOMBRE—de manera predeterminada el nombre de FICHERO sin los
     directorios.

     Cuando RECURSIVE? es verdadero, los contenidos del FICHERO se
     añaden recursivamente; si FICHERO designa un fichero plano y
     RECURSIVE? es verdadero, sus contenidos se añaden, y sus bits de
     permisos se mantienen.

     Cuando RECURSIVE? es verdadero, llama a ‘(SELECT? FICHERO STAT)’
     por cada entrada del directorio, donde FICHERO es el nombre
     absoluto de fichero de la entrada y STAT es el resultado de
     ‘lstat’; excluyendo las entradas para las cuales SELECT? no
     devuelve verdadero.

     Esta es la contraparte declarativa del procedimiento monádico
     ‘interned-file’ (*note ‘interned-file’: La mónada del almacén.).

 -- Procedimiento Scheme: plain-file NOMBRE CONTENIDO
     Devuelve un objeto que representa un fichero de texto llamado
     NOMBRE con el CONTENIDO proporcionado (una cadena o un vector de
     bytes) para ser añadido al almacén.

     Esta es la contraparte declarativa de ‘text-file’.

 -- Procedimiento Scheme: computed-file NOMBRE GEXP [#:options
          '(#:local-build? #t)]
     Devuelve un objeto que representa el elemento del almacén NOMBRE,
     un fichero o un directorio computado por GEXP. OPTIONS es una lista
     de parámetros adicionales a pasar a ‘gexp->derivation’.

     Esta es la contraparte declarativa de ‘gexp->derivation’.

 -- Procedimiento monádico: gexp->script NOMBRE EXP [#:guile
          (default-guile)] [#:module-path %load-path]  [#:system
     (%current-system)] [#:target #f] Devuelve un guión ejecutable
     NOMBRE que ejecuta EXP usando GUILE, con los módulos importados por
     EXP en su ruta de búsqueda. Busca los módulos de EXP en
     MODULE-PATH.

     El ejemplo siguiente construye un guión que simplemente invoca la
     orden ‘ls’:

          (use-modules (guix gexp) (gnu packages base))

          (gexp->script "enumera-ficheros"
                        #~(execl #$(file-append coreutils "/bin/ls")
                                 "ls"))

     Cuando se ejecuta a través del almacén (*note ‘run-with-store’: La
     mónada del almacén.), obtenemos una derivación que produce un
     fichero ejecutable ‘/gnu/store/...-enumera-ficheros’ más o menos
     así:

          #!/gnu/store/...-guile-2.0.11/bin/guile -ds
          !#
          (execl "/gnu/store/...-coreutils-8.22"/bin/ls" "ls")

 -- Procedimiento Scheme: program-file NOMBRE EXP [#:guile #f]
          [#:module-path %load-path]
     Devuelve un objeto que representa el elemento ejecutable del
     almacén NOMBRE que ejecuta GEXP. GUILE es el paquete Guile usado
     para ejecutar el guión. Los módulos importados por GEXP se buscan
     en MODULE-PATH.

     Esta es la contraparte declarativa de ‘gexp->script’.

 -- Procedimiento monádico: gexp->file NOMBRE EXP [#:set-load-path? #t]
          [#:module-path %load-path] [#:splice? #f] [#:guile
          (default-guile)]
     Devuelve una derivación que construye un fichero NOMBRE que
     contiene EXP. Cuando SPLICE? es verdadero, se considera que EXP es
     una lista de expresiones que deben ser expandidas en el fichero
     resultante.

     Cuando SET-LOAD-PATH es verdadero, emite código en el fichero
     resultante para establecer ‘%load-path’ y ‘%load-compiled-path’ de
     manera que respeten los módulos importados por EXP. Busca los
     módulos de EXP en MODULE-PATH.

     El fichero resultante hace referencia a todas las dependencias de
     EXP o a un subconjunto de ellas.

 -- Scheme Procedure: scheme-file NAME EXP [#:splice? #f]
          [#:set-load-path? #t] Return an object representing the
     Scheme file NAME that contains EXP.

     Esta es la contraparte declarativa de ‘gexp->file’.

 -- Procedimiento monádico: text-file* NOMBRE TEXTO ...
     Devuelve como un valor monádico una derivación que construye un
     fichero de texto que contiene todo TEXTO. TEXTO puede ser una lista
     de, además de cadenas, objetos de cualquier tipo que pueda ser
     usado en expresiones-G: paquetes, derivaciones, ficheros locales,
     objetos, etc. El fichero del almacén resultante hace referencia a
     todos ellos.

     Esta variante debe preferirse sobre ‘text-file’ cuando el fichero a
     crear haga referencia a elementos del almacén. Esto es el caso
     típico cuando se construye un fichero de configuración que embebe
     nombres de ficheros del almacén, como este:

          (define (perfil.sh)
            ;; Devuelve el nombre de un guión shell en el almacén
            ;; que establece la variable de entorno 'PATH'
            (text-file* "perfil.sh"
                        "export PATH=" coreutils "/bin:"
                        grep "/bin:" sed "/bin\n"))

     En este ejemplo, el fichero ‘/gnu/store/...-perfil.sh’ resultante
     hará referencia a COREUTILS, GREP y SED, por tanto evitando que se
     recolecten como basura durante su tiempo de vida.

 -- Procedimiento Scheme: mixed-text-file NOMBRE TEXTO ...
     Devuelve un objeto que representa el fichero del almacén NOMBRE que
     contiene TEXTO. TEXTO es una secuencia de cadenas y objetos
     tipo-fichero, como en:

          (mixed-text-file "perfil"
                           "export PATH=" coreutils "/bin:" grep "/bin")

     Esta es la contraparte declarativa de ‘text-file*’.

 -- Procedimiento Scheme: file-union NOMBRE FICHEROS
     Devuelve un ‘<computed-file>’ que construye un directorio que
     contiene todos los FICHEROS. Cada elemento en FICHEROS debe ser una
     lista de dos elementos donde el primer elemento es el nombre de
     fichero usado en el nuevo directorio y el segundo elemento es una
     expresión-G que denota el fichero de destino. Aquí está un ejemplo:

          (file-union "etc"
                      `(("hosts" ,(plain-file "hosts"
                                              "127.0.0.1 localhost"))
                        ("bashrc" ,(plain-file "bashrc"
                                               "alias ls='ls --color=auto'"))))

     Esto emite un directorio ‘etc’ que contiene estos dos ficheros.

 -- Procedimiento Scheme: directory-union NOMBRE COSAS
     Devuelve un directorio que es la unión de COSAS, donde COSAS es una
     lista de objetos tipo-fichero que denotan directorios. Por ejemplo:

          (directory-union "guile+emacs" (list guile emacs))

     emite un directorio que es la unión de los paquetes ‘guile’ y
     ‘emacs’.

 -- Procedimientos Scheme: file-append OBJ SUFIJO ...
     Devuelve un objeto tipo-fichero que se expande a la concatenación
     de OBJ y SUFIJO, donde OBJ es un objeto que se puede bajar de nivel
     y cada SUFIJO es una cadena.

     Como un ejemplo, considere esta expresión-G:

          (gexp->script "ejecuta-uname"
                        #~(system* #$(file-append coreutils
                                                  "/bin/uname")))

     El mismo efecto podría conseguirse con:

          (gexp->script "ejecuta-uname"
                        #~(system* (string-append #$coreutils
                                                  "/bin/uname")))

     Hay una diferencia no obstante: en el caso de ‘file-append’, el
     guión resultante contiene una ruta absoluta de fichero como una
     cadena, mientras que en el segundo caso, el guión resultante
     contiene una expresión ‘(string-append ...)’ para construir el
     nombre de fichero _en tiempo de ejecución_.

 -- Scheme Syntax: let-system SYSTEM BODY...
 -- Scheme Syntax: let-system (SYSTEM TARGET) BODY...
     Bind SYSTEM to the currently targeted system—e.g.,
     ‘"x86_64-linux"’—within BODY.

     In the second case, additionally bind TARGET to the current
     cross-compilation target—a GNU triplet such as
     ‘"arm-linux-gnueabihf"’—or ‘#f’ if we are not cross-compiling.

     ‘let-system’ is useful in the occasional case where the object
     spliced into the gexp depends on the target system, as in this
     example:

          #~(system*
             #+(let-system system
                 (cond ((string-prefix? "armhf-" system)
                        (file-append qemu "/bin/qemu-system-arm"))
                       ((string-prefix? "x86_64-" system)
                        (file-append qemu "/bin/qemu-system-x86_64"))
                       (else
                        (error "dunno!"))))
             "-net" "user" #$image)

 -- Sintaxis Scheme: with-parameters ((PARÁMETRO VALOR ...) EXP
     Este macro es similar a la forma ‘parameterize’ para “parámetros”
     asociados de forma dinámica (*note (guile)Parameters::). La
     principal diferencia es que se hace efectivo cuando el objeto
     tipo-fichero devuelto por EXP se baja de nivel a una derivación o
     un elemento del almacén.

     Un uso típico de ‘with-parameters’ es para forzar el sistema
     efectivo de cierto objeto:

          (with-parameters ((%current-system "i686-linux"))
            coreutils)

     El ejemplo previo devuelve un objeto que corresponde a la
     construcción en i686 de Coreutils, independientemente del valor
     actual de ‘%current-system’.

   Por supuesto, además de expresiones-G embebidas en código
“anfitrión”, hay también módulos que contienen herramientas de
construcción. Para clarificar que están destinados para su uso en el
estrato de construcción, estos módulos se mantienen en el espacio de
nombres ‘(guix build ...)’.

   Internamente, los objetos de alto nivel se “bajan de nivel”, usando
su compilador, a derivaciones o elementos del almacén. Por ejemplo,
bajar de nivel un paquete emite una derivación, y bajar de nivel un
PLAIN-FILE emite un elemento del almacén. Esto se consigue usando el
procedimiento monádico ‘lower-object’.

 -- Procedimiento monádico: lower-object OBJ [SISTEMA] [#:target #f]
          Return as a value in ‘%store-monad’ the derivation or
     store item corresponding to OBJ for SYSTEM, cross-compiling for
     TARGET if TARGET is true. OBJ must be an object that has an
     associated gexp compiler, such as a ‘<package>’.

   ---------- Footnotes ----------

   (1) El término “estrato” en este contexto se debe a Manuel Serrano et
al. en el contexto de su trabajo en Hop. Oleg Kiselyov, quien ha escrito
profundos ensayos sobre el tema
(http://okmij.org/ftp/meta-programming/#meta-scheme), se refiere a este
tipo de generación de código como separación en etapas o “staging”.


File: guix.es.info,  Node: Invocación de guix repl,  Prev: Expresiones-G,  Up: Interfaz programática

6.8 Invocación de ‘guix repl’
=============================

La orden ‘guix repl’ lanza un “bucle de lectura-evaluación-impresión”
Guile (REPL) para programación interactiva (*note (guile)Using Guile
Interactively::). Comparado a simplemente lanzar la orden ‘guile’, ‘guix
repl’ garantiza que todos los módulos Guix y todas sus dependencias
están disponibles en la ruta de búsqueda. Puede usarla de esta manera:

     $ guix repl
     scheme@(guile-user)> ,use (gnu packages base)
     scheme@(guile-user)> coreutils
     $1 = #<package coreutils@8.29 gnu/packages/base.scm:327 3e28300>

   Además, ‘guix repl’ implementa un protocolo del REPL simple legible
por máquinas para su uso por ‘(guix inferior)’, una facilidad para
interactuar con “inferiores”, procesos separados que ejecutan una
revisión de Guix potencialmente distinta.

   Las opciones disponibles son las siguientes:

‘--type=TIPO’
‘-t TIPO’
     Inicia un REPL del TIPO dado, que puede ser uno de los siguientes:

     ‘guile’
          Es el predeterminado, y lanza una sesión interactiva Guile
          estándar con todas las características.
     ‘machine’
          Lanza un REPL que usa el protocolo legible por máquinas. Este
          es el protocolo con el que el módulo ‘(guix inferior)’ se
          comunica.

‘--listen=DESTINO’
     Por defecto, ‘guix repl’ lee de la entrada estándar y escribe en la
     salida estándar. Cuando se pasa esta opción, en vez de eso
     escuchará las conexiones en DESTINO. Estos son ejemplos de opciones
     válidas:

     ‘--listen=tcp:37146’
          Acepta conexiones locales por el puerto 37146.

     ‘--listen=unix:/tmp/socket’
          Acepta conexiones a través del socket de dominio Unix
          ‘/tmp/socket’.

‘--load-path=DIRECTORIO’
‘-L DIRECTORIO’
     Añade DIRECTORIO al frente de la ruta de búsqueda de módulos de
     paquetes (*note Módulos de paquetes::).

     Esto permite a las usuarias definir sus propios paquetes y hacerlos
     visibles a las herramientas de línea de órdenes.

‘-q’
     Inhibe la carga del fichero ‘~/.guile’. De manera predeterminada,
     dicho fichero de configuración se carga al lanzar una sesión
     interactiva de ‘guile’.


File: guix.es.info,  Node: Utilidades,  Next: Configuración del sistema,  Prev: Interfaz programática,  Up: Top

7 Utilidades
************

Esta sección describe las utilidades de línea de órdenes de Guix.
Algunas de ellas están orientadas principalmente para desarrolladoras y
usuarias que escriban definiciones de paquetes nuevas, mientras que
otras son útiles de manera más general. Complementan la interfaz
programática Scheme de Guix de modo conveniente.

* Menu:

* Invocación de guix build::  Construir paquetes desde la línea de
                                 órdenes.
* Invocación de guix edit::  Editar las definiciones de paquetes.
* Invocación de guix download::  Descargar un fichero e imprimir su hash.
* Invocación de guix hash::  Calcular el hash criptográfico de un fichero.
* Invocación de guix import::  Importar definiciones de paquetes.
* Invocación de guix refresh::  Actualizar definiciones de paquetes.
* Invocación de guix lint::  Encontrar errores en definiciones de paquetes.
* Invocación de guix size::  Perfilar el uso del disco.
* Invocación de guix graph::  Visualizar el grafo de paquetes.
* Invocación de guix publish::  Compartir sustituciones.
* Invocación de guix challenge::  Poner a prueba servidores de
                                     sustituciones.
* Invocación de guix copy::  Copiar a y desde un almacén remoto.
* Invocación de guix container::  Aislamiento de procesos.
* Invocación de guix weather::  Comprobar la disponibilidad de
                                   sustituciones.
* Invocación de guix processes::  Enumerar los procesos cliente.


File: guix.es.info,  Node: Invocación de guix build,  Next: Invocación de guix edit,  Up: Utilidades

7.1 Invocación de ‘guix build’
==============================

La orden ‘guix build’ construye paquetes o derivaciones y sus
dependencias, e imprime las rutas del almacén resultantes. Fíjese que no
modifica el perfil de la usuaria—este es el trabajo de la orden ‘guix
package’ (*note Invocación de guix package::). Por tanto, es útil
principalmente para las desarrolladoras de la distribución.

   La sintaxis general es:

     guix build OPCIONES PAQUETE-O-DERIVACIÓN...

   Como ejemplo, la siguiente orden construye las últimas versiones de
Emacs y Guile, muestra sus log de construcción, y finalmente muestra los
directorios resultantes:

     guix build emacs guile

   De forma similar, la siguiente orden construye todos los paquetes
disponibles:

     guix build --quiet --keep-going \
       `guix package -A | cut -f1,2 --output-delimiter=@`

   PAQUETE-O-DERIVACIÓN puede ser tanto el nombre de un paquete que se
encuentra en la distribución de software como ‘coreutils’ o
‘coreutils@8.20’, o una derivación como
‘/gnu/store/...-coreutils-8.19.drv’. En el primer caso, el paquete de
nombre (y opcionalmente versión) correspondiente se busca entre los
módulos de la distribución GNU (*note Módulos de paquetes::).

   Alternatively, the ‘--expression’ option may be used to specify a
Scheme expression that evaluates to a package; this is useful when
disambiguating among several same-named packages or package variants is
needed.

   Puede haber cero o más OPCIONES. Las opciones disponibles se
describen en la subsección siguiente.

* Menu:

* Opciones comunes de construcción::  Opciones de construcción para la
                                         mayoría de órdenes.
* Opciones de transformación de paquetes::  Crear variantes de paquetes.
* Opciones de construcción adicionales::  Opciones específicas de ’guix
                                             build’.
* Depuración de fallos de construcción::  Experiencia de empaquetamiento
                                              en la vida real.


File: guix.es.info,  Node: Opciones comunes de construcción,  Next: Opciones de transformación de paquetes,  Up: Invocación de guix build

7.1.1 Opciones comunes de construcción
--------------------------------------

Un número de opciones que controlan el proceso de construcción son
comunes a ‘guix build’ y otras órdenes que pueden lanzar construcciones,
como ‘guix package’ o ‘guix archive’. Son las siguientes:

‘--load-path=DIRECTORIO’
‘-L DIRECTORIO’
     Añade DIRECTORIO al frente de la ruta de búsqueda de módulos de
     paquetes (*note Módulos de paquetes::).

     Esto permite a las usuarias definir sus propios paquetes y hacerlos
     visibles a las herramientas de línea de órdenes.

‘--keep-failed’
‘-K’
     Mantiene los árboles de construcción de las construcciones
     fallidas. Por tanto, si una construcción falla, su árbol de
     construcción se mantiene bajo ‘/tmp’, en un directorio cuyo nombre
     se muestra al final del log de construcción. Esto es útil cuando se
     depuran problemas en la construcción. *Note Depuración de fallos de
     construcción::, para trucos y consejos sobre cómo depurar problemas
     en la construcción.

     This option implies ‘--no-offload’, and it has no effect when
     connecting to a remote daemon with a ‘guix://’ URI (*note the
     ‘GUIX_DAEMON_SOCKET’ variable: El almacén.).

‘--keep-going’
‘-k’
     Seguir adelante cuando alguna de las derivaciones de un fallo
     durante la construcción; devuelve una única vez todas las
     construcciones que se han completado o bien han fallado.

     El comportamiento predeterminado es parar tan pronto una de las
     derivaciones especificadas falle.

‘--dry-run’
‘-n’
     No construye las derivaciones.

‘--fallback’
     Cuando la sustitución de un binario preconstruido falle, intenta la
     construcción local de paquetes (*note Fallos en las
     sustituciones::).

‘--substitute-urls=URLS’
     Considera URLS la lista separada por espacios de URLs de fuentes de
     sustituciones, anulando la lista predeterminada de URLs de
     ‘guix-daemon’ (*note ‘guix-daemon URLs’: daemon-substitute-urls.).

     Significa que las sustituciones puede ser descargadas de URLS,
     mientras que estén firmadas por una clave autorizada por la
     administradora del sistema (*note Sustituciones::).

     Cuando URLS es la cadena vacía, las sustituciones están
     efectivamente desactivadas.

‘--no-substitutes’
     No usa sustituciones para la construcción de productos. Esto es,
     siempre realiza las construcciones localmente en vez de permitir la
     descarga de binarios pre-construidos (*note Sustituciones::).

‘--no-grafts’
     No “injerta” paquetes. En la práctica esto significa que las
     actualizaciones de paquetes disponibles como injertos no se
     aplican. *Note Actualizaciones de seguridad::, para más información
     sobre los injertos.

‘--rounds=N’
     Construye cada derivación N veces seguidas, y lanza un error si los
     resultados de las construcciones consecutivas no son idénticos
     bit-a-bit.

     Esto es útil para la detección de procesos de construcción
     no-deterministas. Los procesos de construcción no-deterministas son
     un problema puesto que prácticamente imposibilitan a las usuarias
     la _verificación_ de la autenticidad de binarios proporcionados por
     terceras partes. *Note Invocación de guix challenge::, para más
     sobre esto.

     Fíjese que, actualmente, los resultados de las construcciones
     discordantes no se mantienen, por lo que debe que investigar
     manualmente en caso de un error—por ejemplo, mediante la extracción
     de uno de los resultados con ‘guix archive --export’ (*note
     Invocación de guix archive::), seguida de una reconstrucción, y
     finalmente la comparación de los dos resultados.

‘--no-offload’
     No usa la delegación de construcciones en otras máquinas (*note
     Configuración de delegación del daemon::). Es decir, siempre
     realiza las construcciones de manera local en vez de delegar
     construcciones a máquinas remotas.

‘--max-silent-time=SEGUNDOS’
     Cuando la construcción o sustitución permanece en silencio más de
     SEGUNDOS, la finaliza e informa de un fallo de construcción.

     By default, the daemon’s setting is honored (*note
     ‘--max-silent-time’: Invocación de guix-daemon.).

‘--timeout=SEGUNDOS’
     Del mismo modo, cuando el proceso de construcción o sustitución
     dura más de SEGUNDOS, lo termina e informa un fallo de
     construcción.

     By default, the daemon’s setting is honored (*note ‘--timeout’:
     Invocación de guix-daemon.).

‘-v NIVEL’
‘--verbosity=NIVEL’
     Usa el NIVEL de detalle especificado, un entero. Seleccionar 0
     significa que no se produce ninguna salida, 1 es para salida
     silenciosa y 2 muestra toda la salida del registro de construcción
     en la salida estándar de error.

‘--cores=N’
‘-c N’
     Permite usar N núcleos de la CPU para la construcción. El valor
     especial ‘0’ significa usar tantos como núcleos haya en la CPU.

‘--max-jobs=N’
‘-M N’
     Allow at most N build jobs in parallel. *Note ‘--max-jobs’:
     Invocación de guix-daemon, for details about this option and the
     equivalent ‘guix-daemon’ option.

‘--debug=NIVEL’
     Usa el nivel de detalle proporcionado en los mensajes procedentes
     del daemon de construcción. NIVEL debe ser un entero entre 0 y 5;
     valores mayores indican una salida más detallada. Establecer un
     nivel de 4 o superior puede ser útil en la depuración de problemas
     de configuración con el daemon de construcción.

   Tras las cortinas, ‘guix build’ es esencialmente una interfaz al
procedimiento ‘package-derivation’ del módulo ‘(guix packages)’, y al
procedimiento ‘build-derivations’ del módulo ‘(guix derivations)’.

   In addition to options explicitly passed on the command line, ‘guix
build’ and other ‘guix’ commands that support building honor the
‘GUIX_BUILD_OPTIONS’ environment variable.

 -- Variable de entorno: GUIX_BUILD_OPTIONS
     Las usuarias pueden definir esta variable para que contenga una
     lista de opciones de línea de órdenes que se usarán automáticamente
     por ‘guix build’ y otras órdenes ‘guix’ que puedan realizar
     construcciones, como en el ejemplo siguiente:

          $ export GUIX_BUILD_OPTIONS="--no-substitutes -c 2 -L /foo/bar"

     Estas opciones se analizan independientemente, y el resultado se
     añade a continuación de las opciones de línea de órdenes.


File: guix.es.info,  Node: Opciones de transformación de paquetes,  Next: Opciones de construcción adicionales,  Prev: Opciones comunes de construcción,  Up: Invocación de guix build

7.1.2 Opciones de transformación de paquetes
--------------------------------------------

Otro conjunto de opciones de línea de órdenes permitidas por ‘guix
build’ y también ‘guix package’ son las “opciones de transformación de
paquetes”. Son opciones que hacen posible la definición de “variaciones
de paquetes”—por ejemplo, paquetes construidos con un código fuente
diferente. Es una forma conveniente de crear paquetes personalizados al
vuelo sin tener que escribir las definiciones de las variaciones del
paquete (*note Definición de paquetes::).

‘--with-source=FUENTE’
‘--with-source=PAQUETE=FUENTE’
‘--with-source=PAQUETE@VERSIÓN=FUENTE’
     Usa FUENTE como la fuente de PAQUETE, y VERSIÓN como su número de
     versión. FUENTE debe ser un nombre de fichero o una URL, como en
     ‘guix download’ (*note Invocación de guix download::).

     Cuando se omite PAQUETE, se toma el nombre de paquete especificado
     en la línea de ordenes que coincide con el nombre base de
     FUENTE—por ejemplo, si FUENTE fuese ‘/src/guile-2.0.10.tar.gz’, el
     paquete correspondiente sería ‘guile’.

     Del mismo modo, si se omite VERSIÓN, la cadena de versión se deduce
     de ĐUENTE; en el ejemplo previo sería ‘2.0.10’.

     Esta opción permite a las usuarias probar versiones del paquete
     distintas a las proporcionadas en la distribución. El ejemplo
     siguiente descarga ‘ed-1.7.tar.gz’ de un espejo GNU y lo usa como
     la fuente para el paquete ‘ed’:

          guix build ed --with-source=mirror://gnu/ed/ed-1.7.tar.gz

     As a developer, ‘--with-source’ makes it easy to test release
     candidates:

          guix build guile --with-source=../guile-2.0.9.219-e1bb7.tar.xz

     ... o la construcción desde una revisión en un entorno limpio:

          $ git clone git://git.sv.gnu.org/guix.git
          $ guix build guix --with-source=guix@1.0=./guix

‘--with-input=PAQUETE=REEMPLAZO’
     Substituye dependencias de PAQUETE por dependencias de REEMPLAZO.
     PAQUETE debe ser un nombre de paquete, y REEMPLAZO debe ser una
     especificación de paquete como ‘guile’ o ‘guile@1.8’.

     Por ejemplo, la orden siguiente construye Guix, pero substituye su
     dependencia de la versión estable actual de Guile con una
     dependencia en la versión antigua de Guile, ‘guile@2.0’:

          guix build --with-input=guile=guile@2.0 guix

     Esta sustitución se realiza de forma recursiva y en profundidad.
     Por lo que en este ejemplo, tanto ‘guix’ como su dependencia
     ‘guile-json’ (que también depende de ‘guile’) se reconstruyen
     contra ‘guile@2.0’.

     Se implementa usando el procedimiento Scheme
     ‘package-input-rewriting’ (*note ‘package-input-rewriting’:
     Definición de paquetes.).

‘--with-graft=PAQUETE=REEMPLAZO’
     This is similar to ‘--with-input’ but with an important difference:
     instead of rebuilding the whole dependency chain, REPLACEMENT is
     built and then “grafted” onto the binaries that were initially
     referring to PACKAGE. *Note Actualizaciones de seguridad::, for
     more information on grafts.

     Por ejemplo, la orden siguiente injerta la versión 3.5.4 de GnuTLS
     en Wget y todas sus dependencias, substituyendo las referencias a
     la versión de GnuTLS que tienen actualmente:

          guix build --with-graft=gnutls=gnutls@3.5.4 wget

     Esta opción tiene la ventaja de ser mucho más rápida que la
     reconstrucción de todo. Pero hay una trampa: funciona si y solo si
     PAQUETE y REEMPLAZO son estrictamente compatibles—por ejemplo, si
     proporcionan una biblioteca, la interfaz binaria de aplicación
     (ABI) de dichas bibliotecas debe ser compatible. Si REEMPLAZO es
     incompatible de alguna manera con PAQUETE, el paquete resultante
     puede no ser usable. ¡Úsela con precaución!

‘--with-git-url=PAQUETE=URL’
     Construye PAQUETE desde la última revisión de la rama ‘master’ del
     repositorio Git en URL. Los submódulos del repositorio Git se
     obtienen de forma recursiva.

     Por ejemplo, la siguiente orden construye la biblioteca NumPy de
     Python contra la última revisión de la rama master de Python en sí:

          guix build python-numpy \
            --with-git-url=python=https://github.com/python/cpython

     This option can also be combined with ‘--with-branch’ or
     ‘--with-commit’ (see below).

     Obviamente, ya que se usa la última revisión de la rama
     proporcionada, el resultado de dicha orden varia con el tiempo. No
     obstante es una forma conveniente de reconstruir una pila completa
     de software contra las últimas revisiones de uno o varios paquetes.
     Esto es particularmente útil en el contexto de integración continua
     (CI).

     Los directorios de trabajo se conservan en caché en
     ‘~/.cache/guix/checkouts’ para agilizar accesos consecutivos al
     mismo repositorio. Puede desear limpiarla de vez en cuando para
     ahorrar espacio en el disco.

‘--with-branch=PAQUETE=RAMA’
     Build PACKAGE from the latest commit of BRANCH. If the ‘source’
     field of PACKAGE is an origin with the ‘git-fetch’ method (*note
     Referencia de origin::) or a ‘git-checkout’ object, the repository
     URL is taken from that ‘source’. Otherwise you have to use
     ‘--with-git-url’ to specify the URL of the Git repository.

     Por ejemplo, la siguiente orden construye ‘guile-sqlite3’ desde la
     última revisión de su rama ‘master’ y, una vez hecho, construye
     ‘guix’ (que depende de él) y ‘cuirass’ (que depende de ‘guix’) en
     base a esta construcción específica de ‘guile-sqlite3’:

          guix build --with-branch=guile-sqlite3=master cuirass

‘--with-commit=PAQUETE=REVISIÓN’
     This is similar to ‘--with-branch’, except that it builds from
     COMMIT rather than the tip of a branch. COMMIT must be a valid Git
     commit SHA1 identifier or a tag.


File: guix.es.info,  Node: Opciones de construcción adicionales,  Next: Depuración de fallos de construcción,  Prev: Opciones de transformación de paquetes,  Up: Invocación de guix build

7.1.3 Opciones de construcción adicionales
------------------------------------------

Las opciones de línea de ordenes presentadas a continuación son
específicas de ‘guix build’.

‘--quiet’
‘-q’
     Build quietly, without displaying the build log; this is equivalent
     to ‘--verbosity=0’. Upon completion, the build log is kept in
     ‘/var’ (or similar) and can always be retrieved using the
     ‘--log-file’ option.

‘--file=FICHERO’
‘-f FICHERO’
     Construye el paquete, derivación u otro objeto tipo-fichero al que
     evalúa el código en FICHERO (*note objetos “tipo-fichero”:
     Expresiones-G.).

     Como un ejemplo, FICHERO puede contener una definición como esta
     (*note Definición de paquetes::):

          (use-modules (guix)
                       (guix build-system gnu)
                       (guix licenses))

          (package
            (name "hello")
            (version "2.10")
            (source (origin
                      (method url-fetch)
                      (uri (string-append "mirror://gnu/hello/hello-" version
                                          ".tar.gz"))
                      (sha256
                       (base32
                        "0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i"))))
            (build-system gnu-build-system)
            (synopsis "Hello, GNU world: An example GNU package")
            (description "Guess what GNU Hello prints!")
            (home-page "http://www.gnu.org/software/hello/")
            (license gpl3+))

     The FILE may also contain a JSON representation of one or more
     package definitions. Running ‘guix build -f’ on ‘hello.json’ with
     the following contents would result in building the packages
     ‘myhello’ and ‘greeter’:

          [
            {
              "name": "myhello",
              "version": "2.10",
              "source": "mirror://gnu/hello/hello-2.10.tar.gz",
              "build-system": "gnu",
              "arguments": {
                "tests?": false
              }
              "home-page": "https://www.gnu.org/software/hello/",
              "synopsis": "Hello, GNU world: An example GNU package",
              "description": "GNU Hello prints a greeting.",
              "license": "GPL-3.0+",
              "native-inputs": ["gettext"]
            },
            {
              "name": "greeter",
              "version": "1.0",
              "source": "https://example.com/greeter-1.0.tar.gz",
              "build-system": "gnu",
              "arguments": {
                "test-target": "foo",
                "parallel-build?": false,
              },
              "home-page": "https://example.com/",
              "synopsis": "Greeter using GNU Hello",
              "description": "This is a wrapper around GNU Hello.",
              "license": "GPL-3.0+",
              "inputs": ["myhello", "hello"]
            }
          ]

‘--manifest=MANIFIESTO’
‘-m MANIFIESTO’
     Construye todos los paquetes listados en el MANIFIESTO
     proporcionado (*note ‘--manifest’: profile-manifest.).

‘--expression=EXPR’
‘-e EXPR’
     Construye el paquete o derivación a la que evalúa EXPR.

     Por ejemplo, EXPR puede ser ‘(@ (gnu packages guile) guile-1.8)’,
     que designa sin ambigüedad a esta variante específica de la versión
     1.8 de Guile.

     De manera alternativa, EXPR puede ser una expresión-G, en cuyo caso
     se usa como un programa de construcción pasado a ‘gexp->derivation’
     (*note Expresiones-G::).

     Por último, EXPR puede hacer referencia a un procedimiento mónadico
     sin parámetros (*note La mónada del almacén::). El procedimiento
     debe devolver una derivación como un valor monádico, el cual
     después se pasa a través de ‘run-with-store’.

‘--source’
‘-S’
     Construye las derivaciones de las fuentes de los paquetes, en vez
     de los paquetes mismos.

     Por ejemplo, ‘guix build -S gcc’ devuelve algo como
     ‘/gnu/store/...-gcc-4.7.2.tar.bz2’, el cual es el archivador tar de
     fuentes de GCC.

     El archivador tar devuelto es el resultado de aplicar cualquier
     parche y fragmento de código en el origen (campo ‘origin’) del
     paquete (*note Definición de paquetes::).

     Tenga en cuenta que ‘guix build -S’ compila las fuentes únicamente
     de los paquetes especificados. Esto no incluye las dependencias
     enlazadas estáticamente y por sí mismas son insuficientes para
     reproducir los paquetes.

‘--sources’
     Fetch and return the source of PACKAGE-OR-DERIVATION and all their
     dependencies, recursively. This is a handy way to obtain a local
     copy of all the source code needed to build PACKAGES, allowing you
     to eventually build them even without network access. It is an
     extension of the ‘--source’ option and can accept one of the
     following optional argument values:

     ‘package’
          This value causes the ‘--sources’ option to behave in the same
          way as the ‘--source’ option.

     ‘all’
          Construye las derivaciones de las fuentes de todos los
          paquetes, incluyendo cualquier fuente que pueda enumerarse
          como entrada (campo ‘inputs’). Este es el valor
          predeterminado.

               $ guix build --sources tzdata
               The following derivations will be built:
                  /gnu/store/...-tzdata2015b.tar.gz.drv
                  /gnu/store/...-tzcode2015b.tar.gz.drv

     ‘transitive’
          Construye las derivaciones de fuentes de todos los paquetes,
          así como todas las entradas transitivas de los paquetes. Esto
          puede usarse, por ejemplo, para obtener las fuentes de
          paquetes para una construcción posterior sin conexión a la
          red.

               $ guix build --sources=transitive tzdata
               The following derivations will be built:
                  /gnu/store/...-tzcode2015b.tar.gz.drv
                  /gnu/store/...-findutils-4.4.2.tar.xz.drv
                  /gnu/store/...-grep-2.21.tar.xz.drv
                  /gnu/store/...-coreutils-8.23.tar.xz.drv
                  /gnu/store/...-make-4.1.tar.xz.drv
                  /gnu/store/...-bash-4.3.tar.xz.drv
               ...

‘--system=SISTEMA’
‘-s SISTEMA’
     Intenta la construcción para SISTEMA—por ejemplo, ‘i686-linux’—en
     vez del tipo de sistema de la máquina de construcción. La orden
     ‘guix build’ le permite repetir esta opción varias veces, en cuyo
     caso construye para todos los sistemas especificados; otras ordenes
     ignoran opciones ‘-s’ extrañas.

          Nota: The ‘--system’ flag is for _native_ compilation and must
          not be confused with cross-compilation. See ‘--target’ below
          for information on cross-compilation.

     An example use of this is on Linux-based systems, which can emulate
     different personalities. For instance, passing
     ‘--system=i686-linux’ on an ‘x86_64-linux’ system or
     ‘--system=armhf-linux’ on an ‘aarch64-linux’ system allows you to
     build packages in a complete 32-bit environment.

          Nota: La construcción para un sistema ‘armhf-linux’ está
          disponible de manera incondicional en máquinas
          ‘aarch64-linux’, aunque determinados procesadores aarch64 no
          lo permitan, notablemente el ThunderX.

     De manera similar, cuando la emulación transparente con QEMU y
     ‘binfmt_misc’ está activada (*note ‘qemu-binfmt-service-type’:
     Servicios de virtualización.), puede construir para cualquier
     sistema para el que un manejador QEMU de ‘binfmt_misc’ esté
     instalado.

     Las construcciones para un sistema distinto al de la máquina que
     usa se pueden delegar también a una máquina remota de la
     arquitectura correcta. *Note Configuración de delegación del
     daemon::, para más información sobre delegación.

‘--target=TRIPLETA’
     Cross-build for TRIPLET, which must be a valid GNU triplet, such as
     ‘"aarch64-linux-gnu"’ (*note GNU configuration triplets:
     (autoconf)Specifying Target Triplets.).

‘--check’
     Reconstruye PAQUETE-O-DERIVACIÓN, que ya está disponible en el
     almacén, y emite un error si los resultados de la construcción no
     son idénticos bit-a-bit.

     Este mecanismo le permite comprobar si sustituciones previamente
     instaladas son genuinas (*note Sustituciones::), o si el resultado
     de la construcción de un paquete es determinista. *Note Invocación
     de guix challenge::, para más información de referencia y
     herramientas.

     Cuando se usa conjuntamente con ‘--keep-failed’, la salida que
     difiere se mantiene en el almacén, bajo ‘/gnu/store/...-check’.
     Esto hace fácil buscar diferencias entre los dos resultados.

‘--repair’
     Intenta reparar los elementos del almacén especificados, si están
     corruptos, volviendo a descargarlos o mediante su reconstrucción.

     Esta operación no es atómica y por lo tanto está restringida a
     ‘root’.

‘--derivations’
‘-d’
     Devuelve las rutas de derivación, no las rutas de salida, de los
     paquetes proporcionados.

‘--root=FICHERO’
‘-r FICHERO’
     Hace que FICHERO sea un enlace simbólico al resultado, y lo
     registra como una raíz del recolector de basura.

     Consecuentemente, los resultados de esta invocación de ‘guix build’
     se protegen de la recolección de basura hasta que FICHERO se
     elimine. Cuando se omite esa opción, los resultados son candidatos
     a la recolección de basura en cuanto la construcción se haya
     completado. *Note Invocación de guix gc::, para más sobre las
     raíces del recolector de basura.

‘--log-file’
     Devuelve los nombres de ficheros o URL de los log de construcción
     para el PAQUETE-O-DERIVACIÓN proporcionado, o emite un error si no
     se encuentran los log de construcción.

     Esto funciona independientemente de cómo se especificasen los
     paquetes o derivaciones. Por ejemplo, las siguientes invocaciones
     son equivalentes:

          guix build --log-file `guix build -d guile`
          guix build --log-file `guix build guile`
          guix build --log-file guile
          guix build --log-file -e '(@ (gnu packages guile) guile-2.0)'

     If a log is unavailable locally, and unless ‘--no-substitutes’ is
     passed, the command looks for a corresponding log on one of the
     substitute servers (as specified with ‘--substitute-urls’).

     Por lo que dado el caso, imaginese que desea ver el log de
     construcción de GDB en MIPS, pero realmente está en una máquina
     ‘x86_64’:

          $ guix build --log-file gdb -s aarch64-linux
          https://ci.guix.gnu.org/log/...-gdb-7.10

     ¡Puede acceder libremente a una biblioteca inmensa de log de
     construcción!


File: guix.es.info,  Node: Depuración de fallos de construcción,  Prev: Opciones de construcción adicionales,  Up: Invocación de guix build

7.1.4 Depuración de fallos de construcción
------------------------------------------

Cuando esté definiendo un paquete nuevo (*note Definición de
paquetes::), probablemente se encuentre que dedicando algún tiempo a
depurar y afinar la construcción hasta obtener un resultado
satisfactorio. Para hacerlo, tiene que lanzar manualmente las órdenes de
construcción en un entorno tan similar como sea posible al que el daemon
de construcción usa.

   To that end, the first thing to do is to use the ‘--keep-failed’ or
‘-K’ option of ‘guix build’, which will keep the failed build tree in
‘/tmp’ or whatever directory you specified as ‘TMPDIR’ (*note
‘--keep-failed’: Invocación de guix build.).

   De ahí en adelante, puede usar ‘cd’ para ir al árbol de la
construcción fallida y cargar el fichero ‘environment-variables’, que
contiene todas las definiciones de variables de entorno que existían
cuando la construcción falló. Digamos que está depurando un fallo en la
construcción del paquete ‘foo’; una sesión típica sería así:

     $ guix build foo -K
     ... build fails
     $ cd /tmp/guix-build-foo.drv-0
     $ source ./environment-variables
     $ cd foo-1.2

   Ahora puede invocar órdenes (casi) como si fuese el daemon y
encontrar los errores en su proceso de construcción.

   A veces ocurre que, por ejemplo, las pruebas de un paquete pasan
cuando las ejecuta manualmente pero fallan cuando el daemon las ejecuta.
Esto puede suceder debido a que el daemon construye dentro de
contenedores donde, al contrario que en nuestro entorno previo, el
acceso a la red no está disponible, ‘/bin/sh’ no existe, etc. (*note
Configuración del entorno de construcción::).

   En esos casos, puede tener que inspeccionar el proceso de
construcción desde un contenedor similar al creado por el daemon de
construcción:

     $ guix build -K foo
     ...
     $ cd /tmp/guix-build-foo.drv-0
     $ guix environment --no-grafts -C foo --ad-hoc strace gdb
     [env]# source ./environment-variables
     [env]# cd foo-1.2

   Here, ‘guix environment -C’ creates a container and spawns a new
shell in it (*note Invocación de guix environment::). The ‘--ad-hoc
strace gdb’ part adds the ‘strace’ and ‘gdb’ commands to the container,
which you may find handy while debugging. The ‘--no-grafts’ option makes
sure we get the exact same environment, with ungrafted packages (*note
Actualizaciones de seguridad::, for more info on grafts).

   Para acercarnos más al contenedor usado por el daemon de
construcción, podemos eliminar ‘/bin/sh’:

     [env]# rm /bin/sh

   (No se preocupe, es inocuo: todo esto ocurre en el contenedor de usar
y tirar creado por ‘guix environment’).

   La orden ‘strace’ probablemente no esté en la ruta de búsqueda, pero
podemos ejecutar:

     [env]# $GUIX_ENVIRONMENT/bin/strace -f -o log make check

   De este modo, no solo habrá reproducido las variables de entorno que
usa el daemon, también estará ejecutando el proceso de construcción en
un contenedor similar al usado por el daemon.


File: guix.es.info,  Node: Invocación de guix edit,  Next: Invocación de guix download,  Prev: Invocación de guix build,  Up: Utilidades

7.2 Invocación de ‘guix edit’
=============================

¡Tantos paquetes, tantos ficheros de fuentes! La orden ‘guix edit’
facilita la vida de las usuarias y empaquetadoras apuntando su editor al
fichero de fuentes que contiene la definición de los paquetes
especificados. Por ejemplo:

     guix edit gcc@4.9 vim

launches the program specified in the ‘VISUAL’ or in the ‘EDITOR’
environment variable to view the recipe of GCC 4.9.3 and that of Vim.

   If you are using a Guix Git checkout (*note Construcción desde
Git::), or have created your own packages on ‘GUIX_PACKAGE_PATH’ (*note
Módulos de paquetes::), you will be able to edit the package recipes. In
other cases, you will be able to examine the read-only recipes for
packages currently in the store.

   Instead of ‘GUIX_PACKAGE_PATH’, the command-line option
‘--load-path=DIRECTORY’ (or in short ‘-L DIRECTORY’) allows you to add
DIRECTORY to the front of the package module search path and so make
your own packages visible.


File: guix.es.info,  Node: Invocación de guix download,  Next: Invocación de guix hash,  Prev: Invocación de guix edit,  Up: Utilidades

7.3 Invocación de ‘guix download’
=================================

Durante la escritura de una definición de paquete, las desarrolladoras
típicamente tienen que descargar un archivador tar de fuentes, calcular
su hash SHA256 y escribir ese hash en la definición del paquete (*note
Definición de paquetes::). La herramienta ‘guix download’ ayuda con esta
tarea: descarga un fichero de la URI proporcionada, lo añade al almacén
e imprime tanto su nombre de fichero en el almacén como su hash SHA256.

   El hecho de que el fichero descargado se añada al almacén ahorra
ancho de banda: cuando el desarrollador intenta construir el paquete
recién definido con ‘guix build’, el archivador de fuentes no tiene que
descargarse de nuevo porque ya está en el almacén. También es una forma
conveniente de conservar ficheros temporalmente, que pueden ser borrados
en un momento dado (*note Invocación de guix gc::).

   La orden ‘guix download’ acepta las mismas URI que las usadas en las
definiciones de paquetes. En particular, permite URI ‘mirror://’. Las
URI ‘https’ (HTTP sobre TLS) se aceptan _cuando_ el enlace Guile con
GnuTLS está disponible en el entorno de la usuaria; cuando no está
disponible se emite un error. *Note how to install the GnuTLS bindings
for Guile: (gnutls-guile)Guile Preparations, para más información.

   ‘guix download’ verifies HTTPS server certificates by loading the
certificates of X.509 authorities from the directory pointed to by the
‘SSL_CERT_DIR’ environment variable (*note Certificados X.509::), unless
‘--no-check-certificate’ is used.

   Las siguientes opciones están disponibles:

‘--hash=ALGORITHM’
‘-H ALGORITHM’
     Compute a hash using the specified ALGORITHM. *Note Invocación de
     guix hash::, for more information.

‘--format=FMT’
‘-f FMT’
     Escribe el hash en el formato especificado por FMT. Para más
     información sobre los valores aceptados en FMT, *note Invocación de
     guix hash::.

‘--no-check-certificate’
     No valida los certificados X.509 de los servidores HTTPS.

     Cuando se usa esta opción, no tiene _absolutamente ninguna
     garantía_ de que está comunicando con el servidor responsable de la
     URL auténtico, lo que le hace vulnerables a ataques de
     interceptación (“man-in-the-middle”).

‘--output=FICHERO’
‘-o FICHERO’
     Almacena el fichero descargado en FICHERO en vez de añadirlo al
     almacén.


File: guix.es.info,  Node: Invocación de guix hash,  Next: Invocación de guix import,  Prev: Invocación de guix download,  Up: Utilidades

7.4 Invocación de ‘guix hash’
=============================

La orden ‘guix hash’ calcula el hash SHA256 de un fichero. Es
principalmente una conveniente herramienta para cualquiera que
contribuya a la distribución: calcula el hash criptográfico de un
fichero, que puede usarse en la definición de un paquete (*note
Definición de paquetes::).

   La sintaxis general es:

     guix hash OPCIONES FICHERO

   Cuando FICHERO es ‘-’ (un guión), ‘guix hash’ calcula el hash de los
datos leídos por la entrada estándar. ‘guix hash’ tiene las siguientes
opciones:

‘--hash=ALGORITHM’
‘-H ALGORITHM’
     Compute a hash using the specified ALGORITHM, ‘sha256’ by default.

     ALGORITHM must the name of a cryptographic hash algorithm supported
     by Libgcrypt via Guile-Gcrypt—e.g., ‘sha512’ or ‘sha3-256’ (*note
     (guile-gcrypt)Hash Functions::).

‘--format=FMT’
‘-f FMT’
     Escribe el hash en el formato especificado por FMT.

     Supported formats: ‘base64’, ‘nix-base32’, ‘base32’, ‘base16’
     (‘hex’ and ‘hexadecimal’ can be used as well).

     Si no se especifica la opción ‘--format’, ‘guix hash’ mostrará el
     hash en ‘nix-base32’. Esta representación es la usada en las
     definiciones de paquetes.

‘--recursive’
‘-r’
     Calcula el hash de FICHERO recursivamente.

     Es este caso el hash se calcula en un archivador que contiene
     FICHERO, incluyendo su contenido si es un directorio. Algunos de
     los metadatos de FICHERO son parte del archivador; por ejemplo,
     cuando FICHERO es un fichero normal, el hash es diferente
     dependiendo de si FICHERO es ejecutable o no. Los metadatos como
     las marcas de tiempo no influyen en el hash (*note Invocación de
     guix archive::).

‘--exclude-vcs’
‘-x’
     When combined with ‘--recursive’, exclude version control system
     directories (‘.bzr’, ‘.git’, ‘.hg’, etc.).

     Como un ejemplo, así es como calcularía el hash de una copia de
     trabajo Git, lo cual es útil cuando se usa el método ‘git-fetch’
     (*note Referencia de origin::):

          $ git clone http://example.org/foo.git
          $ cd foo
          $ guix hash -rx .


File: guix.es.info,  Node: Invocación de guix import,  Next: Invocación de guix refresh,  Prev: Invocación de guix hash,  Up: Utilidades

7.5 Invocación de ‘guix import’
===============================

La orden ‘guix import’ es útil para quienes desean añadir un paquete a
la distribución con el menor trabajo posible—una demanda legítima. La
orden conoce algunos repositorios de los que puede “importar” metadatos
de paquetes. El resultado es una definición de paquete, o una plantilla
de ella, en el formato que conocemos (*note Definición de paquetes::).

   La sintaxis general es:

     guix import IMPORTADOR OPCIONES...

   IMPORTADOR especifica la fuente de la que se importan los metadatos
del paquete, OPCIONES especifica un identificador de paquete y otras
opciones específicas del IMPORTADOR.

   Algunos de los importadores dependen de poder ejecutar la orden
‘gpgv’. Para ello, GnuPG debe estar instalado y en ‘$PATH’; ejecute
‘guix install gnupg’ si es necesario.

   Actualmente los “importadores” disponibles son:

‘gnu’
     Importa los metadatos del paquete GNU seleccionado. Proporciona una
     plantilla para la última versión de dicho paquete GNU, incluyendo
     el hash de su archivador tar de fuentes, y su sinopsis y
     descripción canónica.

     Información adicional como las dependencias del paquete y su
     licencia deben ser deducidas manualmente.

     Por ejemplo, la siguiente orden devuelve una definición de paquete
     para GNU Hello.

          guix import gnu hello

     Las opciones específicas de línea de ordenes son:

     ‘--key-download=POLÍTICA’
          As for ‘guix refresh’, specify the policy to handle missing
          OpenPGP keys when verifying the package signature. *Note
          ‘--key-download’: Invocación de guix refresh.

‘pypi’
     Importa metadatos desde el índice de paquetes Python (PyPI)
     (https://pypi.python.org/). La información se toma de la
     descripción con formato JSON disponible en ‘pypi.python.org’ y
     habitualmente incluye toda la información relevante, incluyendo las
     dependencias del paquete. Para una máxima eficiencia, se recomienda
     la instalación de la utilidad ‘unzip’, de manera que el importador
     pueda extraer los archivos wheel de Python y obtener datos de
     ellos.

     La siguiente orden importa los metadatos para el paquete de Python
     ‘itsdangerous’:

          guix import pypi itsdangerous

     ‘--recursive’
     ‘-r’
          Recorre el grafo de dependencias del paquete original
          proporcionado recursivamente y genera expresiones de paquete
          para todos aquellos paquetes que no estén todavía en Guix.

‘gem’
     Importa metadatos desde RubyGems (https://rubygems.org/). La
     información se extrae de la descripción en formato JSON disponible
     en ‘rubygems.org’ e incluye la información más relevante,
     incluyendo las dependencias en tiempo de ejecución. Hay algunos
     puntos a tener en cuenta, no obstante. Los metadatos no distinguen
     entre sinopsis y descripción, por lo que se usa la misma cadena
     para ambos campos. Adicionalmente, los detalles de las dependencias
     no-Ruby necesarias para construir extensiones nativas no está
     disponible y se deja como ejercicio a la empaquetadora.

     La siguiente orden importa los meta-datos para el paquete de Ruby
     ‘rails’:

          guix import gem rails

     ‘--recursive’
     ‘-r’
          Recorre el grafo de dependencias del paquete original
          proporcionado recursivamente y genera expresiones de paquete
          para todos aquellos paquetes que no estén todavía en Guix.

‘cpan’
     Importa metadatos desde MetaCPAN (https://www.metacpan.org/). La
     información se extrae de la descripción en formato JSON disponible
     a través del API de MetaCPAN (https://fastapi.metacpan.org/) e
     incluye la información más relevante, como las dependencias de
     otros módulos. La información de la licencia debe ser comprobada
     atentamente. Si Perl está disponible en el almacén, se usará la
     utilidad ‘corelist’ para borrar los módulos básicos de la lista de
     dependencias.

     The command command below imports metadata for the Acme::Boolean
     Perl module:

          guix import cpan Acme::Boolean

‘cran’
     Importa metadatos desde CRAN (https://cran.r-project.org/), el
     repositorio central para el entorno estadístico y gráfico GNU R
     (https://r-project.org).

     Information is extracted from the ‘DESCRIPTION’ file of the
     package.

     The command command below imports metadata for the Cairo R package:

          guix import cran Cairo

     When ‘--recursive’ is added, the importer will traverse the
     dependency graph of the given upstream package recursively and
     generate package expressions for all those packages that are not
     yet in Guix.

     When ‘--archive=bioconductor’ is added, metadata is imported from
     Bioconductor (https://www.bioconductor.org/), a repository of R
     packages for for the analysis and comprehension of high-throughput
     genomic data in bioinformatics.

     Information is extracted from the ‘DESCRIPTION’ file contained in
     the package archive.

     The command below imports metadata for the GenomicRanges R package:

          guix import cran --archive=bioconductor GenomicRanges

     Finally, you can also import R packages that have not yet been
     published on CRAN or Bioconductor as long as they are in a git
     repository. Use ‘--archive=git’ followed by the URL of the git
     repository:

          guix import cran --archive=git https://github.com/immunogenomics/harmony

‘texlive’
     Importa metadatos desde CTAN (https://www.ctan.org/), la completa
     red de archivos TeX para paquetes TeX que son parte de la
     distribución TeX Live (https://www.tug.org/texlive/).

     La información del paquete se obtiene a través del API XML
     proporcionado por CTAN, mientras que el código fuente se descarga
     del repositorio SVN del proyecto TeX Live. Se hace porque CTAN no
     guarda archivos con versiones.

     La siguiente orden importa los metadatos del paquete de TeX
     ‘fontspec’:

          guix import texlive fontspec

     When ‘--archive=DIRECTORY’ is added, the source code is downloaded
     not from the ‘latex’ sub-directory of the ‘texmf-dist/source’ tree
     in the TeX Live SVN repository, but from the specified sibling
     DIRECTORY under the same root.

     La siguiente orden importa los metadatos del paquete ‘ifxetex’ de
     CTAN mientras que obtiene las fuentes del directorio
     ‘texmf/source/generic’:

          guix import texlive --archive=generic ifxetex

‘json’
     Importa metadatos de paquetes desde un fichero JSON local.
     Considere el siguiente ejemplo de definición de paquete en formato
     JSON:

          {
            "name": "hello",
            "version": "2.10",
            "source": "mirror://gnu/hello/hello-2.10.tar.gz",
            "build-system": "gnu",
            "home-page": "https://www.gnu.org/software/hello/",
            "synopsis": "Hello, GNU world: An example GNU package",
            "description": "GNU Hello prints a greeting.",
            "license": "GPL-3.0+",
            "native-inputs": ["gettext"]
          }

     Los nombres de los campos son los mismos que para el registro
     ‘<package>’ (*Note Definición de paquetes::). Las referencias a
     otros paquetes se proporcionan como listas JSON de cadenas de
     especificación de paquete entrecomilladas como ‘guile’ o
     ‘guile@2.0’.

     El importador también permite una definición de fuentes más
     explícita usando los campos comunes de los registros ‘<origin>’:

          {
            ...
            "source": {
              "method": "url-fetch",
              "uri": "mirror://gnu/hello/hello-2.10.tar.gz",
              "sha256": {
                "base32": "0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i"
              }
            }
            ...
          }

     La siguiente orden importa los metadatos desde el fichero JSON
     ‘hello.json’ y devuelve una expresión de “package”:

          guix import json hello.json

‘nix’
     Importa metadatos desde una copia local de las fuentes de la
     distribución Nixpkgs (https://nixos.org/nixpkgs/)(1). Las
     definiciones de paquete en Nixpkgs típicamente están escritas en
     una mezcla de lenguaje Nix y código Bash. Esta orden únicamente
     importa la estructura de alto nivel del paquete escrita en lenguaje
     Nix. Normalmente incluye todos los campos básicos de una definición
     de paquete.

     Cuando se importa un paquete GNU, la sinopsis y la descripción se
     substituyen por la variante canónica oficial.

     Habitualmente, tendrá que ejecutar primero:

          export NIX_REMOTE=daemon

     de modo que ‘nix-instantiate’ no intente abrir la base de datos
     Nix.

     Como un ejemplo, la orden siguiente importa la definición de
     paquete de LibreOffice (más precisamente, importa la definición del
     paquete asociado al atributo de nivel superior ‘libreoffice’):

          guix import nix ~/path/to/nixpkgs libreoffice

‘hackage’
     Importa metadatos desde el archivo central de paquetes de la
     comunidad Haskell Hackage (https://hackage.haskell.org/). La
     información se obtiene de ficheros Cabal e incluye toda la
     información relevante, incluyendo las dependencias del paquete.

     Las opciones específicas de línea de ordenes son:

     ‘--stdin’
     ‘-s’
          Lee un fichero Cabal por la entrada estándar.
     ‘--no-test-dependencies’
     ‘-t’
          No incluye las dependencias necesarias únicamente para las
          baterías de pruebas.
     ‘--cabal-environment=ALIST’
     ‘-e ALIST’
          ALIST es una lista asociativa Scheme que define el entorno en
          el que los condicionales Cabal se evalúan. Los valores
          aceptados son: ‘os’, ‘arch’, ‘impl’ y una cadena que
          representa el nombre de la condición. El valor asociado a la
          condición tiene que ser o bien el símbolo ‘true’ o bien
          ‘false’. Los valores predeterminados asociados a las claves
          ‘os’, ‘arch’ y ‘impl’ son ‘linux’, ‘x86_64’ y ‘ghc’,
          respectivamente.
     ‘--recursive’
     ‘-r’
          Recorre el grafo de dependencias del paquete original
          proporcionado recursivamente y genera expresiones de paquete
          para todos aquellos paquetes que no estén todavía en Guix.

     The command below imports metadata for the latest version of the
     HTTP Haskell package without including test dependencies and
     specifying the value of the flag ‘network-uri’ as ‘false’:

          guix import hackage -t -e "'((\"network-uri\" . false))" HTTP

     Se puede especificar opcionalmente una versión específica del
     paquete añadiendo al nombre del paquete una arroba y el número de
     versión como en el siguiente ejemplo:

          guix import hackage mtl@2.1.3.1

‘stackage’
     El importador ‘stackage’ es un recubrimiento sobre el de ‘hackage’.
     Toma un nombre de paquete, busca la versión de paquete incluida en
     una publicación de la versión de mantenimiento extendido (LTS)
     Stackage (https://www.stackage.org) y usa el importador ‘hackage’
     para obtener sus metadatos. Fíjese que es su decisión seleccionar
     una publicación LTS compatible con el compilador GHC usado en Guix.

     Las opciones específicas de línea de ordenes son:

     ‘--no-test-dependencies’
     ‘-t’
          No incluye las dependencias necesarias únicamente para las
          baterías de pruebas.
     ‘--lts-version=VERSIÓN’
     ‘-l VERSIÓN’
          VERSIÓN es la versión LTS de publicación deseada. Si se omite
          se usa la última publicación.
     ‘--recursive’
     ‘-r’
          Recorre el grafo de dependencias del paquete original
          proporcionado recursivamente y genera expresiones de paquete
          para todos aquellos paquetes que no estén todavía en Guix.

     The command below imports metadata for the HTTP Haskell package
     included in the LTS Stackage release version 7.18:

          guix import stackage --lts-version=7.18 HTTP

‘elpa’
     Importa metadatos desde el repositorio de archivos de paquetes
     Emacs Lisp (ELPA) (*note (emacs)Packages::).

     Las opciones específicas de línea de ordenes son:

     ‘--archive=REPO’
     ‘-a REPO’
          REPO identifica el repositorio de archivos del que obtener la
          información. Actualmente los repositorios disponibles y sus
          identificadores son:
             - GNU (https://elpa.gnu.org/packages), seleccionado con el
               identificador ‘gnu’. Utilizado de manera predeterminada.

               Los paquetes de ‘elpa.gnu.org’ están firmados con una de
               las claves que contiene el anillo de claves GnuPG en
               ‘share/emacs/25.1/etc/package-keyring.gpg’ (o similar) en
               el paquete ‘emacs’ (*note ELPA package signatures:
               (emacs)Package Installation.).

             - MELPA-Stable (https://stable.melpa.org/packages),
               seleccionado con el identificador ‘melpa-stable’.

             - MELPA (https://melpa.org/packages), seleccionado con el
               identificador ‘melpa’.

     ‘--recursive’
     ‘-r’
          Recorre el grafo de dependencias del paquete original
          proporcionado recursivamente y genera expresiones de paquete
          para todos aquellos paquetes que no estén todavía en Guix.

‘crate’
     Importa metadatos desde el repositorio de paquetes Rust crates.io
     (https://crates.io), como en este ejemplo:

          guix import crate blake2-rfc

     El importador de crate también le permite especificar una cadena de
     versión:

          guix import crate constant-time-eq@0.1.0

     La opciones adicionales incluyen:

     ‘--recursive’
     ‘-r’
          Recorre el grafo de dependencias del paquete original
          proporcionado recursivamente y genera expresiones de paquete
          para todos aquellos paquetes que no estén todavía en Guix.

‘opam’
     Importa metadatos desde el repositorio de paquetes OPAM
     (https://opam.ocaml.org/) usado por la comunidad OCaml.

   La estructura del código de ‘guix import’ es modular. Sería útil
tener más importadores para otros formatos de paquetes, y su ayuda es
bienvenida aquí (*note Contribuir::).

   ---------- Footnotes ----------

   (1) Esto depende de la orden ‘nix-instantiate’ de Nix
(https://nixos.org/nix/).


File: guix.es.info,  Node: Invocación de guix refresh,  Next: Invocación de guix lint,  Prev: Invocación de guix import,  Up: Utilidades

7.6 Invocación de ‘guix refresh’
================================

La principal audiencia de ‘guix refresh’ son desarrolladoras de la
distribución de software GNU. Por defecto, informa de cualquier paquete
proporcionado por la distribución que esté anticuado comparado con la
última versión oficial, de esta manera:

     $ guix refresh
     gnu/packages/gettext.scm:29:13: gettext would be upgraded from 0.18.1.1 to 0.18.2.1
     gnu/packages/glib.scm:77:12: glib would be upgraded from 2.34.3 to 2.37.0

   Alternatively, one can specify packages to consider, in which case a
warning is emitted for packages that lack an updater:

     $ guix refresh coreutils guile guile-ssh
     gnu/packages/ssh.scm:205:2: warning: no updater for guile-ssh
     gnu/packages/guile.scm:136:12: guile would be upgraded from 2.0.12 to 2.0.13

   ‘guix refresh’ navega por los repositorios oficiales de cada paquete
y determina el número de versión mayor entre las publicaciones
encontradas. La orden sabe cómo actualizar tipos específicos de
paquetes: paquetes GNU, paquetes ELPA, etc.—vea la documentación de
‘--type’ más adelante. Hay muchos paquetes, no obstante, para los que
carece de un método para determinar si está disponible una versión
oficial posterior. No obstante, el mecanismo es extensible, ¡no tenga
problema en contactar con nosotras para añadir un método nuevo!

‘--recursive’
     Considera los paquetes especificados, y todos los paquetes de los
     que dependen.

          $ guix refresh --recursive coreutils
          gnu/packages/acl.scm:35:2: warning: no updater for acl
          gnu/packages/m4.scm:30:12: info: 1.4.18 is already the latest version of m4
          gnu/packages/xml.scm:68:2: warning: no updater for expat
          gnu/packages/multiprecision.scm:40:12: info: 6.1.2 is already the latest version of gmp
          ...

   A veces el nombre oficial es diferente al nombre de paquete usado en
Guix, y ‘guix refresh’ necesita un poco de ayuda. La mayor parte de los
actualizadores utilizan la propiedad ‘upstream-name’ en las definiciones
de paquetes, que puede usarse para obtener dicho efecto:

     (define-public network-manager
       (package
         (name "network-manager")
         ;; ...
         (properties '((upstream-name . "NetworkManager")))))

   When passed ‘--update’, it modifies distribution source files to
update the version numbers and source tarball hashes of those package
recipes (*note Definición de paquetes::). This is achieved by
downloading each package’s latest source tarball and its associated
OpenPGP signature, authenticating the downloaded tarball against its
signature using ‘gpgv’, and finally computing its hash—note that GnuPG
must be installed and in ‘$PATH’; run ‘guix install gnupg’ if needed.

   Cuando la clave pública usada para firmar el archivador no se
encuentra en el anillo de claves de la usuaria, se intenta
automáticamente su obtención desde un servidor de claves públicas;
cuando se encuentra, la clave se añade al anillo de claves de la
usuaria; en otro caso, ‘guix refresh’ informa de un error.

   Se aceptan las siguientes opciones:

‘--expression=EXPR’
‘-e EXPR’
     Considera el paquete al que evalúa EXPR

     Es útil para hacer una referencia precisa de un paquete concreto,
     como en este ejemplo:

          guix refresh -l -e '(@@ (gnu packages commencement) glibc-final)'

     This command lists the dependents of the “final” libc (essentially
     all the packages).

‘--update’
‘-u’
     Actualiza los ficheros fuente de la distribución (recetas de
     paquetes) en su lugar. Esto se ejecuta habitualmente desde una
     copia de trabajo del árbol de fuentes de Guix (*note Ejecución de
     Guix antes de estar instalado::):

          $ ./pre-inst-env guix refresh -s non-core -u

     *Note Definición de paquetes::, para más información sobre la
     definición de paquetes.

‘--select=[SUBCONJUNTO]’
‘-s SUBCONJUNTO’
     Selecciona todos los paquetes en SUBCONJUNTO, o bien ‘core’ o bien
     ‘non-core’.

     El subconjunto ‘core’ hace referencia a todos los paquetes en el
     núcleo de la distribución—es decir, paquetes que se usan para
     construir “todo lo demás”. Esto incluye GCC, libc, Binutils, Bash,
     etc. Habitualmente, cambiar uno de esos paquetes en la distribución
     conlleva la reconstrucción de todos los demás. Por tanto, esas
     actualizaciones son una inconveniencia para las usuarias en
     términos de tiempo de construcción o ancho de banda usado por la
     actualización.

     El subconjunto ‘non-core’ hace referencia a los paquetes restantes.
     Es típicamente útil en casos donde una actualización de paquetes
     básicos no sería conveniente.

‘--manifest=FICHERO’
‘-m FICHERO’
     Selecciona todos los paquetes del manifiesto en FICHERO. Es útil
     para comprobar si algún paquete del manifiesto puede actualizarse.

‘--type=ACTUALIZADOR’
‘-t ACTUALIZADOR’
     Selecciona únicamente paquetes manejados por ACTUALIZADOR (puede
     ser una lista separada por comas de actualizadores). Actualmente,
     ACTUALIZADOR puede ser:

     ‘gnu’
          el actualizador de paquetes GNU;
     ‘gnome’
          el actualizador para paquetes GNOME;
     ‘kde’
          el actualizador para paquetes KDE;
     ‘xorg’
          el actualizador para paquetes X.org;
     ‘kernel.org’
          el actualizador para paquetes alojados en kernel.org;
     ‘elpa’
          el actualizador para paquetes ELPA (https://elpa.gnu.org/);
     ‘cran’
          el actualizador para paquetes CRAN
          (https://cran.r-project.org/);
     ‘bioconductor’
          el actualizador para paquetes R Bioconductor
          (https://www.bioconductor.org/);
     ‘cpan’
          el actualizador para paquetes CPAN (https://www.cpan.org/);
     ‘pypi’
          el actualizador para paquetes PyPI (https://pypi.python.org).
     ‘gem’
          el actualizador para paquetes RubyGems (https://rubygems.org).
     ‘github’
          el actualizador para paquetes GitHub (https://github.com).
     ‘hackage’
          el actualizador para paquetes Hackage
          (https://hackage.haskell.org).
     ‘stackage’
          el actualizador para paquetes Stackage
          (https://www.stackage.org).
     ‘crate’
          el actualizador para paquetes Crates (https://crates.io).
     ‘launchpad’
          el actualizador para paquetes Launchpad
          (https://launchpad.net).

     Por ejemplo, la siguiente orden únicamente comprueba
     actualizaciones de paquetes Emacs alojados en ‘elpa.gnu.org’ y
     actualizaciones de paquetes CRAN:

          $ guix refresh --type=elpa,cran
          gnu/packages/statistics.scm:819:13: r-testthat would be upgraded from 0.10.0 to 0.11.0
          gnu/packages/emacs.scm:856:13: emacs-auctex would be upgraded from 11.88.6 to 11.88.9

   Además, ‘guix refresh’ puede recibir uno o más nombres de paquetes,
como en este ejemplo:

     $ ./pre-inst-env guix refresh -u emacs idutils gcc@4.8

The command above specifically updates the ‘emacs’ and ‘idutils’
packages. The ‘--select’ option would have no effect in this case.

   Cuando se considera la actualización de un paquete, a veces es
conveniente conocer cuantos paquetes se verían afectados por la
actualización y su compatibilidad debería comprobarse. Para ello la
siguiente opción puede usarse cuando se proporcionan uno o más nombres
de paquete a ‘guix refresh’:

‘--list-updaters’
‘-L’
     List available updaters and exit (see ‘--type’ above).

     Para cada actualizador, muestra la fracción de paquetes que cubre;
     al final muestra la fracción de paquetes cubiertos por todos estos
     actualizadores.

‘--list-dependent’
‘-l’
     Enumera los paquetes de nivel superior dependientes que
     necesitarían una reconstrucción como resultado de la actualización
     de uno o más paquetes.

     *Note el tipo ‘reverse-package’ de ‘guix graph’: Invocación de guix
     graph, para información sobre cómo visualizar la lista de paquetes
     que dependen de un paquete.

   Be aware that the ‘--list-dependent’ option only _approximates_ the
rebuilds that would be required as a result of an upgrade. More rebuilds
might be required under some circumstances.

     $ guix refresh --list-dependent flex
     Building the following 120 packages would ensure 213 dependent packages are rebuilt:
     hop@2.4.0 geiser@0.4 notmuch@0.18 mu@0.9.9.5 cflow@1.4 idutils@4.6 ...

   La orden previa enumera un conjunto de paquetes que puede ser
construido para comprobar la compatibilidad con una versión actualizada
del paquete ‘flex’.

‘--list-transitive’
     Enumera todos los paquetes de los que uno o más paquetes dependen.

          $ guix refresh --list-transitive flex
          flex@2.6.4 depends on the following 25 packages: perl@5.28.0 help2man@1.47.6
          bison@3.0.5 indent@2.2.10 tar@1.30 gzip@1.9 bzip2@1.0.6 xz@5.2.4 file@5.33 ...

   La orden previa enumera un conjunto de paquetes que, en caso de
cambiar, causarían la reconstrucción de ‘flex’.

   Las siguientes opciones pueden usarse para personalizar la operación
de GnuPG:

‘--gpg=ORDEN’
     Use ORDEN como la orden de GnuPG 2.x. Se busca ORDEN en ‘PATH’.

‘--keyring=FICHERO’
     Usa FICHERO como el anillo de claves para claves de proveedoras.
     FICHERO debe estar en el “formato keybox”. Los ficheros Keybox
     normalmente tienen un nombre terminado en ‘.kbx’ y GNU Privacy
     Guard (GPG) puede manipular estos ficheros (*note ‘kbxutil’:
     (gnupg)kbxutil, para información sobre una herramienta para
     manipular ficheros keybox).

     When this option is omitted, ‘guix refresh’ uses
     ‘~/.config/guix/upstream/trustedkeys.kbx’ as the keyring for
     upstream signing keys. OpenPGP signatures are checked against keys
     from this keyring; missing keys are downloaded to this keyring as
     well (see ‘--key-download’ below).

     Puede exportar claves de su anillo de claves GPG predeterminado en
     un fichero keybox usando órdenes como esta:

          gpg --export rms@gnu.org | kbxutil --import-openpgp >> mianillo.kbx

     Del mismo modo, puede obtener claves de un archivo keybox
     específico así:

          gpg --no-default-keyring --keyring mianillo.kbx \
            --recv-keys 3CE464558A84FDC69DB40CFB090B11993D9AEBB5

     *note ‘--keyring’: (gnupg)GPG Configuration Options, para más
     información sobre la opción ‘--keyring’ de GPG.

‘--key-download=POLÍTICA’
     Maneja las claves no encontradas de acuerdo a la POLÍTICA, que
     puede ser una de:

     ‘always’
          Siempre descarga las claves OpenPGP no encontradas del
          servidor de claves, y las añade al anillo de claves GnuPG de
          la usuaria.

     ‘never’
          Nunca intenta descargar claves OpenPGP no encontradas.
          Simplemente propaga el error.

     ‘interactive’
          Cuando se encuentra un paquete firmado por una clave OpenPGP
          desconocida, pregunta a la usuaria si descargarla o no. Este
          es el comportamiento predeterminado.

‘--key-server=DIRECCIÓN’
     Use DIRECCIÓN como el servidor de claves OpenPGP cuando se importa
     una clave pública.

‘--load-path=DIRECTORIO’
     Añade DIRECTORIO al frente de la ruta de búsqueda de módulos de
     paquetes (*note Módulos de paquetes::).

     Esto permite a las usuarias definir sus propios paquetes y hacerlos
     visibles a las herramientas de línea de órdenes.

   The ‘github’ updater uses the GitHub API
(https://developer.github.com/v3/) to query for new releases. When used
repeatedly e.g. when refreshing all packages, GitHub will eventually
refuse to answer any further API requests. By default 60 API requests
per hour are allowed, and a full refresh on all GitHub packages in Guix
requires more than this. Authentication with GitHub through the use of
an API token alleviates these limits. To use an API token, set the
environment variable ‘GUIX_GITHUB_TOKEN’ to a token procured from
<https://github.com/settings/tokens> or otherwise.


File: guix.es.info,  Node: Invocación de guix lint,  Next: Invocación de guix size,  Prev: Invocación de guix refresh,  Up: Utilidades

7.7 Invocación de ‘guix lint’
=============================

The ‘guix lint’ command is meant to help package developers avoid common
errors and use a consistent style. It runs a number of checks on a given
set of packages in order to find common mistakes in their definitions.
Available “checkers” include (see ‘--list-checkers’ for a complete
list):

‘synopsis’
‘description’
     Valida ciertas reglas tipográficas y de estilo en la descripción y
     sinopsis de cada paquete.

‘inputs-should-be-native’
     Identifica entradas que probablemente deberían ser entradas
     nativas.

‘source’
‘home-page’
‘mirror-url’
‘github-url’
‘source-file-name’
     Comprueba las URL ‘home-page’ y ‘source’ e informa aquellas que no
     sean válidas. Sugiere una URL ‘mirror://’ cuando sea aplicable. Si
     la URL ‘source’ redirecciona a una URL GitHub, recomienda el uso de
     la URL GitHub. Comprueba que el nombre de fichero de las fuentes es
     significativo, por ejemplo que no es simplemente un número de
     versión o revisión git, sin un nombre ‘file-name’ declarado (*note
     Referencia de origin::).

‘source-unstable-tarball’
     Analiza la URL ‘source’ para determinar si un archivador tar de
     GitHub se genera de forma automática o es una publicación oficial.
     Desafortunadamente los archivadores tar de GitHub a veces se
     regeneran.

‘archival’
     Comprueba si el código fuente del paquete se encuentra archivado en
     Software Heritage (https://www.softwareheritage.org).

     Cuando el código fuente que no se encuentra archivado proviene de
     un sistema de control de versiones(1)—por ejemplo, se ha obtenido
     con ‘git-fetch’—, envía a Software Heritage una petición de
     almacenamiento de manera que se archive cuando sea posible. Esto
     asegura que las fuentes permanecen disponibles a largo plazo, y que
     Guix puede usar Software Heritage como respaldo en caso de que el
     código fuente desapareciese de la máquina que lo almacenaba
     originalmente. El estado de las peticiones de almacenamiento
     recientes puede verse en su página web
     (https://archive.softwareheritage.org/save/#requests).

     Cuando el código fuente es un fichero comprimido que se obtiene con
     ‘url-fetch’, simplemente imprime un mensaje cuando no se encuentra
     archivado. En el momento de la escritura de este documento,
     Software Heritage no permite el almacenamiento de ficheros
     comprimidos arbitrarios; estamos trabajando en formas de asegurar
     que también se archive el código que no se encuentra bajo control
     de versiones.

     Software Heritage limita la tasa de peticiones por dirección IP
     (https://archive.softwareheritage.org/api/#rate-limiting). Cuando
     se alcanza dicho límite, ‘guix lint’ imprime un mensaje y la
     comprobación ‘archival’ no hace nada hasta que dicho límite se
     reinicie.

‘cve’
     Informa de vulnerabilidades encontradas en las bases de datos de
     vulnerabilidades y exposiciones comunes (CVE) del año actual y el
     pasado publicadas por el NIST de EEUU
     (https://nvd.nist.gov/vuln/data-feeds).

     Para ver información acerca de una vulnerabilidad particular,
     visite páginas como:

        • 
          ‘https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-YYYY-ABCD’
        • ‘https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-YYYY-ABCD’

     donde ‘CVE-YYYY-ABCD’ es el identificador CVE—por ejemplo,
     ‘CVE-2015-7554’.

     Las desarrolladoras de paquetes pueden especificar en las recetas
     del paquete el nombre y versión en la plataforma común de
     enumeración (CPE) (https://nvd.nist.gov/cpe.cfm) del paquete cuando
     el nombre o versión que usa Guix son diferentes, como en este
     ejemplo:

          (package
            (name "grub")
            ;; ...
            ;; CPE llama a este paquete "grub2".
            (properties '((cpe-name . "grub2")
                          (cpe-version . "2.3"))))

     Algunas entradas en la base de datos CVE no especifican a qué
     versión del paquete hacen referencia, y por lo tanto “permanecen
     visibles” para siempre. Las desarrolladoras de paquetes que
     encuentren alertas CVE y verifiquen que pueden ignorarse, pueden
     declararlas como en este ejemplo:

          (package
            (name "t1lib")
            ;; ...
            ;; Estas alertas de CVE no aplican y pueden ignorarse
            ;; con seguridad.
            (properties `((lint-hidden-cve . ("CVE-2011-0433"
                                              "CVE-2011-1553"
                                              "CVE-2011-1554"
                                              "CVE-2011-5244")))))

‘formatting’
     Avisa de problemas de formato obvios en el código fuente: espacios
     en blanco al final de las líneas, uso de tabuladores, etc.

   La sintaxis general es:

     guix lint OPCIONES PAQUETE...

   Si no se proporciona ningún paquete en la linea de órdenes, todos los
paquetes se comprueban. Las OPCIONES pueden ser cero o más de las
siguientes:

‘--list-checkers’
‘-l’
     Enumera y describe todas las comprobaciones disponibles que se
     ejecutarán sobre los paquetes y finaliza.

‘--checkers’
‘-c’
     Only enable the checkers specified in a comma-separated list using
     the names returned by ‘--list-checkers’.

‘--load-path=DIRECTORIO’
‘-L DIRECTORIO’
     Añade DIRECTORIO al frente de la ruta de búsqueda de módulos de
     paquetes (*note Módulos de paquetes::).

     Esto permite a las usuarias definir sus propios paquetes y hacerlos
     visibles a las herramientas de línea de órdenes.

   ---------- Footnotes ----------

   (1) VCS en inglés


File: guix.es.info,  Node: Invocación de guix size,  Next: Invocación de guix graph,  Prev: Invocación de guix lint,  Up: Utilidades

7.8 Invocación de ‘guix size’
=============================

La orden ‘guix size’ ayuda a las desarrolladoras de paquetes a perfilar
el uso de disco de los paquetes. Es fácil pasar por encima el impacto
que produce añadir una dependencia adicional a un paquete, o el impacto
del uso de una salida única para un paquete que puede ser dividido
fácilmente (*note Paquetes con múltiples salidas::). Estos son los
problemas típicos que ‘guix size’ puede resaltar.

   Se le pueden proporcionar una o más especificaciones de paquete como
‘gcc@4.8’ o ‘guile:debug’, o un nombre de fichero en el almacén.
Considere este ejemplo:

     $ guix size coreutils
     store item                               total    self
     /gnu/store/...-gcc-5.5.0-lib           60.4    30.1  38.1%
     /gnu/store/...-glibc-2.27              30.3    28.8  36.6%
     /gnu/store/...-coreutils-8.28          78.9    15.0  19.0%
     /gnu/store/...-gmp-6.1.2               63.1     2.7   3.4%
     /gnu/store/...-bash-static-4.4.12       1.5     1.5   1.9%
     /gnu/store/...-acl-2.2.52              61.1     0.4   0.5%
     /gnu/store/...-attr-2.4.47             60.6     0.2   0.3%
     /gnu/store/...-libcap-2.25             60.5     0.2   0.2%
     total: 78.9 MiB

   Los elementos del almacén enumerados aquí constituyen la “clausura
transitiva” de Coreutils—es decir, Coreutils y todas sus dependencias,
recursivamente—como sería devuelto por:

     $ guix gc -R /gnu/store/...-coreutils-8.23

   Aquí la salida muestra tres columnas junto a los elementos del
almacén. La primera columna, etiquetada “total”, muestra el tamaño en
mebibytes (MiB) de la clausura del elemento del almacén—es decir, su
propio tamaño sumado al tamaño de todas sus dependencias. La siguiente
columna, etiquetada “self”, muestra el tamaño del elemento en sí. La
última columna muestra la relación entre el tamaño del elemento en sí
frente al espacio ocupado por todos los elementos enumerados.

   En este ejemplo, vemos que la clausura de Coreutils ocupa 79 MiB,
cuya mayor parte son libc y las bibliotecas auxiliares de GCC para
tiempo de ejecución. (Que libc y las bibliotecas de GCC representen una
fracción grande de la clausura no es un problema en sí, puesto que
siempre están disponibles en el sistema de todas maneras).

   Cuando los paquetes pasados a ‘guix size’ están disponibles en el
almacén(1) consultando al daemon para determinar sus dependencias, y
mide su tamaño en el almacén, de forma similar a ‘du -ms
--apparent-size’ (*note (coreutils)du invocation::).

   Cuando los paquetes proporcionados _no_ están en el almacén, ‘guix
size’ informa en base de las sustituciones disponibles (*note
Sustituciones::). Esto hace posible perfilar el espacio en disco incluso
de elementos del almacén que no están en el disco, únicamente
disponibles de forma remota.

   Puede especificar también varios nombres de paquetes:

     $ guix size coreutils grep sed bash
     store item                               total    self
     /gnu/store/...-coreutils-8.24          77.8    13.8  13.4%
     /gnu/store/...-grep-2.22               73.1     0.8   0.8%
     /gnu/store/...-bash-4.3.42             72.3     4.7   4.6%
     /gnu/store/...-readline-6.3            67.6     1.2   1.2%
     ...
     total: 102.3 MiB

En este ejemplo vemos que la combinación de los cuatro paquetes toma
102.3 MiB en total, lo cual es mucho menos que la suma de cada clausura,
ya que tienen muchas dependencias en común.

   When looking at the profile returned by ‘guix size’, you may find
yourself wondering why a given package shows up in the profile at all.
To understand it, you can use ‘guix graph --path -t references’ to
display the shortest path between the two packages (*note Invocación de
guix graph::).

   Las opciones disponibles son:

‘--substitute-urls=URLS’
     Usa la información de sustituciones de URLS. *Note la misma opción
     en ‘guix build’: client-substitute-urls.

‘--sort=CLAVE’
     Ordena las líneas de acuerdo a CLAVE, una de las siguientes
     opciones:

     ‘self’
          el tamaño de cada elemento (predeterminada);
     ‘clausura’
          el tamaño total de la clausura del elemento.

‘--map-file=FICHERO’
     Escribe un mapa gráfico del uso del disco en formato PNG en el
     FICHERO.

     Para el ejemplo previo, el mapa tiene esta pinta:

 [image src="images/coreutils-size-map.png" alt="mapa del uso del disco de Coreutils
producido por guix size" ]

     Esta opción necesita que la biblioteca Guile-Charting
     (https://wingolog.org/software/guile-charting/) esté instalada y
     visible en la ruta de búsqueda de módulos Guile. Cuando no es el
     caso, ‘guix size’ produce un error al intentar cargarla.

‘--system=SISTEMA’
‘-s SISTEMA’
     Considera paquetes para SISTEMA—por ejemplo, ‘x86_64-linux’.

‘--load-path=DIRECTORIO’
‘-L DIRECTORIO’
     Añade DIRECTORIO al frente de la ruta de búsqueda de módulos de
     paquetes (*note Módulos de paquetes::).

     Esto permite a las usuarias definir sus propios paquetes y hacerlos
     visibles a las herramientas de línea de órdenes.

   ---------- Footnotes ----------

   (1) Más precisamente, ‘guix size’ busca la variante _sin injertos_ de
los paquetes, como el devuelto por ‘guix build PAQUETE --no-grafts’.
*Note Actualizaciones de seguridad::, para información sobre injertos.


File: guix.es.info,  Node: Invocación de guix graph,  Next: Invocación de guix publish,  Prev: Invocación de guix size,  Up: Utilidades

7.9 Invocación de ‘guix graph’
==============================

Packages and their dependencies form a “graph”, specifically a directed
acyclic graph (DAG). It can quickly become difficult to have a mental
model of the package DAG, so the ‘guix graph’ command provides a visual
representation of the DAG. By default, ‘guix graph’ emits a DAG
representation in the input format of Graphviz
(https://www.graphviz.org/), so its output can be passed directly to the
‘dot’ command of Graphviz. It can also emit an HTML page with embedded
JavaScript code to display a “chord diagram” in a Web browser, using the
d3.js (https://d3js.org/) library, or emit Cypher queries to construct a
graph in a graph database supporting the openCypher
(https://www.opencypher.org/) query language. With ‘--path’, it simply
displays the shortest path between two packages. The general syntax is:

     guix graph OPCIONES PAQUETE...

   Por ejemplo, la siguiente orden genera un fichero PDF que representa
el GAD para GNU Core Utilities, mostrando sus dependencias en tiempo de
construcción:

     guix graph coreutils | dot -Tpdf > gad.pdf

   La salida es algo así:

[Grafo de dependencias de GNU Coreutils]
   Bonito y pequeño grafo, ¿no?

   You may find it more pleasant to navigate the graph interactively
with ‘xdot’ (from the ‘xdot’ package):

     guix graph coreutils | xdot -

   ¡Pero hay más de un grafo! El grafo previo es conciso: es el grafo de
los objetos package, omitiendo las entradas implícitas como GCC, libc,
grep, etc. Es habitualmente útil tener un grafo conciso así, pero a
veces una puede querer ver más detalles. ‘guix graph’ implementa varios
tipos de grafos, lo que le permite seleccionar el nivel de detalle:

‘package’
     Este es el tipo por defecto usado en el ejemplo previo. Muestra el
     GAD de objetos package, excluyendo dependencias implícitas. Es
     conciso, pero deja fuera muchos detalles.

‘reverse-package’
     Esto muestra el GAD _inverso_ de paquetes. Por ejemplo:

          guix graph --type=reverse-package ocaml

     ... yields the graph of packages that _explicitly_ depend on OCaml
     (if you are also interested in cases where OCaml is an implicit
     dependency, see ‘reverse-bag’ below).

     Fíjese que esto puede producir grafos inmensos para los paquetes
     básicos. Si todo lo que quiere saber es el número de paquetes que
     dependen de uno determinado, use ‘guix refresh --list-dependent’
     (*note ‘--list-dependent’: Invocación de guix refresh.).

‘bag-emerged’
     Este es el GAD del paquete, _incluyendo_ entradas implícitas.

     Por ejemplo, la siguiente orden:

          guix graph --type=bag-emerged coreutils

     ... emite este grafo más grande:

[Grafo de dependencias detallado de
GNU Coreutils]
     En la parte inferior del grafo, vemos todas las entradas implícitas
     de GNU-BUILD-SYSTEM (*note ‘gnu-build-system’: Sistemas de
     construcción.).

     Ahora bien, fíjese que las dependencias de estas entradas
     implícitas—es decir, las “dependencias del lanzamiento inicial”
     (*note Lanzamiento inicial::)—no se muestran aquí para mantener una
     salida concisa.

‘bag’
     Similar a ‘bag-emerged’, pero esta vez incluye todas las
     dependencias del lanzamiento inicial.

‘bag-with-origins’
     Similar a ‘bag’, pero también muestra los orígenes y sus
     dependencias.

‘reverse-bag’
     Muestra el GAD _inverso_ de paquetes. Al contrario que
     ‘reverse-package’, también tiene en cuenta las dependencias
     implícitas. Por ejemplo:

          guix graph -t reverse-bag dune

     ... emite el grafo de tosos los paquetes que dependen de Dune,
     directa o indirectamente. Ya que Dune es una dependencia
     _implícita_ de muchos paquetes vía ‘dune-build-system’, esto
     mostrará un gran número de paquetes, mientras que ‘reverse-package’
     mostraría muy pocos si muestra alguno.

‘derivación’
     Esta es la representación más detallada: muestra el GAD de
     derivaciones (*note Derivaciones::) y elementos simples del
     almacén. Comparada con las representaciones previas, muchos nodos
     adicionales son visibles, incluyendo los guiones de construcción,
     parches, módulos Guile, etc.

     Para este tipo de grafo, también es posible pasar un nombre de
     fichero ‘.drv’ en vez del nombre del paquete, como en:

          guix graph -t derivation `guix system build -d mi-configuración.scm`

‘module’
     Este es el grafo de los “módulos de paquete” (*note Módulos de
     paquetes::). Por ejemplo, la siguiente orden muestra el grafo para
     el módulo de paquetes que define el paquete ‘guile’:

          guix graph -t module guile | xdot -

   Todos los tipos previos corresponden a las _dependencias durante la
construcción_. El grafo siguiente representa las _dependencias en tiempo
de ejecución_:

‘references’
     Este es el grafo de “referencias” de la salida de un paquete, como
     lo devuelve ‘guix gc --references’ (*note Invocación de guix gc::).

     Si la salida del paquete proporcionado no está disponible en el
     almacén, ‘guix graph’ intenta obtener la información de
     dependencias desde las sustituciones.

     Aquí también puede proporcionar un nombre de fichero del almacén en
     vez de un nombre de paquete. Por ejemplo, la siguiente orden
     produce el grafo de referencias de su perfil (¡el cuál puede ser
     grande!):

          guix graph -t references `readlink -f ~/.guix-profile`

‘referrers’
     Este es el grafo de “referentes” de la salida de un paquete, como
     lo devuelve ‘guix gc --referrers’ (*note Invocación de guix gc::).

     Depende exclusivamente de información en su almacén. Por ejemplo,
     supongamos que la versión actual de Inkscape está disponible en 10
     perfiles en su máquina; ‘guix graph -t referrers inkscape’ mostrará
     un grafo cuya raíz es Inkscape y con esos 10 perfiles enlazados a
     ella.

     Puede ayudar a determinar qué impide que un elemento del almacén
     sea recolectado.

   Often, the graph of the package you are interested in does not fit on
your screen, and anyway all you want to know is _why_ that package
actually depends on some seemingly unrelated package. The ‘--path’
option instructs ‘guix graph’ to display the shortest path between two
packages (or derivations, or store items, etc.):

     $ guix graph --path emacs libunistring
     emacs@26.3
     mailutils@3.9
     libunistring@0.9.10
     $ guix graph --path -t derivation emacs libunistring
     /gnu/store/...-emacs-26.3.drv
     /gnu/store/...-mailutils-3.9.drv
     /gnu/store/...-libunistring-0.9.10.drv
     $ guix graph --path -t references emacs libunistring
     /gnu/store/...-emacs-26.3
     /gnu/store/...-libidn2-2.2.0
     /gnu/store/...-libunistring-0.9.10

   Las opciones disponibles son las siguientes:

‘--type=TIPO’
‘-t TIPO’
     Produce un grafo de salida de TIPO, donde TIPO debe ser uno de los
     valores enumerados previamente.

‘--list-types’
     Enumera los tipos de grafos implementados.

‘--backend=MOTOR’
‘-b MOTOR’
     Produce un grafo usando el MOTOR seleccionado.

‘--list-backends’
     Enumera los motores de grafos implementados.

     Actualmente, los motores disponibles son Graphviz y d3.js.

‘--path’
     Display the shortest path between two nodes of the type specified
     by ‘--type’. The example below shows the shortest path between
     ‘libreoffice’ and ‘llvm’ according to the references of
     ‘libreoffice’:

          $ guix graph --path -t references libreoffice llvm
          /gnu/store/...-libreoffice-6.4.2.2
          /gnu/store/...-libepoxy-1.5.4
          /gnu/store/...-mesa-19.3.4
          /gnu/store/...-llvm-9.0.1

‘--expression=EXPR’
‘-e EXPR’
     Considera el paquete al que evalúa EXPR

     Es útil para hacer una referencia precisa de un paquete concreto,
     como en este ejemplo:

          guix graph -e '(@@ (gnu packages commencement) gnu-make-final)'

‘--system=SISTEMA’
‘-s SISTEMA’
     Muestra el grafo para SISTEMA—por ejemplo, ‘i686-linux’.

     El grafo de dependencias del paquete es altamente independiente de
     la arquitectura, pero existen algunas partes dependientes de la
     arquitectura que esta opción le permite visualizar.

‘--load-path=DIRECTORIO’
‘-L DIRECTORIO’
     Añade DIRECTORIO al frente de la ruta de búsqueda de módulos de
     paquetes (*note Módulos de paquetes::).

     Esto permite a las usuarias definir sus propios paquetes y hacerlos
     visibles a las herramientas de línea de órdenes.

   Además de esto, ‘guix graph’ permite todas las opciones habituales de
transformación de paquetes (*note Opciones de transformación de
paquetes::). Esto facilita la visualización del efecto de una
transformación de reescritura de grafo como ‘--with-input’. Por ejemplo,
la siguiente orden muestra el grafo de ‘git’ una vez que ‘openssl’ ha
sido reemplazado por ‘libressl’ en todos los nodos del grafo:

     guix graph git --with-input=openssl=libressl

   ¡Tantas posibilidades, tanta diversión!


File: guix.es.info,  Node: Invocación de guix publish,  Next: Invocación de guix challenge,  Prev: Invocación de guix graph,  Up: Utilidades

7.10 Invocación de ‘guix publish’
=================================

El propósito de ‘guix publish’ es permitir a las usuarias compartir
fácilmente su almacén con otras, quienes pueden usarlo como servidor de
sustituciones (*note Sustituciones::).

   Cuando ‘guix publish’ se ejecuta, lanza un servidor HTTP que permite
a cualquiera que tenga acceso a través de la red obtener sustituciones
de él. Esto significa que cualquier máquina que ejecute Guix puede
actuar como si fuese una granja de construcción, ya que la interfaz HTTP
es compatible con Cuirass, el software detrás de la granja de
construcción ‘ci.guix.gnu.org’.

   For security, each substitute is signed, allowing recipients to check
their authenticity and integrity (*note Sustituciones::). Because ‘guix
publish’ uses the signing key of the system, which is only readable by
the system administrator, it must be started as root; the ‘--user’
option makes it drop root privileges early on.

   El par claves de firma debe generarse antes de ejecutar ‘guix
publish’, usando ‘guix archive --generate-key’ (*note Invocación de guix
archive::).

   La sintaxis general es:

     guix publish OPCIONES...

   La ejecución de ‘guix publish’ sin ningún parámetro adicional lanzará
un servidor HTTP en el puerto 8080:

     guix publish

   Una vez el servidor de publicación ha sido autorizado (*note
Invocación de guix archive::), el daemon puede descargar sustituciones
de él:

     guix-daemon --substitute-urls=http://example.org:8080

   Por defecto, ‘guix publish’ comprime los archivos al vuelo cuando es
necesario. Este modo “al vuelo” es conveniente ya que no necesita
configuración y está disponible inmediatamente. No obstante, cuando se
proporciona servicio a muchos clientes, se recomienda usar la opción
‘--cache’, que activa el almacenamiento en caché de los archivos antes
de enviarlos a los clientes—véase a continuación para más detalles. La
orden ‘guix weather’ proporciona una forma fácil de comprobar lo que
proporciona un servidor (*note Invocación de guix weather::).

   Además ‘guix publish’ también sirve como un espejo de acceso por
contenido a ficheros de fuentes a los que los registros ‘origin’ hacen
referencia (*note Referencia de origin::). Por ejemplo, si asumimos que
‘guix publish’ se ejecuta en ‘example.org’, la siguiente URL devuelve
directamente el fichero ‘hello-2.10.tar.gz’ con el hash SHA256
proporcionado (representado en formato ‘nix-base32’, *note Invocación de
guix hash::).

     http://example.org/file/hello-2.10.tar.gz/sha256/0ssi1...ndq1i

   Obviamente estas URL funcionan solamente para ficheros que se
encuentran en el almacén; en otros casos devuelven un 404 (“No
encontrado”).

   Los log de construcción están disponibles desde URL ‘/log’ como:

     http://example.org/log/gwspk...-guile-2.2.3

When ‘guix-daemon’ is configured to save compressed build logs, as is
the case by default (*note Invocación de guix-daemon::), ‘/log’ URLs
return the compressed log as-is, with an appropriate ‘Content-Type’
and/or ‘Content-Encoding’ header. We recommend running ‘guix-daemon’
with ‘--log-compression=gzip’ since Web browsers can automatically
decompress it, which is not the case with Bzip2 compression.

   Las siguientes opciones están disponibles:

‘--port=PUERTO’
‘-p PUERTO’
     Escucha peticiones HTTP en PUERTO.

‘--listen=DIRECCIÓN’
     Escucha en la interfaz de red de la DIRECCIÓN. El comportamiento
     predeterminado es aceptar conexiones de cualquier interfaz.

‘--user=USUARIA’
‘-u USUARIA’
     Cambia los privilegios a los de USUARIA tan pronto como sea
     posible—es decir, una vez el socket del servidor esté abierto y la
     clave de firma haya sido leída.

‘--compression[=MÉTODO[:NIVEL]]’
‘-C [MÉTODO[:NIVEL]]’
     Comprime los datos usando el MÉTODO y NIVEL proporcionados. MÉTODO
     es o bien ‘lzip’ o bien ‘gzip’; cuando MÉTODO se omite, se usa
     ‘gzip’.

     Cuando el NIVEL es cero, desactiva la compresión. El rango 1 a 9
     corresponde a distintos niveles de compresión gzip: 1 es el más
     rápido, y 9 es el mejor (intensivo a nivel de CPU). El valor
     predeterminado es 3.

     Habitualmente ‘lzip’ comprime notablemente mejor que ‘gzip’ a
     cambio de un pequeño incremento en el uso del procesador; véase las
     pruebas en la página web de lzip
     (https://nongnu.org/lzip/lzip_benchmark.html).

     A menos que se use ‘--cache’, la compresión ocurre al vuelo y los
     flujos comprimidos no se almacenan en caché. Por tanto, para
     reducir la carga en la máquina que ejecuta ‘guix publish’, puede
     ser una buena idea elegir un nivel de compresión bajo, ejecutar
     ‘guix publish’ detrás de un proxy con caché o usar ‘--cache’. El
     uso de ‘--cache’ tiene la ventaja de que permite a ‘guix publish’
     añadir la cabecera HTTP ‘Content-Length’ a sus respuestas.

     Se puede repetir esta opción, en cuyo caso cada sustitución se
     comprime usando todos los métodos seleccionados, y todos son
     anunciados. Esto es útil cuando las usuarias pueden no implementar
     todos los métodos de compresión: pueden seleccionar el que
     implementan.

‘--cache=DIRECTORIO’
‘-c DIRECTORIO’
     Almacena en caché los archivos y metadatos (URL ‘.narinfo’) en
     DIRECTORIO y únicamente proporciona archivos que están en la caché.

     Cuando se omite esta opción, los archivos y metadatos se crean al
     vuelo. Esto puede reducir el ancho de banda disponible,
     especialmente cuando la compresión está activa, ya que se puede
     llegar al límite de la CPU. Otra desventaja del modo predeterminado
     es que la longitud de los archivos no se conoce con anterioridad,
     por lo que ‘guix publish’ no puede añadir la cabecera HTTP
     ‘Content-Length’ a sus respuestas, lo que a su vez previene que los
     clientes conozcan la cantidad de datos a descargar.

     De manera contraria, cuando se usa ‘--cache’, la primera petición
     de un elemento del almacén (a través de una URL ‘.narinfo’)
     devuelve 404 e inicia un proceso en segundo plano para “cocinar” el
     archivo—calcular su ‘.narinfo’ y comprimirlo, en caso necesario.
     Una vez el archivo está alojado en la caché de DIRECTORIO, las
     siguientes peticiones obtendrán un resultado satisfactorio y se
     ofrecerá el contenido directamente desde la caché, lo que garantiza
     que los clientes obtienen el mejor ancho de banda posible.

     El proceso de “cocinado” se realiza por hilos de trabajo. Por
     defecto, se crea un hilo por núcleo de la CPU, pero puede ser
     personalizado. Véase ‘--workers’ a continuación.

     Cuando se usa ‘--ttl’, las entradas en caché se borran
     automáticamente cuando hayan expirado.

‘--workers=N’
     Cuando se usa ‘--cache’, solicita la creación de N hilos de trabajo
     para “cocinar” archivos.

‘--ttl=TTL’
     Produce cabeceras HTTP ‘Cache-Control’ que anuncian un
     tiempo-de-vida (TTL) de TTL. TTL debe indicar una duración: ‘5d’
     significa 5 días, ‘1m’ significa un mes, etc.

     Esto permite a la usuaria de Guix mantener información de
     sustituciones en la caché durante TTL. No obstante, fíjese que
     ‘guix publish’ no garantiza en sí que los elementos del almacén que
     proporciona de hecho permanezcan disponibles hasta que TTL expire.

     Adicionalmente, cuando se usa ‘--cache’, las entradas en caché que
     no hayan sido accedidas en TTL y no tengan un elemento
     correspondiente en el almacén pueden ser borradas.

‘--nar-path=RUTA’
     Usa RUTA como el prefijo para las URL de los archivos “nar” (*note
     archivadores normalizados: Invocación de guix archive.).

     Por defecto, los archivos nar se proporcionan en una URL como
     ‘/nar/gzip/...-coreutils-8.25’. Esta opción le permite cambiar la
     parte ‘/nar’ por RUTA.

‘--public-key=FICHERO’
‘--private-key=FICHERO’
     Usa los FICHEROs específicos como el par de claves pública y
     privada usadas para firmar los elementos del almacén publicados.

     Los ficheros deben corresponder al mismo par de claves (la clave
     privada se usa para la firma y la clave pública simplemente se
     anuncia en los metadatos de la firma). Deben contener claves en el
     formato canónico de expresiones-S como el producido por ‘guix
     archive --generate-key’ (*note Invocación de guix archive::). Por
     defecto, se usan ‘/etc/guix/signing-key.pub’ y
     ‘/etc/guix/signing-key.sec’.

‘--repl[=PUERTO]’
‘-r [PUERTO]’
     Lanza un servidor REPL Guile (*note (guile)REPL Servers::) en
     PUERTO (37146 por defecto). Esto se usa principalmente para la
     depuración de un servidor ‘guix publish’ en ejecución.

   Activar ‘guix publish’ en el sistema Guix consiste en solo una línea:
simplemente instancie un servicio ‘guix-publish-service-type’ en el
campo ‘services’ de su declaración del sistema operativo
‘operating-system’ (*note ‘guix-publish-service-type’:
guix-publish-service-type.)

   Si en vez de eso ejecuta Guix en una distribución distinta, siga
estas instrucciones:

   • Si su distribución anfitriona usa el sistema de inicio systemd:

          # ln -s ~root/.guix-profile/lib/systemd/system/guix-publish.service \
                  /etc/systemd/system/
          # systemctl start guix-publish && systemctl enable guix-publish

   • Si su distribución anfitriona usa el sistema de inicio Upstart:

          # ln -s ~root/.guix-profile/lib/upstart/system/guix-publish.conf /etc/init/
          # start guix-publish

   • En otro caso, proceda de forma similar con el sistema de inicio de
     su distribución.


File: guix.es.info,  Node: Invocación de guix challenge,  Next: Invocación de guix copy,  Prev: Invocación de guix publish,  Up: Utilidades

7.11 Invocación de ‘guix challenge’
===================================

¿Los binarios que proporciona este servidor realmente corresponden al
código fuente que dice construir? ¿Es determinista el proceso de
construcción de un paquete? Estas son las preguntas que la orden ‘guix
challenge’ intenta responder.

   La primera es obviamente una cuestión importante: antes de usar un
servidor de sustituciones (*note Sustituciones::), es importante haber
_verificado_ que proporciona los binarios correctos, y por tanto
_ponerlo a prueba_(1). La segunda es lo que permite la primera: si las
construcciones de los paquetes son deterministas, construcciones
independientes deberían emitir el mismo resultado, bit a bit; si el
servidor proporciona un binario diferente al obtenido localmente, o bien
está corrupto o bien tiene intenciones perniciosas.

   Sabemos que el hash que se muestra en los nombres de fichero en
‘/gnu/store’ es el hash de todas las entradas del proceso que construyó
el fichero o directorio—compiladores, bibliotecas, guiones de
construcción, etc. (*note Introducción::). Asumiendo procesos de
construcción deterministas, un nombre de fichero del almacén debe
corresponder exactamente a una salida de construcción. ‘guix challenge’
comprueba si existe, realmente, una asociación unívoca comparando la
salida de la construcción de varias construcciones independientes de
cualquier elemento del almacén proporcionado.

   La salida de la orden muestra algo así:

     $ guix challenge --substitute-urls="https://ci.guix.gnu.org https://guix.example.org"
     actualizando sustituciones desde 'https://ci.guix.gnu.org'... 100.0%
     actualizando sustituciones desde 'https://guix.example.org'... 100.0%
     el contenido de /gnu/store/...-openssl-1.0.2d es diferente:
       hash local: 0725l22r5jnzazaacncwsvp9kgf42266ayyp814v7djxs7nk963q
       https://ci.guix.gnu.org/nar/...-openssl-1.0.2d: 0725l22r5jnzazaacncwsvp9kgf42266ayyp814v7djxs7nk963q
       https://guix.example.org/nar/...-openssl-1.0.2d: 1zy4fmaaqcnjrzzajkdn3f5gmjk754b43qkq47llbyak9z0qjyim
       ficheros diferentes:
         /lib/libcrypto.so.1.1
         /lib/libssl.so.1.1

     el contenido de /gnu/store/...-git-2.5.0 es diferente:
       hash local: 00p3bmryhjxrhpn2gxs2fy0a15lnip05l97205pgbk5ra395hyha
       https://ci.guix.gnu.org/nar/...-git-2.5.0: 069nb85bv4d4a6slrwjdy8v1cn4cwspm3kdbmyb81d6zckj3nq9f
       https://guix.example.org/nar/...-git-2.5.0: 0mdqa9w1p6cmli6976v4wi0sw9r4p5prkj7lzfd1877wk11c9c73
       fichero diferente:
         /libexec/git-core/git-fsck

     el contenido de /gnu/store/...-pius-2.1.1 es diferente:
       hash local: 0k4v3m9z1zp8xzzizb7d8kjj72f9172xv078sq4wl73vnq9ig3ax
       https://ci.guix.gnu.org/nar/...-pius-2.1.1: 0k4v3m9z1zp8xzzizb7d8kjj72f9172xv078sq4wl73vnq9ig3ax
       https://guix.example.org/nar/...-pius-2.1.1: 1cy25x1a4fzq5rk0pmvc8xhwyffnqz95h2bpvqsz2mpvlbccy0gs
       fichero diferente:
         /share/man/man1/pius.1.gz

     ...

     6,406 elementos del almacén fueron analizados:
       - 4,749 (74.1%) fueron idénticos
       - 525 (8.2%) fueron diferentes
       - 1,132 (17.7%) no arrojaron resultados concluyentes

En este ejemplo, ‘guix challenge’ primero recorre el almacén para
determinar el conjunto de derivaciones construidas localmente—en
oposición a elementos del almacén que fueron descargados de un servidor
de sustituciones—y consulta a todos los servidores de sustituciones. Una
vez hecho informa de los elementos del almacén para los cuales los
servidores obtuvieron un resultado diferente de el obtenido en la
construcción local.

   Como un ejemplo, ‘guix.example.org’ siempre obtiene una respuesta
diferente. Por otro modo, ‘ci.guix.gnu.org’ coincide con las
construcciones locales, excepto en el caso de Git. Esto puede indicar
que el proceso de construcción de Git no es determinista, lo que
significa que su salida varia en función de varias cosas que Guix no
controla completamente, aunque la construcción de paquetes se realice en
entornos aislados (*note Características::). Las fuentes más comunes de
indeterminismo incluyen la adición de marcas de tiempo en los resultados
de la construcción, la inclusión de números aleatorios y las
enumeraciones de directorios ordenadas por número de nodos-i. Véase
<https://reproducible-builds.org/docs/> para más información.

   Para encontrar cuál es el problema con este binario Git, la
aproximación más fácil es ejecutar:

     guix challenge git \
       --diff=diffoscope \
       --substitute-urls="https://ci.guix.gnu.org https://guix.example.org"

   Esto invoca automáticamente ‘diffoscope’, que muestra información
detallada sobre los ficheros que son diferentes.

   Alternatively, we can do something along these lines (*note
Invocación de guix archive::):

     $ wget -q -O - https://ci.guix.gnu.org/nar/lzip/...-git-2.5.0 \
        | lzip -d | guix archive -x /tmp/git
     $ diff -ur --no-dereference /gnu/store/...-git.2.5.0 /tmp/git

   Esta orden muestra la diferencia entre los ficheros resultantes de la
construcción local y los ficheros resultantes de la construcción en
‘ci.guix.gnu.org’ (*note Comparing and Merging Files:
(diffutils)Overview.). La orden ‘diff’ funciona muy bien en ficheros de
texto. Cuando son binarios los ficheros diferentes, una opción mejor es
Diffoscope (https://diffoscope.org/), una herramienta que ayuda en la
visualización de diferencias en todo tipo de ficheros.

   Una vez haya realizado este trabajo, puede determinar si las
diferencias son debidas a un procedimiento de construcción
no-determinista o a un servidor con intenciones ocultas. Intentamos
duramente eliminar las fuentes de indeterminismo en los paquetes para
facilitar la verificación de sustituciones, pero por supuesto es un
proceso que implica no solo a Guix, sino a una gran parte de la
comunidad del software libre. Entre tanto, ‘guix challenge’ es una
herramienta para ayudar a afrontar el problema.

   Si esta escribiendo paquetes para Guix, le recomendamos que compruebe
si ‘ci.guix.gnu.org’ y otros servidores de sustituciones obtienen el
mismo resultado de construcción que el obtenido por usted:

     $ guix challenge PAQUETE

donde PAQUETE es una especificación de paquete como ‘guile@2.0’ o
‘glibc:debug’.

   La sintaxis general es:

     guix challenge OPCIONES [PAQUETES...]

   When a difference is found between the hash of a locally-built item
and that of a server-provided substitute, or among substitutes provided
by different servers, the command displays it as in the example above
and its exit code is 2 (other non-zero exit codes denote other kinds of
errors).

   La única opción de importancia es:

‘--substitute-urls=URLS’
     Considera URLS la lista separada por espacios de URL de fuentes de
     sustituciones con las que realizar la comparación.

‘--diff=MODO’
     Muestra las diferencias encontradas de acuerdo con MODO, uno de los
     siguientes:

     ‘simple’ (el predeterminado)
          Muestra la lista de ficheros que son diferentes.

     ‘diffoscope’
     ORDEN
          Invoca Diffoscope (https://diffoscope.org/) y le proporciona
          los dos directorios cuyo contenido es diferente.

          Cuando ORDEN es una ruta absoluta, ejecuta ORDEN en vez de
          Diffoscope.

     ‘none’
          No muestra más detalles sobre las diferencias.

     Thus, unless ‘--diff=none’ is passed, ‘guix challenge’ downloads
     the store items from the given substitute servers so that it can
     compare them.

‘--verbose’
‘-v’
     Muestra detalles sobre coincidencias (contenidos idénticos) además
     de información sobre las discrepancias.

   ---------- Footnotes ----------

   (1) NdT: challenge en inglés.


File: guix.es.info,  Node: Invocación de guix copy,  Next: Invocación de guix container,  Prev: Invocación de guix challenge,  Up: Utilidades

7.12 Invocación de ‘guix copy’
==============================

La orden ‘guix copy’ copia elementos del almacén de una máquina al de
otra a través de una conexión de shell seguro (SSH)(1). Por ejemplo, la
siguiente orden copia el paquete ‘coreutils’, el perfil de la usuaria y
todas sus dependencias a DIRECCIÓN, ingresando en el sistema como
USUARIA:

     guix copy --to=USUARIA@DIRECCIÓN \
               coreutils `readlink -f ~/.guix-profile`

   Si alguno de los elementos del almacén a copiar ya están presentes en
DIRECCIÓN, no se envían realmente.

   La siguiente orden obtiene ‘libreoffice’ y ‘gimp’ de DIRECCIÓN,
asumiendo que estén disponibles allí:

     guix copy --from=DIRECCIÓN libreoffice gimp

   La conexión SSH se establece usando el cliente Guile-SSH, que es
compatible con OpenSSH: tiene en cuenta ‘~/.ssh/known_hosts’ y
‘~/.ssh/config’, y usa el agente SSH para la identificación.

   La clave usada para firmar los elementos enviados debe estar aceptada
por la máquina remota. Del mismo modo, la clave usada por la máquina
remota para firmar los elementos recibidos debe estar en ‘/etc/guix/acl’
de modo que sea aceptada por su propio daemon. *Note Invocación de guix
archive::, para más información sobre la verificación de elementos del
almacén.

   La sintaxis general es:

     guix copy [--to=SPEC|--from=SPEC] ELEMENTOS...

   Siempre debe especificar una de las siguientes opciones:

‘--to=SPEC’
‘--from=SPEC’
     Especifica la máquina a la que mandar o desde la que recibir. SPEC
     debe ser una especificación SSH como ‘example.org’,
     ‘carlos@example.org’, or ‘carlos@example.org:2222’.

   Los ELEMENTOS pueden ser tanto nombres de paquetes, como ‘gimp’, como
elementos del almacén, como ‘/gnu/store/...-idutils-4.6’.

   Cuando se especifica el nombre del paquete a enviar, primero se
construye si es necesario, a menos que se use ‘--dry-run’. Se aceptan
las opciones comunes de construcción (*note Opciones comunes de
construcción::).

   ---------- Footnotes ----------

   (1) Esta orden únicamente está disponible cuando ha encontrado
Guile-SSH. *Note Requisitos::, para detalles.


File: guix.es.info,  Node: Invocación de guix container,  Next: Invocación de guix weather,  Prev: Invocación de guix copy,  Up: Utilidades

7.13 Invocación de ‘guix container’
===================================

     Nota: En la versión 1.0.1.17089-7e269, esta herramienta es
     experimental. La interfaz está sujeta a cambios radicales en el
     futuro.

   El propósito de ‘guix container’ es la manipulación de procesos en
ejecución dentro de entornos aislados, normalmente conocido como un
“contenedor”, típicamente creado por las órdenes ‘guix environment’
(*note Invocación de guix environment::) y ‘guix system container’
(*note Invocación de guix system::).

   La sintaxis general es:

     guix container ACCIÓN OPCIONES...

   ACCIÓN especifica la operación a realizar con el contenedor, y
OPCINES especifica los parámetros específicos del contexto para la
acción.

   Las siguientes acciones están disponibles:

‘exec’
     Ejecute una orden en el contexto de un contenedor en ejecución.

     La sintaxis es:

          guix container exec PID PROGRAMA PARÁMETROS...

     PID especifica el ID del proceso del contenedor en ejecución.
     PROGRAMA especifica el nombre del fichero ejecutable dentro del
     sistema de ficheros raíz del contenedor. PARÁMETROS son opciones
     adicionales que se pasarán a PROGRAMA.

     La siguiente orden lanza un shell interactivo de ingreso al sistema
     dentro de un contenedor del sistema, iniciado por ‘guix system
     container’, y cuyo ID de proceso es 9001:

          guix container exec 9001 /run/current-system/profile/bin/bash --login

     Fíjese que el PID no puede ser el proceso creador del contenedor.
     Debe ser el PID 1 del contenedor o uno de sus procesos hijos.


File: guix.es.info,  Node: Invocación de guix weather,  Next: Invocación de guix processes,  Prev: Invocación de guix container,  Up: Utilidades

7.14 Invocación de ‘guix weather’
=================================

De manera ocasional tendrá un mal día al no estar las sustituciones
disponibles y le toque construir los paquetes a usted misma (*note
Sustituciones::). La orden ‘guix weather’ informa de la disponibilidad
de sustituciones en los servidores especificados de modo que pueda tener
una idea sobre cómo será su día hoy. A veces puede ser una información
útil como usuaria, pero es principalmente útil para quienes ejecuten
‘guix publish’ (*note Invocación de guix publish::).

   Esta es una ejecución de ejemplo:

     $ guix weather --substitute-urls=https://guix.example.org
     computing 5,872 package derivations for x86_64-linux...
     looking for 6,128 store items on https://guix.example.org..
     updating list of substitutes from 'https://guix.example.org'... 100.0%
     https://guix.example.org
       43.4% substitutes available (2,658 out of 6,128)
       7,032.5 MiB of nars (compressed)
       19,824.2 MiB on disk (uncompressed)
       0.030 seconds per request (182.9 seconds in total)
       33.5 requests per second

       9.8% (342 out of 3,470) of the missing items are queued
       867 queued builds
           x86_64-linux: 518 (59.7%)
           i686-linux: 221 (25.5%)
           aarch64-linux: 128 (14.8%)
       build rate: 23.41 builds per hour
           x86_64-linux: 11.16 builds per hour
           i686-linux: 6.03 builds per hour
           aarch64-linux: 6.41 builds per hour

   Como puede ver, informa de la fracción de todos los paquetes para los
cuales hay sustituciones en el servidor—independientemente de que las
sustituciones estén activadas, e independientemente de si la clave de
firma del servidor está autorizada. También informa del tamaño de los
archivos comprimidos (“nar”) proporcionados por el servidor, el tamaño
que los elementos correspondientes del almacén ocupan en el almacén
(asumiendo que la deduplicación está apagada) y el caudal de proceso del
servidor. La segunda parte proporciona estadísticas de integración
continua (CI), si el servidor lo permite. Además, mediante el uso de la
opción ‘--coverage’, ‘guix weather’ puede enumerar sustituciones de
paquetes “importantes” que no se encuentren en el servidor (véase más
adelante).

   Para conseguirlo, ‘guix weather’ consulta los metadatos HTTP(S)
(“narinfo”s) de todos los elementos relevantes del almacén. Como ‘guix
challenge’, ignora las firmas en esas sustituciones, lo cual es inocuo
puesto que la orden únicamente obtiene estadísticas y no puede instalar
esas sustituciones.

   La sintaxis general es:

     guix weather OPCIONES... [PAQUETES...]

   Cuando se omite PAQUETES, ‘guix weather’ comprueba la disponibilidad
de sustituciones para _todos_ los paquetes, o para aquellos
especificados con la opción ‘--manifest’; en otro caso considera
únicamente los paquetes especificados. También es posible consultar
tipos de sistema específicos con ‘--system’. ‘guix weather’ termina con
un código de salida distinto a cero cuando la fracción de sustituciones
disponibles se encuentra por debajo del 100%.

   Las opciones disponibles se enumeran a continuación.

‘--substitute-urls=URLS’
     URLS es la lista separada por espacios de URL de servidores de
     sustituciones a consultar. Cuando se omite esta opción, el conjunto
     predeterminado de servidores de sustituciones es el consultado.

‘--system=SISTEMA’
‘-s SISTEMA’
     Consulta sustituciones para SISTEMA—por ejemplo, ‘aarch64-linux’.
     Esta opción se puede repetir, en cuyo caso ‘guix weather’
     consultará las sustituciones para varios tipos de sistema.

‘--manifest=FICHERO’
     En vez de consultar las sustituciones de todos los paquetes,
     consulta únicamente los especificados en FICHERO. FICHERO debe
     contener un “manifiesto”, como el usado en la opción ‘-m’ de ‘guix
     package’ (*note Invocación de guix package::).

     Esta opción puede repetirse varias veces, en cuyo caso los
     manifiestos se concatenan.

‘--coverage[=NUMERO]’
‘-c [NUMERO]’
     Informa de la cobertura de sustituciones para paquetes: enumera
     paquetes con al menos NÚMERO dependientes (cero por omisión) para
     los cuales no haya sustituciones disponibles. Los paquetes
     dependientes en sí no se enumeran: si B depende de A y A no tiene
     sustituciones disponibles, únicamente se muestra A, aunque B
     normalmente no tenga sustituciones tampoco. El resultado es más o
     menos así:

          $ guix weather --substitute-urls=https://ci.guix.gnu.org -c 10
          calculando 8.983 derivaciones de paquete para x86_64-linux...
          buscando 9.343 elementos del almacén en https://ci.guix.gnu.org...
          actualizando sustituciones desde 'https://ci.guix.gnu.org'... 100.0%
          https://ci.guix.gnu.org
            64,7% sustituciones disponibles (6.047 de 9.343)
          ...
          Faltan 2502 paquetes de 'https://ci.guix.gnu.org' para 'x86_64-linux', entre los cuales:
              58  kcoreaddons@5.49.0      /gnu/store/...-kcoreaddons-5.49.0
              46  qgpgme@1.11.1           /gnu/store/...-qgpgme-1.11.1
              37  perl-http-cookiejar@0.008  /gnu/store/...-perl-http-cookiejar-0.008
              ...

     Lo que este ejemplo muestra es que ‘kcoreaddons’ y presumiblemente
     los 58 paquetes que dependen de él no tienen sustituciones
     disponibles en ‘ci.guix.es.info’; del mismo modo que ‘qgpgme’ y los
     46 paquetes que dependen de él.

     Si es una desarrolladora Guix, o si se encuentra a cargo de esta
     granja de construcción, probablemente quiera inspeccionar estos
     paquetes con más detalle: simplemente puede que su construcción
     falle.

‘--display-missing’
     Muestra los elementos del almacén para los que faltan las
     sustituciones.


File: guix.es.info,  Node: Invocación de guix processes,  Prev: Invocación de guix weather,  Up: Utilidades

7.15 Invocación de ‘guix processes’
===================================

La orden ‘guix processes’ puede ser útil a desarrolladoras y
administradoras de sistemas, especialmente en máquinas multiusuaria y en
granjas de construcción: enumera las sesiones actuales (conexiones al
daemon), así como información sobre los procesos envueltos(1). A
continuación puede verse un ejemplo de la información que devuelve:

     $ sudo guix processes
     SessionPID: 19002
     ClientPID: 19090
     ClientCommand: guix environment --ad-hoc python

     SessionPID: 19402
     ClientPID: 19367
     ClientCommand: guix publish -u guix-publish -p 3000 -C 9 ...

     SessionPID: 19444
     ClientPID: 19419
     ClientCommand: cuirass --cache-directory /var/cache/cuirass ...
     LockHeld: /gnu/store/...-perl-ipc-cmd-0.96.lock
     LockHeld: /gnu/store/...-python-six-bootstrap-1.11.0.lock
     LockHeld: /gnu/store/...-libjpeg-turbo-2.0.0.lock
     ChildProcess: 20495: guix offload x86_64-linux 7200 1 28800
     ChildProcess: 27733: guix offload x86_64-linux 7200 1 28800
     ChildProcess: 27793: guix offload x86_64-linux 7200 1 28800

   En este ejemplo vemos que ‘guix-daemon’ tiene tres clientes: ‘guix
environment’, ‘guix publish’ y la herramienta de integración continua
Cuirass; sus identificadores de proceso (PID) se muestran en el campo
‘ClientPID’. El campo ‘SessionPID’ proporciona el PID del subproceso de
‘guix-daemon’ de cada sesión en particular.

   The ‘LockHeld’ fields show which store items are currently locked by
this session, which corresponds to store items being built or
substituted (the ‘LockHeld’ field is not displayed when ‘guix processes’
is not running as root). Last, by looking at the ‘ChildProcess’ field,
we understand that these three builds are being offloaded (*note
Configuración de delegación del daemon::).

   La salida está en formato Recutils por lo que podemos usar la útil
orden ‘recsel’ para seleccionar sesiones de interés (*note
(recutils)Selection Expressions::). Como un ejemplo, la siguiente orden
muestra la línea de órdenes y el PID del cliente que inició la
construcción de un paquete Perl:

     $ sudo guix processes | \
         recsel -p ClientPID,ClientCommand -e 'LockHeld ~ "perl"'
     ClientPID: 19419
     ClientCommand: cuirass --cache-directory /var/cache/cuirass ...

   ---------- Footnotes ----------

   (1) Las sesiones remotas, cuando ‘guix-daemon’ se ha iniciado con
‘--listen’ especificando un punto de conexión TCP, _no_ son enumeradas.


File: guix.es.info,  Node: Configuración del sistema,  Next: Documentación,  Prev: Utilidades,  Up: Top

8 Configuración del sistema
***************************

El sistema Guix permite un mecanismo de configuración del sistema
completo consistente. Con esto queremos decir que todos los aspectos de
la configuración global del sistema—como los servicios disponibles, la
zona horaria y la configuración de localización, las cuentas de
usuarias—se declaran en un lugar único. Dicha “configuración del
sistema” puede ser “instanciada”—es decir, hecha efectiva.

   Una de las ventajas de poner toda la configuración del sistema bajo
el control de Guix es que permite actualizaciones transaccionales del
sistema, y hace posible volver a una instanciación previa del sistema,
en caso de que haya algún problema con la nueva (*note
Características::). Otra ventaja es que hace fácil replicar exactamente
la misma configuración entre máquinas diferentes, o en diferentes
momentos, sin tener que utilizar herramientas de administración
adicionales sobre las propias herramientas del sistema.

   Esta sección describe este mecanismo. Primero nos enfocaremos en el
punto de vista de la administradora del sistema—explicando cómo se
configura e instancia el sistema. Después mostraremos cómo puede
extenderse este mecanismo, por ejemplo para añadir nuevos servicios del
sistema.

* Menu:

* Uso de la configuración del sistema::  Personalizar su sistema GNU.
* Referencia de operating-system::  Detalle de las declaraciones de sistema
                                      operativo.
* Sistemas de ficheros::     Configurar el montaje de sistemas de ficheros.
* Dispositivos traducidos::  Procesamiento adicional de dispositivos de
                               bloques.
* Cuentas de usuaria::       Especificar las cuentas de usuaria.
* Distribución de teclado::  Cómo interpreta el sistema las pulsaciones
                                del teclado.
* Localizaciones::           Configuración de idioma y convenciones
                               culturales.
* Servicios::                Especificar los servicios del sistema.
* Programas con setuid::     Programas que se ejecutan con privilegios de
                               root.
* Certificados X.509::       Verificar servidores HTTPS.
* Selector de servicios de nombres::  Configurar el selector de servicios de
                                        nombres de libc.
* Disco en RAM inicial::     Arranque de Linux-Libre.
* Configuración del gestor de arranque::  Configurar el gestor de arranque.
* Invocación de guix system::  Instanciar una configuración del sistema.
* Invocación de guix deploy::  Despliegue de una configuración del sistema
                                  en una máquina remota.
* Ejecutar Guix en una máquina virtual::  Cómo ejecutar el sistema Guix en
                                             una máquina virtual.
* Definición de servicios::  Añadir nuevas definiciones de servicios.


File: guix.es.info,  Node: Uso de la configuración del sistema,  Next: Referencia de operating-system,  Up: Configuración del sistema

8.1 Uso de la configuración del sistema
=======================================

El sistema operativo se configura proporcionando una declaración
‘operating-system’ en un fichero que pueda ser proporcionado a la orden
‘guix system’ (*note Invocación de guix system::). Una configuración
simple, con los servicios predeterminados del sistema, el núcleo
Linux-Libre predeterminado, un disco de RAM inicial y un cargador de
arranque puede ser como sigue:

     ;; This is an operating system configuration template
     ;; for a "bare bones" setup, with no X11 display server.

     (use-modules (gnu))
     (use-service-modules networking ssh)
     (use-package-modules screen)

     (operating-system
       (host-name "komputilo")
       (timezone "Europe/Berlin")
       (locale "en_US.utf8")

       ;; Boot in "legacy" BIOS mode, assuming /dev/sdX is the
       ;; target hard disk, and "my-root" is the label of the target
       ;; root file system.
       (bootloader (bootloader-configuration
                     (bootloader grub-bootloader)
                     (target "/dev/sdX")))
       (file-systems (cons (file-system
                             (device (file-system-label "my-root"))
                             (mount-point "/")
                             (type "ext4"))
                           %base-file-systems))

       ;; This is where user accounts are specified.  The "root"
       ;; account is implicit, and is initially created with the
       ;; empty password.
       (users (cons (user-account
                     (name "alice")
                     (comment "Bob's sister")
                     (group "users")

                     ;; Adding the account to the "wheel" group
                     ;; makes it a sudoer.  Adding it to "audio"
                     ;; and "video" allows the user to play sound
                     ;; and access the webcam.
                     (supplementary-groups '("wheel"
                                             "audio" "video")))
                    %base-user-accounts))

       ;; Globally-installed packages.
       (packages (cons screen %base-packages))

       ;; Add services to the baseline: a DHCP client and
       ;; an SSH server.
       (services (append (list (service dhcp-client-service-type)
                               (service openssh-service-type
                                        (openssh-configuration
                                         (port-number 2222))))
                         %base-services)))

   Este ejemplo debería ser auto-descriptivo. Algunos de los campos
definidos anteriormente, como ‘host-name’ y ‘bootloader’, son
necesarios. Otros como ‘packages’ y ‘services’, pueden omitirse, en cuyo
caso obtienen un valor por defecto.

   Más adelante se muestran los efectos de algunos de los campos más
importantes (*note Referencia de operating-system::, para detalles
acerca de todos los campos disponibles), y cómo “instanciar” el sistema
operativo usando ‘guix system’.

Cargador de arranque
--------------------

El campo ‘bootloader’ describe el método que será usado para arrancar su
sistema. Las máquinas basadas en procesadores Intel pueden arrancar en
el “obsoleto” modo BIOS, como en el ejemplo previo. No obstante,
máquinas más recientes usan la “Interfaz Unificada Extensible de
Firmware” (UEFI) para arrancar. En ese caso, el capo ‘bootloader’ debe
contener algo parecido a esto:

     (bootloader-configuration
       (bootloader grub-efi-bootloader)
       (target "/boot/efi"))

   *Note Configuración del gestor de arranque::, para más información
sobre las opciones de configuración disponibles.

Paquetes visibles globalmente
-----------------------------

The ‘packages’ field lists packages that will be globally visible on the
system, for all user accounts—i.e., in every user’s ‘PATH’ environment
variable—in addition to the per-user profiles (*note Invocación de guix
package::). The ‘%base-packages’ variable provides all the tools one
would expect for basic user and administrator tasks—including the GNU
Core Utilities, the GNU Networking Utilities, the GNU Zile lightweight
text editor, ‘find’, ‘grep’, etc. The example above adds GNU Screen to
those, taken from the ‘(gnu packages screen)’ module (*note Módulos de
paquetes::). The ‘(list package output)’ syntax can be used to add a
specific output of a package:

     (use-modules (gnu packages))
     (use-modules (gnu packages dns))

     (operating-system
       ;; ...
       (packages (cons (list bind "utils")
                       %base-packages)))

   Referirse a los paquetes por nombre de variable, como antes a ‘bind’,
tiene la ventaja de evitar ambigüedades; también permite que errores
tipográficos y demás obtengan un diagnóstico directo como “variables sin
definir”. La parte problemática es que se necesita conocer qué módulo
define qué paquete, y aumentar adecuadamente la línea de
‘use-package-modules’. Para evitar esto, se puede usar el procedimiento
‘specification->package’ del módulo ‘(gnu packages)’, que devuelve el
mejor paquete para un nombre dado, o nombre y versión:

     (use-modules (gnu packages))

     (operating-system
       ;; ...
       (packages (append (map specification->package
                              '("tcpdump" "htop" "gnupg@2.0"))
                         %base-packages)))

Servicios del sistema
---------------------

El campo ‘services’ enumera los “servicios del sistema” disponibles
cuando el sistema arranque (*note Servicios::). La declaración
‘operating-system’ previa especifica que, además de los servicios
básicos, queremos que el daemon de shell seguro OpenSSH espere
conexiones por el puerto 2222 (*note ‘openssh-service-type’: Servicios
de red.). En su implementación, ‘openssh-service-type’ prepara todo para
que ‘sshd’ se inicie con las opciones de la línea de órdenes adecuadas,
posiblemente generando bajo demanda los ficheros de configuración
necesarios (*note Definición de servicios::).

   De manera ocasional, en vez de usar los servicios básicos tal y como
vienen, puede querer personalizarlos. Para hacerlo, use
‘modify-services’ (*note ‘modify-services’: Referencia de servicios.)
para modificar la lista.

   Por ejemplo, supongamos que quiere modificar ‘guix-daemon’ y Mingetty
(el punto de acceso al sistema por consola) en la lista ‘%base-services’
(*note ‘%base-services’: Servicios base.). Para hacerlo, puede escribir
lo siguiente en su declaración de sistema operativo:

     (define %mis-servicios
       ;; Mi propia lista de servicios
       (modify-services %base-services
         (guix-service-type config =>
                            (guix-configuration
                             (inherit config)
                             (use-substitutes? #f)
                             (extra-options '("--gc-keep-derivations"))))
         (mingetty-service-type config =>
                                (mingetty-configuration
                                 (inherit config)))))

     (operating-system
       ;; ...
       (services %mis-servicios))

   Esto modifica la configuración—es decir, los parámetros de los
servicios—de la instancia ‘guix-service-type’, y de todas las instancias
de ‘mingetty-service-type’ en la lista ‘%base-services’. Observe cómo se
consigue: primero, enlazamos la configuración actual al identificador
‘config’ en el CUERPO, y entonces escribimos el CUERPO de manera que
evalúe a la configuración deseada. En particular, fíjese como se usa
‘inherit’ para crear una nueva configuración que tiene los mismos
valores que la configuración antigua, pero con unas pocas
modificaciones.

   La configuración para un uso típico de “escritorio”, con una
partición de raíz cifrada, el servidor gráfico X11, GNOME y Xfce (las
usuarias pueden escoger cual de estos entornos de escritorio usarán en
la pantalla de inicio de sesión pulsando ‘F1’), gestión de red, gestión
de energía y más, podría ser así:

     ;; This is an operating system configuration template
     ;; for a "desktop" setup with GNOME and Xfce where the
     ;; root partition is encrypted with LUKS.

     (use-modules (gnu) (gnu system nss))
     (use-service-modules desktop xorg)
     (use-package-modules certs gnome)

     (operating-system
       (host-name "antelope")
       (timezone "Europe/Paris")
       (locale "en_US.utf8")

       ;; Choose US English keyboard layout.  The "altgr-intl"
       ;; variant provides dead keys for accented characters.
       (keyboard-layout (keyboard-layout "us" "altgr-intl"))

       ;; Use the UEFI variant of GRUB with the EFI System
       ;; Partition mounted on /boot/efi.
       (bootloader (bootloader-configuration
                     (bootloader grub-efi-bootloader)
                     (target "/boot/efi")
                     (keyboard-layout keyboard-layout)))

       ;; Specify a mapped device for the encrypted root partition.
       ;; The UUID is that returned by 'cryptsetup luksUUID'.
       (mapped-devices
        (list (mapped-device
               (source (uuid "12345678-1234-1234-1234-123456789abc"))
               (target "my-root")
               (type luks-device-mapping))))

       (file-systems (append
                      (list (file-system
                              (device (file-system-label "my-root"))
                              (mount-point "/")
                              (type "ext4")
                              (dependencies mapped-devices))
                            (file-system
                              (device (uuid "1234-ABCD" 'fat))
                              (mount-point "/boot/efi")
                              (type "vfat")))
                      %base-file-systems))

       (users (cons (user-account
                     (name "bob")
                     (comment "Alice's brother")
                     (group "users")
                     (supplementary-groups '("wheel" "netdev"
                                             "audio" "video")))
                    %base-user-accounts))

       ;; This is where we specify system-wide packages.
       (packages (append (list
                          ;; for HTTPS access
                          nss-certs
                          ;; for user mounts
                          gvfs)
                         %base-packages))

       ;; Add GNOME and Xfce---we can choose at the log-in screen
       ;; by clicking the gear.  Use the "desktop" services, which
       ;; include the X11 log-in service, networking with
       ;; NetworkManager, and more.
       (services (append (list (service gnome-desktop-service-type)
                               (service xfce-desktop-service-type)
                               (set-xorg-configuration
                                (xorg-configuration
                                 (keyboard-layout keyboard-layout))))
                         %desktop-services))

       ;; Allow resolution of '.local' host names with mDNS.
       (name-service-switch %mdns-host-lookup-nss))

   Un sistema gráfico con una selección de gestores de ventanas ligeros
en vez de entornos de escritorio completos podría ser así:

     ;; This is an operating system configuration template
     ;; for a "desktop" setup without full-blown desktop
     ;; environments.

     (use-modules (gnu) (gnu system nss))
     (use-service-modules desktop)
     (use-package-modules bootloaders certs ratpoison suckless wm)
     (use-package-modules bootloaders certs ratpoison suckless wm xorg)

     (operating-system
       (host-name "antelope")
       (timezone "Europe/Paris")
       (locale "en_US.utf8")

       ;; Use the UEFI variant of GRUB with the EFI System
       ;; Partition mounted on /boot/efi.
       (bootloader (bootloader-configuration
                     (bootloader grub-efi-bootloader)
                     (target "/boot/efi")))

       ;; Assume the target root file system is labelled "my-root",
       ;; and the EFI System Partition has UUID 1234-ABCD.
       (file-systems (append
                      (list (file-system
                              (device (file-system-label "my-root"))
                              (mount-point "/")
                              (type "ext4"))
                            (file-system
                              (device (uuid "1234-ABCD" 'fat))
                              (mount-point "/boot/efi")
                              (type "vfat")))
                      %base-file-systems))

       (users (cons (user-account
                     (name "alice")
                     (comment "Bob's sister")
                     (group "users")
                     (supplementary-groups '("wheel" "netdev"
                                             "audio" "video")))
                    %base-user-accounts))

       ;; Add a bunch of window managers; we can choose one at
       ;; the log-in screen with F1.
       (packages (append (list
                          ;; window managers
                          ratpoison i3-wm i3status dmenu
                          ;; terminal emulator
                          xterm
                          ;; for HTTPS access
                          nss-certs)
                         %base-packages))

       ;; Use the "desktop" services, which include the X11
       ;; log-in service, networking with NetworkManager, and more.
       (services %desktop-services)

       ;; Allow resolution of '.local' host names with mDNS.
       (name-service-switch %mdns-host-lookup-nss))

   Este ejemplo se refiere al sistema de ficheros ‘/boot/efi’ por su
UUID ‘1234-ABCD’. Substituya este UUID con el UUID correcto en su
sistema, como el devuelto por la orden ‘blkid’.

   *Note Servicios de escritorio::, para la lista exacta de servicios
proporcionados por ‘%desktop-services’. *Note Certificados X.509::, para
información sobre el paquete ‘nss-certs’ usado aquí.

   De nuevo, ‘%desktop-services’ es simplemente una lista de objetos de
servicios. Si desea borrar servicios de aquí, puede hacerlo usando
procedimientos de filtrado de listas (*note (guile)SRFI-1 Filtering and
Partitioning::). Por ejemplo, la siguiente expresión devuelve una lista
que contiene todos los servicios en ‘%desktop-services’ excepto el
servicio Avahi:

     (remove (lambda (service)
               (eq? (service-kind service) avahi-service-type))
             %desktop-services)

Instanciación del sistema
-------------------------

Asumiendo que la declaración de ‘operating-system’ se encuentra en el
fichero ‘mi-configuración-del-sistema.scm’, la orden ‘guix system
mi-conf-del-sistema.scm’ instancia esa configuración, y la convierte en
la entrada predeterminada de GRUB en el arranque (*note Invocación de
guix system::).

   La manera habitual de cambiar la configuración del sistema es
actualizar este fichero y volver a ejecutar ‘guix system reconfigure’.
Nunca se deberían tocar los ficheros en ‘/etc’ o ejecutar órdenes que
modifiquen el estado del sistema como ‘useradd’ o ‘grub-install’. De
hecho, debe evitarlo ya que no únicamente anularía su garantía sino que
también le impediría volver a una versión previa de su sistema, en caso
de necesitarlo.

   Hablando de vuelta atrás, cada vez que ejecuta ‘guix system
reconfigure’ se crea una nueva “generación” del sistema—sin modificar o
borrar generaciones previas. Las generaciones previas tienen una entrada
en el menú del cargador de arranque, lo que permite arrancarlas en caso
de que algo funcionase mal en las últimas generaciones. Tranquilizador,
¿no? La orden ‘guix system list-generations’ enumera las generaciones
del sistema disponibles en el disco. Es también posible volver a una
versión previa con las órdenes ‘guix system roll-back’ y ‘guix system
switch-generation’.

   Aunque la orden ‘guix system reconfigure’ no modificará las
generaciones previas, debe tener cuidado cuando la generación actual no
es la última (por ejemplo, después de invocar ‘guix system roll-back’),
ya que la operación puede sobreescribir una generación posterior (*note
Invocación de guix system::).

La interfaz programática
------------------------

A nivel Scheme, el grueso de una declaración ‘operating-system’ se
instancia con el siguiente procedimiento monádico (*note La mónada del
almacén::):

 -- Procedimiento monádico: operating-system-derivation so
     Devuelve una derivación que construye SO, un objeto
     ‘operating-system’ (*note Derivaciones::).

     La salida de la derivación es un único directorio que hace
     referencia a todos los paquetes, ficheros de configuración y otros
     ficheros auxiliares necesarios para instanciar SO.

   Este procedimiento se proporciona por el módulo ‘(gnu system)’. Junto
con ‘(gnu services)’ (*note Servicios::), este módulo contiene los
entresijos del sistema Guix. ¡Asegúrese de echarle un vistazo!


File: guix.es.info,  Node: Referencia de operating-system,  Next: Sistemas de ficheros,  Prev: Uso de la configuración del sistema,  Up: Configuración del sistema

8.2 Referencia de ‘operating-system’
====================================

Esta sección resume todas las opciones disponibles en las declaraciones
de ‘operating-system’ (*note Uso de la configuración del sistema::).

 -- Tipo de datos: operating-system
     Este es el tipo de datos que representa la configuración del
     sistema operativo. Con ello queremos decir toda la configuración
     global del sistema, no la configuración específica de las usuarias
     (*note Uso de la configuración del sistema::).

     ‘kernel’ (default: ‘linux-libre’)
          The package object of the operating system kernel to use(1).

     ‘hurd’ (default: ‘#f’)
          The hurd to be started by the kernel. This is required to
          build an experimental vm-image for the Hurd and requires using
          ‘kernel’ GNU mach as well as other specific operating system
          overrides.

     ‘kernel-loadable-modules’ (predeterminados: ‘'()’)
          Una lista de objetos (habitualmente paquetes) desde los que se
          obtendrán los módulos del núcleo–por ejemplo ‘(list
          ddcci-driver-linux)’.

     ‘kernel-arguments’ (default: ‘%default-kernel-arguments’)
          Lista de cadenas o expresiones-G que representan parámetros
          adicionales a pasar en la línea de órdenes del núcleo—por
          ejemplo, ‘("console=ttyS0")’.

     ‘bootloader’
          El objeto de configuración del cargador de arranque del
          sistema. *Note Configuración del gestor de arranque::.

     ‘label’
          Es una etiqueta (una cadena) con la que aparecerá en el menú
          del cargador de arranque. La etiqueta predeterminada incluye
          el nombre y la versión del núcleo.

     ‘keyboard-layout’ (predeterminada: ‘#f’)
          Este campo especifica la distribución de teclado usada para la
          consola. Puede ser o bien ‘#f’, en cuyo caso se usa la
          distribución predeterminada (normalmente Inglés de EEUU), o un
          registro ‘<keyboard-layout>’.

          Esta distribución de teclado se hace efectiva tan pronto el
          núcleo haya arrancado. Por ejemplo, la distribución de teclado
          está en efecto cuando introduzca una contraseña si su sistema
          de ficheros raíz se encuentra en un dispositivo traducido
          ‘luks-device-mapping’ (*note Dispositivos traducidos::).

               Nota: Esto _no_ especifica la distribución de teclado
               usada por el cargador de arranque, ni tampoco la usada
               por el servidor gráfico. *Note Configuración del gestor
               de arranque::, para información sobre cómo especificar la
               distribución de teclado del cargador de arranque. *Note
               Sistema X Window::, para información sobre cómo
               especificar la distribución de teclado usada por el
               sistema de ventanas X.

     ‘initrd-modules’ (predeterminados: ‘%base-initrd-modules’)
          La lista de módulos del núcleo Linux que deben estar
          disponibles en el disco inicial de RAM. *Note Disco en RAM
          inicial::.

     ‘initrd’ (predeterminado: ‘base-initrd’)
          Un procedimiento que devuelve un disco inicial de RAM para el
          núcleo Linux. Este campo se proporciona para permitir
          personalizaciones de bajo nivel y no debería ser necesario
          para un uso habitual. *Note Disco en RAM inicial::.

     ‘firmware’ (predeterminado: ‘%base-firmware’)
          Lista de paquetes de firmware que pueden ser cargados por el
          núcleo del sistema operativo.

          El valor predeterminado incluye el firmware necesario para
          dispositivos WiFi basados en Atheros y Broadcom (módulos
          Linux-libre ‘ath9k’ y ‘b43-open’, respectivamente). *Note
          Consideraciones sobre el hardware::, para más información
          sobre hardware soportado.

     ‘host-name’
          El nombre de la máquina.

     ‘hosts-file’
          Un objeto tipo-fichero (*note objetos “tipo-fichero”:
          Expresiones-G.) para ser usado como ‘/etc/hosts’ (*note
          (libc)Host Names::). El predeterminado es un fichero con
          entradas para ‘localhost’ y HOST-NAME.

     ‘mapped-devices’ (predeterminados: ‘'()’)
          Una lista de dispositivos traducidos. *Note Dispositivos
          traducidos::.

     ‘file-systems’
          Una lista de sistemas de ficheros. *Note Sistemas de
          ficheros::.

     ‘swap-devices’ (predeterminados: ‘'()’)
          Una lista de cadenas que identifiquen dispositivos o ficheros
          usados como “espacio de intercambio” (*note (libc)Memory
          Concepts::). Por ejemplo ‘'("/dev/sda3")’ o
          ‘'("/fichero-intercambio")’. Es posible especificar un fichero
          de intercambio en un sistema de ficheros en un dispositivo
          traducido, siempre que la traducción y el sistema de ficheros
          se especifiquen también. *Note Dispositivos traducidos:: y
          *note Sistemas de ficheros::.

     ‘users’ (predeterminadas: ‘%base-user-accounts’)
     ‘groups’ (predeterminados: ‘%base-groups’)
          Lista de cuentas de usuaria y grupos. *Note Cuentas de
          usuaria::.

          Si la lista de ‘usuarias’ carece de una cuenta de usuaria con
          UID 0, una cuenta “root” con UID 0 se añade automáticamente.

     ‘skeletons’ (predeterminados: ‘(default-skeletons)’)
          Una lista de tuplas de nombre de fichero de destino/objeto
          tipo-fichero (*note objetos “tipo-fichero”: Expresiones-G.).
          Estos son los ficheros de esqueleto que se añadirán al
          directorio de las cuentas de usuaria que se creen.

          Por ejemplo, un valor válido puede parecer algo así:

               `((".bashrc" ,(plain-file "bashrc" "echo Hola\n"))
                 (".guile" ,(plain-file "guile"
                                        "(use-modules (ice-9 readline))
                                         (activate-readline)")))

     ‘issue’ (predeterminado: ‘%default-issue’)
          Una cadena que denota el contenido del fichero ‘/etc/issue’,
          que se muestra cuando las usuarias ingresan al sistema en una
          consola de texto.

     ‘packages’ (predeterminados: ‘%base-packages’)
          El conjunto de paquetes instalados en el perfil global, que es
          accesible en ‘/run/current-system/profile’.

          El conjunto predeterminado incluye utilidades básicas y es una
          buena práctica instalar utilidades no-básicas en los perfiles
          de las usuarias (*note Invocación de guix package::).

     ‘timezone’
          Una cadena que identifica la zona horaria—por ejemplo,
          ‘"Europe/Paris"’.

          Puede ejecutar la orden ‘tzselect’ para encontrar qué cadena
          de zona horaria corresponde con su región. Elegir una zona
          horaria no válida provoca un fallo en ‘guix system’.

     ‘locale’ (predeterminado: ‘"en_US.utf8"’)
          El nombre de la localización predeterminada (*note
          (libc)Locale Names::). *Note Localizaciones::, para más
          información.

     ‘locale-definitions’ (predeterminadas: ‘%default-locale-definitions’)
          La lista de definiciones de localizaciones a compilar y que
          puede ser usada en tiempo de ejecución. *Note
          Localizaciones::.

     ‘locale-libcs’ (predeterminadas: ‘(list GLIBC)’)
          La lista de paquetes GNU libc cuyos datos de localización y
          herramientas son usadas para las definiciones de
          localizaciones. *Note Localizaciones::, para consideraciones
          de compatibilidad que justifican esta opción.

     ‘name-service-switch’ (predeterminado: ‘%default-nss’)
          Configuración del selector de servicios de nombres de libc
          (NSS)—un objeto ‘<name-service-switch>’. *Note Selector de
          servicios de nombres::, para detalles.

     ‘services’ (predeterminados: ‘%base-services’)
          Una lista de objetos service denotando los servicios del
          sistema. *Note Servicios::.

     ‘essential-services’ (predeterminados: ...)
          La lista de “servicios esenciales”—es decir, cosas como
          instancias de ‘system-service-type’ y ‘host-name-service-type’
          (*note Referencia de servicios::), las cuales se derivan de su
          definición de sistema operativo en sí. Como usuaria _nunca_
          debería modificar este campo.

     ‘pam-services’ (predeterminados: ‘(base-pam-services)’)
          Servicios de los “módulos de identificación conectables” (PAM)
          de Linux.

     ‘setuid-programs’ (default: ‘%setuid-programs’)
          Lista de expresiones-G con valores de cadena que denotan los
          programas setuid. *Note Programas con setuid::.

     ‘sudoers-file’ (default: ‘%sudoers-specification’)
          El contenido de ‘/etc/sudoers’ como un objeto tipo-fichero
          (*note ‘local-file’ y ‘plain-file’: Expresiones-G.).

          Este fichero especifica qué usuarias pueden usar la orden
          ‘sudo’, lo que se les permite hacer y qué privilegios pueden
          obtener. El comportamiento predefinido es que únicamente
          ‘root’ y los miembros del grupo ‘wheel’ pueden usar ‘sudo’.

      -- Tipo de datos: this-operating-system
          Cuando se usa en el _ámbito léxico_ de un campo de una
          definición de sistema operativo, este identificador está
          enlazado al sistema operativo en definición.

          El siguiente ejemplo muestra cómo hacer referencia al sistema
          operativo en definición en la definición del campo ‘label’:

               (use-modules (gnu) (guix))

               (operating-system
                 ;; ...
                 (label (package-full-name
                         (operating-system-kernel this-operating-system))))

          Es un error hacer referencia a ‘this-operating-system’ fuera
          de una definición de sistema operativo.

   ---------- Footnotes ----------

   (1) Currently only the Linux-libre kernel is fully supported. Using
GNU mach in combination with a ‘hurd’ is experimental and only available
when building a vm-image.


File: guix.es.info,  Node: Sistemas de ficheros,  Next: Dispositivos traducidos,  Prev: Referencia de operating-system,  Up: Configuración del sistema

8.3 Sistemas de ficheros
========================

La lista de sistemas de ficheros que deben montarse se especifica en el
campo ‘file-systems’ de la declaración del sistema operativo (*note Uso
de la configuración del sistema::). Cada sistema de ficheros se declara
usando la forma ‘file-system’, como en el siguiente ejemplo:

     (file-system
       (mount-point "/home")
       (device "/dev/sda3")
       (type "ext4"))

   Como es habitual, algunos de los campos son obligatorios—aquellos
mostrados en el ejemplo previo—mientras que otros pueden omitirse. Se
describen a continuación.

 -- Tipo de datos: file-system
     Objetos de este tipo representan los sistemas de ficheros a montar.
     Contienen los siguientes campos:

     ‘type’
          Este campo es una cadena que especifica el tipo de sistema de
          ficheros—por ejemplo, ‘"ext4"’.

     ‘mount-point’
          Designa la ruta donde el sistema de ficheros debe montarse.

     ‘device’
          Nombra la “fuente” del sistema de ficheros. Puede ser una de
          estas tres opciones: una etiqueta de sistema de ficheros, un
          UUID de sistema de ficheros o el nombre de un nodo ‘/dev’. Las
          etiquetas y UUID ofrecen una forma de hacer referencia a
          sistemas de ficheros sin codificar su nombre de dispositivo
          actual(1).

          Las etiquetas del sistema de ficheros se crean mediante el uso
          del procedimiento ‘file-system-label’, los UUID se crean
          mediante el uso de ‘uuid’ y los nodos ‘/dev’ son simples
          cadenas. A continuación se proporciona un ejemplo de un
          sistema de ficheros al que se hace referencia mediante su
          etiqueta, como es mostrada por la orden ‘e2label’:

               (file-system
                 (mount-point "/home")
                 (type "ext4")
                 (device (file-system-label "mi-home")))

          Los UUID se convierten dede su representación en forma de
          cadena (como se muestra con la orden ‘tune2fs -l’) mediante el
          uso de la forma ‘uuid’(2), como sigue:

               (file-system
                 (mount-point "/home")
                 (type "ext4")
                 (device (uuid "4dab5feb-d176-45de-b287-9b0a6e4c01cb")))

          Cuando la fuente de un sistema de ficheros es un dispositivo
          traducido (*note Dispositivos traducidos::), su campo ‘device’
          _debe_ hacer referencia al nombre del dispositivo
          traducido—por ejemplo, ‘"/dev/mapper/particion-raiz"’. Esto es
          necesario para que el sistema sepa que el montaje del sistema
          de ficheros depende del establecimiento de la traducción de
          dispositivos correspondiente.

     ‘flags’ (predeterminadas: ‘'()’)
          Es una lista de símbolos que indican opciones del montado. Las
          opciones reconocidas incluyen ‘read-only’(3), ‘bind-mount’(4),
          ‘no-dev’ (prohibición del acceso a ficheros especiales),
          ‘no-suid’ (ignora los bits setuid y setgid), ‘no-atime’ (no
          actualiza la marca de tiempo del acceso a ficheros),
          ‘strict-atime’ (actualiza la marca de tiempo del acceso a
          ficheros), ‘lazy-time’ (únicamente actualiza la marca de
          tiempo en la versión en memoria del nodo-i) y ‘no-exec’ (no
          permite de la ejecución de programas). *Note
          (libc)Mount-Unmount-Remount::, para más información sobre
          estas opciones.

     ‘options’ (predeterminadas: ‘#f’)
          This is either ‘#f’, or a string denoting mount options passed
          to the file system driver. *Note
          (libc)Mount-Unmount-Remount::, for details and run ‘man 8
          mount’ for options for various file systems. Note that the
          ‘file-system-options->alist’ and ‘alist->file-system-options’
          procedures from ‘(gnu system file-systems)’ can be used to
          convert file system options given as an association list to
          the string representation, and vice-versa.

     ‘mount?’ (predeterminado: ‘#t’)
          Este valor indica si debe montarse el sistema de ficheros
          automáticamente al iniciar el sistema. Cuando se establece
          como ‘#f’, el sistema de ficheros tiene una entrada en
          ‘/etc/fstab’ (el cual es leído por la orden ‘mount’) pero no
          se montará automáticamente.

     ‘needed-for-boot?’ (predeterminado: ‘#f’)
          Este valor lógico indica si el sistema de ficheros es
          necesario para el arranque. Si es verdadero, el sistema de
          ficheros se monta al cargar el disco inicial de RAM (initrd).
          Este es siempre el caso, por ejemplo, para el sistema de
          ficheros raíz.

     ‘check?’ (predeterminado: ‘#t’)
          Este valor lógico indica si el sistema de ficheros se debe
          comprobar en busca de errores antes de montarse.

     ‘create-mount-point?’ (predeterminado: ‘#f’)
          Cuando es verdadero, el punto de montaje es creado si no
          existía previamente.

     ‘dependencies’ (predeterminadas: ‘'()’)
          Una lista de objetos ‘<file-system>’ o ‘<mapped-device>’ que
          representan sistemas de ficheros que deben montarse o
          dispositivos traducidos que se deben abrir antes (y desmontar
          o cerrar después) que el declarado.

          Como ejemplo, considere la siguiente jerarquía de montajes:
          ‘/sys/fs/cgroup’ es una dependencia de ‘/sys/fs/cgroup/cpu’ y
          ‘/sys/fs/cgroup/memory’.

          Otro ejemplo es un sistema de ficheros que depende de un
          dispositivo traducido, por ejemplo una partición cifrada
          (*note Dispositivos traducidos::).

   El módulo ‘(gnu system file-systems)’ exporta las siguientes
variables útiles.

 -- Variable Scheme: %base-file-systems
     These are essential file systems that are required on normal
     systems, such as ‘%pseudo-terminal-file-system’ and
     ‘%immutable-store’ (see below). Operating system declarations
     should always contain at least these.

 -- Variable Scheme: %pseudo-terminal-file-systems
     El sistema de ficheros que debe montarse como ‘/dev/pts’. Permite
     la creación de “pseudoterminales” a través de ‘openpty’ y funciones
     similares (*note (libc)Pseudo-Terminals::). Los pseudoterminales
     son usados por emuladores de terminales como ‘xterm’.

 -- Variable Scheme: %shared-memory-file-system
     Este sistema de ficheros se monta como ‘/dev/shm’ y se usa para
     permitir el uso de memoria compartida entre procesos (*note
     ‘shm_open’: (libc)Memory-mapped I/O.).

 -- Variable Scheme: %immutable-store
     Este sistema de ficheros crea un montaje enlazado (“bind-mount”) de
     ‘/gnu/store’, permitiendo solo el acceso de lectura para todas las
     usuarias incluyendo a ‘root’. Esto previene modificaciones
     accidentales por software que se ejecuta como ‘root’ o por las
     administradoras del sistema.

     El daemon sí es capaz de escribir en el almacén: vuelve a montar
     ‘/gnu/store’ en modo lectura-escritura en su propio “espacio de
     nombres”.

 -- Variable Scheme: %binary-format-file-system
     El sistema de ficheros ‘binfmt_misc’, que permite que el manejo de
     tipos de ficheros ejecutables arbitrarios se delegue al espacio de
     usuaria. Necesita la carga del módulo del núcleo ‘binfmt.ko’.

 -- Variable Scheme: %fuse-control-file-system
     El sistema de ficheros ‘fusectl’, que permite a usuarias sin
     privilegios montar y desmontar sistemas de ficheros de espacio de
     usuaria FUSE. Necesita la carga del módulo del núcleo ‘fuse.ko’.

* Menu:

* Btrfs file system::

   ---------- Footnotes ----------

   (1) Fíjese que, aunque es tentador usa ‘/dev/disk/by-uuid’ y nombres
de dispositivo similares para obtener el mismo resultado, no es lo
recomendado: estos nodo especiales de dispositivos se crean por el
daemon udev y puede no estar disponible cuando el dispositivo sea
montado.

   (2) La forma ‘uuid’ espera un UUID de 16 bytes como se define en la
RFC 4122 (https://tools.ietf.org/html/rfc4122). Este es el formato de
UUID que usan la familia de sistemas de ficheros ext2 y otros, pero es
diferente de los “UUID” de los sistemas de ficheros FAT, por ejemplo.

   (3) NdT: modo de sólo lectura.

   (4) NdT: montaje enlazado.


File: guix.es.info,  Node: Btrfs file system,  Up: Sistemas de ficheros

8.3.1 Btrfs file system
-----------------------

The Btrfs has special features, such as subvolumes, that merit being
explained in more details. The following section attempts to cover basic
as well as complex uses of a Btrfs file system with the Guix System.

   In its simplest usage, a Btrfs file system can be described, for
example, by:

     (file-system
       (mount-point "/home")
       (type "btrfs")
       (device (file-system-label "my-home")))

   The example below is more complex, as it makes use of a Btrfs
subvolume, named ‘rootfs’. The parent Btrfs file system is labeled
‘my-btrfs-pool’, and is located on an encrypted device (hence the
dependency on ‘mapped-devices’):

     (file-system
       (device (file-system-label "my-btrfs-pool"))
       (mount-point "/")
       (type "btrfs")
       (options "subvol=rootfs")
       (dependencies mapped-devices))

   Some bootloaders, for example GRUB, only mount a Btrfs partition at
its top level during the early boot, and rely on their configuration to
refer to the correct subvolume path within that top level. The
bootloaders operating in this way typically produce their configuration
on a running system where the Btrfs partitions are already mounted and
where the subvolume information is readily available. As an example,
‘grub-mkconfig’, the configuration generator command shipped with GRUB,
reads ‘/proc/self/mountinfo’ to determine the top-level path of a
subvolume.

   The Guix System produces a bootloader configuration using the
operating system configuration as its sole input; it is therefore
necessary to extract the subvolume name on which ‘/gnu/store’ lives (if
any) from that operating system configuration. To better illustrate,
consider a subvolume named ’rootfs’ which contains the root file system
data. In such situation, the GRUB bootloader would only see the top
level of the root Btrfs partition, e.g.:

     /                   (top level)
     ├── rootfs          (subvolume directory)
         ├── gnu         (normal directory)
             ├── store   (normal directory)
     [...]

   Thus, the subvolume name must be prepended to the ‘/gnu/store’ path
of the kernel, initrd binaries and any other files referred to in the
GRUB configuration that must be found during the early boot.

   The next example shows a nested hierarchy of subvolumes and
directories:

     /                   (top level)
     ├── rootfs          (subvolume)
         ├── gnu         (normal directory)
             ├── store   (subvolume)
     [...]

   This scenario would work without mounting the ’store’ subvolume.
Mounting ’rootfs’ is sufficient, since the subvolume name matches its
intended mount point in the file system hierarchy. Alternatively, the
’store’ subvolume could be referred to by setting the ‘subvol’ option to
either ‘/rootfs/gnu/store’ or ‘rootfs/gnu/store’.

   Finally, a more contrived example of nested subvolumes:

     /                           (top level)
     ├── root-snapshots          (subvolume)
         ├── root-current        (subvolume)
             ├── guix-store      (subvolume)
     [...]

   Here, the ’guix-store’ subvolume doesn’t match its intended mount
point, so it is necessary to mount it. The subvolume must be fully
specified, by passing its file name to the ‘subvol’ option. To
illustrate, the ’guix-store’ subvolume could be mounted on ‘/gnu/store’
by using a file system declaration such as:

     (file-system
       (device (file-system-label "btrfs-pool-1"))
       (mount-point "/gnu/store")
       (type "btrfs")
       (options "subvol=root-snapshots/root-current/guix-store,\
     compress-force=zstd,space_cache=v2"))


File: guix.es.info,  Node: Dispositivos traducidos,  Next: Cuentas de usuaria,  Prev: Sistemas de ficheros,  Up: Configuración del sistema

8.4 Dispositivos traducidos
===========================

El núcleo Linux tiene una noción de “traducción de dispositivos”: un
dispositivo de bloques, como una partición de disco duro, puede
“traducirse” en otro dispositivo, habitualmente en ‘/dev/mapper/’, con
un procesamiento adicional sobre los datos que fluyen a través de
ella(1). Un ejemplo típico es la traducción de dispositivos para el
cifrado: todas las escrituras en el dispositivo traducido se cifran, y
todas las lecturas se descifran, de forma transparente. Guix extiende
esta noción considerando cualquier dispositivo o conjunto de
dispositivos que son “transformados” de alguna manera para crear un
nuevo dispositivo; por ejemplo, los dispositivos RAID se obtienen
“ensamblando” otros dispositivos, como discos duros o particiones, en
uno nuevo que se comporta como una partición. Otros ejemplos, todavía no
implementados, son los volúmenes lógicos LVM.

   Los dispositivos traducidos se declaran mediante el uso de la forma
‘mapped-device’, definida a continuación; ejemplos más adelante.

 -- Tipo de datos: mapped-device
     Objetos de este tipo representan traducciones de dispositivo que se
     llevarán a cabo cuando el sistema arranque.

     ‘source’
          Puede ser tanto una cadena que especifica el nombre de un
          dispositivo de bloques a traducir, como ‘"/dev/sda3"’, o una
          lista de dichas cadenas cuando varios dispositivos necesitan
          ser ensamblados para crear uno nuevo.

     ‘target’
          Esta cadena especifica el nombre del dispositivo traducido
          resultante. Para traductores del núcleo como dispositivos de
          cifrado del tipo ‘luks-device-mapping’, especificar
          ‘"mi-particion"’ produce la creación del dispositivo
          ‘"/dev/mapper/mi-particion"’. Para dispositivos RAID de tipo
          ‘raid-device-mapping’, el nombre del dispositivo completo como
          ‘"/dev/md0"’ debe ser proporcionado.

     ‘type’
          Debe ser un objeto ‘mapped-device-kind’, que especifica cómo
          SOURCE se traduce a TARGET.

 -- Variable Scheme: luks-device-mapping
     Define el cifrado de bloques LUKS mediante el uso de la orden
     ‘cryptsetup’ del paquete del mismo nombre. Depende del módulo
     ‘dm-crypt’ del núcleo Linux.

 -- Variable Scheme: raid-device-mapping
     Define un dispositivo RAID, el cual se ensambla mediante el uso de
     la orden ‘mdadm’ del paquete del mismo nombre. Requiere la carga
     del módulo del núcleo Linux para el nivel RAID apropiado, como
     ‘raid456’ para RAID-4, RAID-5 o RAID-6, o ‘raid10’ para RAID-10.

   El siguiente ejemplo especifica una traducción de ‘/dev/sda3’ a
‘/dev/mapper/home’ mediante el uso de LUKS—la configuración de claves
unificada de Linux (https://gitlab.com/cryptsetup/cryptsetup), un
mecanismo estándar para cifrado de disco. El dispositivo
‘/dev/mapper/home’ puede usarse entonces como el campo ‘device’ de una
declaración ‘file-system’ (*note Sistemas de ficheros::).

     (mapped-device
       (source "/dev/sda3")
       (target "home")
       (type luks-device-mapping))

   De manera alternativa, para independizarse de la numeración de
dispositivos, puede obtenerse el UUID LUKS (“identificador único”) del
dispositivo fuente con una orden así:

     cryptsetup luksUUID /dev/sda3

   y usarlo como sigue:

     (mapped-device
       (source (uuid "cb67fc72-0d54-4c88-9d4b-b225f30b0f44"))
       (target "home")
       (type luks-device-mapping))

   También es deseable cifrar el espacio de intercambio, puesto que el
espacio de intercambio puede contener información sensible. Una forma de
conseguirlo es usar un fichero de intercambio en un sistema de ficheros
en un dispositivo traducido a través del cifrado LUKS. *Note
Particionado del disco: Preparación para la instalación, para un
ejemplo.

   Un dispositivo RAID formado por las particiones ‘/dev/sda1’ y
‘/dev/sdb1’ puede declararse como se muestra a continuación:

     (mapped-device
       (source (list "/dev/sda1" "/dev/sdb1"))
       (target "/dev/md0")
       (type raid-device-mapping))

   El dispositivo ‘/dev/md0’ puede usarse entonces como el campo
‘device’ de una declaración ‘file-system’ (*note Sistemas de
ficheros::). Fíjese que no necesita proporcionar el nivel RAID; se
selecciona durante la creación inicial y formato del dispositivo RAID y
después se determina automáticamente.

   ---------- Footnotes ----------

   (1) Fíjese que GNU Hurd no diferencia entre el concepto de un
“dispositivo traducido” y el de un sistema de ficheros: ambos se reducen
a _traducir_ operaciones de entrada/salida realizadas en un fichero a
operaciones en su almacenamiento subyacente. Por tanto, Hurd implementa
dispositivos traducidos, como sistemas de ficheros, usando el mecanismo
genérico de “traducción” (*note (hurd)Translators::).


File: guix.es.info,  Node: Cuentas de usuaria,  Next: Distribución de teclado,  Prev: Dispositivos traducidos,  Up: Configuración del sistema

8.5 Cuentas de usuaria
======================

Los grupos y cuentas de usuaria se gestionan completamente a través de
la declaración ‘operating-system’. Se especifican con las formas
‘user-account’ y ‘user-group’:

     (user-account
       (name "alicia")
       (group "users")
       (supplementary-groups '("wheel"   ;permite usar sudo, etc.
                               "audio"   ;tarjeta de sonido
                               "video"   ;dispositivos de vídeo como cámaras
                               "cdrom")) ;el veterano CD-ROM
       (comment "hermana de Roberto")
       (home-directory "/home/alicia"))

   Durante el arranque o tras la finalización de ‘guix system
reconfigure’, el sistema se asegura de que únicamente las cuentas de
usuaria y grupos especificados en la declaración ‘operating-system’
existen, y con las propiedades especificadas. Por tanto, la creación o
modificación de cuentas o grupos realizadas directamente invocando
órdenes como ‘useradd’ se pierden al reconfigurar o reiniciar el
sistema. Esto asegura que el sistema permanece exactamente como se
declaró.

 -- Tipo de datos: user-account
     Objetos de este tipo representan cuentas de usuaria. Los siguientes
     miembros pueden ser especificados:

     ‘name’
          El nombre de la cuenta de usuaria.

     ‘group’
          Este es el nombre (una cadena) o identificador (un número) del
          grupo de usuarias al que esta cuenta pertenece.

     ‘supplementary-groups’ (predeterminados: ‘'()’)
          Opcionalmente, esto puede definirse como una lista de nombres
          de grupo a los que esta cuenta pertenece.

     ‘uid’ (predeterminado: ‘#f’)
          Este es el ID de usuaria para esta cuenta (un número), o ‘#f’.
          En el último caso, un número es seleccionado automáticamente
          por el sistema cuando la cuenta es creada.

     ‘comment’ (predeterminado: ‘""’)
          Un comentario sobre la cuenta, como el nombre completo de la
          propietaria.

     ‘home-directory’
          Este es el nombre del directorio de usuaria de la cuenta.

     ‘create-home-directory?’ (predeterminado: ‘#t’)
          Indica si el directorio de usuaria de esta cuenta debe ser
          creado si no existe todavía.

     ‘shell’ (predeterminado: Bash)
          Esto es una expresión-G denotando el nombre de fichero de un
          programa que será usado como shell (*note Expresiones-G::).

     ‘system?’ (predeterminado: ‘#f’)
          Este valor lógico indica si la cuenta es una cuenta “del
          sistema”. Las cuentas del sistema se tratan a veces de forma
          especial; por ejemplo, los gestores gráficos de inicio no las
          enumeran.

     ‘password’ (predeterminada: ‘#f’)
          Normalmente debería dejar este campo a ‘#f’, inicializar la
          contraseña de usuaria como ‘root’ con la orden ‘passwd’, y
          entonces dejar a las usuarias cambiarla con ‘passwd’. Las
          contraseñas establecidas con ‘passwd’ son, por supuesto,
          preservadas entre reinicio y reinicio, y entre
          reconfiguraciones.

          Si usted _realmente quiere_ tener una contraseña prefijada
          para una cuenta, entonces este campo debe contener la
          contraseña cifrada, como una cadena. Puede usar el
          procedimiento ‘crypt’ para este fin:

               (user-account
                 (name "carlos")
                 (group "users")

                 ;; Especifica una contraseña inicial mediante un hash SHA-512.
                 (password (crypt "ContraseñaInicial!" "$6$abc")))

               Nota: El hash de esta contraseña inicial estará
               disponible en un fichero en ‘/gnu/store’, legible por
               todas las usuarias, por lo que este método debe usarse
               con precaución.

          *Note (libc)Passphrase Storage::, para más información sobre
          el cifrado de contraseñas, y *note (guile)Encryption::, para
          información sobre el procedimiento de Guile ‘crypt’.

   Las declaraciones de grupos incluso son más simples:

     (user-group (name "estudiantes"))

 -- Tipo de datos: user-group
     Este tipo es para grupos de usuarias. Hay únicamente unos pocos
     campos:

     ‘name’
          El nombre del grupo.

     ‘id’ (predeterminado: ‘#f’)
          El identificador del grupo (un número). Si es ‘#f’, un nuevo
          número es reservado automáticamente cuando se crea el grupo.

     ‘system?’ (predeterminado: ‘#f’)
          Este valor booleano indica si el grupo es un grupo “del
          sistema”. Los grupos del sistema tienen identificadores
          numéricos bajos.

     ‘password’ (predeterminada: ‘#f’)
          ¿Qué? ¿Los grupos de usuarias pueden tener una contraseña?
          Bueno, aparentemente sí. A menos que sea ‘#f’, este campo
          especifica la contraseña del grupo.

   Por conveniencia, una variable contiene una lista con todos los
grupos de usuarias básicos que se puede esperar:

 -- Variable Scheme: %base-groups
     Esta es la lista de grupos de usuarias básicos que las usuarias y/o
     los paquetes esperan que estén presentes en el sistema. Esto
     incluye grupos como “root”, “wheel” y “users”, así como grupos
     usados para controlar el acceso a dispositivos específicos como
     “audio”, “disk” y “cdrom”.

 -- Variable Scheme: %base-user-accounts
     Esta es la lista de cuentas de usuaria básicas que los programas
     pueden esperar encontrar en un sistema GNU/Linux, como la cuenta
     “nobody”.

     Fíjese que la cuenta de “root” no se incluye aquí. Es un caso
     especial y se añade automáticamente esté o no especificada.


File: guix.es.info,  Node: Distribución de teclado,  Next: Localizaciones,  Prev: Cuentas de usuaria,  Up: Configuración del sistema

8.6 Distribución de teclado
===========================

Para especificar qué hace cada tecla de su teclado, necesita decirle al
sistema operativo qué “distribución de teclado” desea usar. La
predeterminada, cuando no se especifica ninguna, es la distribución
QWERTY de 105 teclas para PC de teclado inglés estadounidense. No
obstante, las personas germano-parlantes habitualmente prefieren la
distribución QWERTZ alemana, las franco-parlantes desearán la
distribución AZERTY, etcétera; las hackers pueden preferir Dvorak o
bépo, y pueden incluso desear personalizar más aún el efecto de
determinadas teclas. Esta sección explica cómo hacerlo.

   Hay tres componentes que desearán conocer la distribución de su
teclado:

   • El _cargador de arranque_ puede desear conocer cual es la
     distribución de teclado que desea usar (*note ‘keyboard-layout’:
     Configuración del gestor de arranque.). Esto es útil si desea, por
     ejemplo, asegurarse de que puede introducir la contraseña de
     cifrado de su partición raíz usando la distribución correcta.

   • El _núcleo del sistema operativo_, Linux, la necesitará de manera
     que la consola se configure de manera adecuada (*note
     ‘keyboard-layout’: Referencia de operating-system.).

   • El _servidor gráfico_, habitualmente Xorg, también tiene su propia
     idea de distribución de teclado (*note ‘keyboard-layout’: Sistema X
     Window.).

   Guix le permite configurar las tres distribuciones por separado pero,
afortunadamente, también le permite compartir la misma distribución de
teclado para los tres componentes.

   Las distribuciones de teclado se representan mediante registros
creados con el procedimiento ‘keyboard-layout’ de ‘(gnu system
keyboard)’. A imagen de la extensión de teclado de X (XKB), cada
distribución tiene cuatro atributos: un nombre (habitualmente un código
de idioma como “fi” para finés o “jp” para japonés), un nombre opcional
de variante, un nombre opcional de modelo de teclado y una lista
posiblemente vacía de opciones adicionales. En la mayor parte de los
casos el nombre de la distribución es lo único que le interesará. Aquí
tiene algunos ejemplos:

     ;; La distribución QWERTZ alemana. Se asume un modelo de
     ;; teclado "pc105" estándar.
     (keyboard-layout "de")

     ;; La variante bépo de la distribución francesa.
     (keyboard-layout "fr" "bepo")

     ;; La distribución de teclado para catalán.
     (keyboard-layout "es" "cat")

     ;; Distribución de teclado árabe con "Alt-Shift" para cambiar
     ;; a la distribución de teclado de EEUU.
     (keyboard-layout "ar,us" #:options '("grp:alt_shift_toggle"))

     ;; La distribución de teclado de latinoamérica. Además,
     ;; la tecla "Bloq Mayús" se usa como una tecla "Ctrl"
     ;; adicional, y la tecla "Menú" se usa como una tecla
     ;; "Componer/Compose" para introducir letras acentuadas.
     (keyboard-layout "latam"
                      #:options '("ctrl:nocaps" "compose:menu"))

     ;; La distribución rusa para un teclado ThinkPad.
     (keyboard-layout "ru" #:model "thinkpad")

     ;; La distribución estadounidense internacional, la cual es
     ;; la distribución estadounidense junto a teclas muertas para
     ;; introducir caracteres acentuados. Esta es para un teclado
     ;; Apple MackBook.
     (keyboard-layout "us" "intl" #:model "macbook78")

   Véase el directorio ‘share/X11/xkb’ del paquete ‘xkeyboard-config’
para una lista completa de implementaciones de distribuciones, variantes
y modelos.

   Digamos que desea que su sistema use la distribución de teclado turca
a lo largo de todo su sistema—cargador de arranque, consola y Xorg. Así
es como sería su configuración del sistema:

     ;; Usando la distribución turca para el cargador de
     ;; arranque, la consola y Xorg.

     (operating-system
       ;; ...
       (keyboard-layout (keyboard-layout "tr"))  ;para la consola
       (bootloader (bootloader-configuration
                     (bootloader grub-efi-bootloader)
                     (target "/boot/efi")
                     (keyboard-layout keyboard-layout))) ;para GRUB
       (services (cons (set-xorg-configuration
                         (xorg-configuration             ;para Xorg
                           (keyboard-layout keyboard-layout)))
                       %desktop-services)))

   En el ejemplo previo, para GRUB y para Xorg, simplemente hemos hecho
referencia al campo ‘keyboard-layout’ definido previamente, pero también
podíamos haber hecho referencia a una distribución diferente. El
procedimiento ‘set-xorg-configuration’ comunica la configuración de Xorg
deseada al gestor gráfico de ingreso en el sistema, GDM por omisión.

   Hemos tratado cómo especificar la distribución _predeterminada_ del
teclado de su sistema cuando arranca, pero también la puede modificar en
tiempo de ejecución:

   • Si usa GNOME, su panel de configuración tiene una entrada de
     “Región e Idioma” donde puede seleccionar una o más distribuciones
     de teclado.

   • En Xorg, la orden ‘setxkbmap’ (del paquete con el mismo nombre) le
     permite cambiar la distribución en uso actualmente. Por ejemplo,
     así es como cambiaría a la distribución Dvorak estadounidense:

          setxkbmap us dvorak

   • La orden ‘loadkeys’ cambia la distribución de teclado en efecto en
     la consola Linux. No obstante, tenga en cuenta que ‘loadkeys’ _no_
     usa la categorización de distribuciones de XKB descrita
     previamente. La orden a continuación carga la distribución francesa
     bépo:

          loadkeys fr-bepo


File: guix.es.info,  Node: Localizaciones,  Next: Servicios,  Prev: Distribución de teclado,  Up: Configuración del sistema

8.7 Localizaciones
==================

Una “localización” define convenciones culturales para una lengua y
región del mundo particular (*note (libc)Localizaciones::). Cada
localización tiene un nombre que típicamente tiene la forma de
‘LENGUA_TERRITORIO.CODIFICACIÓN’—por ejemplo, ‘fr_LU.utf8’ designa la
localización para la lengua francesa, con las convenciones culturales de
Luxemburgo, usando la codificación UTF-8.

   Normalmente deseará especificar la localización predeterminada para
la máquina usando el campo ‘locale’ de la declaración ‘operating-system’
(*note ‘locale’: Referencia de operating-system.).

   La localización seleccionada es automáticamente añadida a las
“definiciones de localización” conocidas en el sistema si es necesario,
con su codificación inferida de su nombre—por ejemplo, se asume que
‘bo_CN.utf8’ usa la codificación ‘UTF-8’. Definiciones de localización
adicionales pueden ser especificadas en el campo ‘locale-definitions’ de
‘operating-system’—esto es util, por ejemplo, si la codificación no
puede ser inferida del nombre de la localización. El conjunto
predeterminado de definiciones de localización incluye algunas
localizaciones ampliamente usadas, pero no todas las disponibles, para
ahorrar espacio.

   Por ejemplo, para añadir la localización del frisio del norte para
Alemania, el valor de dicho campo puede ser:

     (cons (locale-definition
             (name "fy_DE.utf8") (source "fy_DE"))
           %default-locale-definitions)

   De mismo modo, para ahorrar espacio, se puede desear que
‘locale-definitions’ contenga únicamente las localizaciones que son
realmente usadas, como en:

     (list (locale-definition
             (name "ja_JP.eucjp") (source "ja_JP")
             (charset "EUC-JP")))

   The compiled locale definitions are available at
‘/run/current-system/locale/X.Y’, where ‘X.Y’ is the libc version, which
is the default location where the GNU libc provided by Guix looks for
locale data. This can be overridden using the ‘LOCPATH’ environment
variable (*note ‘LOCPATH’ and locale packages: locales-and-locpath.).

   La forma ‘locale-definition’ es proporcionada por el módulo ‘(gnu
system locale)’. Los detalles se proporcionan a continuación.

 -- Tipo de datos: locale-definition
     Este es el tipo de datos de una definición de localización.

     ‘name’
          El nombre de la localización. *Note (libc)Locale Names::, para
          más información sobre nombres de localizaciones.

     ‘source’
          El nombre de la fuente para dicha localización. Habitualmente
          es la parte ‘IDIOMA_TERRITORIO’ del nombre de localización.

     ‘charset’ (predeterminado: ‘"UTF-8"’)
          La “codificación de caracteres” o “conjunto de caracteres”
          para dicha localización, como lo define IANA
          (https://www.iana.org/assignments/character-sets).

 -- Variable Scheme: %default-locale-definitions
     Una lista de localizaciones UTF-8 usadas de forma común, usada como
     valor predeterminado del campo ‘locale-definitions’ en las
     declaraciones ‘operating-system’.

     Estas definiciones de localizaciones usan la “codificación
     normalizada” para el fragmento tras el punto en el nombre (*note
     normalized codeset: (libc)Using gettextized software.). Por lo que
     por ejemplo es válido ‘uk_UA.utf8’ pero _no_, digamos,
     ‘uk_UA.UTF-8’.

8.7.1 Consideraciones sobre la compatibilidad de datos de localización
----------------------------------------------------------------------

Las declaraciones ‘operating-system’ proporcionan un campo
‘locale-libcs’ para especificar los paquetes GNU libc que se usarán para
compilar las declaraciones de localizaciones (*note Referencia de
operating-system::). “¿Por qué debo preocuparme?”, puede preguntarse.
Bueno, sucede que el formato binario de los datos de localización es
ocasionalmente incompatible de una versión de libc a otra.

   For instance, a program linked against libc version 2.21 is unable to
read locale data produced with libc 2.22; worse, that program _aborts_
instead of simply ignoring the incompatible locale data(1). Similarly, a
program linked against libc 2.22 can read most, but not all, of the
locale data from libc 2.21 (specifically, ‘LC_COLLATE’ data is
incompatible); thus calls to ‘setlocale’ may fail, but programs will not
abort.

   El “problema” con Guix es que las usuarias tienen mucha libertad:
pueden elegir cuando e incluso si actualizar el software en sus
perfiles, y pueden estar usando una versión de libc diferente de la que
la administradora del sistema usó para construir los datos de
localización comunes a todo el sistema.

   Fortunately, unprivileged users can also install their own locale
data and define ‘GUIX_LOCPATH’ accordingly (*note ‘GUIX_LOCPATH’ and
locale packages: locales-and-locpath.).

   No obstante, es mejor si los datos de localización globales del
sistema en ‘/run/current-system/locale’ se construyen para todas las
versiones de libc realmente en uso en el sistema, de manera que todos
los programas puedan acceder a ellos—esto es especialmente crucial en un
sistema multiusuaria. Para hacerlo, la administradora puede especificar
varios paquetes libc en el campo ‘locale-libcs’ de ‘operating-system’:

     (use-package-modules base)

     (operating-system
       ;; ...
       (locale-libcs (list glibc-2.21 (canonical-package glibc))))

   Este ejemplo llevaría a un sistema que contiene definiciones de
localización tanto para libc 2.21 como para la versión actual de libc en
‘/run/current-system/locale’.

   ---------- Footnotes ----------

   (1) Versions 2.23 and later of GNU libc will simply skip the
incompatible locale data, which is already an improvement.


File: guix.es.info,  Node: Servicios,  Next: Programas con setuid,  Prev: Localizaciones,  Up: Configuración del sistema

8.8 Servicios
=============

Una parte importante de la preparación de una declaración
‘operating-system’ es listar los “servicios del sistema” y su
configuración (*note Uso de la configuración del sistema::). Los
servicios del sistema típicamente son daemon lanzados cuando el sistema
arrancha, u otras acciones necesarias en ese momento—por ejemplo,
configurar el acceso de red.

   Guix tiene una definición amplia de “servicio” (*note Composición de
servicios::), pero muchos servicios se gestionan por GNU Shepherd (*note
Servicios de Shepherd::). En un sistema en ejecución, la orden ‘herd’ le
permite enumerar los servicios disponibles, mostrar su estado,
arrancarlos y pararlos, o realizar otras acciones específicas (*note
(shepherd)Jump Start::). Por ejemplo:

     # herd status

   La orden previa, ejecutada como ‘root’, enumera los servicios
actualmente definidos. La orden ‘herd doc’ muestra una sinopsis del
servicio proporcionado y sus acciones asociadas:

     # herd doc nscd
     Run libc's name service cache daemon (nscd).

     # herd doc nscd action invalidate
     invalidate: Invalidate the given cache--e.g., 'hosts' for host name lookups.

   Las ordenes internas ‘start’, ‘stop’ y ‘restart’ tienen el efecto de
arrancar, parar y reiniciar el servicio, respectivamente. Por ejemplo,
las siguientes órdenes paran el servicio nscd y reinician el servidor
gráfico Xorg:

     # herd stop nscd
     Service nscd has been stopped.
     # herd restart xorg-server
     Service xorg-server has been stopped.
     Service xorg-server has been started.

   Las siguientes secciones documentan los servicios disponibles,
comenzando con los servicios básicos, que pueden ser usados en una
declaración ‘operating-system’.

* Menu:

* Servicios base::           Servicios esenciales del sistema.
* Ejecución de tareas programadas::  El servicio mcron.
* Rotación del registro de mensajes::  El servicio rottlog.
* Servicios de red::         Configuración de red, daemon SSH, etc.
* Sistema X Window::         Interfaz gráfica.
* Servicios de impresión::  Soporte de impresoras locales y remotas.
* Servicios de escritorio::  D-Bus y servicios de escritorio.
* Servicios de sonido::      Servicios de ALSA y Pulseaudio.
* Servicios de bases de datos::  Bases de datos SQL, almacenes de
                                   clave-valor, etc.
* Servicios de correo::      IMAP, POP3, SMTP y todo eso.
* Servicios de mensajería::  Servicios de mensajería.
* Servicios de telefonía::  Servicios de telefonía.
* Servicios de monitorización::  Servicios de monitorización.
* Servicios Kerberos::       Servicios Kerberos.
* Servicios LDAP::           Servicios LDAP.
* Servicios Web::            Servidores Web.
* Servicios de certificados::  Certificados TLS via Let’s Encrypt.
* Servicios DNS::            Daemon de DNS.
* Servicios VPN::            Daemon de VPN.
* Sistema de ficheros en red::  Servicios relacionados con NFS.
* Integración continua::    El servicio Cuirass.
* Servicios de gestión de energía::  Extender la vida de la batería.
* Servicios de audio::       El MPD.
* Servicios de virtualización::  Servicios de virtualización.
* Servicios de control de versiones::  Proporcionar acceso remoto a
                                         repositorios Git.
* Servicios de juegos::      Servidores de juegos.
* Servicio PAM Mount::       Servicio de montado de volúmenes en el ingreso
                               al sistema.
* Servicios de Guix::        Servicios relacionados específicamente con
                               Guix.
* Servicios de Linux::       Servicios asociados al núcleo Linux.
* Hurd Services::            Services specific for a Hurd System.
* Servicios misceláneos::   Otros servicios.


File: guix.es.info,  Node: Servicios base,  Next: Ejecución de tareas programadas,  Up: Servicios

8.8.1 Servicios base
--------------------

El módulo ‘(gnu services base)’ proporciona definiciones para los
servicios básicos que se esperan en el sistema. Los servicios exportados
por este módulo se enumeran a continuación.

 -- Variable Scheme: %base-services
     Esta variable contiene una lista de servicios básicos (*note Tipos
     de servicios y servicios::, para más información sobre los objetos
     servicio) que se pueden esperar en el sistema: un servicio de
     ingreso al sistema (mingetty) en cada tty, syslogd, el daemon de la
     caché del servicio de nombres (nscd), el gestor de dispositivos
     udev, y más.

     Este es el valor predeterminado del campo ‘services’ de las
     declaraciones ‘operating-system’. De manera habitual, cuando se
     personaliza el sistema, es deseable agregar servicios a
     ‘%base-services’, de esta forma:

          (append (list (service avahi-service-type)
                        (service openssh-service-type))
                  %base-services)

 -- Variable Scheme: special-files-service-type
     El servicio que establece “ficheros especiales” como ‘/bin/sh’; una
     instancia suya es parte de ‘%base-services’.

     El valor asociado con servicios ‘special-file-service-type’ debe
     ser una lista de tuplas donde el primer elemento es el “fichero
     especial” y el segundo elemento es su destino. El valor
     predeterminado es:

          `(("/bin/sh" ,(file-append bash "/bin/sh")))

     Si quiere añadir, digamos, ‘/usr/bin/env’ a su sistema, puede
     cambiar su valor por:

          `(("/bin/sh" ,(file-append bash "/bin/sh"))
            ("/usr/bin/env" ,(file-append coreutils "/bin/env")))

     Since this is part of ‘%base-services’, you can use
     ‘modify-services’ to customize the set of special files (*note
     ‘modify-services’: Referencia de servicios.). But the simple way to
     add a special file is via the ‘extra-special-file’ procedure (see
     below).

 -- Procedimiento Scheme: extra-special-file FICHERO DESTINO
     Usa DESTINO como el “fichero especial” FICHERO.

     Por ejemplo, la adición de las siguientes líneas al campo
     ‘services’ de su declaración de sistema operativo genera
     ‘/usr/bin/env’ como un enlace simbólico:

          (extra-special-file "/usr/bin/env"
                              (file-append coreutils "/bin/env"))

 -- Procedimiento Scheme: host-name-service NOMBRE
     Devuelve un servicio que establece el nombre de máquina a NOMBRE.

 -- Variable Scheme: console-font-service-type
     Instala las tipografías proporcionadas en las consolas virtuales
     (tty) especificados (las tipografías se asocian a cada consola
     virtual con el núcleo Linux). El valor de este servicio es una
     lista de pares tty/tipografía. La tipografía puede ser el nombre de
     alguna de las proporcionadas por el paquete ‘kbd’ o cualquier
     parámetro válido para la orden ‘setfont’, como en este ejemplo:

          `(("tty1" . "LatGrkCyr-8x16")
            ("tty2" . ,(file-append
                          font-tamzen
                          "/share/kbd/consolefonts/TamzenForPowerline10x20.psf"))
            ("tty3" . ,(file-append
                          font-terminus
                          "/share/consolefonts/ter-132n"))) ; para HDPI

 -- Procedimiento Scheme: login-service CONFIG
     Devuelve un servicio para ejecutar el ingreso al sistema de acuerdo
     con CONFIG, un objeto ‘<login-configuration>’, que especifica el
     mensaje del día, entre otras cosas.

 -- Tipo de datos: login-configuration
     Este es el tipo de datos que representa la configuración del
     ingreso al sistema.

     ‘motd’
          Un objeto tipo-fichero que contiene el “mensaje del día”.

     ‘allow-empty-passwords?’ (predeterminado: ‘#t’)
          Permite contraseñas vacías por defecto para que las primeras
          usuarias puedan ingresar en el sistema cuando la cuenta de
          “root” está recién creada.

 -- Procedimiento Scheme: mingetty-service CONFIG
     Devuelve un servicio para ejecutar mingetty de acuerdo con CONFIG,
     un objeto ‘<mingetty-configuration>’, que especifica el tty a
     ejecutar entre otras cosas.

 -- Tipo de datos: mingetty-configuration
     Este es el tipo de datos que representa la configuración de
     Mingetty, el cual proporciona la implementación predeterminada de
     ingreso al sistema en las consolas virtuales.

     ‘tty’
          El sistema de la consola en la que se ejecuta este
          Mingetty—por ejemplo, ‘"tty1"’.

     ‘auto-login’ (predeterminado: ‘#f’)
          Cuando sea verdadero, este campo debe ser una cadena que
          denote el nombre de usuaria bajo el cual el sistema ingresa
          automáticamente. Cuando es ‘#f’, se deben proporcionar un
          nombre de usuaria y una contraseña para ingresar en el
          sistema.

     ‘login-program’ (predeterminado: ‘#f’)
          Debe ser ‘#f’, en cuyo caso se usa el programa predeterminado
          de ingreso al sistema (‘login’ de las herramientas Shadow), o
          una expresión-G que determine el nombre del programa de
          ingreso al sistema.

     ‘login-pause?’ (predeterminado: ‘#f’)
          Cuando es ‘#t’ en conjunción con AUTO-LOGIN, la usuaria deberá
          presionar una tecla para lanzar el shell de ingreso al
          sistema.

     ‘mingetty’ (predeterminado: MINGETTY)
          El paquete Mingetty usado.

 -- Procedure Scheme: agetty-service CONFIG
     Devuelve un servicio para ejecutar agetty de acuerdo con CONFIG, un
     objeto ‘<agetty-configuration>’, que especifica el tty a ejecutar
     entre otras cosas.

 -- Tipo de datos: agetty-configuration
     Este es el tipo de datos que representa la configuración de agetty,
     que implementa el ingreso al sistema en las consolas virtuales y
     serie. Véase la página de manual ‘agetty(8)’ para más información.

     ‘tty’
          The name of the console this agetty runs on, as a string—e.g.,
          ‘"ttyS0"’. This argument is optional, it will default to a
          reasonable default serial port used by the kernel Linux.

          Para ello, si hay un valor para una opción ‘agetty.tty’ en la
          línea de órdenes del núcleo, agetty extraerá el nombre del
          dispositivo del puerto serie de allí y usará dicho valor.

          Si no y hay un valor para la opción ‘console’ con un tty en la
          línea de órdenes de Linux, agetty extraerá el nombre del
          dispositivo del puerto serie de allí y usará dicho valor.

          En ambos casos, agetty dejará el resto de configuración de
          dispositivos serie (tasa de transmisión, etc.) sin modificar—a
          la espera de que Linux los haya fijado a los valores
          correctos.

     ‘baud-rate’ (predeterminado: ‘#f’)
          Una cadena que contenga una lista separada por comas de una o
          más tasas de transmisión, en orden descendiente.

     ‘term’ (predeterminado: ‘#f’)
          A string containing the value used for the ‘TERM’ environment
          variable.

     ‘eight-bits?’ (predeterminado: ‘#f’)
          En caso de ser ‘#t’, se asume que el tty permite el paso de 8
          bits, y la detección de paridad está desactivada.

     ‘auto-login’ (predeterminado: ‘#f’)
          Cuando se proporciona un nombre de ingreso al sistema, como
          una cadena, la usuaria especificada ingresará automáticamente
          sin solicitar su nombre de ingreso ni su contraseña.

     ‘no-reset?’ (predeterminado: ‘#f’)
          En caso de ser ‘#t’, no reinicia los modos de control del
          terminal (cflags).

     ‘host’ (predeterminado: ‘#f’)
          This accepts a string containing the “login_host”, which will
          be written into the ‘/var/run/utmpx’ file.

     ‘remote?’ (predeterminado: ‘#f’)
          Cuando se fija a ‘#t’ en conjunción con HOST, se añadirá una
          opción ‘-r’ "fakehost" a la línea de órdenes del programa de
          ingreso al sistema especificado en LOGIN-PROGRAM.

     ‘flow-control?’ (predeterminado: ‘#f’)
          Cuando es ‘#t’, activa el control de flujo hardware (RTS/CTS).

     ‘no-issue?’ (predeterminado: ‘#f’)
          Cuando es ‘#t’, el contenido del fichero ‘/etc/issue’ no se
          mostrará antes de presentar el mensaje de ingreso al sistema.

     ‘init-string’ (predeterminada: ‘#f’)
          Esto acepta una cadena que se enviará al tty o módem antes de
          mandar nada más. Puede usarse para inicializar un modem.

     ‘no-clear?’ (predeterminado: ‘#f’)
          Cuando es ‘#t’, agetty no limpiará la pantalla antes de
          mostrar el mensaje de ingreso al sistema.

     ‘login-program’ (predeterminado: (file-append shadow "/bin/login"))
          Esto debe ser o bien una expresión-g que denote el nombre del
          programa de ingreso al sistema, o no debe proporcionarse, en
          cuyo caso el valor predeterminado es ‘login’ del conjunto de
          herramientas Shadow.

     ‘local-line’ (predeterminado: ‘#f’)
          Controla el selector la línea CLOCAL. Acepta uno de estos tres
          símbolos como parámetros, ‘'auto’, ‘'always’ (siempre) o
          ‘'never’ (nunca). Si es ‘#f’, el valor predeterminado elegido
          por agetty es ‘'auto’.

     ‘extract-baud?’ (predeterminado: ‘#f’)
          Cuando es ‘#t’, instruye a agetty para extraer la tasa de
          transmisión de los mensajes de estado producidos por ciertos
          tipos de módem.

     ‘skip-login?’ (predeterminado: ‘#f’)
          Cuando es ‘#t’, no solicita el nombre de la usuaria para el
          ingreso al sistema. Puede usarse con el campo LOGIN-PROGRAM
          para usar sistemas de ingreso no estándar.

     ‘no-newline?’ (predeterminado: ‘#f’)
          Cuando es ‘#t’, no imprime una nueva línea antes de imprimir
          el fichero ‘/etc/issue’.

     ‘login-options’ (predeterminadas: ‘#f’)
          Esta opción acepta una cadena que contenga opciones para
          proporcionar al programa de ingreso al sistema. Cuando se use
          con LOGIN-PROGRAM, sea consciente de que una usuaria con malas
          intenciones podría intentar introducir un nombre que
          contuviese opciones embebidas que serían procesadas por el
          programa de ingreso.

     ‘login-pause’ (predeterminada: ‘#f’)
          Cuando es ‘#t’, espera la pulsación de cualquier tecla antes
          de mostrar el mensaje de ingreso al sistema. Esto puede usarse
          en conjunción con AUTO-LOGIN para ahorrar memoria lanzando
          cada shell cuando sea necesario.

     ‘chroot’ (predeterminado: ‘#f’)
          Cambia la raíz al directorio especificado. Esta opción acepta
          una ruta de directorio como una cadena.

     ‘hangup?’ (predeterminado: ‘#f’)
          Usa la llamada del sistema Linux ‘vhangup’ para colgar de
          forma virtual el terminal especificado.

     ‘keep-baud?’ (predeterminado: ‘#f’)
          Cuando es ‘#t’, prueba a mantener la tasa de transmisión
          existente. Las tasas de transmisión de BAUD-RATE se usan
          cuando agetty recibe un carácter <BREAK>.

     ‘timeout’ (predeterminado: ‘#f’)
          Cuando sea un valor entero, termina si no se pudo leer ningún
          nombre de usuaria en TIMEOUT segundos.

     ‘detect-case?’ (predeterminado: ‘#f’)
          Cuando es ‘#t’, activa la detección de terminales únicamente
          con mayúsculas. ESta configuración detectará un nombre de
          ingreso que contenga únicamente letras mayúsculas como un
          indicativo de un terminal con letras únicamente mayúsculas y
          activará las conversiones de mayúscula a minúscula. Tenga en
          cuenta que esto no permitirá caracteres Unicode.

     ‘wait-cr?’ (predeterminado: ‘#f’)
          Cuando es ‘#t’, espera hasta que la usuaria o el modem envíen
          un carácter de retorno de carro o de salto de línea antes de
          mostrar ‘/etc/issue’ o el mensaje de ingreso. Se usa de forma
          típica junto a la opción INIT-STRING.

     ‘no-hints?’ (predeterminado: ‘#f’)
          Cuando es ‘#t’, no imprime avisos sobre el bloqueo numérico,
          las mayúsculas o el bloqueo del desplazamiento.

     ‘no-hostname?’ (predeterminado: ‘#f’)
          El nombre de la máquina se imprime de forma predeterminada.
          Cuando esta opción es ‘#t’, no se mostrará ningún nombre de
          máquina.

     ‘long-hostname?’ (predeterminado: ‘#f’)
          El nombre de máquina se imprime de forma predeterminada
          únicamente hasta el primer punto. Cuando esta opción es ‘#t’,
          se muestra el nombre completamente cualificado de la máquina
          mostrado por ‘gethostname’ o ‘getaddrinfo’.

     ‘erase-characters’ (predeterminado: ‘#f’)
          Esta opción acepta una cadena de caracteres adicionales que
          deben interpretarse como borrado del carácter anterior cuando
          la usuaria introduce su nombre de ingreso.

     ‘kill-characters’ (predeterminado: ‘#f’)
          This option accepts a string that should be interpreted to
          mean “ignore all previous characters” (also called a “kill”
          character) when the user types their login name.

     ‘chdir’ (predeterminado: ‘#f’)
          Esta opción acepta, como una cadena, una ruta de directorio
          que a la que se cambiará antes del ingreso al sistema.

     ‘delay’ (predeterminado: ‘#f’)
          Esta opción acepta, como un entero, el número de segundos a
          esperar antes de abrir el tty y mostrar el mensaje de ingreso
          al sistema.

     ‘nice’ (predeterminado: ‘#f’)
          Esta opción acepta, como un entero, el valor “nice” con el que
          se ejecutará el programa ‘login’.

     ‘extra-options’ (predeterminadas: ‘'()’)
          This option provides an “escape hatch” for the user to provide
          arbitrary command-line arguments to ‘agetty’ as a list of
          strings.

 -- Procedimiento Scheme: kmscon-service-type CONFIG
     Devuelve un servicio que ejecuta kmscon
     (https://www.freedesktop.org/wiki/Software/kmscon) de acuerdo a
     CONFIG, un objeto ‘<kmscon-configuration>’, que especifica el tty
     sobre el que se ejecutará, entre otras cosas.

 -- Tipo de datos: kmscon-configuration
     Este es el tipo de datos que representa la configuración de Kmscon,
     que implementa el ingreso al sistema en consolas virtuales.

     ‘virtual-terminal’
          El sistema de la consola en la que se ejecuta este Kmscon—por
          ejemplo, ‘"tty1"’.

     ‘login-program’ (predeterminado: ‘#~(string-append #$shadow "/bin/login")’)
          Una expresión-g que denota el programa de ingreso al sistema.
          El programa de ingreso al sistema predeterminado es ‘login’
          del conjunto de herramientas Shadow.

     ‘login-arguments’ (predeterminados: ‘'("-p")’)
          Una lista de parámetros para proporcionar a ‘login’.

     ‘auto-login’ (predeterminado: ‘#f’)
          Cuando se proporciona un nombre de ingreso al sistema, como
          una cadena, la usuaria especificada ingresará automáticamente
          sin solicitar su nombre de ingreso ni su contraseña.

     ‘hardware-acceleration?’ (predeterminado: #f)
          Determina si se usará aceleración hardware.

     ‘kmscon’ (predeterminado: KMSCON)
          El paquete Kmscon usado.

 -- Procedimiento Scheme: nscd-service [CONFIGURACIÓN] [#:glibc glibc]
          [#:name-services '()]
     Devuelve un servicio que ejecuta el daemon de la caché del servicio
     de nombres (nscd) con la CONFIGURACIÓN proporcionada—un objeto
     ‘<nscd-configuration>’. *Note Selector de servicios de nombres::,
     para un ejemplo.

     Por conveniencia, el servicio ncsd de Shepherd proporciona las
     siguientes acciones:

     ‘invalidate’
          Esto invalida la caché dada. Por ejemplo, ejecutar:

               herd invalidate nscd hosts

          invalida la caché de búsqueda de nombres de máquinas de nscd.

     ‘statistics’
          Ejecutar ‘herd statistics nscd’ muestra información del uso
          nscd y la caché.

 -- Variable Scheme: %nscd-default-configuration
     This is the default ‘<nscd-configuration>’ value (see below) used
     by ‘nscd-service’. It uses the caches defined by
     ‘%nscd-default-caches’; see below.

 -- Tipo de datos: nscd-configuration
     Este tipo de datos representa la configuración del daemon de caché
     del servicio de nombres (nscd).

     ‘name-services’ (predeterminados: ‘'()’)
          Lista de paquetes que indican los “servicios de nombres” que
          serán visibles al nscd—por ejemplo, ‘(list NSS-MDNS)’.

     ‘glibc’ (predeterminada: GLIBC)
          Paquete que denota la biblioteca C de GNU que proporciona la
          orden ‘nscd’.

     ‘log-file’ (predeterminado: ‘"/var/log/nscd.log"’)
          Nombre del fichero de registro de nscd. Aquí es donde se
          almacena la salida de depuración cuando ‘debug-level’ es
          estrictamente positivo.

     ‘debug-level’ (predeterminado: ‘0’)
          Entero que indica el nivel de depuración. Números mayores
          significan que se registra más salida de depuración.

     ‘caches’ (default: ‘%nscd-default-caches’)
          Lista de objetos ‘<nscd-cache>’ que indican cosas a mantener
          en caché; véase a continuación.

 -- Tipo de datos: nscd-cache
     Tipo de datos que representa una base de datos de caché de nscd y
     sus parámetros.

     ‘base de datos’
          Es un símbolo que representa el nombre de la base de datos de
          la que se actúa como caché. Se aceptan los valores ‘passwd’,
          ‘group’, ‘hosts’ y ‘services’, que designan las bases de datos
          NSS correspondientes (*note (libc)NSS Basics::).

     ‘positive-time-to-live’
     ‘negative-time-to-live’ (predeterminado: ‘20’)
          Un número que representa el número de segundos durante los que
          una búsqueda positiva o negativa permanece en la caché.

     ‘check-files?’ (predeterminado: ‘#t’)
          Si se comprobará en busca de actualizaciones los ficheros que
          correspondan con DATABASE.

          Por ejemplo, cuando DATABASE es ‘hosts’, la activación de esta
          opción instruye a nscd para comprobar actualizaciones en
          ‘/etc/hosts’ y tenerlas en cuenta.

     ‘persistent?’ (predeterminada: ‘#t’)
          Determina si la caché debe almacenarse de manera persistente
          en disco.

     ‘shared?’ (predeterminado: ‘#t’)
          Determina si la caché debe compartirse entre las usuarias.

     ‘max-database-size’ (predeterminado: 32 MiB)
          Tamaño máximo en bytes de la caché de la base de datos.

 -- Variable Scheme: %nscd-default-caches
     Lista de objetos ‘<nscd-cache>’ usados por omisión por
     ‘nscd-configuration’ (véase en la sección previa)

     Activa el almacenamiento en caché persistente y agresivo de
     búsquedas de servicios y nombres de máquina. La última proporciona
     un mejor rendimiento en la búsqueda de nombres de máquina,
     resilencia en caso de nombres de servidor no confiables y también
     mejor privacidad—a menudo el resultado de las búsquedas de nombres
     de máquina está en la caché local, por lo que incluso ni es
     necesario consultar servidores de nombres externos.

 -- Tipo de datos: syslog-configuration
     Este tipo de datos representa la configuración del daemon syslog.

     ‘syslogd’ (predeterminado: ‘#~(string-append #$inetutils "/libexec/syslogd")’)
          El daemon syslog usado.

     ‘config-file’ (predeterminado: ‘%default-syslog.conf’)
          El fichero de configuración de syslog usado.

 -- Procedimiento Scheme: syslog-service CONFIG
     Devuelve un servicio que ejecuta el daemon de syslog de acuerdo a
     CONFIG.

     *Note (inetutils)syslogd invocation::, para más información sobre
     la sintaxis del fichero de configuración.

 -- Variable Scheme: guix-service-type
     El tipo de servicio que ejecuta el daemon de construcción,
     ‘guix-daemon’ (*note Invocación de guix-daemon::). Su valor debe
     ser un registro ‘guix-configuration’ como se describe a
     continuación.

 -- Tipo de datos: guix-configuration
     Este tipo de datos representa la configuración del daemon de
     construcción de Guix. *Note Invocación de guix-daemon::, para más
     información.

     ‘guix’ (predeterminado: GUIX)
          El paquete Guix usado.

     ‘build-group’ (predeterminado: ‘"guixbuild"’)
          El nombre del grupo de las cuentas de usuarias de
          construcción.

     ‘build-accounts’ (predeterminadas: ‘10’)
          Número de cuentas de usuarias de construcción a crear.

     ‘authorize-key?’ (predeterminado: ‘#t’)
          Determina si se autoriza las claves de sustituciones listadas
          en ‘authorized-keys’—predeterminada la de ‘ci.guix.gnu.org’
          (*note Sustituciones::).

     ‘authorized-keys’ (predeterminadas: ‘%default-authorized-guix-keys’)
          La lista de ficheros de claves autorizadas para importaciones
          de archivos, como una lista de expresiones-G que evalúan a
          cadenas (*note Invocación de guix archive::). Por defecto,
          contiene las de ‘ci.guix.gnu.org’ (*note Sustituciones::).

     ‘use-substitutes?’ (predeterminado: ‘#t’)
          Determina si se usarán sustituciones.

     ‘substitute-urls’ (predeterminado: ‘%default-substitute-urls’)
          La lista de URLs donde se buscarán sustituciones por defecto.

     ‘max-silent-time’ (predeterminado: ‘0’)
     ‘timeout’ (predeterminado: ‘0’)
          El número de segundos de silencio y el número de segundos de
          actividad respectivamente, tras los cuales el proceso de
          construcción supera el plazo. Un valor de cero proporciona
          plazos ilimitados.

     ‘log-compression’ (predeterminado: ‘'bzip2’)
          El tipo de compresión usado en los log de construcción—o bien
          ‘gzip’, o bien ‘bzip2’ o ‘none’.

     ‘extra-options’ (predeterminadas: ‘'()’)
          Lista de opciones de línea de órdenes adicionales para
          ‘guix-daemon’.

     ‘log-file’ (predeterminado: ‘"/var/log/guix-daemon.log"’)
          Fichero al que se escriben la salida estándar y la salida
          estándar de error de ‘guix-daemon’.

     ‘http-proxy’ (predeterminado: ‘#f’)
          La URL de los proxy HTTP y HTTPS que se usa para la descarga
          de derivaciones de salida fija y sustituciones.

          También es posible cambiar el proxy del daemon en tiempo te
          ejecución con la acción ‘set-http-proxy’, la cual lo reinicia:

               herd set-http-proxy guix-daemon http://localhost:8118

          Para limpiar la configuración del proxy ejecute:

               herd set-http-proxy guix-daemon

     ‘tmpdir’ (predeterminado: ‘#f’)
          Una ruta de directorio donde ‘guix-daemon’ realiza las
          construcciones.

 -- Procedimiento Scheme: udev-service [#:udev EUDEV #:rules ‘'()’]
     Run UDEV, which populates the ‘/dev’ directory dynamically. udev
     rules can be provided as a list of files through the RULES
     variable. The procedures ‘udev-rule’, ‘udev-rules-service’ and
     ‘file->udev-rule’ from ‘(gnu services base)’ simplify the creation
     of such rule files.

     La orden ‘herd rules udev’, como root, devuelve el nombre del
     directorio que contiene todas las reglas udev activas.

 -- Procedimiento Scheme: udev-rule [NOMBRE-FICHERO CONTENIDO]
     Devuelve un fichero de reglas de udev con nombre NOMBRE-FICHERO que
     contiene las reglas definidas en el literal CONTENIDO.

     En el ejemplo siguiente se define una regla para un dispositivo USB
     que será almacenada en el fichero ‘90-usb-cosa.rules’. Esta regla
     ejecuta un script cuando se detecta un dispositivo USB con un
     identificador de producto dado.

          (define %regla-ejemplo-udev
            (udev-rule
              "90-usb-cosa.rules"
              (string-append "ACTION==\"add\", SUBSYSTEM==\"usb\", "
                             "ATTR{product}==\"Ejemplo\", "
                             "RUN+=\"/ruta/al/ejecutable\"")))

 -- Scheme Procedure: udev-rules-service [NAME RULES] [#:groups GROUPS]
          Return a service that extends
     ‘udev-service-type ’ with RULES and ‘account-service-type’ with
     GROUPS as system groups. This works by creating a singleton service
     type ‘NAME-udev-rules’, of which the returned service is an
     instance.

     Here we show how it can be used to extend ‘udev-service-type’ with
     the previously defined rule ‘%example-udev-rule’.

          (operating-system
           ;; ...
           (services
             (cons (udev-rules-service 'usb-thing %example-udev-rule)
                   %desktop-services)))

 -- Procedimiento Scheme: file->udev-rule [NOMBRE-FICHERO FICHERO]
     Devuelve un fichero de udev con nombre NOMBRE-FICHERO que contiene
     las reglas definidas en FICHERO, un objeto tipo-fichero.

     El ejemplo siguiente muestra cómo podemos usar un fichero de reglas
     existente.

          (use-modules (guix download)     ;para url-fetch
                       (guix packages)     ;para origin
                       ...)

          (define %reglas-android-udev
            (file->udev-rule
              "51-android-udev.rules"
              (let ((version "20170910"))
                (origin
                 (method url-fetch)
                 (uri (string-append "https://raw.githubusercontent.com/M0Rf30/"
                                     "android-udev-rules/" version "/51-android.rules"))
                 (sha256
                  (base32 "0lmmagpyb6xsq6zcr2w1cyx9qmjqmajkvrdbhjx32gqf1d9is003"))))))

   Adicionalmente, las definiciones de paquete Gui pueden ser incluidas
en RULES para extender las reglas udev con las definiciones encontradas
bajo su subdirectorio ‘lib/udev/rules.d’. En vez del ejemplo previo de
FILE->UDEV-RULE, podíamos haber usado el paquete ANDROID-UDEV-RULES que
existe en Guix en el módulo ‘(gnu packages android)’.

   The following example shows how to use the ANDROID-UDEV-RULES package
so that the Android tool ‘adb’ can detect devices without root
privileges. It also details how to create the ‘adbusers’ group, which is
required for the proper functioning of the rules defined within the
‘android-udev-rules’ package. To create such a group, we must define it
both as part of the ‘supplementary-groups’ of our ‘user-account’
declaration, as well as in the GROUPS of the ‘udev-rules-service’
procedure.

     (use-modules (gnu packages android)  ;para android-udev-rules
                  (gnu system shadow)     ;para user-group
                  ...)

     (operating-system
       ;; ...
       (users (cons (user-account
                     ;; ...
                     (supplementary-groups
                      '("adbusers"   ;for adb
                        "wheel" "netdev" "audio" "video")))))
       ;; ...
       (services
         (cons (udev-rules-service 'android android-udev-rules
                                   #:groups '("adbusers"))
               %desktop-services)))

 -- Variable Scheme: urandom-seed-service-type
     Save some entropy in ‘%random-seed-file’ to seed ‘/dev/urandom’
     when rebooting. It also tries to seed ‘/dev/urandom’ from
     ‘/dev/hwrng’ while booting, if ‘/dev/hwrng’ exists and is readable.

 -- Variable Scheme: %random-seed-file
     Es el nombre del fichero donde algunos bytes aleatorios son
     almacenados por el servicio URANDOM-SEED-SERVICE para alimentar
     ‘/dev/urandom’ durante el reinicio. Su valor predeterminado es
     ‘/var/lib/random-seed’.

 -- Variable Scheme: gpm-service-type
     Este es el tipo de servicio que ejecuta GPM, el “daemon de ratón de
     propósito general”, que permite el uso del ratón en la consola
     Linux. GPM permite a las usuarias el uso del ratón en la consola,
     notablemente la selección, copia y pegado de texto.

     El valor para servicios de este tipo debe ser un objeto
     ‘gpm-configuration’ (véase a continuación). Este servicio no es
     parte de ‘%base-services’.

 -- Tipo de datos: gpm-configuration
     Tipo de datos que representa la configuración de GPM.

     ‘opciones’ (predeterminadas: ‘%default-gpm-options’)
          Opciones de línea de órdenes proporcionadas a ‘gpm’. El
          conjunto predeterminado de opciones instruye a ‘gpm’ para
          esperar eventos de ratón en ‘/dev/input/mice’. *Note
          (gpm)Command Line::, para más información.

     ‘gpm’ (predeterminado: ‘gpm’)
          El paquete GPM usado.

 -- Variable Scheme: guix-publish-service-type
     Este es el tipo de servicio para ‘guix publish’ (*note Invocación
     de guix publish::). Su valor debe ser un objeto
     ‘guix-publish-configuration’, como se describe a continuación.

     Se asume que ‘/etc/guix’ ya contiene el par de claves de firma como
     ‘guix archive --generate-key’ lo crea (*note Invocación de guix
     archive::). Si no es el caso, el servicio fallará al arrancar.

 -- Tipo de datos: guix-publish-configuration
     Tipo de datos que representa la configuración del servicio ‘guix
     publish’.

     ‘guix’ (predeterminado: ‘guix’)
          El paquete Guix usado.

     ‘port’ (predeterminado: ‘80’)
          El puerto TCP en el que se esperan conexiones.

     ‘host’ (predeterminado: ‘"localhost"’)
          La dirección de red (y, por tanto, la interfaz de red) en la
          que se esperarán conexiones. Use ‘"0.0.0.0"’ para aceptar
          conexiones por todas las interfaces de red.

     ‘compression’ (predeterminada: ‘'(("gzip" 3))’)
          Es una lista de tuplas método de compresión/nivel usadas para
          la compresión de sustituciones. Por ejemplo, para comprimir
          todas las sustituciones _tanto con_ lzip a nivel 8 _como con_
          gzip a nivel 9, escriba:

               '(("lzip" 7) ("gzip" 9))

          El nivel 9 obtiene la mejor relación de compresión con un
          incremento en el uso del procesador, mientras que el nivel 1
          realiza la compresión rápido.

          Una lista vacía desactiva completamente la compresión.

     ‘nar-path’ (predeterminado: ‘"nar"’)
          The URL path at which “nars” can be fetched. *Note
          ‘--nar-path’: Invocación de guix publish, for details.

     ‘cache’ (predeterminado: ‘#f’)
          Cuando es ‘#f’, desactiva la caché y genera los archivos bajo
          demanda. De otro modo, debería ser el nombre de un
          directorio—por ejemplo, ‘"/var/cache/guix/publish"’—donde
          ‘guix pubish’ almacena los archivos y metadatos en caché
          listos para ser enviados. *Note ‘--cache’: Invocación de guix
          publish, para más información sobre sus ventajas e
          inconvenientes.

     ‘workers’ (predeterminado: ‘#f’)
          Cuando es un entero, es el número de hilos de trabajo usados
          para la caché; cuando es ‘#f’, se usa el número de
          procesadores. *Note ‘--workers’: Invocación de guix publish,
          para más información.

     ‘ttl’ (predeterminado: ‘#f’)
          Cuando es un entero, denota el “tiempo de vida” en segundos de
          los archivos publicados. *Note ‘--ttl’: Invocación de guix
          publish, para más información.

 -- Procedimiento Scheme: rngd-service [#:rng-tools RNG-TOOLS] [#:device
          "/dev/hwrng"]
     Devuelve un servicio que ejecuta el programa ‘rngd’ de RNG-TOOLS
     para añadir DEVICE a la fuente de entropía del núcleo. El servicio
     emitirá un fallo si DEVICE no existe.

 -- Procedimiento Scheme: pam-limits-service [#:limits ‘'()’]

     Devuelve un servicio que instala un fichero de configuración para
     el módulo ‘pam_limits’
     (http://linux-pam.org/Linux-PAM-html/sag-pam_limits.html). El
     procedimiento toma de manera opcional una lista de valores
     ‘pam-limits-entry’, que se pueden usar para especificar límites
     ‘ulimit’ y limites de prioridad “nice” para sesiones de usuaria.

     Las siguientes definiciones de límites establecen dos límites
     “hard” y “soft” para todas las sesiones de ingreso al sistema de
     usuarias pertenecientes al grupo ‘realtime’:

          (pam-limits-service
           (list
            (pam-limits-entry "@realtime" 'both 'rtprio 99)
            (pam-limits-entry "@realtime" 'both 'memlock 'unlimited)))

     La primera entrada incrementa la prioridad máxima de tiempo real
     para procesos sin privilegios; la segunda entrada elimina cualquier
     restricción sobre el espacio de direcciones que puede bloquearse en
     memoria. Estas configuraciones se usan habitualmente para sistemas
     de sonido en tiempo real.


File: guix.es.info,  Node: Ejecución de tareas programadas,  Next: Rotación del registro de mensajes,  Prev: Servicios base,  Up: Servicios

8.8.2 Ejecución de tareas programadas
-------------------------------------

El módulo ‘(gnu services mcron)’ proporciona una interfaz a GNU mcron,
un daemon para ejecutar trabajos planificados de antemano (*note
(mcron)Top::). GNU mcron es similar al daemon tradicional de Unix
‘cron’; la principal diferencia es que está implementado en Scheme
Guile, que proporciona mucha flexibilidad cuando se especifica la
planificación de trabajos y sus acciones.

   El siguiente ejemplo define un sistema operativo que ejecuta las
órdenes ‘updatedb’ (*note (find)Invoking updatedb::) y ‘guix gc’ (*note
Invocación de guix gc::) de manera diaria, así como la orden ‘mkid’ como
una usuaria sin privilegios (*note (idutils)mkid invocation::). Usa
expresiones-g para introducir definiciones de trabajos que serán
proporcionados a mcron (*note Expresiones-G::).

     (use-modules (guix) (gnu) (gnu services mcron))
     (use-package-modules base idutils)

     (define trabajo-updatedb
       ;; Ejecuta 'updatedb' a las 3AM cada día. Aquí escribimos
       ;; las acciones del trabajo como un procedimiento Scheme.
       #~(job '(next-hour '(3))
              (lambda ()
                (execl (string-append #$findutils "/bin/updatedb")
                       "updatedb"
                       "--prunepaths=/tmp /var/tmp /gnu/store"))))

     (define trabajo-recolector-basura
       ;; Recolecta basura 5 minutos después de media noche,
       ;; todos los días. La acción del trabajo es una orden
       ;; del shell.
       #~(job "5 0 * * *"            ;sintaxis de Vixie cron
              "guix gc -F 1G"))

     (define trabajo-idutils
       ;; Actualiza el índice de la base de datos como "carlos" a las
       ;; 12:15 y a las 19:15.  Esto se ejecuta desde su directorio.
       #~(job '(next-minute-from (next-hour '(12 19)) '(15))
              (string-append #$idutils "/bin/mkid src")
              #:user "carlos"))

     (operating-system
       ;; ...
       (services (cons (service mcron-service-type
                                (mcron-configuration
                                 (jobs (list trabajo-recolector-basura
                                             trabajo-updatedb
                                             trabajo-idutils))))
                       %base-services)))

   Para trabajos más complejos definidos en Scheme donde necesita
control en el ámbito global, por ejemplo para introducir una forma
‘use-modules’, puede mover su código a un programa separado usando el
procedimiento ‘program-file’ del módulo ‘(guix gexp)’ (*note
Expresiones-G::). El siguiente ejemplo ilustra este caso.

     (define %tarea-alerta-bateria
       ;; Pita cuando la carga de la batería es inferior a %CARGA-MIN
       #~(job
          '(next-minute (range 0 60 1))
          #$(program-file
             "alerta-batería.scm"
             (with-imported-modules (source-module-closure
                                     '((guix build utils)))
               #~(begin
                   (define %carga-min 20)
                   (use-modules (guix build utils)
                                (ice-9 popen)
                                (ice-9 regex)
                                (ice-9 textual-ports)
                                (srfi srfi-2))
                   (setenv "LC_ALL" "C")     ;Procesado de cadenas en inglés
                   (and-let* ((entrada (open-pipe*
                                        OPEN_READ
                                        #$(file-append acpi "/bin/acpi")))
                              (salida (get-string-all entrada))
                              (m (string-match "Discharging, ([0-9]+)%" output))
                              (carga (string->number (match:substring m 1)))
                              ((< carga %carga-min)))
                     (setenv "LC_ALL" "")     ;Mensaje de salida traducido
                     (format #t "aviso: La carga de la batería es baja (~a%)~%"
                             carga)
                     (invoke #$(file-append beep "/bin/beep") "-r5")))))))

   *Note mcron job specifications: (mcron)Guile Syntax, para más
información sobre las especificaciones de trabajos de mcron. A
continuación se encuentra la referencia del servicio mcron.

   En un sistema en ejecución puede usar la acción ‘schedule’ del
servicio para visualizar los siguientes trabajos mcron que se
ejecutarán:

     # herd schedule mcron

El ejemplo previo enumera las siguientes cinco tareas que se ejecutarán,
pero también puede especificar el número de tareas a mostrar:

     # herd schedule mcron 10

 -- Variable Scheme: mcron-service-type
     Este es el tipo del servicio ‘mcron’, cuyo valor es un objeto
     ‘mcron-configuration’.

     Este tipo de servicio puede ser objeto de una extensión de servicio
     que le proporciona especificaciones de trabajo adicionales (*note
     Composición de servicios::). En otras palabras, es posible definir
     servicios que proporcionen trabajos mcron adicionales para su
     ejecución.

 -- Tipo de datos: mcron-configuration
     Tipo de datos que representa la configuración de mcron.

     ‘mcron’ (predeterminado: MCRON)
          El paquete mcron usado.

     ‘jobs’
          Es una lista de expresiones-G (*note Expresiones-G::), donde
          cada expresión-G corresponde a una especificación de trabajo
          de mcron (*note mcron job specifications: (mcron)Syntax.).

