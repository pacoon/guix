@node Contribuir
@chapter Contribuir

Este proyecto es un esfuerzo colaborativo, y ¡necesitamos su ayuda para que
crezca! Por favor, contacte con nosotras en @email{guix-devel@@gnu.org} y en
@code{#guix} en la red IRC Freenode. Estamos abiertas a ideas, informes de
errores, parches y cualquier cosa que pueda ser de ayuda para el
proyecto. Especialmente se agradece ayuda en empaquetamiento
(@pxref{Guías de empaquetamiento}).

@cindex código de conducta, de contribuidoras
@cindex acuerdo de contribución
Queremos proporcionar un entorno cálido, amistoso y libre de acoso, para que
cualquiera pueda contribuir al máximo de sus capacidades. Para este fin
nuestro proyecto usa un ``Acuerdo de Contribución'', que fue adaptado de
@url{https://contributor-coventant.org}. Se puede encontrar una versión
local en el fichero @file{CODE-OF-CONDUCT} del árbol de fuentes.

Las contribuidoras no están obligadas a usar su nombre legal en los parches
ni en la comunicación on-line; pueden usar cualquier nombre o seudónimo de
su elección.

@menu
* Construcción desde Git::  Lo último y mejor.
* Ejecución de Guix antes de estar instalado::  Trucos de hacker.
* La configuración perfecta::  Las herramientas adecuadas.
* Guías de empaquetamiento::  Crecimiento de la distribución.
* Estilo de codificación::  Higiene de la contribuidora.
* Envío de parches::        Comparta su trabajo.
* Seguimiento de errores y parches::  Uso de Debbugs.
* Acceso al repositorio::    Subida de revisiones al repositorio oficial.
@end menu

@node Construcción desde Git
@section Construcción desde Git

Si quiere picar en el mismo Guix se recomienda usar la última versión del
repositorio Git:

@example
git clone https://git.savannah.gnu.org/git/guix.git
@end example

@cindex identificación, de una copia de Guix
¿Cómo puede asegurarse de haber obtenido una copia genuina del repositorio?
Guix proporciona una herramienta @dfn{identificar} su copia, pero primero
debe comprobar que esta herramienta es genuina para iniciar la cadena de
confianza. Para hacerlo, ejecute:

@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c XXX: Adjust instructions when there's a known tag to start from.
@example
git verify-commit `git log --format=%H build-aux/git-authenticate.scm`
@end example

La salida debe ser parecida a esta:

@example
gpg: Firmado el vie 27 dic 2019 01:27:41 CET
gpg:                usando RSA clave 3CE464558A84FDC69DB40CFB090B11993D9AEBB5
@dots{}
gpg: Firmado el vie 27 dic 2019 01:25:22 CET
gpg:                usando RSA clave 3CE464558A84FDC69DB40CFB090B11993D9AEBB5
@dots{}
@end example

@noindent
... que significa que los cambios en este fichero están todos firmados con
la clave @code{3CE464558A84FDC69DB40CFB090B11993D9AEBB5} (puede tener que
obtener la clave de un servidor de claves, si no lo ha hecho todavía).

De aquí en adelante, puede identificar todos las revisiones incluidas en su
copia ejecutando:

@example
make authenticate
@end example

La primera ejecución puede tardar varios minutos, pero las ejecuciones
siguientes son más rápidas.

@quotation Nota
Se recomienda que ejecute @command{make authenticate} tras cada ejecución de
@command{git pull}. Así se asegura de que está recibiendo cambios válidos
del repositorio.
@end quotation

El modo más fácil de preparar un entorno de desarrollo para Guix es, por
supuesto, ¡usando Guix! Las siguientes órdenes inician un nuevo intérprete
donde todas las dependencias y las variables de entorno apropiadas están
listas para picar código en Guix:

@example
guix environment guix --pure
@end example

@xref{Invocación de guix environment}, para más información sobre dicha orden.

Si no puede usar Guix para construir Guix desde una copia de trabajo, son
necesarios los paquetes siguientes además de los mencionados en las
instrucciones de instalación (@pxref{Requisitos}).

@itemize
@item @url{https://gnu.org/software/autoconf/, GNU Autoconf};
@item @url{https://gnu.org/software/automake/, GNU Automake};
@item @url{https://gnu.org/software/gettext/, GNU Gettext};
@item @url{https://gnu.org/software/texinfo/, GNU Texinfo};
@item @url{https://www.graphviz.org/, Graphviz};
@item @url{https://www.gnu.org/software/help2man/, GNU Help2man (opcional)}.
@end itemize

En Guix se pueden añadir las dependencias opcionales ejecutando
@command{guix environment} con @option{--ad-hoc}:

@example
guix environment guix --pure --ad-hoc help2man git strace
@end example

Ejecute @command{./bootstrap} para generar la infraestructura del sistema de
construcción usando Autoconf y Automake. Si obtiene un error como este:

@example
configure.ac:46: error: possibly undefined macro: PKG_CHECK_MODULES
@end example

@noindent
probablemente significa que Autoconf no pudo encontrar el fichero pkg.m4,
que proporciona pkg-config. Asegúrese de que @file{pkg.m4} está
disponible. Lo mismo aplica para el conjunto de macros @file{guile.m4} que
proporciona Guile. Por ejemplo, si ha instalado Automake en
@file{/usr/local}, no va a buscar ficheros @file{.m4} en
@file{/usr/share}. En ese caso tiene que ejecutar la siguiente orden:

@example
export ACLOCAL_PATH=/usr/share/aclocal
@end example

@xref{Macro Search Path,,, automake, The GNU Automake Manual} para más
información.

Una vez terminada, ejecute @command{./configure} como siempre. Asegúrese de
pasar @code{--localstatedir=@var{directorio}}, donde @var{directorio} es el
valor de @code{localstatedir} usado en su instalación actual (@pxref{El almacén}, para información sobre esto). Recomendamos usar el valor @code{/var}

Finalmente, tiene que ejecutar @code{make check} para iniciar las pruebas
(@pxref{Ejecución de la batería de pruebas}). Si algo falla, eche un vistazo a las
instrucciones de instalación (@pxref{Instalación}) o envíe un mensaje---en
Inglés---a la @email{guix-devel@@gnu.org, lista de correo}.


@node Ejecución de Guix antes de estar instalado
@section Ejecución de Guix antes de estar instalado

Para mantener un entorno de trabajo estable, encontrará útil probar los
cambios hechos en su copia de trabajo local sin instalarlos realmente. De
esa manera, puede distinguir entre su sombrero de ``usuaria final'' y el
traje de ``harapos''.

Para dicho fin, todas las herramientas de línea de órdenes pueden ser usadas
incluso si no ha ejecutado @code{make install}. Para hacerlo, primero
necesita tener un entorno con todas las dependencias disponibles
(@pxref{Construcción desde Git}), y entonces añada al inicio de cada orden
@command{./pre-inst-env} (el guión @file{pre-inst-env} se encuentra en la
raíz del árbol de compilación de Guix; se genera con
@command{./configure}). Un ejemplo@footnote{La opción @option{-E} a
@command{sudo} asegura que @code{GUILE_LOAD_PATH} contiene la información
correcta para que @command{guix-daemon} y las herramientas que usa puedan
encontrar los módulos Guile que necesitan.}:

@example
$ sudo -E ./pre-inst-env guix-daemon --build-users-group=guixbuild
$ ./pre-inst-env guix build hello
@end example

@noindent
De manera similar, un ejemplo de una sesión de Guile con los módulos Guix
disponibles:

@example
$ ./pre-inst-env guile -c '(use-modules (guix utils)) (pk (%current-system))'

;;; ("x86_64-linux")
@end example

@noindent
@cindex REPL
@cindex entorno interactivo
@dots{} y para un entorno interactivo (REPL) (@pxref{Using Guile
Interactively,,, guile, Guile Reference Manual}):

@example
$ ./pre-inst-env guile
scheme@@(guile-user)> ,use(guix)
scheme@@(guile-user)> ,use(gnu)
scheme@@(guile-user)> (define serpientes
                       (fold-packages
                         (lambda (paquete lst)
                           (if (string-prefix? "python"
                                               (package-name paquete))
                               (cons paquete lst)
                               lst))
                         '()))
scheme@@(guile-user)> (length serpientes)
$1 = 361
@end example

El guión @command{pre-inst-env} fija todas las variables de entorno
necesarias para permitir esto, incluyendo @env{PATH} y
@env{GUILE_LOAD_PATH}.

Fíjese que la orden @command{./pre-inst-env guix pull} @emph{no} actualiza
el árbol de fuentes local; simplemente actualiza el enlace
@file{~/.config/guix/latest} (@pxref{Invocación de guix pull}). Ejecute
@command{git pull} si quiere actualizar su árbol de fuentes local.


@node La configuración perfecta
@section La configuración perfecta

La configuración perfecta para hackear en Guix es básicamente la
configuración perfecta para hacerlo en Guile (@pxref{Using Guile in Emacs,,,
guile, Guile Reference Manual}). Primero, necesita más que un editor,
necesita @url{https://www.gnu.org/software/emacs, Emacs}, con su potencia
aumentada gracias al maravilloso @url{https://nongnu.org/geiser,
Geiser}. Para conseguir esta configuración ejecute:

@example
guix package -i emacs guile emacs-geiser
@end example

Geiser permite desarrollo incremental e interactivo dentro de Emacs:
compilación y evaluación de código dentro de los buffers, acceso a
documentación en línea (docstrings), completado dependiente del contexto,
@kbd{M-.} para saltar a la definición de un objeto, una consola interactiva
(REPL) para probar su código, y más (@pxref{Introducción,,, geiser, Geiser
User Manual}). Para desarrollar Guix adecuadamente, asegúrese de aumentar la
ruta de carga de Guile (load-path) para que encuentre los ficheros fuente de
su copia de trabajo:

@lisp
;; @r{Suponiendo que la copia de trabajo de Guix está en ~/src/guix.}
(with-eval-after-load 'geiser-guile
  (add-to-list 'geiser-guile-load-path "~/src/guix"))
@end lisp

Para realmente editar el código, Emacs tiene un modo para Scheme muy
limpio. Pero además de eso, no debe perderse
@url{http://www.emacswiki.org/emacs/ParEdit, Paredit}. Provee de facilidades
para operar directamente en el árbol sintáctico como elevar una expresión-S
o recubrirla, embeber o expulsar la siguiente expresión-S, etc.

@cindex fragmentos de código
@cindex plantillas
@cindex reducir la verborrea
También proporcionamos plantillas para los mensajes de revisión de git
comunes y definiciones de paquetes en el directorio
@file{etc/snippets}. Estas plantillas pueden ser usadas con
@url{https://joaotavora.github.io/yasnippet, YASnippet} para expandir
mnemotécnicos a fragmentos interactivos de texto. Puedes querer añadir el
directorio de fragmentos a la variable @var{yas-snippet-dirs} en Emacs.

@lisp
;; @r{Suponiendo que la copia de trabajo de Guix está en ~/src/guix.}
(with-eval-after-load 'yasnippet
  (add-to-list 'yas-snippet-dirs "~/src/guix/etc/snippets"))
@end lisp

Los fragmentos de mensajes de la revisión dependen de
@url{https://magit.vc/, Magit} para mostrar los ficheros preparados. En la
edición del mensaje de la revisión teclee @code{add} seguido de @kbd{TAB}
(el tabulador) para insertar la plantilla del mensaje de la revisión de
adición de un paquete; teclee @code{update} seguido de @kbd{TAB} para
insertar una plantilla de actualización de un paquete; teclee @code{https}
seguido de @kbd{TAB} para insertar una plantilla para cambiar la URI de la
página de un paquete a HTTPS.

El fragmento principal para @code{scheme-mode} es activado al teclear
@code{package...} seguido de @kbd{TAB}. Este fragmento también inserta el
lanzador @code{origin...} que puede ser expandido de nuevo. El fragmento
@code{origin} puede a su vez insertar otros identificadores de lanzado
terminando en @code{...}, que pueden ser expandidos de nuevo.

@cindex introduce o actualiza el copyright
@cindex @code{M-x guix-copyright}
@cindex @code{M-x copyright-update}
Adicionalmente, proporcionamos herramientas para la inserción y
actualización automática del copyright en @file{etc/copyright.el}. Puede
proporcionar su nombre completo, correo electrónico y cargar el fichero.

@lisp
(setq user-full-name "Alicia Díaz")
(setq user-mail-address "alicia@@correo.org")
;; @r{Se asume que la copia trabajo de guix está en ~/src/guix.}
(load-file "~/src/guix/etc/copyright.el")
@end lisp

Para insertar el aviso de copyright en la línea actual invoque @code{M-x
guix-copyright}.

Para actualizar el aviso de copyright debe especificar una expresión regular
de nombres en la variable @code{copyright-names-regexp}.

@lisp
(setq copyright-names-regexp
      (format "%s <%s>" user-full-name user-mail-address))
@end lisp

Puede comprobar si su copyright está actualizado evaluando @code{M-x
copyright-update}. Si desea hacerlo de manera automática tras guardar un
fichero añada @code{(add-hook 'after-save-hook 'copyright-update)} en Emacs.

@node Guías de empaquetamiento
@section Guías de empaquetamiento

@cindex paquetes, creación
La distribución GNU es reciente y puede no disponer de alguno de sus
paquetes favoritos. Esta sección describe cómo puede ayudar a hacer crecer
la distribución.

Los paquetes de software libre habitualmente se distribuyen en forma de
@dfn{archivadores de código fuente}---típicamente ficheros @file{tar.gz} que
contienen todos los ficheros fuente. Añadir un paquete a la distribución
significa esencialmente dos cosas: añadir una @dfn{receta} que describe cómo
construir el paquete, la que incluye una lista de otros paquetes necesarios
para la construcción, y añadir @dfn{metadatos del paquete} junto a dicha
receta, como la descripción y la información de licencias.

En Guix toda esta información está contenida en @dfn{definiciones de
paquete}. Las definiciones de paquete proporcionan una vista de alto nivel
del paquete. Son escritas usando la sintaxis del lenguaje de programación
Scheme; de hecho, definimos una variable por cada paquete enlazada a su
definición y exportamos esa variable desde un módulo (@pxref{Módulos de paquetes}). No obstante, un conocimiento profundo de Scheme @emph{no} es un
pre-requisito para la creación de paquetes. Para más información obre las
definiciones de paquetes, @pxref{Definición de paquetes}.

Una vez que una definición de paquete está en su lugar, almacenada en un
fichero del árbol de fuentes de Guix, puede probarse usando la orden
@command{guix build} (@pxref{Invocación de guix build}). Por ejemplo, asumiendo
que el nuevo paquete se llama @code{gnuevo}, puede ejecutar esta orden desde
el árbol de construcción de Guix (@pxref{Ejecución de Guix antes de estar instalado}):

@example
./pre-inst-env guix build gnuevo --keep-failed
@end example

El uso de @code{--keep-failed} facilita la depuración de errores de
construcción ya que proporciona acceso al árbol de la construcción
fallida. Otra opción útil de línea de órdenes para la depuración es
@code{--log-file}, para acceder al log de construcción.

Si el paquete resulta desconocido para la orden @command{guix}, puede ser
que el fichero fuente contenga un error de sintaxis, o no tenga una cláusula
@code{define-public} para exportar la variable del paquete. Para encontrar
el problema puede cargar el módulo desde Guile para obtener más información
sobre el error real:

@example
./pre-inst-env guile -c '(use-modules (gnu packages gnuevo))'
@end example

Una vez que se construya correctamente su paquete, por favor, envíenos un
parche (@pxref{Envío de parches}). En cualquier caso, si necesita ayuda
también estaremos felices de ayudarle. Una vez el parche se haya incorporado
al repositorio de Guix, el nuevo paquete se construye automáticamente en las
plataformas disponibles por @url{@value{SUBSTITUTE-SERVER}, nuestro sistema
de integración continua}.

@cindex servidor de sustituciones
Las usuarias pueden obtener la nueva definición de paquete ejecutando
simplemente @command{guix pull} (@pxref{Invocación de guix pull}). Cuando
@code{@value{SUBSTITUTE-SERVER}} ha terminado de construir el paquete, la
instalación del paquete descarga automáticamente los binarios desde allí
(@pxref{Sustituciones}). El único lugar donde la intervención humana es
necesaria es en la revisión y aplicación del parche.


@menu
* Libertad del software::    Qué puede entrar en la distribución.
* Nombrado de paquetes::     ¿Qué hay en un nombre?
* Versiones numéricas::     Cuando el nombre no es suficiente.
* Sinopsis y descripciones::  Ayuda para que las usuarias encuentren el 
                                paquete correcto.
* Módulos Python::          Un toque de comedia británica.
* Módulos Perl::            Pequeñas perlas.
* Paquetes Java::            La parada del café.
* Crates de Rust::           Sistema de paquetes de Rust.
* Tipografías::             Amor por las letras.
@end menu

@node Libertad del software
@subsection Libertad del software

@c Adapted from http://www.gnu.org/philosophy/philosophy.html.
@cindex software libre
El sistema operativo GNU se ha desarrollado para que las usuarias puedan
ejercitar su libertad de computación. GNU es @dfn{software libre}, lo que
significa ue las usuarias tienen las
@url{https://www.gnu.org/philosophy/free-sw.html,cuatro libertades
esenciales}: para ejecutar el programa, para estudiar y modificar el
programa en la forma de código fuente, para redistribuir copias exactas y
para distribuir versiones modificadas. Los paquetes encontrados en la
distribución GNU contienen únicamente software que proporciona estas cuatro
libertades.

Además, la distribución GNU sigue las
@url{https://www.gnu.org/distros/free-system-distribution-guidelines.html,directrices
de distribución de software libre}. Entre otras cosas, estas directrices
rechazan firmware no-libre, recomendaciones de software no-libre, y tienen
en cuenta formas de tratar con marcas registradas y patentes.

Algunos paquetes originales, que serían de otra manera software libre,
contienen un subconjunto pequeño y opcional que viola estas directrices, por
ejemplo debido a que ese subconjunto sea en sí código no-libre. Cuando esto
sucede, las partes indeseadas son eliminadas con parches o fragmentos de
código en la forma @code{origin} del paquete (@pxref{Definición de paquetes}). De
este modo, @code{guix build --source} devuelve las fuentes ``liberadas'' en
vez de la versión original de las fuentes.


@node Nombrado de paquetes
@subsection Nombrado de paquetes

@cindex nombre de paquete
Un paquete tiene realmente dos nombres asociados con él: Primero, el nombre
de la @emph{variable Scheme} asociada, que aparece después de
@code{define-public}. A través de este nombre, el paquete está disponible en
código Scheme, por ejemplo como entrada de otro paquete. Segundo, la cadena
en el campo @code{name} de la definición de paquete. Este nombre se usa por
las órdenes de gestión de paquetes como @command{guix package} y
@command{guix build}.

Ambos normalmente son iguales y corresponden a la conversión a minúsculas
del nombre de proyecto elegido por sus creadoras, con los guiones bajos
sustituidos por guiones. Por ejemplo, GNUnet está disponible como
@code{gnunet}, y SDL_net como @code{sdl-net}.

No añadimos prefijos @code{lib} para paquetes de bibliotecas, a menos que
sean parte del nombre oficial del proyecto. Pero vea @ref{Módulos Python} y
@ref{Módulos Perl} para reglas especiales que conciernen a los módulos de
los lenguajes Python y Perl.

Los nombres de paquetes de tipografías se manejan de forma diferente,
@pxref{Tipografías}.


@node Versiones numéricas
@subsection Versiones numéricas

@cindex versión de paquete
Normalmente empaquetamos únicamente la última versión de un proyecto dado de
software libre. Pero a veces, por ejemplo para versiones de bibliotecas
incompatibles, se necesitan dos (o más) versiones del mismo paquete. Estas
necesitan nombres diferentes para las variables Scheme. Usamos el nombre
como se define en @ref{Nombrado de paquetes} para la versión más reciente; las
versiones previas usan el mismo nombre, añadiendo un @code{-} y el prefijo
menor del número de versión que permite distinguir las dos versiones.

El nombre dentro de la definición de paquete es el mismo para todas las
versiones de un paquete y no contiene ningún número de versión.

Por ejemplo, las versiones 2.24.20 y 3.9.12 de GTK+ pueden empaquetarse como
sigue:

@lisp
(define-public gtk+
  (package
    (name "gtk+")
    (version "3.9.12")
    ...))
(define-public gtk+-2
  (package
    (name "gtk+")
    (version "2.24.20")
    ...))
@end lisp
Si también deseásemos GTK+3.8.2, se empaquetaría como
@lisp
(define-public gtk+-3.8
  (package
    (name "gtk+")
    (version "3.8.2")
    ...))
@end lisp

@c See <https://lists.gnu.org/archive/html/guix-devel/2016-01/msg00425.html>,
@c for a discussion of what follows.
@cindex número de versión, para revisiones de VCS
De manera ocasional, empaquetamos instantáneas del sistema de control de
versiones (VCS) de las desarrolladoras originales en vez de publicaciones
formales. Esto debería permanecer como algo excepcional, ya que son las
desarrolladoras originales quienes deben clarificar cual es la entrega
estable. No obstante, a veces es necesario. Por tanto, ¿qué deberíamos poner
en el campo @code{version}?

Claramente, tenemos que hacer visible el identificador de la revisión en el
VCS en la cadena de versión, pero también debemos asegurarnos que la cadena
de versión incrementa monotónicamente de manera que @command{guix package
--upgrade} pueda determinar qué versión es más moderna. Ya que los
identificadores de revisión, notablemente en Git, no incrementan
monotónicamente, añadimos un número de revisión que se incrementa cada vez
que actualizamos a una nueva instantánea. La versión que resulta debería ser
así:

@example
2.0.11-3.cabba9e
  ^    ^    ^
  |    |    `-- ID de revisión original
  |    |
  |    `--- revisión del paquete Guix
  |
última versión de publicación
@end example

It is a good idea to strip commit identifiers in the @code{version} field
to, say, 7 digits.  It avoids an aesthetic annoyance (assuming aesthetics
have a role to play here) as well as problems related to OS limits such as
the maximum shebang length (127 bytes for the Linux kernel).  It is best to
use the full commit identifiers in @code{origin}s, though, to avoid
ambiguities.  A typical package definition may look like this:

@lisp
(define mi-paquete
  (let ((commit "c3f29bc928d5900971f65965feaae59e1272a3f7")
        (revision "1"))          ;Revisión Guix del paquete
    (package
      (version (git-version "0.9" revision commit))
      (source (origin
                (method git-fetch)
                (uri (git-reference
                      (url "git://example.org/mi-paquete.git")
                      (commit commit)))
                (sha256 (base32 "1mbikn@dots{}"))
                (file-name (git-file-name name version))))
      ;; @dots{}
      )))
@end lisp

@node Sinopsis y descripciones
@subsection Sinopsis y descripciones

@cindex descripción de paquete
@cindex sinopsis de paquete
Como hemos visto previamente, cada paquete en GNU@tie{}Guix incluye una
sinopsis y una descripción (@pxref{Definición de paquetes}). Las sinopsis y
descripciones son importantes: son en lo que @command{guix package --search}
busca, y una pieza crucial de información para ayudar a las usuarias a
determinar si un paquete dado cubre sus necesidades. Consecuentemente, las
empaquetadoras deben prestar atención a qué se incluye en ellas.

Las sinopsis deben empezar con mayúscula y no deben terminar con punto. No
deben empezar con un artículo que habitualmente no aporta nada; por ejemplo,
se prefiere ``Herramienta para chiribizar'' sobre ``Una herramienta que
chiribiza ficheros''. La sinopsis debe decir qué es el paquete---por
ejemplo, ``Utilidades básicas GNU (ficheros, texto, shell)''---o para qué se
usa---por ejemplo, la sinopsis de GNU@tie{}grep es ``Imprime líneas
aceptadas por un patrón''.

Tenga en cuenta que las sinopsis deben tener un claro significado para una
audiencia muy amplia. Por ejemplo, ``Manipula la alineación en el formato
SAM'' puede tener sentido para una investigadora de bioinformática con
experiencia, pero puede ser de poca ayuda o incluso llevar a confusión a una
audiencia no-especializada. Es una buena idea proporcionar una sinopsis que
da una idea del dominio de aplicación del paquete. En ese ejemplo, esto
podría ser algo como ``Manipula la alineación de secuencias de
nucleótidos'', lo que con suerte proporcionará a la usuaria una mejor idea
sobre si esto es lo que está buscando.

Las descripciones deben tener entre cinco y diez líneas. Use frases
completas, y evite usar acrónimos sin introducirlos previamente. Por favor
evite frases comerciales como ``líder mundial'', ``de potencia industrial''
y ``siguiente generación'', y evite superlativos como ``el más
avanzado''---no son útiles para las usuarias que buscan un paquete e incluso
pueden sonar sospechosas. En vez de eso, intente ceñirse a los hechos,
mencionando casos de uso y características.

@cindex marcado Texinfo, en descripciones de paquetes
Las descripciones pueden incluir marcado Texinfo, lo que es útil para
introducir ornamentos como @code{@@code} o @code{@@dfn}, listas de puntos o
enlaces (@pxref{Overview,,, texinfo, GNU Texinfo}). Por consiguiente, debe
ser cuidadosa cuando use algunos caracteres, por ejemplo @samp{@@} y llaves,
que son los caracteres especiales básicos en Texinfo (@pxref{Special
Characters,,, texinfo, GNU Texinfo}). Las interfaces de usuaria como
@command{guix package --show} se encargan de su correcta visualización.

Las sinopsis y descripciones son traducidas por voluntarias
@uref{https://translationproject.org/domain/guix-packages.html, en
Translation Project} para que todas las usuarias posibles puedan leerlas en
su lengua nativa. Las interfaces de usuaria las buscan y las muestran en el
idioma especificado por la localización actual.

Para permitir a @command{xgettext} extraerlas como cadenas traducibles, las
sinopsis y descripciones @emph{deben ser cadenas literales}. Esto significa
que no puede usar @code{string-append} o @code{format} para construir estas
cadenas:

@lisp
(package
  ;; @dots{}
  (synopsis "Esto es traducible")
  (description (string-append "Esto " "*no*" " es traducible.")))
@end lisp

La traducción requiere mucho trabajo, por lo que, como empaquetadora, le
rogamos que ponga incluso más atención a sus sinopsis y descripciones ya que
cada cambio puede suponer trabajo adicional para las traductoras. Para
ayudarlas, es posible hacer recomendaciones o instrucciones insertando
comentarios especiales como este (@pxref{xgettext Invocation,,, gettext, GNU
Gettext}):

@example
;; TRANSLATORS: "X11 resize-and-rotate" should not be translated.
(description "ARandR is designed to provide a simple visual front end
for the X11 resize-and-rotate (RandR) extension. @dots{}")
@end example


@node Módulos Python
@subsection Módulos Python

@cindex python
Actualmente empaquetamos Python 2 y Python 3, bajo los nombres de variable
Scheme @code{python-2} y @code{python} como se explica en @ref{Versiones numéricas}. Para evitar confusiones y conflictos de nombres con otros
lenguajes de programación, parece deseable que el nombre de paquete para un
módulo Python contenga la palabra @code{python}.

Algunos módulos son compatibles únicamente con una versión de Python, otros
con ambas. Si el paquete Foo se compila únicamente con Python 3, lo llamamos
@code{python-foo}. Si se compila con Python 2, lo llamamos
@code{python2-foo}. Los paquetes deben añadirse cuando sean necesarios; no
añadimos la variante de Python 2 del paquete a menos que vayamos a usarla.

Si un proyecto ya contiene la palabra @code{python}, la eliminamos; por
ejemplo, el módulo python-dateutil se empaqueta con los nombres
@code{python-dateutil} y @code{python2-dateutil}. Si el nombre del proyecto
empieza con @code{py} (por ejemplo @code{pytz}), este se mantiene y el
prefijo es el especificado anteriormente..

@subsubsection Especificación de dependencias
@cindex entradas, para paquetes Python

La información de dependencias para paquetes Python está disponible
habitualmente en el árbol de fuentes, con varios grados de precisión: en el
fichero @file{setup.py}, en @file{requirements.txt} o en @file{tox.ini}.

Su misión, cuando escriba una receta para un paquete Python, es asociar
estas dependencias con el tipo apropiado de ``entrada'' (@pxref{Referencia de package, inputs}). Aunque el importador de @code{pypi} normalmente hace un
buen trabajo (@pxref{Invocación de guix import}), puede querer comprobar la
siguiente lista para determinar qué dependencia va dónde.

@itemize

@item
Actualmente empaquetamos con @code{setuptools} y @code{pip} instalados como
Python 3.4 tiene por defecto. Por tanto no necesita especificar ninguno de
ellos como entrada. @command{guix lint} le avisará si lo hace.

@item
Las dependencias Python requeridas en tiempo de ejecución van en
@code{propagated-inputs}. Típicamente están definidas con la palabra clave
@code{install_requires} en @file{setup.py}, o en el fichero
@file{requirements.txt}.

@item
Los paquetes Python requeridos únicamente durante la construcción---por
ejemplo, aquellos listados con la palabra clave @code{setup_requires} en
@file{setup.py}---o únicamente para pruebas---por ejemplo, aquellos en
@code{tests_require}---van en @code{native-inputs}. La razón es que (1) no
necesitan ser propagados ya que no se requieren en tiempo de ejecución, y
(2) en un entorno de compilación cruzada lo que necesitamos es la entrada
``nativa''.

Ejemplos son las bibliotecas de pruebas @code{pytest}, @code{mock} y
@code{nose}. Por supuesto, si alguno de estos paquetes también se necesita
en tiempo de ejecución, necesita ir en @code{propagated-inputs}.

@item
Todo lo que no caiga en las categorías anteriores va a @code{inputs}, por
ejemplo programas o bibliotecas C requeridas para construir los paquetes
Python que contienen extensiones C.

@item
Si un paquete Python tiene dependencias opcionales (@code{extras_require}),
queda en su mano decidir si las añade o no, en base a la relación
utilidad/sobrecarga (@pxref{Envío de parches, @command{guix size}}).

@end itemize


@node Módulos Perl
@subsection Módulos Perl

@cindex perl
Los programas ejecutables Perl se nombran como cualquier otro paquete,
mediante el uso del nombre oficial en minúsculas. Para paquetes Perl que
contienen una única clase, usamos el nombre en minúsculas de la clase,
substituyendo todas las ocurrencias de @code{::} por guiones y agregando el
prefijo @code{perl-}. Por tanto la clase @code{XML::Parser} se convierte en
@code{perl-xml-parser}. Los módulos que contienen varias clases mantienen su
nombre oficial en minúsculas y también se agrega @code{perl-} al
inicio. Dichos módulos tienden a tener la palabra @code{perl} en alguna
parte de su nombre, la cual se elimina en favor del prefijo. Por ejemplo,
@code{libwww-perl} se convierte en @code{perl-libwww}.


@node Paquetes Java
@subsection Paquetes Java

@cindex java
Los programas Java ejecutables se nombran como cualquier otro paquete,
mediante el uso del nombre oficial en minúsculas.

Para evitar confusión y colisiones de nombres con otros lenguajes de
programación, es deseable que el nombre del paquete para un paquete Java
contenga el prefijo @code{java-}. Si el proyecto ya tiene la palabra
@code{java}, eliminamos esta; por ejemplo, el paquete @code{ngsjaga} se
empaqueta bajo el nombre @code{java-ngs}.

Para los paquetes Java que contienen una clase única o una jerarquía
pequeña, usamos el nombre de clase en minúsculas, substituyendo todas las
ocurrencias de @code{.} por guiones y agregando el prefijo @code{java-}. Por
tanto la clase @code{apache.commons.cli} se convierte en el paquete
@code{java-apache-commons-cli}.


@node Crates de Rust
@subsection Crates de Rust

@cindex rust
Los programas Rust ejecutables se nombran como cualquier otro paquete,
mediante el uso del nombre oficial en minúsculas.

Para evitar colisiones en el espacio de nombres añadimos @code{rust-} como
prefijo al resto de paquetes de Rust. El nombre debe cambiarse a letras
minúsculas cuando sea apropiado y los guiones deben mantenerse.

En el ecosistema de rust es común que se usen al mismo tiempo múltiples
versiones de un paquete incompatibles entre ellas, por lo que todos los
paquetes tienen que incorporar una referencia a su versión como sufijo. Si
un paquete ha superado la versión 1.0.0, el número de superior de versión es
suficiente (por ejemplo @code{rust-clap-2}), en otro caso se deben
incorporar tanto el número de versión superior como el siguiente (por
ejemplo @code{rust-rand-0.6}).

Debido a la dificultad a la hora de reusar paquetes de rust como entradas
pre-compiladas de otros paquetes, el sistema de construcción de Cargo
(@pxref{Sistemas de construcción, @code{cargo-build-system}}) presenta las palabras
clave @code{#:cargo-inputs} y @code{cargo-development-inputs} como
parámetros del sistema de construcción. Puede servir de ayuda pensar en
estos parámetros de manera similar a @code{propagated-inputs} y
@code{native-inputs}. Las dependencias de rust de @code{dependencies} y
@code{build-dependencies} deben proporcionarse a través de
@code{#:cargo-inputs}, y @code{dev-dependencies} deben proporcionarse a
través de @code{#:cargo-development-inputs}. Si un paquete de Rust se enlaza
con otras bibliotecas deben proporcionarse como habitualmente en
@code{inputs} y otros campos relacionados.

Se debe tener cuidado a la hora de asegurar que se usan las versiones
correctas de las dependencias; para ello intentamos no evitar la ejecución
de pruebas o la construcción completa con @code{#:skip-build?} cuando sea
posible. Por supuesto, no siempre es posible, ya que el paquete puede
desarrollarse para un sistema operativo distinto, depender de
características del compilador de Rust que se construye a diario (Nightly),
o la batería de pruebas puede haberse atrofiado desde su lanzamiento.


@node Tipografías
@subsection Tipografías

@cindex tipografías
Para tipografías que no se instalan generalmente por una usuaria para
propósitos tipográficos, o que se distribuyen como parte de un paquete de
software más grande, seguimos las reglas generales de empaquetamiento de
software; por ejemplo, esto aplica a las tipografías distribuidas como parte
del sistema X.Org o las tipografías que son parte de TeX Live.

Para facilitar a las usuarias la búsqueda de tipografías, los nombres para
otros paquetes que contienen únicamente tipografías se construyen como
sigue, independientemente del nombre de paquete oficial.

El nombre de un paquete que contiene únicamente una familia tipográfica
comienza con @code{font-}; seguido por el nombre de la tipografía y un guión
si la tipografía es conocida, y el nombre de la familia tipográfica, donde
los espacios se sustituyen por guiones (y como es habitual, todas las letras
mayúsculas se transforman a minúsculas). Por ejemplo, la familia de
tipografías Gentium de SIL se empaqueta bajo el nombre de
@code{font-sil-gentium}.

Para un paquete que contenga varias familias tipográficas, el nombre de la
colección se usa en vez del nombre de la familia tipográfica. Por ejemplo,
las tipografías Liberation consisten en tres familias: Liberation Sans,
Liberation Serif y Liberation Mono. Estas se podrían empaquetar por separado
bajo los nombres @code{font-liberation-sans}, etcétera; pero como se
distribuyen de forma conjunta bajo un nombre común, preferimos empaquetarlas
conjuntamente como @code{font-liberation}.

En el caso de que varios formatos de la misma familia o colección
tipográfica se empaqueten de forma separada, una forma corta del formato,
precedida por un guión, se añade al nombre del paquete. Usamos @code{-ttf}
para tipografías TrueType, @code{-otf} para tipografías OpenType y
@code{-type1} para tipografías Tipo 1 PostScript.


@node Estilo de codificación
@section Estilo de codificación

En general nuestro código sigue los Estándares de codificación GNU
(@pxref{Top,,, standards, GNU Coding Standards}). No obstante, no dicen
mucho de Scheme, así que aquí están algunas reglas adicionales.

@menu
* Paradigma de programación::  Cómo componer sus elementos.
* Módulos::                 ¿Dónde almacenar su código?
* Tipos de datos y reconocimiento de patrones::  Implementación de 
                                                   estructuras de datos.
* Formato del código::      Convenciones de escritura.
@end menu

@node Paradigma de programación
@subsection Paradigma de programación

El código scheme en Guix está escrito en un estilo puramente funcional. Una
excepción es el código que incluye entrada/salida, y procedimientos que
implementan conceptos de bajo nivel, como el procedimiento @code{memoize}.

@node Módulos
@subsection Módulos

Los módulos Guile que están destinados a ser usados en el lado del
constructor deben encontrarse en el espacio de nombres @code{(guix build
@dots{})}. No deben hacer referencia a otros módulos Guix o GNU. No
obstante, no hay problema en usar un módulo del lado del constructor en un
módulo ``del lado del cliente''.

Los módulos que tratan con el sistema GNU más amplio deben estar en el
espacio de nombres @code{(gnu @dots{})} en vez de en @code{(guix @dots{})}.

@node Tipos de datos y reconocimiento de patrones
@subsection Tipos de datos y reconocimiento de patrones

La tendencia en el Lisp clásico es usar listas para representar todo, y
recorrerlas ``a mano'' usando @code{car}, @code{cdr}, @code{cadr} y
compañía. Hay varios problemas con este estilo, notablemente el hecho de que
es difícil de leer, propenso a errores y una carga para informes adecuados
de errores de tipado.

El código de Guix debe definir tipos de datos apropiados (por ejemplo,
mediante el uso @code{define-record-type*}) en vez de abusar de las
listas. Además debe usarse el reconocimiento de patrones, vía el módulo de
Guile @code{(ice-9 match)}, especialmente cuando se analizan listas.

@node Formato del código
@subsection Formato del código

@cindex dar formato al código
@cindex estilo de codificación
Cuando escribimos código Scheme, seguimos la sabiduría común entre las
programadoras Scheme. En general, seguimos las
@url{https://mumble.net/~campbell/scheme/style.txt, Reglas de estilo Lisp de
Riastradh}. Este documento resulta que también describe las convenciones más
usadas en el código Guile. Está lleno de ideas y bien escrito, así que
recomendamos encarecidamente su lectura.

Algunas formas especiales introducidas en Guix, como el macro
@code{substitute*} tienen reglas de indentación especiales. Estas están
definidas en el fichero @file{.dir-locals.el}, el cual Emacs usa
automáticamente. Fíjese que además Emacs-Guix proporciona el modo
@code{guix-devel-mode} que indenta y resalta adecuadamente el código de Guix
(@pxref{Desarrollo,,, emacs-guix, The Emacs-Guix Reference Manual}).

@cindex indentación, de código
@cindex formato, de código
Si no usa Emacs, por favor asegúrese de que su editor conoce esas
reglas. Para indentar automáticamente una definición de paquete también
puede ejecutar:

@example
./etc/indent-code.el gnu/packages/@var{fichero}.scm @var{paquete}
@end example

@noindent
Esto indenta automáticamente la definición de @var{paquete} en
@file{gnu/packages/@var{fichero}.scm} ejecutando Emacs en modo de
procesamiento de lotes. Para indentar un fichero completo, omita el segundo
parámetro:

@example
./etc/indent-code.el gnu/services/@var{fichero}.scm
@end example

@cindex Vim, edición de código Scheme
Si está editando código con Vim, le recomendamos ejecutar @code{:set
autoindent} para que el código se indente automáticamente mientras
escribe. Adicionalmente,
@uref{https://www.vim.org/scripts/script.php?script_id=3998,
@code{paredit.vim}} puede ayudar a manejar todos estos paréntesis.

Requerimos que todos los procedimientos del nivel superior tengan una cadena
de documentación. Este requisito puede relajarse para procedimientos simples
privados en el espacio de nombres @code{(guix build @dots{})} no obstante.

Los procedimientos no deben tener más de cuatro parámetros posicionales. Use
parámetros con palabras clave para procedimientos que toman más de cuatro
parámetros.


@node Envío de parches
@section Envío de parches

El desarrollo se lleva a cabo usando el sistema de control de versiones
distribuido Git. Por lo tanto, no es estrictamente necesario el acceso al
repositorio. Son bienvenidas las contribuciones en forma de parches como los
producidos por @code{git format-patch} enviadas a la lista de correo
@email{guix-patches@@gnu.org}. Las desarrolladoras de Guix que lleven un
tiempo en ello puede que también quieran leer la sección sobre el acceso al
repositorio (@pxref{Acceso al repositorio}).

Esta lista de correo está respaldada por una instancia de Debbugs accesible
en @uref{https://bugs.gnu.org/guix-patches}, la cual nos permite mantener el
seguimiento de los envíos. A cada mensaje enviado a esa lista de correo se
le asigna un número de seguimiento; la gente puede realizar aportaciones
sobre el tema mediante el envío de correos electrónicos a
@code{@var{NNN}@@debbugs.gnu.org}, donde @var{NNN} es el número de
seguimiento (@pxref{Envío de una serie de parches}).

Le rogamos que escriba los mensajes de revisiones en formato ChangeLog
(@pxref{Change Logs,,, standards, GNU Coding Standards}); puede comprobar la
historia de revisiones en busca de ejemplos.

Antes de enviar un parche que añade o modifica una definición de un paquete,
por favor recorra esta lista de comprobaciones:

@enumerate
@item
Si las autoras del paquete software proporcionan una firma criptográfica
para el archivo de la versión, haga un esfuerzo para verificar la
autenticidad del archivo. Para un fichero de firma GPG separado esto puede
hacerse con la orden @code{gpg --verify}.

@item
Dedique algún tiempo a proporcionar una sinopsis y descripción adecuadas
para el paquete. @xref{Sinopsis y descripciones}, para algunas directrices.

@item
Ejecute @code{guix lint @var{paquete}}, donde @var{paquete} es el nombre del
paquete nuevo o modificado, y corrija cualquier error del que informe
(@pxref{Invocación de guix lint}).

@item
Asegúrese de que el paquete compile en su plataforma, usando @code{guix
build @var{package}}.

@item
También le recomendamos que pruebe a construir el paquete en otras
plataformas disponibles. Como puede no disponer de acceso a dichas
plataformas hardware físicamente, le recomendamos el uso de
@code{qemu-binfmt-service-type} para emularlas. Para activarlo, añada el
siguiente servicio a la lista de servicios en su configuración
@code{operating-system}:

@lisp
(service qemu-binfmt-service-type
 (qemu-binfmt-configuration
   (platforms (lookup-qemu-platforms "arm" "aarch64"))
   (guix-support? #t)))
@end lisp

Una vez hecho esto, reconfigure su sistema.

Entonces podrá construir paquetes para diferentes plataformas mediante la
opción @code{--system}. Por ejemplo, para la construcción del paquete
"hello" para las arquitecturas armhf, aarch64 o mips64 ejecutaría las
siguientes órdenes, respectivamente:
@example
guix build --system=armhf-linux --rounds=2 hello
guix build --system=aarch64-linux --rounds=2 hello
@end example

@item
@cindex empaquetamientos
Asegúrese de que el paquete no usa copias empaquetadas de software ya
disponible como paquetes separados.

A veces, paquetes incluyen copias embebidas del código fuente de sus
dependencias para conveniencia de las usuarias. No obstante, como
distribución, queremos asegurar que dichos paquetes efectivamente usan la
copia que ya tenemos en la distribución si hay ya una. Esto mejora el uso de
recursos (la dependencia es construida y almacenada una sola vez), y permite
a la distribución hacer cambios transversales como aplicar actualizaciones
de seguridad para un software dado en un único lugar y que afecte a todo el
sistema---algo que esas copias embebidas impiden.

@item
Eche un vistazo al perfil mostrado por @command{guix size} (@pxref{Invocación de guix size}). Esto le permitirá darse cuenta de referencias a otros paquetes
retenidas involuntariamente. También puede ayudar a determinar si se debe
dividir el paquete (@pxref{Paquetes con múltiples salidas}), y qué
dependencias opcionales deben usarse. En particular, evite añadir
@code{texlive} como una dependencia: debido a su tamaño extremo, use
@code{texlive-tiny} o @code{texlive-union}.

@item
Para cambios importantes, compruebe que los paquetes dependientes (si
aplica) no se ven afectados por el cambio; @code{guix refresh
--list-dependent @var{package}} le ayudará a hacerlo (@pxref{Invocación de guix refresh}).

@c See <https://lists.gnu.org/archive/html/guix-devel/2016-10/msg00933.html>.
@cindex estrategia de ramas
@cindex estrategia de planificación de reconstrucciones
En base al número de paquetes dependientes y, por tanto, del tamaño de la
reconstrucción inducida, los revisiones van a ramas separadas, según estas
líneas:

@table @asis
@item 300 paquetes dependientes o menos
rama @code{master} (cambios no disruptivos).

@item entre 300 y 1.200 paquetes dependientes
rama @code{staging} (cambios no disruptivos). Esta rama está pensada para
ser incorporada en @code{master} cada 3 semanas más o menos. Ramas temáticas
(por ejemplo, una actualización de la pila de GNOME) pueden ir en una rama
específica (digamos, @code{gnome-updates}).

@item más de 1.200 paquetes dependientes
rama @code{core-updates} (puede incluir cambios mayores y potencialmente
disruptivos). Esta rama está pensada para ser incluida en @code{master} cada
2,5 más o menos.
@end table

Todas estas ramas son @uref{@value{SUBSTITUTE-SERVER}, seguidas por nuestra
granja de construcción} e incluidas en @code{master} una vez todo se ha
construido satisfactoriamente. Esto nos permite corregir errores antes de
que afecten a usuarias, y reducir la ventana durante la cual los binarios
preconstruidos no están disponibles.

@c TODO: It would be good with badges on the website that tracks these
@c branches.  Or maybe even a status page.
Generalmente, ramas distintas a @code{master} se consideran
@emph{congeladas} si ha habido una evaluación reciente, o hay una rama
@code{-next} correspondiente. Por favor, pregunte en la lista de correo o en
IRC si no está segura de dónde colocar un parche.

@item
@cindex determinismo, del proceso de construcción
@cindex construcciones reproducibles, comprobar
Compruebe si el proceso de construcción de un paquete es determinista. Esto
significa típicamente comprobar si una construcción independiente del
paquete ofrece exactamente el mismo resultado que usted obtuvo, bit a bit.

Una forma simple de hacerlo es construyendo el mismo paquete varias veces
seguidas en su máquina (@pxref{Invocación de guix build}):

@example
guix build --rounds=2 mi-paquete
@end example

Esto es suficiente una clase común de problemas de no-determinismo, como las
marcas de tiempo o salida generada aleatoriamente en el resultado de la
construcción.

Otra opción es el uso de @command{guix challenge} (@pxref{Invocación de guix challenge}). Puede ejecutarse una vez la revisión del paquete haya sido
publicada y construida por @code{@value{SUBSTITUTE-SERVER}} para comprobar
si obtuvo el mismo resultado que usted. Mejor aún: encuentre otra máquina
que pueda construirla y ejecute @command{guix publish}. Ya que la máquina
remota es probablemente diferente a la suya, puede encontrar problemas de
no-determinismo relacionados con el hardware---por ejemplo, el uso de un
conjunto de instrucciones extendido diferente---o con el núcleo del sistema
operativo---por ejemplo, dependencias en @code{uname} o ficheros
@file{/proc}.

@item
Cuando escriba documentación, por favor use construcciones neutrales de
género para referirse a la gente@footnote{NdT: En esta traducción se ha
optado por usar el femenino para referirse a @emph{personas}, ya que es el
género gramatical de dicha palabra. Aunque las construcciones impersonales
pueden adoptarse en la mayoría de casos, también pueden llegar a ser muy
artificiales en otros usos del castellano; en ocasiones son directamente
imposibles. Algunas construcciones que proponen la neutralidad de género
dificultan la lectura automática (-x), o bien dificultan la corrección
automática (-e), o bien aumentan significativamente la redundancia y reducen
del mismo modo la velocidad en la lectura (-as/os, -as y -os). No obstante,
la adopción del genero neutro heredado del latín, el que en castellano se ha
unido con el masculino, como construcción neutral de género se considera
inaceptable, ya que sería equivalente al ``it'' en inglés, nada más lejos de
la intención de las autoras originales del texto.}, como
@uref{https://en.wikipedia.org/wiki/Singular_they, singular ``they''@comma{}
``their''@comma{} ``them''} y demás.

@item
Compruebe que su parche contiene únicamente un conjunto relacionado de
cambios. Agrupando cambios sin relación dificulta y ralentiza la revisión.

Ejemplos de cambios sin relación incluyen la adición de varios paquetes, o
una actualización de un paquete junto a correcciones a ese paquete.

@item
Por favor, siga nuestras reglas de formato de código, posiblemente
ejecutando el guión @command{etc/indent-code.el} para que lo haga
automáticamente por usted (@pxref{Formato del código}).

@item
Cuando sea posible, use espejos en la URL de las fuentes (@pxref{Invocación de guix download}). Use URL fiables, no generadas. Por ejemplo, los archivos de
GitHub no son necesariamente idénticos de una generación a la siguiente, así
que en este caso es normalmente mejor clonar el repositorio. No use el campo
@command{name} en la URL: no es muy útil y si el nombre cambia, la URL
probablemente estará mal.

@item
Comprueba si Guix se puede construir correctamente (@pxref{Construcción desde Git}) y trata los avisos, especialmente aquellos acerca del uso de símbolos
sin definición.

@item
Asegúrese de que sus cambios no rompen Guix y simule @code{guix pull} con:
@example
guix pull --url=/ruta/a/su/copia --profile=/tmp/guix.master
@end example

@end enumerate

When posting a patch to the mailing list, use @samp{[PATCH] @dots{}} as a
subject, if your patch is to be applied on a branch other than
@code{master}, say @code{core-updates}, specify it in the subject like
@samp{[PATCH core-updates] @dots{}}.  You may use your email client or the
@command{git send-email} command (@pxref{Envío de una serie de parches}).  We
prefer to get patches in plain text messages, either inline or as MIME
attachments.  You are advised to pay attention if your email client changes
anything like line breaks or indentation which could potentially break the
patches.

Cuando un error es resuelto, por favor cierre el hilo enviando un correo a
@email{@var{NNN}-done@@debbugs.gnu.org}.

@unnumberedsubsec Envío de una serie de parches
@anchor{Envío de una serie de parches}
@cindex series de parches
@cindex @code{git send-email}
@cindex @code{git-send-email}

@c Debbugs bug: https://debbugs.gnu.org/db/15/15361.html
Cuando envíe una serie de parches (por ejemplo, usando @code{git
send-email}), por favor mande primero un mensaje a
@email{guix-patches@@gnu.org}, y después mande los parches siguientes a
@email{@var{NNN}@@debbugs.gnu.org} para asegurarse de que se mantienen
juntos. Véase @uref{https://debbugs.gnu.org/Advanced.html, la documentación
de Debbugs} para más información. Puede instalar @command{git send-email}
con @command{guix install git:send-email}.

@node Seguimiento de errores y parches
@section Seguimiento de errores y parches

@cindex informes de errores, seguimiento
@cindex envíos de parches, seguimiento
@cindex seguimiento de incidencias
@cindex Debbugs, sistema de seguimiento de incidencias
El seguimiento de los informes de errores y los envíos de parches se realiza
con una instancia de Debbugs en @uref{https://bugs.gnu.org}. Los informes de
errores se abren para el ``paquete'' @code{guix} (en la jerga de Debbugs),
enviando un correo a @email{bug-guix@@gnu.org}, mientras que para los envíos
de parches se usa el paquete @code{guix-patches} enviando un correo a
@email{guix-patches@@gnu.org} (@pxref{Envío de parches}).

Hay disponible una interfaz web (¡en realidad @emph{dos} interfaces web!)
para la navegación por las incidencias:

@itemize
@item
@url{https://bugs.gnu.org/guix} muestra informes de errores;
@item
@url{https://bugs.gnu.org/guix-patches} muestra parches enviados.
@end itemize

También puede acceder ambas listas a través de la interfaz@footnote{The web
interface at @url{https://issues.guix.gnu.org} (más agradable)
@url{https://issues.guix.gnu.org} implementada con Mumi, un interesante
software escrito en Guile, ¡y en el que puede ayudar! Véase
@url{https://git.elephly.net/gitweb.cgi?p=software/mumi.git}.}. Para ver los
hilos relacionados con el número de incidencia @var{n}, vaya a
@indicateurl{https://issues.guix.gnu.org/issue/@var{n}} o
@indicateurl{https://bugs.gnu.org/@var{n}}.

Si usa Emacs, puede encontrar más conveniente la interacción con las
incidencias mediante @file{debbugs.el}, que puede instalar con:

@example
guix install emacs-debbugs
@end example

Por ejemplo, para enumerar todos las incidencias abiertas en
@code{guix-patches} pulse:

@example
@kbd{C-u} @kbd{M-x} debbugs-gnu @kbd{RET} @kbd{RET} guix-patches @kbd{RET} n y
@end example

@xref{Top,,, debbugs-ug, Debbugs User Guide}, para más información sobre
esta útil herramienta.

@node Acceso al repositorio
@section Acceso al repositorio

@cindex acceso al repositorio, para desarrolladoras
El acceso de escritura al repositorio es conveniente para personas que
contribuyen frecuentemente. Cuando lo crea necesario, considere solicitar
acceso al repositorio siguiendo estos pasos:

@enumerate
@item
Encuentre tres personas que contribuyan al proyecto que puedan
respaldarle. Puede ver la lista de personas que contribuyen en
@url{https://savannah.gnu.org/project/memberlist.php?group=guix}. Cada una
de ellas deberá enviar un correo confirmando el respaldo a
@email{guix-maintainers@@gnu.org} (un alias privado para el colectivo de
personas que mantienen el proyecto), firmado con su clave OpenPGP.

Se espera que dichas personas hayan tenido algunas interacciones con usted
en sus contribuciones y sean capaces de juzgar si es suficientemente
familiar con las prácticas del proyecto. @emph{No} es un juicio sobre el
valor de su trabajo, por lo que un rechazo debe ser interpretado más bien
como un ``habrá que probar de nuevo más adelante''.

@item
Envíe un correo a @email{guix-maintainers@@gnu.org} expresando su intención,
enumerando a las tres contribuidoras que respaldan su petición, firmado con
su clave OpenPGP que usará para firmar las revisiones, y proporcionando su
huella dactilar (véase a continuación). Véase
@uref{https://emailselfdefense.fsf.org/es/} para una introducción a la
criptografía de clave pública con GnuPG.

@c See <https://sha-mbles.github.io/>.
Set up GnuPG such that it never uses the SHA1 hash algorithm for digital
signatures, which is known to be unsafe since 2019, for instance by adding
the following line to @file{~/.gnupg/gpg.conf} (@pxref{GPG Esoteric
Options,,, gnupg, The GNU Privacy Guard Manual}):

@example
digest-algo sha512
@end example

@item
Las personas que mantienen el proyecto decidirán en última instancia si
conceder o no el acceso de escritura, habitualmente siguiendo las
recomendaciones de las personas de referencia proporcionadas.

@item
@cindex OpenPGP, signed commits
Una vez haya conseguido acceso, en caso de hacerlo, por favor envíe un
mensaje a @email{guix-devel@@gnu.org} para notificarlo, de nuevo firmado con
la clave OpenPGP que vaya a usar para firmar las revisiones (hágalo antes de
subir su primera revisión). De esta manera todo el mundo puede enterarse y
asegurarse de que controla su clave OpenPGP.

@quotation Important
Before you can push for the first time, maintainers must:

@enumerate
@item
add your OpenPGP key to the @code{keyring} branch;
@item
add your OpenPGP fingerprint to the @file{.guix-authorizations} file of the
branch(es) you will commit to.
@end enumerate
@end quotation

@item
Asegúrese de leer el resto de esta sección y... ¡a disfrutar!
@end enumerate

@quotation Nota
Quienes mantienen el proyecto están encantadas de proporcionar acceso al
repositorio a personas que han contribuido durante algún tiempo y tienen
buen registro---¡no sea tímida y no subestime su trabajo!

No obstante, tenga en cuenta que el proyecto está trabajando hacia la
automatización de la revisión de parches y el sistema de mezclas, lo que,
como consecuencia, puede hacer necesario que menos gente tenga acceso de
escritura al repositorio principal. ¡Seguiremos informando!
@end quotation

Si obtiene acceso, por favor asegúrese de seguir la política descrita a
continuación (el debate sobre dicha política puede llevarse a cabo en
@email{guix-devel@@gnu.org}).

Los parches no triviales deben enviarse siempre a
@email{guix-patches@@gnu.org} (los parches triviales incluyen la corrección
de errores tipográficos, etcétera). Esta lista de correo rellena la base de
datos de seguimiento de parches (@pxref{Seguimiento de errores y parches}).

Para los parches que únicamente añaden un nuevo paquete, y uno simple, está
bien subirlos directamente, si tiene confianza en ello (lo que significa que
lo ha construido de manera correcta en un entorno chroot, y ha hecho un
auditado razonable de derechos de copia y licencias). Lo mismo puede ser
dicho de las actualizaciones de paquetes, excepto actualizaciones que
desencadenen muchas reconstrucciones (por ejemplo, la actualización de
GnuTLS o GLib). Tenemos una lista de correo para las notificaciones de
revisiones (@email{guix-commits@@gnu.org}), de manera que la gente pueda
enterarse. Antes de subir los cambios, asegúrese de ejecutar @code{git pull
--rebase}.

Todas las revisiones que se suban al repositorio central de Savannah deben
estar firmadas por una clave OpenPGP, y la clave pública debe subirse a su
cuenta de usuaria en Savannah y a servidores públicos de claves, como
@code{keys.openpgp.org}. Para configurar que Git firme automáticamente las
revisiones ejecute:

@example
git config commit.gpgsign true
git config user.signingkey CABBA6EA1DC0FF33
@end example

Puede evitar la subida accidental de revisiones sin firma a Savannah
mediante el uso del hook pre-push de Git que se encuentra en
@file{etc/git/pre-push}:

@example
cp etc/git/pre-push .git/hooks/pre-push
@end example

Cuando suba un commit en nombre de alguien, por favor añada una línea de
@code{Signed-off-by} al final del mensaje de la revisión---por ejemplo con
@command{git am --signoff}. Esto mejora el seguimiento sobre quién hizo qué.

When adding channel news entries (@pxref{Canales, Writing Channel News}),
make sure they are well-formed by running the following command right before
pushing:

@example
make check-channel-news
@end example

Para cualquier otra cosa, envíe un mensaje a @email{guix-patches@@gnu.org} y
deje tiempo para que sea revisado, sin subir ningún cambio
(@pxref{Envío de parches}). Si no recibe ninguna respuesta después de dos
semanas y tiene confianza en ello, está bien subir el cambio.

Esta última parte está sujeta a revisión, para permitir a individualidades
que suban cambios que no puedan generar controversia directamente en partes
con las que estén familiarizadas.

Una última cosa: el proyecto sigue adelante porque las contribuidoras no
solo suben sus cambios, sino que también ofrecen su tiempo @emph{revisando}
y subiendo cambios de otras personas. Como contribuidora, también se
agradece que use su experiencia y derechos de escritura en el repositorio
para ayudar a otras personas que quieren contribuir.
