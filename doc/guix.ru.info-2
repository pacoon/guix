This is guix.ru.info, produced by makeinfo version 6.7 from
guix.ru.texi.

Copyright © 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020 Ludovic
Courtès
Copyright © 2013, 2014, 2016 Andreas Enge
Copyright © 2013 Nikita Karetnikov
Copyright © 2014, 2015, 2016 Alex Kost
Copyright © 2015, 2016 Mathieu Lirzin
Copyright © 2014 Pierre-Antoine Rault
Copyright © 2015 Taylan Ulrich Bayırlı/Kammer
Copyright © 2015, 2016, 2017, 2019, 2020 Leo Famulari
Copyright © 2015, 2016, 2017, 2018, 2019, 2020 Ricardo Wurmus
Copyright © 2016 Ben Woodcroft
Copyright © 2016, 2017, 2018 Chris Marusich
Copyright © 2016, 2017, 2018, 2019, 2020 Efraim Flashner
Copyright © 2016 John Darrington
Copyright © 2016, 2017 Nikita Gillmann
Copyright © 2016, 2017, 2018, 2019, 2020 Jan Nieuwenhuizen
Copyright © 2016, 2017, 2018, 2019, 2020 Julien Lepiller
Copyright © 2016 Alex ter Weele
Copyright © 2016, 2017, 2018, 2019 Christopher Baines
Copyright © 2017, 2018, 2019 Clément Lassieur
Copyright © 2017, 2018 Mathieu Othacehe
Copyright © 2017 Federico Beffa
Copyright © 2017, 2018 Carlo Zancanaro
Copyright © 2017 Thomas Danckaert
Copyright © 2017 humanitiesNerd
Copyright © 2017 Christopher Allan Webber
Copyright © 2017, 2018, 2019, 2020 Marius Bakke
Copyright © 2017, 2019, 2020 Hartmut Goebel
Copyright © 2017, 2019, 2020 Maxim Cournoyer
Copyright © 2017, 2018, 2019, 2020 Tobias Geerinckx-Rice
Copyright © 2017 George Clemmer
Copyright © 2017 Andy Wingo
Copyright © 2017, 2018, 2019 Arun Isaac
Copyright © 2017 nee
Copyright © 2018 Rutger Helling
Copyright © 2018 Oleg Pykhalov
Copyright © 2018 Mike Gerwitz
Copyright © 2018 Pierre-Antoine Rouby
Copyright © 2018, 2019 Gábor Boskovits
Copyright © 2018, 2019 Florian Pelz
Copyright © 2018 Laura Lazzati
Copyright © 2018 Alex Vong
Copyright © 2019 Josh Holland
Copyright © 2019, 2020 Diego Nicola Barbato
Copyright © 2019 Ivan Petkov
Copyright © 2019 Jakob L. Kreuze
Copyright © 2019 Kyle Andrews
Copyright © 2019 Alex Griffin
Copyright © 2019 Guillaume Le Vaillant
Copyright © 2020 Leo Prikler
Copyright © 2019, 2020 Simon Tournier
Copyright © 2020 Wiktor Żelazny
Copyright © 2020 Damien Cassou
Copyright © 2020 Jakub Kądziołka
Copyright © 2020 Jack Hill
Copyright © 2020 Naga Malleswari
Copyright © 2020 Brice Waegeneire
Copyright © 2020 R Veera Kumar
Copyright © 2020 Pierre Langlois
Copyright © 2020 pinoaffe

   Разрешено копирование, распространение и/или модификация этого
документа на условиях лицензии свободной документации GNU (GNU FDL)
версии 1.3 или любой более поздней версии, опубликованной Фондом
свободного программного обеспечения (FSF), исключая неизменяемые секции,
исключая тексты, размещенные на переплёте и задней стороне обложки.
Копия лицензии включена в документ в разделе под названием "GNU Free
Documentation Licens".
INFO-DIR-SECTION Администрирование системы
START-INFO-DIR-ENTRY
* Guix: (guix).              Управление установленным
                               ПО и настройка системы
* guix package: (guix)Запуск guix package.  Установка,
                                                    удаление и
                                                    обновление
                                                    пакетов
* guix gc: (guix)Запуск guix gc.  Освобождение
                                          неиспользуемого
                                          места на диске
* guix pull: (guix)Запуск guix pull.  Обновление
                                              списка доступных
                                              пакетов
* guix system: (guix)Запуск guix system.  Управление
                                                  конфигурацией
                                                  ОС
* guix deploy: (guix)Запуск guix deploy.  Управление
                                                  конфигурациями
                                                  ОС на удалённых
                                                  машинах
END-INFO-DIR-ENTRY

INFO-DIR-SECTION Разработка программного обеспечения
START-INFO-DIR-ENTRY
* guix environment: (guix)Запуск guix environment.  Сборка
                                                            среды
                                                            разработки
                                                            с помощью
                                                            Guix
* guix build: (guix)Запуск guix build.  Сборка пакетов
* guix pack: (guix)Запуск guix pack.  Создание
                                              бинарных пакетов
END-INFO-DIR-ENTRY


File: guix.ru.info,  Node: Тулчейн GCC,  Prev: Запуск guix pack,  Up: Разработка

5.3 Тулчейн GCC
===============

If you need a complete toolchain for compiling and linking C or C++
source code, use the ‘gcc-toolchain’ package.  This package provides a
complete GCC toolchain for C/C++ development, including GCC itself, the
GNU C Library (headers and binaries, plus debugging symbols in the
‘debug’ output), Binutils, and a linker wrapper.

   The wrapper’s purpose is to inspect the ‘-L’ and ‘-l’ switches passed
to the linker, add corresponding ‘-rpath’ arguments, and invoke the
actual linker with this new set of arguments.  You can instruct the
wrapper to refuse to link against libraries not in the store by setting
the ‘GUIX_LD_WRAPPER_ALLOW_IMPURITIES’ environment variable to ‘no’.

   The package ‘gfortran-toolchain’ provides a complete GCC toolchain
for Fortran development.  For other languages, please use ‘guix search
gcc toolchain’ (*note Invoking guix package: guix-search.).


File: guix.ru.info,  Node: Программный интерфейс,  Next: Утилиты,  Prev: Разработка,  Up: Top

6 Программный интерфейс
***********************

GNU Guix provides several Scheme programming interfaces (APIs) to
define, build, and query packages.  The first interface allows users to
write high-level package definitions.  These definitions refer to
familiar packaging concepts, such as the name and version of a package,
its build system, and its dependencies.  These definitions can then be
turned into concrete build actions.

   Build actions are performed by the Guix daemon, on behalf of users.
In a standard setup, the daemon has write access to the store—the
‘/gnu/store’ directory—whereas users do not.  The recommended setup also
has the daemon perform builds in chroots, under a specific build users,
to minimize interference with the rest of the system.

   Lower-level APIs are available to interact with the daemon and the
store.  To instruct the daemon to perform a build action, users actually
provide it with a “derivation”.  A derivation is a low-level
representation of the build actions to be taken, and the environment in
which they should occur—derivations are to package definitions what
assembly is to C programs.  The term “derivation” comes from the fact
that build results _derive_ from them.

   This chapter describes all these APIs in turn, starting from
high-level package definitions.

* Menu:

* Пакетные модули::  Пакеты с точки зрения
                                     программиста.
* Описание пакетов::  Описание новых
                                       пакетов.
* Системы сборки::  Задание параметров
                                   сборки пакетов.
* Хранилище::       Работа с хранилищем
                               пакетов.
* Деривации::       Низкоуровневый интерфейс
                               дериваций пакетов.
* Устройство склада::  Чисто
                                         функциональный
                                         интерфейс доступа к
                                         складу.
* G-Expressions::            Управление механизмом
                               сборки.
* Запуск guix repl::   Интерактивное общение с
                               Guix


File: guix.ru.info,  Node: Пакетные модули,  Next: Описание пакетов,  Up: Программный интерфейс

6.1 Пакетные модули
===================

From a programming viewpoint, the package definitions of the GNU
distribution are provided by Guile modules in the ‘(gnu packages ...)’
name space(1) (*note Guile modules: (guile)Модули.).  For instance, the
‘(gnu packages emacs)’ module exports a variable named ‘emacs’, which is
bound to a ‘<package>’ object (*note Описание пакетов::).

   The ‘(gnu packages ...)’ module name space is automatically scanned
for packages by the command-line tools.  For instance, when running
‘guix install emacs’, all the ‘(gnu packages ...)’ modules are scanned
until one that exports a package object whose name is ‘emacs’ is found.
This package search facility is implemented in the ‘(gnu packages)’
module.

   Users can store package definitions in modules with different
names—e.g., ‘(my-packages emacs)’(2).  There are two ways to make these
package definitions visible to the user interfaces:

  1. By adding the directory containing your package modules to the
     search path with the ‘-L’ flag of ‘guix package’ and other commands
     (*note Стандартные параметры сборки::), or by setting the
     ‘GUIX_PACKAGE_PATH’ environment variable described below.

  2. By defining a “channel” and configuring ‘guix pull’ so that it
     pulls from it.  A channel is essentially a Git repository
     containing package modules.  *Note Каналы::, for more information
     on how to define and use channels.

   ‘GUIX_PACKAGE_PATH’ works similarly to other search path variables:

 -- Environment Variable: GUIX_PACKAGE_PATH
     This is a colon-separated list of directories to search for
     additional package modules.  Directories listed in this variable
     take precedence over the own modules of the distribution.

   The distribution is fully “bootstrapped” and “self-contained”: each
package is built based solely on other packages in the distribution.
The root of this dependency graph is a small set of “bootstrap
binaries”, provided by the ‘(gnu packages bootstrap)’ module.  For more
information on bootstrapping, *note Начальная загрузка::.

   ---------- Footnotes ----------

   (1) Note that packages under the ‘(gnu packages ...)’ module name
space are not necessarily “GNU packages”.  This module naming scheme
follows the usual Guile module naming convention: ‘gnu’ means that these
modules are distributed as part of the GNU system, and ‘packages’
identifies modules that define packages.

   (2) Note that the file name and module name must match.  For
instance, the ‘(my-packages emacs)’ module must be stored in a
‘my-packages/emacs.scm’ file relative to the load path specified with
‘--load-path’ or ‘GUIX_PACKAGE_PATH’.  *Note (guile)Modules and the File
System::, for details.


File: guix.ru.info,  Node: Описание пакетов,  Next: Системы сборки,  Prev: Пакетные модули,  Up: Программный интерфейс

6.2 Описание пакетов
====================

The high-level interface to package definitions is implemented in the
‘(guix packages)’ and ‘(guix build-system)’ modules.  As an example, the
package definition, or “recipe”, for the GNU Hello package looks like
this:

     (define-module (gnu packages hello)
       #:use-module (guix packages)
       #:use-module (guix download)
       #:use-module (guix build-system gnu)
       #:use-module (guix licenses)
       #:use-module (gnu packages gawk))

     (define-public hello
       (package
         (name "hello")
         (version "2.10")
         (source (origin
                   (method url-fetch)
                   (uri (string-append "mirror://gnu/hello/hello-" version
                                       ".tar.gz"))
                   (sha256
                    (base32
                     "0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i"))))
         (build-system gnu-build-system)
         (arguments '(#:configure-flags '("--enable-silent-rules")))
         (inputs `(("gawk" ,gawk)))
         (synopsis "Hello, GNU world: An example GNU package")
         (description "Guess what GNU Hello prints!")
         (home-page "https://www.gnu.org/software/hello/")
         (license gpl3+)))

Without being a Scheme expert, the reader may have guessed the meaning
of the various fields here.  This expression binds the variable ‘hello’
to a ‘<package>’ object, which is essentially a record (*note Scheme
records: (guile)SRFI-9.).  This package object can be inspected using
procedures found in the ‘(guix packages)’ module; for instance,
‘(package-name hello)’ returns—surprise!—‘"hello"’.

   With luck, you may be able to import part or all of the definition of
the package you are interested in from another repository, using the
‘guix import’ command (*note Запуск guix import::).

   In the example above, HELLO is defined in a module of its own, ‘(gnu
packages hello)’.  Technically, this is not strictly necessary, but it
is convenient to do so: all the packages defined in modules under ‘(gnu
packages ...)’ are automatically known to the command-line tools (*note
Пакетные модули::).

   There are a few points worth noting in the above package definition:

   • The ‘source’ field of the package is an ‘<origin>’ object (*note
     Интерфейс origin::, for the complete reference).  Here, the
     ‘url-fetch’ method from ‘(guix download)’ is used, meaning that the
     source is a file to be downloaded over FTP or HTTP.

     The ‘mirror://gnu’ prefix instructs ‘url-fetch’ to use one of the
     GNU mirrors defined in ‘(guix download)’.

     The ‘sha256’ field specifies the expected SHA256 hash of the file
     being downloaded.  It is mandatory, and allows Guix to check the
     integrity of the file.  The ‘(base32 ...)’ form introduces the
     base32 representation of the hash.  You can obtain this information
     with ‘guix download’ (*note Запуск guix download::) and ‘guix hash’
     (*note Запуск guix hash::).

     When needed, the ‘origin’ form can also have a ‘patches’ field
     listing patches to be applied, and a ‘snippet’ field giving a
     Scheme expression to modify the source code.

   • The ‘build-system’ field specifies the procedure to build the
     package (*note Системы сборки::).  Here, GNU-BUILD-SYSTEM
     represents the familiar GNU Build System, where packages may be
     configured, built, and installed with the usual ‘./configure &&
     make && make check && make install’ command sequence.

   • The ‘arguments’ field specifies options for the build system (*note
     Системы сборки::).  Here it is interpreted by GNU-BUILD-SYSTEM as a
     request run ‘configure’ with the ‘--enable-silent-rules’ flag.

     What about these quote (‘'’) characters?  They are Scheme syntax to
     introduce a literal list; ‘'’ is synonymous with ‘quote’.  *Note
     quoting: (guile)Expression Syntax, for details.  Here the value of
     the ‘arguments’ field is a list of arguments passed to the build
     system down the road, as with ‘apply’ (*note ‘apply’: (guile)Fly
     Evaluation.).

     The hash-colon (‘#:’) sequence defines a Scheme “keyword” (*note
     (guile)Keywords::), and ‘#:configure-flags’ is a keyword used to
     pass a keyword argument to the build system (*note (guile)Coding
     With Keywords::).

   • The ‘inputs’ field specifies inputs to the build process—i.e.,
     build-time or run-time dependencies of the package.  Here, we
     define an input called ‘"gawk"’ whose value is that of the GAWK
     variable; GAWK is itself bound to a ‘<package>’ object.

     Again, ‘`’ (a backquote, synonymous with ‘quasiquote’) allows us to
     introduce a literal list in the ‘inputs’ field, while ‘,’ (a comma,
     synonymous with ‘unquote’) allows us to insert a value in that list
     (*note unquote: (guile)Expression Syntax.).

     Note that GCC, Coreutils, Bash, and other essential tools do not
     need to be specified as inputs here.  Instead, GNU-BUILD-SYSTEM
     takes care of ensuring that they are present (*note Системы
     сборки::).

     However, any other dependencies need to be specified in the
     ‘inputs’ field.  Any dependency not specified here will simply be
     unavailable to the build process, possibly leading to a build
     failure.

   *Note Интерфейс package::, for a full description of possible fields.

   Once a package definition is in place, the package may actually be
built using the ‘guix build’ command-line tool (*note Запуск guix
build::), troubleshooting any build failures you encounter (*note
Отладка ошибок сборки::).  You can easily jump back to the package
definition using the ‘guix edit’ command (*note Запуск guix edit::).
*Note Принципы опакечивания::, for more information on how to test
package definitions, and *note Запуск guix lint::, for information on
how to check a definition for style conformance.  Lastly, *note
Каналы::, for information on how to extend the distribution by adding
your own package definitions in a “channel”.

   Finally, updating the package definition to a new upstream version
can be partly automated by the ‘guix refresh’ command (*note Запуск guix
refresh::).

   Behind the scenes, a derivation corresponding to the ‘<package>’
object is first computed by the ‘package-derivation’ procedure.  That
derivation is stored in a ‘.drv’ file under ‘/gnu/store’.  The build
actions it prescribes may then be realized by using the
‘build-derivations’ procedure (*note Хранилище::).

 -- Scheme Procedure: package-derivation STORE PACKAGE [SYSTEM]
     Return the ‘<derivation>’ object of PACKAGE for SYSTEM (*note
     Деривации::).

     PACKAGE must be a valid ‘<package>’ object, and SYSTEM must be a
     string denoting the target system type—e.g., ‘"x86_64-linux"’ for
     an x86_64 Linux-based GNU system.  STORE must be a connection to
     the daemon, which operates on the store (*note Хранилище::).

Similarly, it is possible to compute a derivation that cross-builds a
package for some other system:

 -- Scheme Procedure: package-cross-derivation STORE PACKAGE TARGET
          [SYSTEM] Return the ‘<derivation>’
     object of PACKAGE cross-built from SYSTEM to TARGET.

     TARGET must be a valid GNU triplet denoting the target hardware and
     operating system, such as ‘"aarch64-linux-gnu"’ (*note
     (autoconf)Specifying Target Triplets::).

   Packages can be manipulated in arbitrary ways.  An example of a
useful transformation is “input rewriting”, whereby the dependency tree
of a package is rewritten by replacing specific inputs by others:

 -- Scheme Procedure: package-input-rewriting REPLACEMENTS
          [REWRITE-NAME] Return a procedure that, when passed a package,
     replaces its direct and indirect dependencies (but not its implicit
     inputs) according to REPLACEMENTS.  REPLACEMENTS is a list of
     package pairs; the first element of each pair is the package to
     replace, and the second one is the replacement.

     Optionally, REWRITE-NAME is a one-argument procedure that takes the
     name of a package and returns its new name after rewrite.

Consider this example:

     (define libressl-instead-of-openssl
       ;; This is a procedure to replace OPENSSL by LIBRESSL,
       ;; recursively.
       (package-input-rewriting `((,openssl . ,libressl))))

     (define git-with-libressl
       (libressl-instead-of-openssl git))

Here we first define a rewriting procedure that replaces OPENSSL with
LIBRESSL.  Then we use it to define a “variant” of the GIT package that
uses LIBRESSL instead of OPENSSL.  This is exactly what the
‘--with-input’ command-line option does (*note ‘--with-input’: Параметры
преобразования пакета.).

   The following variant of ‘package-input-rewriting’ can match packages
to be replaced by name rather than by identity.

 -- Scheme Procedure: package-input-rewriting/spec REPLACEMENTS
     Return a procedure that, given a package, applies the given
     REPLACEMENTS to all the package graph (excluding implicit inputs).
     REPLACEMENTS is a list of spec/procedures pair; each spec is a
     package specification such as ‘"gcc"’ or ‘"guile@2"’, and each
     procedure takes a matching package and returns a replacement for
     that package.

   The example above could be rewritten this way:

     (define libressl-instead-of-openssl
       ;; Replace all the packages called "openssl" with LibreSSL.
       (package-input-rewriting/spec `(("openssl" . ,(const libressl)))))

   The key difference here is that, this time, packages are matched by
spec and not by identity.  In other words, any package in the graph that
is called ‘openssl’ will be replaced.

   A more generic procedure to rewrite a package dependency graph is
‘package-mapping’: it supports arbitrary changes to nodes in the graph.

 -- Scheme Procedure: package-mapping PROC [CUT?]
     Return a procedure that, given a package, applies PROC to all the
     packages depended on and returns the resulting package.  The
     procedure stops recursion when CUT? returns true for a given
     package.

* Menu:

* Интерфейс package::  Тип данных package
* Интерфейс origin::  Тип данных origin


File: guix.ru.info,  Node: Интерфейс package,  Next: Интерфейс origin,  Up: Описание пакетов

6.2.1 ‘package’ Reference
-------------------------

This section summarizes all the options available in ‘package’
declarations (*note Описание пакетов::).

 -- Data Type: package
     This is the data type representing a package recipe.

     ‘name’
          The name of the package, as a string.

     ‘version’
          The version of the package, as a string.

     ‘source’
          An object telling how the source code for the package should
          be acquired.  Most of the time, this is an ‘origin’ object,
          which denotes a file fetched from the Internet (*note
          Интерфейс origin::).  It can also be any other “file-like”
          object such as a ‘local-file’, which denotes a file from the
          local file system (*note ‘local-file’: G-Expressions.).

     ‘build-system’
          The build system that should be used to build the package
          (*note Системы сборки::).

     ‘arguments’ (default: ‘'()’)
          The arguments that should be passed to the build system.  This
          is a list, typically containing sequential keyword-value
          pairs.

     ‘inputs’ (default: ‘'()’)
     ‘native-inputs’ (default: ‘'()’)
     ‘propagated-inputs’ (default: ‘'()’)
          These fields list dependencies of the package.  Each one is a
          list of tuples, where each tuple has a label for the input (a
          string) as its first element, a package, origin, or derivation
          as its second element, and optionally the name of the output
          thereof that should be used, which defaults to ‘"out"’ (*note
          Пакеты со множественным выходом::, for more on package
          outputs).  For example, the list below specifies three inputs:

               `(("libffi" ,libffi)
                 ("libunistring" ,libunistring)
                 ("glib:bin" ,glib "bin"))  ;the "bin" output of Glib

          The distinction between ‘native-inputs’ and ‘inputs’ is
          necessary when considering cross-compilation.  When
          cross-compiling, dependencies listed in ‘inputs’ are built for
          the _target_ architecture; conversely, dependencies listed in
          ‘native-inputs’ are built for the architecture of the _build_
          machine.

          ‘native-inputs’ is typically used to list tools needed at
          build time, but not at run time, such as Autoconf, Automake,
          pkg-config, Gettext, or Bison.  ‘guix lint’ can report likely
          mistakes in this area (*note Запуск guix lint::).

          Lastly, ‘propagated-inputs’ is similar to ‘inputs’, but the
          specified packages will be automatically installed alongside
          the package they belong to (*note ‘guix package’:
          package-cmd-propagated-inputs, for information on how ‘guix
          package’ deals with propagated inputs).

          For example this is necessary when a C/C++ library needs
          headers of another library to compile, or when a pkg-config
          file refers to another one via its ‘Requires’ field.

          Another example where ‘propagated-inputs’ is useful is for
          languages that lack a facility to record the run-time search
          path akin to the ‘RUNPATH’ of ELF files; this includes Guile,
          Python, Perl, and more.  To ensure that libraries written in
          those languages can find library code they depend on at run
          time, run-time dependencies must be listed in
          ‘propagated-inputs’ rather than ‘inputs’.

     ‘outputs’ (default: ‘'("out")’)
          The list of output names of the package.  *Note Пакеты со
          множественным выходом::, for typical uses of additional
          outputs.

     ‘native-search-paths’ (default: ‘'()’)
     ‘search-paths’ (default: ‘'()’)
          A list of ‘search-path-specification’ objects describing
          search-path environment variables honored by the package.

     ‘replacement’ (default: ‘#f’)
          This must be either ‘#f’ or a package object that will be used
          as a “replacement” for this package.  *Note grafts: Обновления
          безопасности, for details.

     ‘synopsis’
          A one-line description of the package.

     ‘description’
          A more elaborate description of the package.

     ‘license’
          The license of the package; a value from ‘(guix licenses)’, or
          a list of such values.

     ‘home-page’
          The URL to the home-page of the package, as a string.

     ‘supported-systems’ (default: ‘%supported-systems’)
          The list of systems supported by the package, as strings of
          the form ‘architecture-kernel’, for example ‘"x86_64-linux"’.

     ‘location’ (default: source location of the ‘package’ form)
          The source location of the package.  It is useful to override
          this when inheriting from another package, in which case this
          field is not automatically corrected.

 -- Scheme Syntax: this-package
     When used in the _lexical scope_ of a package field definition,
     this identifier resolves to the package being defined.

     The example below shows how to add a package as a native input of
     itself when cross-compiling:

          (package
            (name "guile")
            ;; ...

            ;; When cross-compiled, Guile, for example, depends on
            ;; a native version of itself.  Add it here.
            (native-inputs (if (%current-target-system)
                               `(("self" ,this-package))
                               '())))

     It is an error to refer to ‘this-package’ outside a package
     definition.


File: guix.ru.info,  Node: Интерфейс origin,  Prev: Интерфейс package,  Up: Описание пакетов

6.2.2 ‘origin’ Reference
------------------------

This section summarizes all the options available in ‘origin’
declarations (*note Описание пакетов::).

 -- Data Type: origin
     This is the data type representing a source code origin.

     ‘uri’
          An object containing the URI of the source.  The object type
          depends on the ‘method’ (see below).  For example, when using
          the URL-FETCH method of ‘(guix download)’, the valid ‘uri’
          values are: a URL represented as a string, or a list thereof.

     ‘method’
          A procedure that handles the URI.

          Examples include:

          URL-FETCH from ‘(guix download)’
               download a file from the HTTP, HTTPS, or FTP URL
               specified in the ‘uri’ field;

          GIT-FETCH from ‘(guix git-download)’
               clone the Git version control repository, and check out
               the revision specified in the ‘uri’ field as a
               ‘git-reference’ object; a ‘git-reference’ looks like
               this:

                    (git-reference
                      (url "https://git.savannah.gnu.org/git/hello.git")
                      (commit "v2.10"))

     ‘sha256’
          A bytevector containing the SHA-256 hash of the source.  This
          is equivalent to providing a ‘content-hash’ SHA256 object in
          the ‘hash’ field described below.

     ‘hash’
          The ‘content-hash’ object of the source—see below for how to
          use ‘content-hash’.

          You can obtain this information using ‘guix download’ (*note
          Запуск guix download::) or ‘guix hash’ (*note Запуск guix
          hash::).

     ‘file-name’ (default: ‘#f’)
          The file name under which the source code should be saved.
          When this is ‘#f’, a sensible default value will be used in
          most cases.  In case the source is fetched from a URL, the
          file name from the URL will be used.  For version control
          checkouts, it is recommended to provide the file name
          explicitly because the default is not very descriptive.

     ‘patches’ (default: ‘'()’)
          A list of file names, origins, or file-like objects (*note
          file-like objects: G-Expressions.) pointing to patches to be
          applied to the source.

          This list of patches must be unconditional.  In particular, it
          cannot depend on the value of ‘%current-system’ or
          ‘%current-target-system’.

     ‘snippet’ (default: ‘#f’)
          A G-expression (*note G-Expressions::) or S-expression that
          will be run in the source directory.  This is a convenient way
          to modify the source, sometimes more convenient than a patch.

     ‘patch-flags’ (default: ‘'("-p1")’)
          A list of command-line flags that should be passed to the
          ‘patch’ command.

     ‘patch-inputs’ (default: ‘#f’)
          Input packages or derivations to the patching process.  When
          this is ‘#f’, the usual set of inputs necessary for patching
          are provided, such as GNU Patch.

     ‘modules’ (default: ‘'()’)
          A list of Guile modules that should be loaded during the
          patching process and while running the code in the ‘snippet’
          field.

     ‘patch-guile’ (default: ‘#f’)
          The Guile package that should be used in the patching process.
          When this is ‘#f’, a sensible default is used.

 -- Data Type: content-hash VALUE [ALGORITHM]
     Construct a content hash object for the given ALGORITHM, and with
     VALUE as its hash value.  When ALGORITHM is omitted, assume it is
     ‘sha256’.

     VALUE can be a literal string, in which case it is base32-decoded,
     or it can be a bytevector.

     The following forms are all equivalent:

          (content-hash "05zxkyz9bv3j9h0xyid1rhvh3klhsmrpkf3bcs6frvlgyr2gwilj")
          (content-hash "05zxkyz9bv3j9h0xyid1rhvh3klhsmrpkf3bcs6frvlgyr2gwilj"
                        sha256)
          (content-hash (base32
                         "05zxkyz9bv3j9h0xyid1rhvh3klhsmrpkf3bcs6frvlgyr2gwilj"))
          (content-hash (base64 "kkb+RPaP7uyMZmu4eXPVkM4BN8yhRd8BTHLslb6f/Rc=")
                        sha256)

     Technically, ‘content-hash’ is currently implemented as a macro.
     It performs sanity checks at macro-expansion time, when possible,
     such as ensuring that VALUE has the right size for ALGORITHM.


File: guix.ru.info,  Node: Системы сборки,  Next: Хранилище,  Prev: Описание пакетов,  Up: Программный интерфейс

6.3 Системы сборки
==================

Each package definition specifies a “build system” and arguments for
that build system (*note Описание пакетов::).  This ‘build-system’ field
represents the build procedure of the package, as well as implicit
dependencies of that build procedure.

   Build systems are ‘<build-system>’ objects.  The interface to create
and manipulate them is provided by the ‘(guix build-system)’ module, and
actual build systems are exported by specific modules.

   Under the hood, build systems first compile package objects to
“bags”.  A “bag” is like a package, but with less ornamentation—in other
words, a bag is a lower-level representation of a package, which
includes all the inputs of that package, including some that were
implicitly added by the build system.  This intermediate representation
is then compiled to a derivation (*note Деривации::).

   Build systems accept an optional list of “arguments”.  In package
definitions, these are passed via the ‘arguments’ field (*note Описание
пакетов::).  They are typically keyword arguments (*note keyword
arguments in Guile: (guile)Optional Arguments.).  The value of these
arguments is usually evaluated in the “build stratum”—i.e., by a Guile
process launched by the daemon (*note Деривации::).

   The main build system is ‘gnu-build-system’, which implements the
standard build procedure for GNU and many other packages.  It is
provided by the ‘(guix build-system gnu)’ module.

 -- Scheme Variable: gnu-build-system
     ‘gnu-build-system’ represents the GNU Build System, and variants
     thereof (*note configuration and makefile conventions:
     (standards)Configuration.).

     In a nutshell, packages using it are configured, built, and
     installed with the usual ‘./configure && make && make check && make
     install’ command sequence.  In practice, a few additional steps are
     often needed.  All these steps are split up in separate “phases”,
     notably(1):

     ‘unpack’
          Unpack the source tarball, and change the current directory to
          the extracted source tree.  If the source is actually a
          directory, copy it to the build tree, and enter that
          directory.

     ‘patch-source-shebangs’
          Patch shebangs encountered in source files so they refer to
          the right store file names.  For instance, this changes
          ‘#!/bin/sh’ to ‘#!/gnu/store/...-bash-4.3/bin/sh’.

     ‘configure’
          Run the ‘configure’ script with a number of default options,
          such as ‘--prefix=/gnu/store/...’, as well as the options
          specified by the ‘#:configure-flags’ argument.

     ‘build’
          Run ‘make’ with the list of flags specified with
          ‘#:make-flags’.  If the ‘#:parallel-build?’ argument is true
          (the default), build with ‘make -j’.

     ‘check’
          Run ‘make check’, or some other target specified with
          ‘#:test-target’, unless ‘#:tests? #f’ is passed.  If the
          ‘#:parallel-tests?’ argument is true (the default), run ‘make
          check -j’.

     ‘install’
          Run ‘make install’ with the flags listed in ‘#:make-flags’.

     ‘patch-shebangs’
          Patch shebangs on the installed executable files.

     ‘strip’
          Strip debugging symbols from ELF files (unless
          ‘#:strip-binaries?’ is false), copying them to the ‘debug’
          output when available (*note Установка файлов отладки::).

     The build-side module ‘(guix build gnu-build-system)’ defines
     ‘%standard-phases’ as the default list of build phases.
     ‘%standard-phases’ is a list of symbol/procedure pairs, where the
     procedure implements the actual phase.

     The list of phases used for a particular package can be changed
     with the ‘#:phases’ parameter.  For instance, passing:

          #:phases (modify-phases %standard-phases (delete 'configure))

     means that all the phases described above will be used, except the
     ‘configure’ phase.

     In addition, this build system ensures that the “standard”
     environment for GNU packages is available.  This includes tools
     such as GCC, libc, Coreutils, Bash, Make, Diffutils, grep, and sed
     (see the ‘(guix build-system gnu)’ module for a complete list).  We
     call these the “implicit inputs” of a package, because package
     definitions do not have to mention them.

   Other ‘<build-system>’ objects are defined to support other
conventions and tools used by free software packages.  They inherit most
of ‘gnu-build-system’, and differ mainly in the set of inputs implicitly
added to the build process, and in the list of phases executed.  Some of
these build systems are listed below.

 -- Scheme Variable: ant-build-system
     This variable is exported by ‘(guix build-system ant)’.  It
     implements the build procedure for Java packages that can be built
     with Ant build tool (https://ant.apache.org/).

     It adds both ‘ant’ and the “Java Development Kit” (JDK) as provided
     by the ‘icedtea’ package to the set of inputs.  Different packages
     can be specified with the ‘#:ant’ and ‘#:jdk’ parameters,
     respectively.

     When the original package does not provide a suitable Ant build
     file, the parameter ‘#:jar-name’ can be used to generate a minimal
     Ant build file ‘build.xml’ with tasks to build the specified jar
     archive.  In this case the parameter ‘#:source-dir’ can be used to
     specify the source sub-directory, defaulting to “src”.

     The ‘#:main-class’ parameter can be used with the minimal ant
     buildfile to specify the main class of the resulting jar.  This
     makes the jar file executable.  The ‘#:test-include’ parameter can
     be used to specify the list of junit tests to run.  It defaults to
     ‘(list "**/*Test.java")’.  The ‘#:test-exclude’ can be used to
     disable some tests.  It defaults to ‘(list "**/Abstract*.java")’,
     because abstract classes cannot be run as tests.

     The parameter ‘#:build-target’ can be used to specify the Ant task
     that should be run during the ‘build’ phase.  By default the “jar”
     task will be run.

 -- Scheme Variable: android-ndk-build-system
     This variable is exported by ‘(guix build-system android-ndk)’.  It
     implements a build procedure for Android NDK (native development
     kit) packages using a Guix-specific build process.

     The build system assumes that packages install their public
     interface (header) files to the subdirectory ‘include’ of the ‘out’
     output and their libraries to the subdirectory ‘lib’ the ‘out’
     output.

     It’s also assumed that the union of all the dependencies of a
     package has no conflicting files.

     For the time being, cross-compilation is not supported - so right
     now the libraries and header files are assumed to be host tools.

 -- Scheme Variable: asdf-build-system/source
 -- Scheme Variable: asdf-build-system/sbcl
 -- Scheme Variable: asdf-build-system/ecl

     These variables, exported by ‘(guix build-system asdf)’, implement
     build procedures for Common Lisp packages using “ASDF”
     (https://common-lisp.net/project/asdf/).  ASDF is a system
     definition facility for Common Lisp programs and libraries.

     The ‘asdf-build-system/source’ system installs the packages in
     source form, and can be loaded using any common lisp
     implementation, via ASDF. The others, such as
     ‘asdf-build-system/sbcl’, install binary systems in the format
     which a particular implementation understands.  These build systems
     can also be used to produce executable programs, or lisp images
     which contain a set of packages pre-loaded.

     The build system uses naming conventions.  For binary packages, the
     package name should be prefixed with the lisp implementation, such
     as ‘sbcl-’ for ‘asdf-build-system/sbcl’.

     Additionally, the corresponding source package should be labeled
     using the same convention as python packages (see *note Модули
     Python::), using the ‘cl-’ prefix.

     For binary packages, each system should be defined as a Guix
     package.  If one package ‘origin’ contains several systems, package
     variants can be created in order to build all the systems.  Source
     packages, which use ‘asdf-build-system/source’, may contain several
     systems.

     In order to create executable programs and images, the build-side
     procedures ‘build-program’ and ‘build-image’ can be used.  They
     should be called in a build phase after the ‘create-symlinks’
     phase, so that the system which was just built can be used within
     the resulting image.  ‘build-program’ requires a list of Common
     Lisp expressions to be passed as the ‘#:entry-program’ argument.

     If the system is not defined within its own ‘.asd’ file of the same
     name, then the ‘#:asd-file’ parameter should be used to specify
     which file the system is defined in.  Furthermore, if the package
     defines a system for its tests in a separate file, it will be
     loaded before the tests are run if it is specified by the
     ‘#:test-asd-file’ parameter.  If it is not set, the files
     ‘<system>-tests.asd’, ‘<system>-test.asd’, ‘tests.asd’, and
     ‘test.asd’ will be tried if they exist.

     If for some reason the package must be named in a different way
     than the naming conventions suggest, the ‘#:asd-system-name’
     parameter can be used to specify the name of the system.

 -- Scheme Variable: cargo-build-system
     This variable is exported by ‘(guix build-system cargo)’.  It
     supports builds of packages using Cargo, the build tool of the Rust
     programming language (https://www.rust-lang.org).

     It adds ‘rustc’ and ‘cargo’ to the set of inputs.  A different Rust
     package can be specified with the ‘#:rust’ parameter.

     Regular cargo dependencies should be added to the package
     definition via the ‘#:cargo-inputs’ parameter as a list of name and
     spec pairs, where the spec can be a package or a source definition.
     Note that the spec must evaluate to a path to a gzipped tarball
     which includes a ‘Cargo.toml’ file at its root, or it will be
     ignored.  Similarly, cargo dev-dependencies should be added to the
     package definition via the ‘#:cargo-development-inputs’ parameter.

     In its ‘configure’ phase, this build system will make any source
     inputs specified in the ‘#:cargo-inputs’ and
     ‘#:cargo-development-inputs’ parameters available to cargo.  It
     will also remove an included ‘Cargo.lock’ file to be recreated by
     ‘cargo’ during the ‘build’ phase.  The ‘install’ phase installs any
     crate the binaries if they are defined by the crate.

 -- Scheme Variable: copy-build-system
     This variable is exported by ‘(guix build-system copy)’.  It
     supports builds of simple packages that don’t require much
     compiling, mostly just moving files around.

     It adds much of the ‘gnu-build-system’ packages to the set of
     inputs.  Because of this, the ‘copy-build-system’ does not require
     all the boilerplate code often needed for the
     ‘trivial-build-system’.

     To further simplify the file installation process, an
     ‘#:install-plan’ argument is exposed to let the packager specify
     which files go where.  The install plan is a list of ‘(SOURCE
     TARGET [FILTERS])’.  FILTERS are optional.

        • When SOURCE matches a file or directory without trailing
          slash, install it to TARGET.
             • If TARGET has a trailing slash, install SOURCE basename
               beneath TARGET.
             • Otherwise install SOURCE as TARGET.

        • When SOURCE is a directory with a trailing slash, or when
          FILTERS are used, the trailing slash of TARGET is implied with
          the same meaning as above.
             • Without FILTERS, install the full SOURCE _content_ to
               TARGET.
             • With FILTERS among ‘#:include’, ‘#:include-regexp’,
               ‘#:exclude’, ‘#:exclude-regexp’, only select files are
               installed depending on the filters.  Each filters is
               specified by a list of strings.
                  • With ‘#:include’, install all the files which the
                    path suffix matches at least one of the elements in
                    the given list.
                  • With ‘#:include-regexp’, install all the files which
                    the subpaths match at least one of the regular
                    expressions in the given list.
                  • The ‘#:exclude’ and ‘#:exclude-regexp’ filters are
                    the complement of their inclusion counterpart.
                    Without ‘#:include’ flags, install all files but
                    those matching the exclusion filters.  If both
                    inclusions and exclusions are specified, the
                    exclusions are done on top of the inclusions.
          In all cases, the paths relative to SOURCE are preserved
          within TARGET.

     Examples:

        • ‘("foo/bar" "share/my-app/")’: Install ‘bar’ to
          ‘share/my-app/bar’.
        • ‘("foo/bar" "share/my-app/baz")’: Install ‘bar’ to
          ‘share/my-app/baz’.
        • ‘("foo/" "share/my-app")’: Install the content of ‘foo’ inside
          ‘share/my-app’, e.g., install ‘foo/sub/file’ to
          ‘share/my-app/sub/file’.
        • ‘("foo/" "share/my-app" #:include ("sub/file"))’: Install only
          ‘foo/sub/file’ to ‘share/my-app/sub/file’.
        • ‘("foo/sub" "share/my-app" #:include ("file"))’: Install
          ‘foo/sub/file’ to ‘share/my-app/file’.

 -- Scheme Variable: clojure-build-system
     This variable is exported by ‘(guix build-system clojure)’.  It
     implements a simple build procedure for Clojure
     (https://clojure.org/) packages using plain old ‘compile’ in
     Clojure.  Cross-compilation is not supported yet.

     It adds ‘clojure’, ‘icedtea’ and ‘zip’ to the set of inputs.
     Different packages can be specified with the ‘#:clojure’, ‘#:jdk’
     and ‘#:zip’ parameters, respectively.

     A list of source directories, test directories and jar names can be
     specified with the ‘#:source-dirs’, ‘#:test-dirs’ and ‘#:jar-names’
     parameters, respectively.  Compile directory and main class can be
     specified with the ‘#:compile-dir’ and ‘#:main-class’ parameters,
     respectively.  Other parameters are documented below.

     This build system is an extension of ‘ant-build-system’, but with
     the following phases changed:

     ‘build’
          This phase calls ‘compile’ in Clojure to compile source files
          and runs ‘jar’ to create jars from both source files and
          compiled files according to the include list and exclude list
          specified in ‘#:aot-include’ and ‘#:aot-exclude’,
          respectively.  The exclude list has priority over the include
          list.  These lists consist of symbols representing Clojure
          libraries or the special keyword ‘#:all’ representing all
          Clojure libraries found under the source directories.  The
          parameter ‘#:omit-source?’ decides if source should be
          included into the jars.

     ‘check’
          This phase runs tests according to the include list and
          exclude list specified in ‘#:test-include’ and
          ‘#:test-exclude’, respectively.  Their meanings are analogous
          to that of ‘#:aot-include’ and ‘#:aot-exclude’, except that
          the special keyword ‘#:all’ now stands for all Clojure
          libraries found under the test directories.  The parameter
          ‘#:tests?’ decides if tests should be run.

     ‘install’
          This phase installs all jars built previously.

     Apart from the above, this build system also contains an additional
     phase:

     ‘install-doc’
          This phase installs all top-level files with base name
          matching ‘%doc-regex’.  A different regex can be specified
          with the ‘#:doc-regex’ parameter.  All files (recursively)
          inside the documentation directories specified in ‘#:doc-dirs’
          are installed as well.

 -- Scheme Variable: cmake-build-system
     This variable is exported by ‘(guix build-system cmake)’.  It
     implements the build procedure for packages using the CMake build
     tool (https://www.cmake.org).

     It automatically adds the ‘cmake’ package to the set of inputs.
     Which package is used can be specified with the ‘#:cmake’
     parameter.

     The ‘#:configure-flags’ parameter is taken as a list of flags
     passed to the ‘cmake’ command.  The ‘#:build-type’ parameter
     specifies in abstract terms the flags passed to the compiler; it
     defaults to ‘"RelWithDebInfo"’ (short for “release mode with
     debugging information”), which roughly means that code is compiled
     with ‘-O2 -g’, as is the case for Autoconf-based packages by
     default.

 -- Scheme Variable: dune-build-system
     This variable is exported by ‘(guix build-system dune)’.  It
     supports builds of packages using Dune (https://dune.build/), a
     build tool for the OCaml programming language.  It is implemented
     as an extension of the ‘ocaml-build-system’ which is described
     below.  As such, the ‘#:ocaml’ and ‘#:findlib’ parameters can be
     passed to this build system.

     It automatically adds the ‘dune’ package to the set of inputs.
     Which package is used can be specified with the ‘#:dune’ parameter.

     There is no ‘configure’ phase because dune packages typically don’t
     need to be configured.  The ‘#:build-flags’ parameter is taken as a
     list of flags passed to the ‘dune’ command during the build.

     The ‘#:jbuild?’ parameter can be passed to use the ‘jbuild’ command
     instead of the more recent ‘dune’ command while building a package.
     Its default value is ‘#f’.

     The ‘#:package’ parameter can be passed to specify a package name,
     which is useful when a package contains multiple packages and you
     want to build only one of them.  This is equivalent to passing the
     ‘-p’ argument to ‘dune’.

 -- Scheme Variable: go-build-system
     This variable is exported by ‘(guix build-system go)’.  It
     implements a build procedure for Go packages using the standard Go
     build mechanisms
     (https://golang.org/cmd/go/#hdr-Compile_packages_and_dependencies).

     The user is expected to provide a value for the key ‘#:import-path’
     and, in some cases, ‘#:unpack-path’.  The import path
     (https://golang.org/doc/code.html#ImportPaths) corresponds to the
     file system path expected by the package’s build scripts and any
     referring packages, and provides a unique way to refer to a Go
     package.  It is typically based on a combination of the package
     source code’s remote URI and file system hierarchy structure.  In
     some cases, you will need to unpack the package’s source code to a
     different directory structure than the one indicated by the import
     path, and ‘#:unpack-path’ should be used in such cases.

     Packages that provide Go libraries should install their source code
     into the built output.  The key ‘#:install-source?’, which defaults
     to ‘#t’, controls whether or not the source code is installed.  It
     can be set to ‘#f’ for packages that only provide executable files.

 -- Scheme Variable: glib-or-gtk-build-system
     This variable is exported by ‘(guix build-system glib-or-gtk)’.  It
     is intended for use with packages making use of GLib or GTK+.

     This build system adds the following two phases to the ones defined
     by ‘gnu-build-system’:

     ‘glib-or-gtk-wrap’
          The phase ‘glib-or-gtk-wrap’ ensures that programs in ‘bin/’
          are able to find GLib “schemas” and GTK+ modules
          (https://developer.gnome.org/gtk3/stable/gtk-running.html).
          This is achieved by wrapping the programs in launch scripts
          that appropriately set the ‘XDG_DATA_DIRS’ and ‘GTK_PATH’
          environment variables.

          It is possible to exclude specific package outputs from that
          wrapping process by listing their names in the
          ‘#:glib-or-gtk-wrap-excluded-outputs’ parameter.  This is
          useful when an output is known not to contain any GLib or GTK+
          binaries, and where wrapping would gratuitously add a
          dependency of that output on GLib and GTK+.

     ‘glib-or-gtk-compile-schemas’
          The phase ‘glib-or-gtk-compile-schemas’ makes sure that all
          GSettings schemas
          (https://developer.gnome.org/gio/stable/glib-compile-schemas.html)
          of GLib are compiled.  Compilation is performed by the
          ‘glib-compile-schemas’ program.  It is provided by the package
          ‘glib:bin’ which is automatically imported by the build
          system.  The ‘glib’ package providing ‘glib-compile-schemas’
          can be specified with the ‘#:glib’ parameter.

     Both phases are executed after the ‘install’ phase.

 -- Scheme Variable: guile-build-system
     This build system is for Guile packages that consist exclusively of
     Scheme code and that are so lean that they don’t even have a
     makefile, let alone a ‘configure’ script.  It compiles Scheme code
     using ‘guild compile’ (*note (guile)Compilation::) and installs the
     ‘.scm’ and ‘.go’ files in the right place.  It also installs
     documentation.

     This build system supports cross-compilation by using the
     ‘--target’ option of ‘guild compile’.

     Packages built with ‘guile-build-system’ must provide a Guile
     package in their ‘native-inputs’ field.

 -- Scheme Variable: julia-build-system
     This variable is exported by ‘(guix build-system julia)’.  It
     implements the build procedure used by julia
     (https://julialang.org/) packages, which essentially is similar to
     running ‘julia -e 'using Pkg; Pkg.add(package)'’ in an environment
     where ‘JULIA_LOAD_PATH’ contains the paths to all Julia package
     inputs.  Tests are run not run.

     Julia packages require the source ‘file-name’ to be the real name
     of the package, correctly capitalized.

     For packages requiring shared library dependencies, you may need to
     write the ‘/deps/deps.jl’ file manually.  It’s usually a line of
     ‘const variable = /gnu/store/library.so’ for each dependency, plus
     a void function ‘check_deps() = nothing’.

     Some older packages that aren’t using ‘Package.toml’ yet, will
     require this file to be created, too.  The function
     ‘julia-create-package-toml’ helps creating the file.  You need to
     pass the outputs and the source of the package, it’s name (the same
     as the ‘file-name’ parameter), the package uuid, the package
     version, and a list of dependencies specified by their name and
     their uuid.

 -- Scheme Variable: minify-build-system
     This variable is exported by ‘(guix build-system minify)’.  It
     implements a minification procedure for simple JavaScript packages.

     It adds ‘uglify-js’ to the set of inputs and uses it to compress
     all JavaScript files in the ‘src’ directory.  A different minifier
     package can be specified with the ‘#:uglify-js’ parameter, but it
     is expected that the package writes the minified code to the
     standard output.

     When the input JavaScript files are not all located in the ‘src’
     directory, the parameter ‘#:javascript-files’ can be used to
     specify a list of file names to feed to the minifier.

 -- Scheme Variable: ocaml-build-system
     This variable is exported by ‘(guix build-system ocaml)’.  It
     implements a build procedure for OCaml (https://ocaml.org)
     packages, which consists of choosing the correct set of commands to
     run for each package.  OCaml packages can expect many different
     commands to be run.  This build system will try some of them.

     When the package has a ‘setup.ml’ file present at the top-level, it
     will run ‘ocaml setup.ml -configure’, ‘ocaml setup.ml -build’ and
     ‘ocaml setup.ml -install’.  The build system will assume that this
     file was generated by OASIS (http://oasis.forge.ocamlcore.org/) and
     will take care of setting the prefix and enabling tests if they are
     not disabled.  You can pass configure and build flags with the
     ‘#:configure-flags’ and ‘#:build-flags’.  The ‘#:test-flags’ key
     can be passed to change the set of flags used to enable tests.  The
     ‘#:use-make?’ key can be used to bypass this system in the build
     and install phases.

     When the package has a ‘configure’ file, it is assumed that it is a
     hand-made configure script that requires a different argument
     format than in the ‘gnu-build-system’.  You can add more flags with
     the ‘#:configure-flags’ key.

     When the package has a ‘Makefile’ file (or ‘#:use-make?’ is ‘#t’),
     it will be used and more flags can be passed to the build and
     install phases with the ‘#:make-flags’ key.

     Finally, some packages do not have these files and use a somewhat
     standard location for its build system.  In that case, the build
     system will run ‘ocaml pkg/pkg.ml’ or ‘ocaml pkg/build.ml’ and take
     care of providing the path to the required findlib module.
     Additional flags can be passed via the ‘#:build-flags’ key.
     Install is taken care of by ‘opam-installer’.  In this case, the
     ‘opam’ package must be added to the ‘native-inputs’ field of the
     package definition.

     Note that most OCaml packages assume they will be installed in the
     same directory as OCaml, which is not what we want in guix.  In
     particular, they will install ‘.so’ files in their module’s
     directory, which is usually fine because it is in the OCaml
     compiler directory.  In guix though, these libraries cannot be
     found and we use ‘CAML_LD_LIBRARY_PATH’.  This variable points to
     ‘lib/ocaml/site-lib/stubslibs’ and this is where ‘.so’ libraries
     should be installed.

 -- Scheme Variable: python-build-system
     This variable is exported by ‘(guix build-system python)’.  It
     implements the more or less standard build procedure used by Python
     packages, which consists in running ‘python setup.py build’ and
     then ‘python setup.py install --prefix=/gnu/store/...’.

     For packages that install stand-alone Python programs under ‘bin/’,
     it takes care of wrapping these programs so that their ‘PYTHONPATH’
     environment variable points to all the Python libraries they depend
     on.

     Which Python package is used to perform the build can be specified
     with the ‘#:python’ parameter.  This is a useful way to force a
     package to be built for a specific version of the Python
     interpreter, which might be necessary if the package is only
     compatible with a single interpreter version.

     By default guix calls ‘setup.py’ under control of ‘setuptools’,
     much like ‘pip’ does.  Some packages are not compatible with
     setuptools (and pip), thus you can disable this by setting the
     ‘#:use-setuptools?’ parameter to ‘#f’.

 -- Scheme Variable: perl-build-system
     This variable is exported by ‘(guix build-system perl)’.  It
     implements the standard build procedure for Perl packages, which
     either consists in running ‘perl Build.PL --prefix=/gnu/store/...’,
     followed by ‘Build’ and ‘Build install’; or in running ‘perl
     Makefile.PL PREFIX=/gnu/store/...’, followed by ‘make’ and ‘make
     install’, depending on which of ‘Build.PL’ or ‘Makefile.PL’ is
     present in the package distribution.  Preference is given to the
     former if both ‘Build.PL’ and ‘Makefile.PL’ exist in the package
     distribution.  This preference can be reversed by specifying ‘#t’
     for the ‘#:make-maker?’ parameter.

     The initial ‘perl Makefile.PL’ or ‘perl Build.PL’ invocation passes
     flags specified by the ‘#:make-maker-flags’ or
     ‘#:module-build-flags’ parameter, respectively.

     Which Perl package is used can be specified with ‘#:perl’.

 -- Scheme Variable: qt-build-system
     This variable is exported by ‘(guix build-system qt)’.  It is
     intended for use with applications using Qt or KDE.

     This build system adds the following two phases to the ones defined
     by ‘cmake-build-system’:

     ‘check-setup’
          The phase ‘check-setup’ prepares the environment for running
          the checks as commonly used by Qt test programs.  For now this
          only sets some environment variables:
          ‘QT_QPA_PLATFORM=offscreen’, ‘DBUS_FATAL_WARNINGS=0’ and
          ‘CTEST_OUTPUT_ON_FAILURE=1’.

          This phase is added before the ‘check’ phase.  It’s a separate
          phase to ease adjusting if necessary.

     ‘qt-wrap’
          The phase ‘qt-wrap’ searches for Qt5 plugin paths, QML paths
          and some XDG in the inputs and output.  In case some path is
          found, all programs in the output’s ‘bin/’, ‘sbin/’,
          ‘libexec/’ and ‘lib/libexec/’ directories are wrapped in
          scripts defining the necessary environment variables.

          It is possible to exclude specific package outputs from that
          wrapping process by listing their names in the
          ‘#:qt-wrap-excluded-outputs’ parameter.  This is useful when
          an output is known not to contain any Qt binaries, and where
          wrapping would gratuitously add a dependency of that output on
          Qt, KDE, or such.

          This phase is added after the ‘install’ phase.

 -- Scheme Variable: r-build-system
     This variable is exported by ‘(guix build-system r)’.  It
     implements the build procedure used by R (https://r-project.org)
     packages, which essentially is little more than running ‘R CMD
     INSTALL --library=/gnu/store/...’ in an environment where
     ‘R_LIBS_SITE’ contains the paths to all R package inputs.  Tests
     are run after installation using the R function
     ‘tools::testInstalledPackage’.

 -- Scheme Variable: rakudo-build-system
     This variable is exported by ‘(guix build-system rakudo)’.  It
     implements the build procedure used by Rakudo (https://rakudo.org/)
     for Perl6 (https://perl6.org/) packages.  It installs the package
     to ‘/gnu/store/.../NAME-VERSION/share/perl6’ and installs the
     binaries, library files and the resources, as well as wrap the
     files under the ‘bin/’ directory.  Tests can be skipped by passing
     ‘#f’ to the ‘tests?’ parameter.

     Which rakudo package is used can be specified with ‘rakudo’.  Which
     perl6-tap-harness package used for the tests can be specified with
     ‘#:prove6’ or removed by passing ‘#f’ to the ‘with-prove6?’
     parameter.  Which perl6-zef package used for tests and installing
     can be specified with ‘#:zef’ or removed by passing ‘#f’ to the
     ‘with-zef?’ parameter.

 -- Scheme Variable: texlive-build-system
     This variable is exported by ‘(guix build-system texlive)’.  It is
     used to build TeX packages in batch mode with a specified engine.
     The build system sets the ‘TEXINPUTS’ variable to find all TeX
     source files in the inputs.

     By default it runs ‘luatex’ on all files ending on ‘ins’.  A
     different engine and format can be specified with the
     ‘#:tex-format’ argument.  Different build targets can be specified
     with the ‘#:build-targets’ argument, which expects a list of file
     names.  The build system adds only ‘texlive-bin’ and
     ‘texlive-latex-base’ (both from ‘(gnu packages tex’) to the inputs.
     Both can be overridden with the arguments ‘#:texlive-bin’ and
     ‘#:texlive-latex-base’, respectively.

     The ‘#:tex-directory’ parameter tells the build system where to
     install the built files under the texmf tree.

 -- Scheme Variable: ruby-build-system
     This variable is exported by ‘(guix build-system ruby)’.  It
     implements the RubyGems build procedure used by Ruby packages,
     which involves running ‘gem build’ followed by ‘gem install’.

     The ‘source’ field of a package that uses this build system
     typically references a gem archive, since this is the format that
     Ruby developers use when releasing their software.  The build
     system unpacks the gem archive, potentially patches the source,
     runs the test suite, repackages the gem, and installs it.
     Additionally, directories and tarballs may be referenced to allow
     building unreleased gems from Git or a traditional source release
     tarball.

     Which Ruby package is used can be specified with the ‘#:ruby’
     parameter.  A list of additional flags to be passed to the ‘gem’
     command can be specified with the ‘#:gem-flags’ parameter.

 -- Scheme Variable: waf-build-system
     This variable is exported by ‘(guix build-system waf)’.  It
     implements a build procedure around the ‘waf’ script.  The common
     phases—‘configure’, ‘build’, and ‘install’—are implemented by
     passing their names as arguments to the ‘waf’ script.

     The ‘waf’ script is executed by the Python interpreter.  Which
     Python package is used to run the script can be specified with the
     ‘#:python’ parameter.

 -- Scheme Variable: scons-build-system
     This variable is exported by ‘(guix build-system scons)’.  It
     implements the build procedure used by the SCons software
     construction tool.  This build system runs ‘scons’ to build the
     package, ‘scons test’ to run tests, and then ‘scons install’ to
     install the package.

     Additional flags to be passed to ‘scons’ can be specified with the
     ‘#:scons-flags’ parameter.  The default build and install targets
     can be overridden with ‘#:build-targets’ and ‘#:install-targets’
     respectively.  The version of Python used to run SCons can be
     specified by selecting the appropriate SCons package with the
     ‘#:scons’ parameter.

 -- Scheme Variable: haskell-build-system
     This variable is exported by ‘(guix build-system haskell)’.  It
     implements the Cabal build procedure used by Haskell packages,
     which involves running ‘runhaskell Setup.hs configure
     --prefix=/gnu/store/...’ and ‘runhaskell Setup.hs build’.  Instead
     of installing the package by running ‘runhaskell Setup.hs install’,
     to avoid trying to register libraries in the read-only compiler
     store directory, the build system uses ‘runhaskell Setup.hs copy’,
     followed by ‘runhaskell Setup.hs register’.  In addition, the build
     system generates the package documentation by running ‘runhaskell
     Setup.hs haddock’, unless ‘#:haddock? #f’ is passed.  Optional
     Haddock parameters can be passed with the help of the
     ‘#:haddock-flags’ parameter.  If the file ‘Setup.hs’ is not found,
     the build system looks for ‘Setup.lhs’ instead.

     Which Haskell compiler is used can be specified with the
     ‘#:haskell’ parameter which defaults to ‘ghc’.

 -- Scheme Variable: dub-build-system
     This variable is exported by ‘(guix build-system dub)’.  It
     implements the Dub build procedure used by D packages, which
     involves running ‘dub build’ and ‘dub run’.  Installation is done
     by copying the files manually.

     Which D compiler is used can be specified with the ‘#:ldc’
     parameter which defaults to ‘ldc’.

 -- Scheme Variable: emacs-build-system
     This variable is exported by ‘(guix build-system emacs)’.  It
     implements an installation procedure similar to the packaging
     system of Emacs itself (*note (emacs)Packages::).

     It first creates the ‘package-autoloads.el’ file, then it byte
     compiles all Emacs Lisp files.  Differently from the Emacs
     packaging system, the Info documentation files are moved to the
     standard documentation directory and the ‘dir’ file is deleted.
     The Elisp package files are installed directly under
     ‘share/emacs/site-lisp’.

 -- Scheme Variable: font-build-system
     This variable is exported by ‘(guix build-system font)’.  It
     implements an installation procedure for font packages where
     upstream provides pre-compiled TrueType, OpenType, etc. font files
     that merely need to be copied into place.  It copies font files to
     standard locations in the output directory.

 -- Scheme Variable: meson-build-system
     This variable is exported by ‘(guix build-system meson)’.  It
     implements the build procedure for packages that use Meson
     (https://mesonbuild.com) as their build system.

     It adds both Meson and Ninja (https://ninja-build.org/) to the set
     of inputs, and they can be changed with the parameters ‘#:meson’
     and ‘#:ninja’ if needed.  The default Meson is ‘meson-for-build’,
     which is special because it doesn’t clear the ‘RUNPATH’ of binaries
     and libraries when they are installed.

     This build system is an extension of ‘gnu-build-system’, but with
     the following phases changed to some specific for Meson:

     ‘configure’
          The phase runs ‘meson’ with the flags specified in
          ‘#:configure-flags’.  The flag ‘--buildtype’ is always set to
          ‘debugoptimized’ unless something else is specified in
          ‘#:build-type’.

     ‘build’
          The phase runs ‘ninja’ to build the package in parallel by
          default, but this can be changed with ‘#:parallel-build?’.

     ‘check’
          The phase runs ‘ninja’ with the target specified in
          ‘#:test-target’, which is ‘"test"’ by default.

     ‘install’
          The phase runs ‘ninja install’ and can not be changed.

     Apart from that, the build system also adds the following phases:

     ‘fix-runpath’
          This phase ensures that all binaries can find the libraries
          they need.  It searches for required libraries in
          subdirectories of the package being built, and adds those to
          ‘RUNPATH’ where needed.  It also removes references to
          libraries left over from the build phase by ‘meson-for-build’,
          such as test dependencies, that aren’t actually required for
          the program to run.

     ‘glib-or-gtk-wrap’
          This phase is the phase provided by
          ‘glib-or-gtk-build-system’, and it is not enabled by default.
          It can be enabled with ‘#:glib-or-gtk?’.

     ‘glib-or-gtk-compile-schemas’
          This phase is the phase provided by
          ‘glib-or-gtk-build-system’, and it is not enabled by default.
          It can be enabled with ‘#:glib-or-gtk?’.

 -- Scheme Variable: linux-module-build-system
     ‘linux-module-build-system’ allows building Linux kernel modules.

     This build system is an extension of ‘gnu-build-system’, but with
     the following phases changed:

     ‘configure’
          This phase configures the environment so that the Linux
          kernel’s Makefile can be used to build the external kernel
          module.

     ‘build’
          This phase uses the Linux kernel’s Makefile in order to build
          the external kernel module.

     ‘install’
          This phase uses the Linux kernel’s Makefile in order to
          install the external kernel module.

     It is possible and useful to specify the Linux kernel to use for
     building the module (in the ‘arguments’ form of a package using the
     ‘linux-module-build-system’, use the key ‘#:linux’ to specify it).

 -- Scheme Variable: node-build-system
     This variable is exported by ‘(guix build-system node)’.  It
     implements the build procedure used by Node.js
     (https://nodejs.org), which implements an approximation of the ‘npm
     install’ command, followed by an ‘npm test’ command.

     Which Node.js package is used to interpret the ‘npm’ commands can
     be specified with the ‘#:node’ parameter which defaults to ‘node’.

   Lastly, for packages that do not need anything as sophisticated, a
“trivial” build system is provided.  It is trivial in the sense that it
provides basically no support: it does not pull any implicit inputs, and
does not have a notion of build phases.

 -- Scheme Variable: trivial-build-system
     This variable is exported by ‘(guix build-system trivial)’.

     This build system requires a ‘#:builder’ argument.  This argument
     must be a Scheme expression that builds the package output(s)—as
     with ‘build-expression->derivation’ (*note
     ‘build-expression->derivation’: Деривации.).

   ---------- Footnotes ----------

   (1) Please see the ‘(guix build gnu-build-system)’ modules for more
details about the build phases.


File: guix.ru.info,  Node: Хранилище,  Next: Деривации,  Prev: Системы сборки,  Up: Программный интерфейс

6.4 Хранилище
=============

Conceptually, the “store” is the place where derivations that have been
built successfully are stored—by default, ‘/gnu/store’.  Sub-directories
in the store are referred to as “store items” or sometimes “store
paths”.  The store has an associated database that contains information
such as the store paths referred to by each store path, and the list of
_valid_ store items—results of successful builds.  This database resides
in ‘LOCALSTATEDIR/guix/db’, where LOCALSTATEDIR is the state directory
specified via ‘--localstatedir’ at configure time, usually ‘/var’.

   The store is _always_ accessed by the daemon on behalf of its clients
(*note Вызов guix-daemon::).  To manipulate the store, clients connect
to the daemon over a Unix-domain socket, send requests to it, and read
the result—these are remote procedure calls, or RPCs.

     Примечание: Users must _never_ modify files under ‘/gnu/store’
     directly.  This would lead to inconsistencies and break the
     immutability assumptions of Guix’s functional model (*note
     Введение::).

     *Note ‘guix gc --verify’: Вызов guix gc, for information on how to
     check the integrity of the store and attempt recovery from
     accidental modifications.

   The ‘(guix store)’ module provides procedures to connect to the
daemon, and to perform RPCs.  These are described below.  By default,
‘open-connection’, and thus all the ‘guix’ commands, connect to the
local daemon or to the URI specified by the ‘GUIX_DAEMON_SOCKET’
environment variable.

 -- Environment Variable: GUIX_DAEMON_SOCKET
     When set, the value of this variable should be a file name or a URI
     designating the daemon endpoint.  When it is a file name, it
     denotes a Unix-domain socket to connect to.  In addition to file
     names, the supported URI schemes are:

     ‘file’
     ‘unix’
          These are for Unix-domain sockets.
          ‘file:///var/guix/daemon-socket/socket’ is equivalent to
          ‘/var/guix/daemon-socket/socket’.

     ‘guix’
          These URIs denote connections over TCP/IP, without encryption
          nor authentication of the remote host.  The URI must specify
          the host name and optionally a port number (by default port
          44146 is used):

               guix://master.guix.example.org:1234

          This setup is suitable on local networks, such as clusters,
          where only trusted nodes may connect to the build daemon at
          ‘master.guix.example.org’.

          The ‘--listen’ option of ‘guix-daemon’ can be used to instruct
          it to listen for TCP connections (*note ‘--listen’: Вызов
          guix-daemon.).

     ‘ssh’
          These URIs allow you to connect to a remote daemon over SSH.
          This feature requires Guile-SSH (*note Требования::) and a
          working ‘guile’ binary in ‘PATH’ on the destination machine.
          It supports public key and GSSAPI authentication.  A typical
          URL might look like this:

               ssh://charlie@guix.example.org:22

          As for ‘guix copy’, the usual OpenSSH client configuration
          files are honored (*note Запуск guix copy::).

     Additional URI schemes may be supported in the future.

          Примечание: The ability to connect to remote build daemons is
          considered experimental as of 1.0.1.17089-7e269.  Please get
          in touch with us to share any problems or suggestions you may
          have (*note Содействие::).

 -- Scheme Procedure: open-connection [URI] [#:reserve-space? #t]
     Connect to the daemon over the Unix-domain socket at URI (a
     string).  When RESERVE-SPACE? is true, instruct it to reserve a
     little bit of extra space on the file system so that the garbage
     collector can still operate should the disk become full.  Return a
     server object.

     FILE defaults to ‘%default-socket-path’, which is the normal
     location given the options that were passed to ‘configure’.

 -- Scheme Procedure: close-connection SERVER
     Close the connection to SERVER.

 -- Scheme Variable: current-build-output-port
     This variable is bound to a SRFI-39 parameter, which refers to the
     port where build and error logs sent by the daemon should be
     written.

   Procedures that make RPCs all take a server object as their first
argument.

 -- Scheme Procedure: valid-path? SERVER PATH
     Return ‘#t’ when PATH designates a valid store item and ‘#f’
     otherwise (an invalid item may exist on disk but still be invalid,
     for instance because it is the result of an aborted or failed
     build).

     A ‘&store-protocol-error’ condition is raised if PATH is not
     prefixed by the store directory (‘/gnu/store’).

 -- Scheme Procedure: add-text-to-store SERVER NAME TEXT [REFERENCES]
     Add TEXT under file NAME in the store, and return its store path.
     REFERENCES is the list of store paths referred to by the resulting
     store path.

 -- Scheme Procedure: build-derivations STORE DERIVATIONS [MODE] Build
          DERIVATIONS, a list of ‘<derivation>’ objects,
     ‘.drv’ file names, or derivation/output pairs, using the specified
     MODE—‘(build-mode normal)’ by default.

   Note that the ‘(guix monads)’ module provides a monad as well as
monadic versions of the above procedures, with the goal of making it
more convenient to work with code that accesses the store (*note
Устройство склада::).

   This section is currently incomplete.


File: guix.ru.info,  Node: Деривации,  Next: Устройство склада,  Prev: Хранилище,  Up: Программный интерфейс

6.5 Деривации
=============

Low-level build actions and the environment in which they are performed
are represented by “derivations”.  A derivation contains the following
pieces of information:

   • The outputs of the derivation—derivations produce at least one file
     or directory in the store, but may produce more.

   • The inputs of the derivations—i.e., its build-time
     dependencies—which may be other derivations or plain files in the
     store (patches, build scripts, etc.).

   • The system type targeted by the derivation—e.g., ‘x86_64-linux’.

   • The file name of a build script in the store, along with the
     arguments to be passed.

   • A list of environment variables to be defined.

   Derivations allow clients of the daemon to communicate build actions
to the store.  They exist in two forms: as an in-memory representation,
both on the client- and daemon-side, and as files in the store whose
name end in ‘.drv’—these files are referred to as “derivation paths”.
Derivations paths can be passed to the ‘build-derivations’ procedure to
perform the build actions they prescribe (*note Хранилище::).

   Operations such as file downloads and version-control checkouts for
which the expected content hash is known in advance are modeled as
“fixed-output derivations”.  Unlike regular derivations, the outputs of
a fixed-output derivation are independent of its inputs—e.g., a source
code download produces the same result regardless of the download method
and tools being used.

   The outputs of derivations—i.e., the build results—have a set of
“references”, as reported by the ‘references’ RPC or the ‘guix gc
--references’ command (*note Вызов guix gc::).  References are the set
of run-time dependencies of the build results.  References are a subset
of the inputs of the derivation; this subset is automatically computed
by the build daemon by scanning all the files in the outputs.

   The ‘(guix derivations)’ module provides a representation of
derivations as Scheme objects, along with procedures to create and
otherwise manipulate derivations.  The lowest-level primitive to create
a derivation is the ‘derivation’ procedure:

 -- Scheme Procedure: derivation STORE NAME BUILDER ARGS [#:outputs
          '("out")] [#:hash #f] [#:hash-algo #f]  [#:recursive?
     #f] [#:inputs ’()] [#:env-vars ’()]  [#:system (%current-system)]
     [#:references-graphs #f]  [#:allowed-references #f]
     [#:disallowed-references #f]  [#:leaked-env-vars #f]
     [#:local-build?  #f]  [#:substitutable?  #t] [#:properties ’()]
     Build a derivation with the given arguments, and return the
     resulting ‘<derivation>’ object.

     When HASH and HASH-ALGO are given, a “fixed-output derivation” is
     created—i.e., one whose result is known in advance, such as a file
     download.  If, in addition, RECURSIVE? is true, then that fixed
     output may be an executable file or a directory and HASH must be
     the hash of an archive containing this output.

     When REFERENCES-GRAPHS is true, it must be a list of file
     name/store path pairs.  In that case, the reference graph of each
     store path is exported in the build environment in the
     corresponding file, in a simple text format.

     When ALLOWED-REFERENCES is true, it must be a list of store items
     or outputs that the derivation’s output may refer to.  Likewise,
     DISALLOWED-REFERENCES, if true, must be a list of things the
     outputs may _not_ refer to.

     When LEAKED-ENV-VARS is true, it must be a list of strings denoting
     environment variables that are allowed to “leak” from the daemon’s
     environment to the build environment.  This is only applicable to
     fixed-output derivations—i.e., when HASH is true.  The main use is
     to allow variables such as ‘http_proxy’ to be passed to derivations
     that download files.

     When LOCAL-BUILD? is true, declare that the derivation is not a
     good candidate for offloading and should rather be built locally
     (*note Установка демона разгрузки::).  This is the case for small
     derivations where the costs of data transfers would outweigh the
     benefits.

     When SUBSTITUTABLE? is false, declare that substitutes of the
     derivation’s output should not be used (*note Подстановки::).  This
     is useful, for instance, when building packages that capture
     details of the host CPU instruction set.

     PROPERTIES must be an association list describing “properties” of
     the derivation.  It is kept as-is, uninterpreted, in the
     derivation.

Here’s an example with a shell script as its builder, assuming STORE is
an open connection to the daemon, and BASH points to a Bash executable
in the store:

     (use-modules (guix utils)
                  (guix store)
                  (guix derivations))

     (let ((builder   ; add the Bash script to the store
             (add-text-to-store store "my-builder.sh"
                                "echo hello world > $out\n" '())))
       (derivation store "foo"
                   bash `("-e" ,builder)
                   #:inputs `((,bash) (,builder))
                   #:env-vars '(("HOME" . "/homeless"))))
     ⇒ #<derivation /gnu/store/...-foo.drv => /gnu/store/...-foo>

   As can be guessed, this primitive is cumbersome to use directly.  A
better approach is to write build scripts in Scheme, of course!  The
best course of action for that is to write the build code as a
“G-expression”, and to pass it to ‘gexp->derivation’.  For more
information, *note G-Expressions::.

   Once upon a time, ‘gexp->derivation’ did not exist and constructing
derivations with build code written in Scheme was achieved with
‘build-expression->derivation’, documented below.  This procedure is now
deprecated in favor of the much nicer ‘gexp->derivation’.

 -- Scheme Procedure: build-expression->derivation STORE NAME EXP
           [#:system (%current-system)] [#:inputs '()] [#:outputs
          '("out")] [#:hash #f] [#:hash-algo #f]  [#:recursive? #f]
     [#:env-vars ’()] [#:modules ’()]  [#:references-graphs #f]
     [#:allowed-references #f]  [#:disallowed-references #f]
      [#:local-build?  #f] [#:substitutable?  #t] [#:guile-for-build #f]
     Return a derivation that executes Scheme expression EXP as a
     builder for derivation NAME.  INPUTS must be a list of ‘(name
     drv-path sub-drv)’ tuples; when SUB-DRV is omitted, ‘"out"’ is
     assumed.  MODULES is a list of names of Guile modules from the
     current search path to be copied in the store, compiled, and made
     available in the load path during the execution of EXP—e.g.,
     ‘((guix build utils) (guix build gnu-build-system))’.

     EXP is evaluated in an environment where ‘%outputs’ is bound to a
     list of output/path pairs, and where ‘%build-inputs’ is bound to a
     list of string/output-path pairs made from INPUTS.  Optionally,
     ENV-VARS is a list of string pairs specifying the name and value of
     environment variables visible to the builder.  The builder
     terminates by passing the result of EXP to ‘exit’; thus, when EXP
     returns ‘#f’, the build is considered to have failed.

     EXP is built using GUILE-FOR-BUILD (a derivation).  When
     GUILE-FOR-BUILD is omitted or is ‘#f’, the value of the
     ‘%guile-for-build’ fluid is used instead.

     See the ‘derivation’ procedure for the meaning of
     REFERENCES-GRAPHS, ALLOWED-REFERENCES, DISALLOWED-REFERENCES,
     LOCAL-BUILD?, and SUBSTITUTABLE?.

Here’s an example of a single-output derivation that creates a directory
containing one file:

     (let ((builder '(let ((out (assoc-ref %outputs "out")))
                       (mkdir out)    ; create /gnu/store/...-goo
                       (call-with-output-file (string-append out "/test")
                         (lambda (p)
                           (display '(hello guix) p))))))
       (build-expression->derivation store "goo" builder))

     ⇒ #<derivation /gnu/store/...-goo.drv => ...>


File: guix.ru.info,  Node: Устройство склада,  Next: G-Expressions,  Prev: Деривации,  Up: Программный интерфейс

6.6 Устройство склада
=====================

The procedures that operate on the store described in the previous
sections all take an open connection to the build daemon as their first
argument.  Although the underlying model is functional, they either have
side effects or depend on the current state of the store.

   The former is inconvenient: the connection to the build daemon has to
be carried around in all those functions, making it impossible to
compose functions that do not take that parameter with functions that
do.  The latter can be problematic: since store operations have side
effects and/or depend on external state, they have to be properly
sequenced.

   This is where the ‘(guix monads)’ module comes in.  This module
provides a framework for working with “monads”, and a particularly
useful monad for our uses, the “store monad”.  Monads are a construct
that allows two things: associating “context” with values (in our case,
the context is the store), and building sequences of computations (here
computations include accesses to the store).  Values in a monad—values
that carry this additional context—are called “monadic values”;
procedures that return such values are called “monadic procedures”.

   Consider this “normal” procedure:

     (define (sh-symlink store)
       ;; Return a derivation that symlinks the 'bash' executable.
       (let* ((drv (package-derivation store bash))
              (out (derivation->output-path drv))
              (sh  (string-append out "/bin/bash")))
         (build-expression->derivation store "sh"
                                       `(symlink ,sh %output))))

   Using ‘(guix monads)’ and ‘(guix gexp)’, it may be rewritten as a
monadic function:

     (define (sh-symlink)
       ;; Same, but return a monadic value.
       (mlet %store-monad ((drv (package->derivation bash)))
         (gexp->derivation "sh"
                           #~(symlink (string-append #$drv "/bin/bash")
                                      #$output))))

   There are several things to note in the second version: the ‘store’
parameter is now implicit and is “threaded” in the calls to the
‘package->derivation’ and ‘gexp->derivation’ monadic procedures, and the
monadic value returned by ‘package->derivation’ is “bound” using ‘mlet’
instead of plain ‘let’.

   As it turns out, the call to ‘package->derivation’ can even be
omitted since it will take place implicitly, as we will see later (*note
G-Expressions::):

     (define (sh-symlink)
       (gexp->derivation "sh"
                         #~(symlink (string-append #$bash "/bin/bash")
                                    #$output)))

   Calling the monadic ‘sh-symlink’ has no effect.  As someone once
said, “you exit a monad like you exit a building on fire: by running”.
So, to exit the monad and get the desired effect, one must use
‘run-with-store’:

     (run-with-store (open-connection) (sh-symlink))
     ⇒ /gnu/store/...-sh-symlink

   Note that the ‘(guix monad-repl)’ module extends the Guile REPL with
new “meta-commands” to make it easier to deal with monadic procedures:
‘run-in-store’, and ‘enter-store-monad’.  The former is used to “run” a
single monadic value through the store:

     scheme@(guile-user)> ,run-in-store (package->derivation hello)
     $1 = #<derivation /gnu/store/...-hello-2.9.drv => ...>

   The latter enters a recursive REPL, where all the return values are
automatically run through the store:

     scheme@(guile-user)> ,enter-store-monad
     store-monad@(guile-user) [1]> (package->derivation hello)
     $2 = #<derivation /gnu/store/...-hello-2.9.drv => ...>
     store-monad@(guile-user) [1]> (text-file "foo" "Hello!")
     $3 = "/gnu/store/...-foo"
     store-monad@(guile-user) [1]> ,q
     scheme@(guile-user)>

Note that non-monadic values cannot be returned in the ‘store-monad’
REPL.

   The main syntactic forms to deal with monads in general are provided
by the ‘(guix monads)’ module and are described below.

 -- Scheme Syntax: with-monad MONAD BODY ...
     Evaluate any ‘>>=’ or ‘return’ forms in BODY as being in MONAD.

 -- Scheme Syntax: return VAL
     Return a monadic value that encapsulates VAL.

 -- Scheme Syntax: >>= MVAL MPROC ...
     “Bind” monadic value MVAL, passing its “contents” to monadic
     procedures MPROC...(1).  There can be one MPROC or several of them,
     as in this example:

          (run-with-state
              (with-monad %state-monad
                (>>= (return 1)
                     (lambda (x) (return (+ 1 x)))
                     (lambda (x) (return (* 2 x)))))
            'some-state)

          ⇒ 4
          ⇒ some-state

 -- Scheme Syntax: mlet MONAD ((VAR MVAL) ...) BODY ...
 -- Scheme Syntax: mlet* MONAD ((VAR MVAL) ...) BODY ... Bind the
          variables VAR to the monadic values
     MVAL in BODY, which is a sequence of expressions.  As with the bind
     operator, this can be thought of as “unpacking” the raw,
     non-monadic value “contained” in MVAL and making VAR refer to that
     raw, non-monadic value within the scope of the BODY.  The form (VAR
     -> VAL) binds VAR to the “normal” value VAL, as per ‘let’.  The
     binding operations occur in sequence from left to right.  The last
     expression of BODY must be a monadic expression, and its result
     will become the result of the ‘mlet’ or ‘mlet*’ when run in the
     MONAD.

     ‘mlet*’ is to ‘mlet’ what ‘let*’ is to ‘let’ (*note (guile)Local
     Bindings::).

 -- Scheme System: mbegin MONAD MEXP ...
     Bind MEXP and the following monadic expressions in sequence,
     returning the result of the last expression.  Every expression in
     the sequence must be a monadic expression.

     This is akin to ‘mlet’, except that the return values of the
     monadic expressions are ignored.  In that sense, it is analogous to
     ‘begin’, but applied to monadic expressions.

 -- Scheme System: mwhen CONDITION MEXP0 MEXP* ...
     When CONDITION is true, evaluate the sequence of monadic
     expressions MEXP0..MEXP* as in an ‘mbegin’.  When CONDITION is
     false, return ‘*unspecified*’ in the current monad.  Every
     expression in the sequence must be a monadic expression.

 -- Scheme System: munless CONDITION MEXP0 MEXP* ...
     When CONDITION is false, evaluate the sequence of monadic
     expressions MEXP0..MEXP* as in an ‘mbegin’.  When CONDITION is
     true, return ‘*unspecified*’ in the current monad.  Every
     expression in the sequence must be a monadic expression.

   The ‘(guix monads)’ module provides the “state monad”, which allows
an additional value—the state—to be _threaded_ through monadic procedure
calls.

 -- Scheme Variable: %state-monad
     The state monad.  Procedures in the state monad can access and
     change the state that is threaded.

     Consider the example below.  The ‘square’ procedure returns a value
     in the state monad.  It returns the square of its argument, but
     also increments the current state value:

          (define (square x)
            (mlet %state-monad ((count (current-state)))
              (mbegin %state-monad
                (set-current-state (+ 1 count))
                (return (* x x)))))

          (run-with-state (sequence %state-monad (map square (iota 3))) 0)
          ⇒ (0 1 4)
          ⇒ 3

     When “run” through ‘%state-monad’, we obtain that additional state
     value, which is the number of ‘square’ calls.

 -- Monadic Procedure: current-state
     Return the current state as a monadic value.

 -- Monadic Procedure: set-current-state VALUE
     Set the current state to VALUE and return the previous state as a
     monadic value.

 -- Monadic Procedure: state-push VALUE
     Push VALUE to the current state, which is assumed to be a list, and
     return the previous state as a monadic value.

 -- Monadic Procedure: state-pop
     Pop a value from the current state and return it as a monadic
     value.  The state is assumed to be a list.

 -- Scheme Procedure: run-with-state MVAL [STATE]
     Run monadic value MVAL starting with STATE as the initial state.
     Return two values: the resulting value, and the resulting state.

   The main interface to the store monad, provided by the ‘(guix store)’
module, is as follows.

 -- Scheme Variable: %store-monad
     The store monad—an alias for ‘%state-monad’.

     Values in the store monad encapsulate accesses to the store.  When
     its effect is needed, a value of the store monad must be
     “evaluated” by passing it to the ‘run-with-store’ procedure (see
     below).

 -- Scheme Procedure: run-with-store STORE MVAL [#:guile-for-build]
          [#:system (%current-system)]
     Run MVAL, a monadic value in the store monad, in STORE, an open
     store connection.

 -- Monadic Procedure: text-file NAME TEXT [REFERENCES]
     Return as a monadic value the absolute file name in the store of
     the file containing TEXT, a string.  REFERENCES is a list of store
     items that the resulting text file refers to; it defaults to the
     empty list.

 -- Monadic Procedure: binary-file NAME DATA [REFERENCES]
     Return as a monadic value the absolute file name in the store of
     the file containing DATA, a bytevector.  REFERENCES is a list of
     store items that the resulting binary file refers to; it defaults
     to the empty list.

 -- Monadic Procedure: interned-file FILE [NAME] [#:recursive? #t]
          [#:select? (const #t)] Return the name of FILE once
     interned in the store.  Use NAME as its store name, or the basename
     of FILE if NAME is omitted.

     When RECURSIVE? is true, the contents of FILE are added
     recursively; if FILE designates a flat file and RECURSIVE? is true,
     its contents are added, and its permission bits are kept.

     When RECURSIVE? is true, call ‘(SELECT? FILE STAT)’ for each
     directory entry, where FILE is the entry’s absolute file name and
     STAT is the result of ‘lstat’; exclude entries for which SELECT?
     does not return true.

     The example below adds a file to the store, under two different
     names:

          (run-with-store (open-connection)
            (mlet %store-monad ((a (interned-file "README"))
                                (b (interned-file "README" "LEGU-MIN")))
              (return (list a b))))

          ⇒ ("/gnu/store/rwm...-README" "/gnu/store/44i...-LEGU-MIN")

   The ‘(guix packages)’ module exports the following package-related
monadic procedures:

 -- Monadic Procedure: package-file PACKAGE [FILE] [#:system
          (%current-system)] [#:target #f]  [#:output "out"] Return as a
     monadic value in the absolute file name of FILE within the OUTPUT
     directory of PACKAGE.  When FILE is omitted, return the name of the
     OUTPUT directory of PACKAGE.  When TARGET is true, use it as a
     cross-compilation target triplet.

     Note that this procedure does _not_ build PACKAGE.  Thus, the
     result might or might not designate an existing file.  We recommend
     not using this procedure unless you know what you are doing.

 -- Monadic Procedure: package->derivation PACKAGE [SYSTEM]
 -- Monadic Procedure: package->cross-derivation PACKAGE TARGET [SYSTEM]
          Monadic version of ‘package-derivation’ and
     ‘package-cross-derivation’ (*note Описание пакетов::).

   ---------- Footnotes ----------

   (1) This operation is commonly referred to as “bind”, but that name
denotes an unrelated procedure in Guile.  Thus we use this somewhat
cryptic symbol inherited from the Haskell language.


File: guix.ru.info,  Node: G-Expressions,  Next: Запуск guix repl,  Prev: Устройство склада,  Up: Программный интерфейс

6.7 G-Expressions
=================

So we have “derivations”, which represent a sequence of build actions to
be performed to produce an item in the store (*note Деривации::).  These
build actions are performed when asking the daemon to actually build the
derivations; they are run by the daemon in a container (*note Вызов
guix-daemon::).

   It should come as no surprise that we like to write these build
actions in Scheme.  When we do that, we end up with two “strata” of
Scheme code(1): the “host code”—code that defines packages, talks to the
daemon, etc.—and the “build code”—code that actually performs build
actions, such as making directories, invoking ‘make’, etc.

   To describe a derivation and its build actions, one typically needs
to embed build code inside host code.  It boils down to manipulating
build code as data, and the homoiconicity of Scheme—code has a direct
representation as data—comes in handy for that.  But we need more than
the normal ‘quasiquote’ mechanism in Scheme to construct build
expressions.

   The ‘(guix gexp)’ module implements “G-expressions”, a form of
S-expressions adapted to build expressions.  G-expressions, or “gexps”,
consist essentially of three syntactic forms: ‘gexp’, ‘ungexp’, and
‘ungexp-splicing’ (or simply: ‘#~’, ‘#$’, and ‘#$@’), which are
comparable to ‘quasiquote’, ‘unquote’, and ‘unquote-splicing’,
respectively (*note ‘quasiquote’: (guile)Expression Syntax.).  However,
there are major differences:

   • Gexps are meant to be written to a file and run or manipulated by
     other processes.

   • When a high-level object such as a package or derivation is
     unquoted inside a gexp, the result is as if its output file name
     had been introduced.

   • Gexps carry information about the packages or derivations they
     refer to, and these dependencies are automatically added as inputs
     to the build processes that use them.

   This mechanism is not limited to package and derivation objects:
“compilers” able to “lower” other high-level objects to derivations or
files in the store can be defined, such that these objects can also be
inserted into gexps.  For example, a useful type of high-level objects
that can be inserted in a gexp is “file-like objects”, which make it
easy to add files to the store and to refer to them in derivations and
such (see ‘local-file’ and ‘plain-file’ below).

   To illustrate the idea, here is an example of a gexp:

     (define build-exp
       #~(begin
           (mkdir #$output)
           (chdir #$output)
           (symlink (string-append #$coreutils "/bin/ls")
                    "list-files")))

   This gexp can be passed to ‘gexp->derivation’; we obtain a derivation
that builds a directory containing exactly one symlink to
‘/gnu/store/...-coreutils-8.22/bin/ls’:

     (gexp->derivation "the-thing" build-exp)

   As one would expect, the ‘"/gnu/store/...-coreutils-8.22"’ string is
substituted to the reference to the COREUTILS package in the actual
build code, and COREUTILS is automatically made an input to the
derivation.  Likewise, ‘#$output’ (equivalent to ‘(ungexp output)’) is
replaced by a string containing the directory name of the output of the
derivation.

   In a cross-compilation context, it is useful to distinguish between
references to the _native_ build of a package—that can run on the
host—versus references to cross builds of a package.  To that end, the
‘#+’ plays the same role as ‘#$’, but is a reference to a native package
build:

     (gexp->derivation "vi"
        #~(begin
            (mkdir #$output)
            (mkdir (string-append #$output "/bin"))
            (system* (string-append #+coreutils "/bin/ln")
                     "-s"
                     (string-append #$emacs "/bin/emacs")
                     (string-append #$output "/bin/vi")))
        #:target "aarch64-linux-gnu")

In the example above, the native build of COREUTILS is used, so that
‘ln’ can actually run on the host; but then the cross-compiled build of
EMACS is referenced.

   Another gexp feature is “imported modules”: sometimes you want to be
able to use certain Guile modules from the “host environment” in the
gexp, so those modules should be imported in the “build environment”.
The ‘with-imported-modules’ form allows you to express that:

     (let ((build (with-imported-modules '((guix build utils))
                    #~(begin
                        (use-modules (guix build utils))
                        (mkdir-p (string-append #$output "/bin"))))))
       (gexp->derivation "empty-dir"
                         #~(begin
                             #$build
                             (display "success!\n")
                             #t)))

In this example, the ‘(guix build utils)’ module is automatically pulled
into the isolated build environment of our gexp, such that ‘(use-modules
(guix build utils))’ works as expected.

   Usually you want the _closure_ of the module to be imported—i.e., the
module itself and all the modules it depends on—rather than just the
module; failing to do that, attempts to use the module will fail because
of missing dependent modules.  The ‘source-module-closure’ procedure
computes the closure of a module by looking at its source file headers,
which comes in handy in this case:

     (use-modules (guix modules))   ;for 'source-module-closure'

     (with-imported-modules (source-module-closure
                              '((guix build utils)
                                (gnu build vm)))
       (gexp->derivation "something-with-vms"
                         #~(begin
                             (use-modules (guix build utils)
                                          (gnu build vm))
                             ...)))

   In the same vein, sometimes you want to import not just pure-Scheme
modules, but also “extensions” such as Guile bindings to C libraries or
other “full-blown” packages.  Say you need the ‘guile-json’ package
available on the build side, here’s how you would do it:

     (use-modules (gnu packages guile))  ;for 'guile-json'

     (with-extensions (list guile-json)
       (gexp->derivation "something-with-json"
                         #~(begin
                             (use-modules (json))
                             ...)))

   The syntactic form to construct gexps is summarized below.

 -- Scheme Syntax: #~EXP
 -- Scheme Syntax: (gexp EXP)
     Return a G-expression containing EXP.  EXP may contain one or more
     of the following forms:

     ‘#$OBJ’
     ‘(ungexp OBJ)’
          Introduce a reference to OBJ.  OBJ may have one of the
          supported types, for example a package or a derivation, in
          which case the ‘ungexp’ form is replaced by its output file
          name—e.g., ‘"/gnu/store/...-coreutils-8.22’.

          If OBJ is a list, it is traversed and references to supported
          objects are substituted similarly.

          If OBJ is another gexp, its contents are inserted and its
          dependencies are added to those of the containing gexp.

          If OBJ is another kind of object, it is inserted as is.

     ‘#$OBJ:OUTPUT’
     ‘(ungexp OBJ OUTPUT)’
          This is like the form above, but referring explicitly to the
          OUTPUT of OBJ—this is useful when OBJ produces multiple
          outputs (*note Пакеты со множественным выходом::).

     ‘#+OBJ’
     ‘#+OBJ:output’
     ‘(ungexp-native OBJ)’
     ‘(ungexp-native OBJ OUTPUT)’
          Same as ‘ungexp’, but produces a reference to the _native_
          build of OBJ when used in a cross compilation context.

     ‘#$output[:OUTPUT]’
     ‘(ungexp output [OUTPUT])’
          Insert a reference to derivation output OUTPUT, or to the main
          output when OUTPUT is omitted.

          This only makes sense for gexps passed to ‘gexp->derivation’.

     ‘#$@LST’
     ‘(ungexp-splicing LST)’
          Like the above, but splices the contents of LST inside the
          containing list.

     ‘#+@LST’
     ‘(ungexp-native-splicing LST)’
          Like the above, but refers to native builds of the objects
          listed in LST.

     G-expressions created by ‘gexp’ or ‘#~’ are run-time objects of the
     ‘gexp?’ type (see below).

 -- Scheme Syntax: with-imported-modules MODULES BODY...
     Mark the gexps defined in BODY... as requiring MODULES in their
     execution environment.

     Each item in MODULES can be the name of a module, such as ‘(guix
     build utils)’, or it can be a module name, followed by an arrow,
     followed by a file-like object:

          `((guix build utils)
            (guix gcrypt)
            ((guix config) => ,(scheme-file "config.scm"
                                            #~(define-module ...))))

     In the example above, the first two modules are taken from the
     search path, and the last one is created from the given file-like
     object.

     This form has _lexical_ scope: it has an effect on the gexps
     directly defined in BODY..., but not on those defined, say, in
     procedures called from BODY....

 -- Scheme Syntax: with-extensions EXTENSIONS BODY...
     Mark the gexps defined in BODY... as requiring EXTENSIONS in their
     build and execution environment.  EXTENSIONS is typically a list of
     package objects such as those defined in the ‘(gnu packages guile)’
     module.

     Concretely, the packages listed in EXTENSIONS are added to the load
     path while compiling imported modules in BODY...; they are also
     added to the load path of the gexp returned by BODY....

 -- Scheme Procedure: gexp? OBJ
     Return ‘#t’ if OBJ is a G-expression.

   G-expressions are meant to be written to disk, either as code
building some derivation, or as plain files in the store.  The monadic
procedures below allow you to do that (*note Устройство склада::, for
more information about monads).

 -- Monadic Procedure: gexp->derivation NAME EXP [#:system
          (%current-system)] [#:target #f] [#:graft? #t]  [#:hash #f]
     [#:hash-algo #f]  [#:recursive?  #f] [#:env-vars ’()] [#:modules
     ’()]  [#:module-path ‘%load-path’]  [#:effective-version "2.2"]
      [#:references-graphs #f] [#:allowed-references #f]
      [#:disallowed-references #f]  [#:leaked-env-vars #f]
      [#:script-name (string-append NAME "-builder")]
      [#:deprecation-warnings #f]  [#:local-build?  #f]
     [#:substitutable?  #t]  [#:properties ’()] [#:guile-for-build #f]
     Return a derivation NAME that runs EXP (a gexp) with
     GUILE-FOR-BUILD (a derivation) on SYSTEM; EXP is stored in a file
     called SCRIPT-NAME.  When TARGET is true, it is used as the
     cross-compilation target triplet for packages referred to by EXP.

     MODULES is deprecated in favor of ‘with-imported-modules’.  Its
     meaning is to make MODULES available in the evaluation context of
     EXP; MODULES is a list of names of Guile modules searched in
     MODULE-PATH to be copied in the store, compiled, and made available
     in the load path during the execution of EXP—e.g., ‘((guix build
     utils) (guix build gnu-build-system))’.

     EFFECTIVE-VERSION determines the string to use when adding
     extensions of EXP (see ‘with-extensions’) to the search path—e.g.,
     ‘"2.2"’.

     GRAFT? determines whether packages referred to by EXP should be
     grafted when applicable.

     When REFERENCES-GRAPHS is true, it must be a list of tuples of one
     of the following forms:

          (FILE-NAME PACKAGE)
          (FILE-NAME PACKAGE OUTPUT)
          (FILE-NAME DERIVATION)
          (FILE-NAME DERIVATION OUTPUT)
          (FILE-NAME STORE-ITEM)

     The right-hand-side of each element of REFERENCES-GRAPHS is
     automatically made an input of the build process of EXP.  In the
     build environment, each FILE-NAME contains the reference graph of
     the corresponding item, in a simple text format.

     ALLOWED-REFERENCES must be either ‘#f’ or a list of output names
     and packages.  In the latter case, the list denotes store items
     that the result is allowed to refer to.  Any reference to another
     store item will lead to a build error.  Similarly for
     DISALLOWED-REFERENCES, which can list items that must not be
     referenced by the outputs.

     DEPRECATION-WARNINGS determines whether to show deprecation
     warnings while compiling modules.  It can be ‘#f’, ‘#t’, or
     ‘'detailed’.

     The other arguments are as for ‘derivation’ (*note Деривации::).

   The ‘local-file’, ‘plain-file’, ‘computed-file’, ‘program-file’, and
‘scheme-file’ procedures below return “file-like objects”.  That is,
when unquoted in a G-expression, these objects lead to a file in the
store.  Consider this G-expression:

     #~(system* #$(file-append glibc "/sbin/nscd") "-f"
                #$(local-file "/tmp/my-nscd.conf"))

   The effect here is to “intern” ‘/tmp/my-nscd.conf’ by copying it to
the store.  Once expanded, for instance via ‘gexp->derivation’, the
G-expression refers to that copy under ‘/gnu/store’; thus, modifying or
removing the file in ‘/tmp’ does not have any effect on what the
G-expression does.  ‘plain-file’ can be used similarly; it differs in
that the file content is directly passed as a string.

 -- Scheme Procedure: local-file FILE [NAME] [#:recursive? #f]
          [#:select? (const #t)] Return an object representing local
     file FILE to add to the store; this object can be used in a gexp.
     If FILE is a literal string denoting a relative file name, it is
     looked up relative to the source file where it appears; if FILE is
     not a literal string, it is looked up relative to the current
     working directory at run time.  FILE will be added to the store
     under NAME–by default the base name of FILE.

     When RECURSIVE? is true, the contents of FILE are added
     recursively; if FILE designates a flat file and RECURSIVE? is true,
     its contents are added, and its permission bits are kept.

     When RECURSIVE? is true, call ‘(SELECT? FILE STAT)’ for each
     directory entry, where FILE is the entry’s absolute file name and
     STAT is the result of ‘lstat’; exclude entries for which SELECT?
     does not return true.

     This is the declarative counterpart of the ‘interned-file’ monadic
     procedure (*note ‘interned-file’: Устройство склада.).

 -- Scheme Procedure: plain-file NAME CONTENT
     Return an object representing a text file called NAME with the
     given CONTENT (a string or a bytevector) to be added to the store.

     This is the declarative counterpart of ‘text-file’.

 -- Scheme Procedure: computed-file NAME GEXP [#:options
          '(#:local-build? #t)] Return an object representing the store
     item NAME, a file or directory computed by GEXP.  OPTIONS is a list
     of additional arguments to pass to ‘gexp->derivation’.

     This is the declarative counterpart of ‘gexp->derivation’.

 -- Monadic Procedure: gexp->script NAME EXP [#:guile (default-guile)]
          [#:module-path %load-path]  [#:system
     (%current-system)] [#:target #f] Return an executable script NAME
     that runs EXP using GUILE, with EXP’s imported modules in its
     search path.  Look up EXP’s modules in MODULE-PATH.

     The example below builds a script that simply invokes the ‘ls’
     command:

          (use-modules (guix gexp) (gnu packages base))

          (gexp->script "list-files"
                        #~(execl #$(file-append coreutils "/bin/ls")
                                 "ls"))

     When “running” it through the store (*note ‘run-with-store’:
     Устройство склада.), we obtain a derivation that produces an
     executable file ‘/gnu/store/...-list-files’ along these lines:

          #!/gnu/store/...-guile-2.0.11/bin/guile -ds
          !#
          (execl "/gnu/store/...-coreutils-8.22"/bin/ls" "ls")

 -- Scheme Procedure: program-file NAME EXP [#:guile #f] [#:module-path
          %load-path] Return an object representing the
     executable store item NAME that runs GEXP.  GUILE is the Guile
     package used to execute that script.  Imported modules of GEXP are
     looked up in MODULE-PATH.

     This is the declarative counterpart of ‘gexp->script’.

 -- Monadic Procedure: gexp->file NAME EXP [#:set-load-path? #t]
          [#:module-path %load-path]  [#:splice? #f]  [#:guile
     (default-guile)] Return a derivation that builds a file NAME
     containing EXP.  When SPLICE? is true, EXP is considered to be a
     list of expressions that will be spliced in the resulting file.

     When SET-LOAD-PATH? is true, emit code in the resulting file to set
     ‘%load-path’ and ‘%load-compiled-path’ to honor EXP’s imported
     modules.  Look up EXP’s modules in MODULE-PATH.

     The resulting file holds references to all the dependencies of EXP
     or a subset thereof.

 -- Scheme Procedure: scheme-file NAME EXP [#:splice? #f]
          [#:set-load-path? #t] Return an object representing the
     Scheme file NAME that contains EXP.

     This is the declarative counterpart of ‘gexp->file’.

 -- Monadic Procedure: text-file* NAME TEXT ...
     Return as a monadic value a derivation that builds a text file
     containing all of TEXT.  TEXT may list, in addition to strings,
     objects of any type that can be used in a gexp: packages,
     derivations, local file objects, etc.  The resulting store file
     holds references to all these.

     This variant should be preferred over ‘text-file’ anytime the file
     to create will reference items from the store.  This is typically
     the case when building a configuration file that embeds store file
     names, like this:

          (define (profile.sh)
            ;; Return the name of a shell script in the store that
            ;; initializes the 'PATH' environment variable.
            (text-file* "profile.sh"
                        "export PATH=" coreutils "/bin:"
                        grep "/bin:" sed "/bin\n"))

     In this example, the resulting ‘/gnu/store/...-profile.sh’ file
     will reference COREUTILS, GREP, and SED, thereby preventing them
     from being garbage-collected during its lifetime.

 -- Scheme Procedure: mixed-text-file NAME TEXT ...
     Return an object representing store file NAME containing TEXT.
     TEXT is a sequence of strings and file-like objects, as in:

          (mixed-text-file "profile"
                           "export PATH=" coreutils "/bin:" grep "/bin")

     This is the declarative counterpart of ‘text-file*’.

 -- Scheme Procedure: file-union NAME FILES
     Return a ‘<computed-file>’ that builds a directory containing all
     of FILES.  Each item in FILES must be a two-element list where the
     first element is the file name to use in the new directory, and the
     second element is a gexp denoting the target file.  Here’s an
     example:

          (file-union "etc"
                      `(("hosts" ,(plain-file "hosts"
                                              "127.0.0.1 localhost"))
                        ("bashrc" ,(plain-file "bashrc"
                                               "alias ls='ls --color=auto'"))))

     This yields an ‘etc’ directory containing these two files.

 -- Scheme Procedure: directory-union NAME THINGS
     Return a directory that is the union of THINGS, where THINGS is a
     list of file-like objects denoting directories.  For example:

          (directory-union "guile+emacs" (list guile emacs))

     yields a directory that is the union of the ‘guile’ and ‘emacs’
     packages.

 -- Scheme Procedure: file-append OBJ SUFFIX ...
     Return a file-like object that expands to the concatenation of OBJ
     and SUFFIX, where OBJ is a lowerable object and each SUFFIX is a
     string.

     As an example, consider this gexp:

          (gexp->script "run-uname"
                        #~(system* #$(file-append coreutils
                                                  "/bin/uname")))

     The same effect could be achieved with:

          (gexp->script "run-uname"
                        #~(system* (string-append #$coreutils
                                                  "/bin/uname")))

     There is one difference though: in the ‘file-append’ case, the
     resulting script contains the absolute file name as a string,
     whereas in the second case, the resulting script contains a
     ‘(string-append ...)’ expression to construct the file name _at run
     time_.

 -- Scheme Syntax: let-system SYSTEM BODY...
 -- Scheme Syntax: let-system (SYSTEM TARGET) BODY...
     Bind SYSTEM to the currently targeted system—e.g.,
     ‘"x86_64-linux"’—within BODY.

     In the second case, additionally bind TARGET to the current
     cross-compilation target—a GNU triplet such as
     ‘"arm-linux-gnueabihf"’—or ‘#f’ if we are not cross-compiling.

     ‘let-system’ is useful in the occasional case where the object
     spliced into the gexp depends on the target system, as in this
     example:

          #~(system*
             #+(let-system system
                 (cond ((string-prefix? "armhf-" system)
                        (file-append qemu "/bin/qemu-system-arm"))
                       ((string-prefix? "x86_64-" system)
                        (file-append qemu "/bin/qemu-system-x86_64"))
                       (else
                        (error "dunno!"))))
             "-net" "user" #$image)

 -- Scheme Syntax: with-parameters ((PARAMETER VALUE) ...) EXP
     This macro is similar to the ‘parameterize’ form for
     dynamically-bound “parameters” (*note (guile)Parameters::).  The
     key difference is that it takes effect when the file-like object
     returned by EXP is lowered to a derivation or store item.

     A typical use of ‘with-parameters’ is to force the system in effect
     for a given object:

          (with-parameters ((%current-system "i686-linux"))
            coreutils)

     The example above returns an object that corresponds to the i686
     build of Coreutils, regardless of the current value of
     ‘%current-system’.

   Of course, in addition to gexps embedded in “host” code, there are
also modules containing build tools.  To make it clear that they are
meant to be used in the build stratum, these modules are kept in the
‘(guix build ...)’ name space.

   Internally, high-level objects are “lowered”, using their compiler,
to either derivations or store items.  For instance, lowering a package
yields a derivation, and lowering a ‘plain-file’ yields a store item.
This is achieved using the ‘lower-object’ monadic procedure.

 -- Monadic Procedure: lower-object OBJ [SYSTEM] [#:target #f] Return as
          a value in ‘%store-monad’ the derivation or
     store item corresponding to OBJ for SYSTEM, cross-compiling for
     TARGET if TARGET is true.  OBJ must be an object that has an
     associated gexp compiler, such as a ‘<package>’.

   ---------- Footnotes ----------

   (1) The term “stratum” in this context was coined by Manuel Serrano
et al. in the context of their work on Hop.  Oleg Kiselyov, who has
written insightful essays and code on this topic
(http://okmij.org/ftp/meta-programming/#meta-scheme), refers to this
kind of code generation as “staging”.


File: guix.ru.info,  Node: Запуск guix repl,  Prev: G-Expressions,  Up: Программный интерфейс

6.8 Invoking ‘guix repl’
========================

The ‘guix repl’ command spawns a Guile “read-eval-print loop” (REPL) for
interactive programming (*note (guile)Using Guile Interactively::).
Compared to just launching the ‘guile’ command, ‘guix repl’ guarantees
that all the Guix modules and all its dependencies are available in the
search path.  You can use it this way:

     $ guix repl
     scheme@(guile-user)> ,use (gnu packages base)
     scheme@(guile-user)> coreutils
     $1 = #<package coreutils@8.29 gnu/packages/base.scm:327 3e28300>

   In addition, ‘guix repl’ implements a simple machine-readable REPL
protocol for use by ‘(guix inferior)’, a facility to interact with
“inferiors”, separate processes running a potentially different revision
of Guix.

   The available options are as follows:

‘--type=TYPE’
‘-t TYPE’
     Start a REPL of the given TYPE, which can be one of the following:

     ‘guile’
          This is default, and it spawns a standard full-featured Guile
          REPL.
     ‘machine’
          Spawn a REPL that uses the machine-readable protocol.  This is
          the protocol that the ‘(guix inferior)’ module speaks.

‘--listen=ENDPOINT’
     By default, ‘guix repl’ reads from standard input and writes to
     standard output.  When this option is passed, it will instead
     listen for connections on ENDPOINT.  Here are examples of valid
     options:

     ‘--listen=tcp:37146’
          Accept connections on localhost on port 37146.

     ‘--listen=unix:/tmp/socket’
          Accept connections on the Unix-domain socket ‘/tmp/socket’.

‘--load-path=DIRECTORY’
‘-L DIRECTORY’
     Add DIRECTORY to the front of the package module search path (*note
     Пакетные модули::).

     This allows users to define their own packages and make them
     visible to the command-line tool.

‘-q’
     Inhibit loading of the ‘~/.guile’ file.  By default, that
     configuration file is loaded when spawning a ‘guile’ REPL.


File: guix.ru.info,  Node: Утилиты,  Next: Конфигурирование системы,  Prev: Программный интерфейс,  Up: Top

7 Утилиты
*********

This section describes Guix command-line utilities.  Some of them are
primarily targeted at developers and users who write new package
definitions, while others are more generally useful.  They complement
the Scheme programming interface of Guix in a convenient way.

* Menu:

* Запуск guix build::  Сборка пакетов в
                               командной строке.
* Запуск guix edit::   Редактирование описания
                               пакета.
* Запуск guix download::  Загрузка файла и вывод
                                  его хэша.
* Запуск guix hash::   Вычисление
                               криптографического хеша
                               файла.
* Запуск guix import::  Импорт описаниий
                                пакетов.
* Запуск guix refresh::  Обновление описаний
                                 пакетов.
* Запуск guix lint::   Поиск ошибок в описаниях
                               пакетов.
* Запуск guix size::   Обзор использования
                               диска.
* Запуск guix graph::  Визуализация графа
                               пакета.
* Запуск guix publish::  Совместное
                                 использование
                                 подстановок.
* Запуск guix challenge::  Соперничающие серверы
                                   подстановок.
* Запуск guix copy::   Копирование из и в
                               удалённый склад.
* Запуск guix container::  Изоляция процесса.
* Запуск guix weather::  Оценка доступности
                                 подстановок.
* Запуск guix processes::  Чтение клиентских
                                   процессов.


File: guix.ru.info,  Node: Запуск guix build,  Next: Запуск guix edit,  Up: Утилиты

7.1 Запуск ‘guix build’
=======================

The ‘guix build’ command builds packages or derivations and their
dependencies, and prints the resulting store paths.  Note that it does
not modify the user’s profile—this is the job of the ‘guix package’
command (*note Вызов guix package::).  Thus, it is mainly useful for
distribution developers.

   Основной синтаксис:

     guix build OPTIONS PACKAGE-OR-DERIVATION...

   As an example, the following command builds the latest versions of
Emacs and of Guile, displays their build logs, and finally displays the
resulting directories:

     guix build emacs guile

   Similarly, the following command builds all the available packages:

     guix build --quiet --keep-going \
       `guix package -A | cut -f1,2 --output-delimiter=@`

   PACKAGE-OR-DERIVATION may be either the name of a package found in
the software distribution such as ‘coreutils’ or ‘coreutils@8.20’, or a
derivation such as ‘/gnu/store/...-coreutils-8.19.drv’.  In the former
case, a package with the corresponding name (and optionally version) is
searched for among the GNU distribution modules (*note Пакетные
модули::).

   Alternatively, the ‘--expression’ option may be used to specify a
Scheme expression that evaluates to a package; this is useful when
disambiguating among several same-named packages or package variants is
needed.

   There may be zero or more OPTIONS.  The available options are
described in the subsections below.

* Menu:

* Стандартные параметры сборки::  Параметры
                                                              сборки
                                                              для
                                                              большинства
                                                              команд.
* Параметры преобразования пакета::  Создание
                                                                    вариантов
                                                                    пакетов.
* Дополнительные параметры сборки::  Особые
                                                                    параметры
                                                                    для
                                                                    ’guix
                                                                    build’.
* Отладка ошибок сборки::  Жизненный опыт в
                                                сборке пакетов.


File: guix.ru.info,  Node: Стандартные параметры сборки,  Next: Параметры преобразования пакета,  Up: Запуск guix build

7.1.1 Стандартные параметры сборки
----------------------------------

A number of options that control the build process are common to ‘guix
build’ and other commands that can spawn builds, such as ‘guix package’
or ‘guix archive’.  These are the following:

‘--load-path=DIRECTORY’
‘-L DIRECTORY’
     Add DIRECTORY to the front of the package module search path (*note
     Пакетные модули::).

     This allows users to define their own packages and make them
     visible to the command-line tools.

‘--keep-failed’
‘-K’
     Keep the build tree of failed builds.  Thus, if a build fails, its
     build tree is kept under ‘/tmp’, in a directory whose name is shown
     at the end of the build log.  This is useful when debugging build
     issues.  *Note Отладка ошибок сборки::, for tips and tricks on how
     to debug build issues.

     This option implies ‘--no-offload’, and it has no effect when
     connecting to a remote daemon with a ‘guix://’ URI (*note the
     ‘GUIX_DAEMON_SOCKET’ variable: Хранилище.).

‘--keep-going’
‘-k’
     Keep going when some of the derivations fail to build; return only
     once all the builds have either completed or failed.

     The default behavior is to stop as soon as one of the specified
     derivations has failed.

‘--dry-run’
‘-n’
     Do not build the derivations.

‘--fallback’
     When substituting a pre-built binary fails, fall back to building
     packages locally (*note Ошибки при подстановке::).

‘--substitute-urls=URLS’
     Consider URLS the whitespace-separated list of substitute source
     URLs, overriding the default list of URLs of ‘guix-daemon’ (*note
     ‘guix-daemon’ URLs: daemon-substitute-urls.).

     This means that substitutes may be downloaded from URLS, provided
     they are signed by a key authorized by the system administrator
     (*note Подстановки::).

     When URLS is the empty string, substitutes are effectively
     disabled.

‘--no-substitutes’
     Не использовать подстановки для сборок.  Это означает — собирать
     элементы локально вместо того, чтобы скачивать собранные бинарники
     (*note Подстановки::).

‘--no-grafts’
     Do not “graft” packages.  In practice, this means that package
     updates available as grafts are not applied.  *Note Обновления
     безопасности::, for more information on grafts.

‘--rounds=N’
     Build each derivation N times in a row, and raise an error if
     consecutive build results are not bit-for-bit identical.

     This is a useful way to detect non-deterministic builds processes.
     Non-deterministic build processes are a problem because they make
     it practically impossible for users to _verify_ whether third-party
     binaries are genuine.  *Note Запуск guix challenge::, for more.

     Note that, currently, the differing build results are not kept
     around, so you will have to manually investigate in case of an
     error—e.g., by stashing one of the build results with ‘guix archive
     --export’ (*note Вызов guix archive::), then rebuilding, and
     finally comparing the two results.

‘--no-offload’
     Do not use offload builds to other machines (*note Установка демона
     разгрузки::).  That is, always build things locally instead of
     offloading builds to remote machines.

‘--max-silent-time=SECONDS’
     Когда процесс сборки или подстановки молчит более SECONDS секунд,
     завершить его и отчитаться об ошибке сборки.

     By default, the daemon’s setting is honored (*note
     ‘--max-silent-time’: Вызов guix-daemon.).

‘--timeout=SECONDS’
     Точно так же, когда процесс сборки или подстановки длится более
     SECONDS, завершить его и отчитаться об ошибке сборки.

     By default, the daemon’s setting is honored (*note ‘--timeout’:
     Вызов guix-daemon.).

‘-v LEVEL’
‘--verbosity=LEVEL’
     Use the given verbosity LEVEL, an integer.  Choosing 0 means that
     no output is produced, 1 is for quiet output, and 2 shows all the
     build log output on standard error.

‘--cores=N’
‘-c N’
     Allow the use of up to N CPU cores for the build.  The special
     value ‘0’ means to use as many CPU cores as available.

‘--max-jobs=N’
‘-M N’
     Allow at most N build jobs in parallel.  *Note ‘--max-jobs’: Вызов
     guix-daemon, for details about this option and the equivalent
     ‘guix-daemon’ option.

‘--debug=LEVEL’
     Produce debugging output coming from the build daemon.  LEVEL must
     be an integer between 0 and 5; higher means more verbose output.
     Setting a level of 4 or more may be helpful when debugging setup
     issues with the build daemon.

   Behind the scenes, ‘guix build’ is essentially an interface to the
‘package-derivation’ procedure of the ‘(guix packages)’ module, and to
the ‘build-derivations’ procedure of the ‘(guix derivations)’ module.

   In addition to options explicitly passed on the command line, ‘guix
build’ and other ‘guix’ commands that support building honor the
‘GUIX_BUILD_OPTIONS’ environment variable.

 -- Environment Variable: GUIX_BUILD_OPTIONS
     Users can define this variable to a list of command line options
     that will automatically be used by ‘guix build’ and other ‘guix’
     commands that can perform builds, as in the example below:

          $ export GUIX_BUILD_OPTIONS="--no-substitutes -c 2 -L /foo/bar"

     These options are parsed independently, and the result is appended
     to the parsed command-line options.


File: guix.ru.info,  Node: Параметры преобразования пакета,  Next: Дополнительные параметры сборки,  Prev: Стандартные параметры сборки,  Up: Запуск guix build

7.1.2 Параметры преобразования пакета
-------------------------------------

Another set of command-line options supported by ‘guix build’ and also
‘guix package’ are “package transformation options”.  These are options
that make it possible to define “package variants”—for instance,
packages built from different source code.  This is a convenient way to
create customized packages on the fly without having to type in the
definitions of package variants (*note Описание пакетов::).

‘--with-source=SOURCE’
‘--with-source=PACKAGE=SOURCE’
‘--with-source=PACKAGE@VERSION=SOURCE’
     Use SOURCE as the source of PACKAGE, and VERSION as its version
     number.  SOURCE must be a file name or a URL, as for ‘guix
     download’ (*note Запуск guix download::).

     When PACKAGE is omitted, it is taken to be the package name
     specified on the command line that matches the base of SOURCE—e.g.,
     if SOURCE is ‘/src/guile-2.0.10.tar.gz’, the corresponding package
     is ‘guile’.

     Likewise, when VERSION is omitted, the version string is inferred
     from SOURCE; in the previous example, it is ‘2.0.10’.

     This option allows users to try out versions of packages other than
     the one provided by the distribution.  The example below downloads
     ‘ed-1.7.tar.gz’ from a GNU mirror and uses that as the source for
     the ‘ed’ package:

          guix build ed --with-source=mirror://gnu/ed/ed-1.7.tar.gz

     As a developer, ‘--with-source’ makes it easy to test release
     candidates:

          guix build guile --with-source=../guile-2.0.9.219-e1bb7.tar.xz

     ... or to build from a checkout in a pristine environment:

          $ git clone git://git.sv.gnu.org/guix.git
          $ guix build guix --with-source=guix@1.0=./guix

‘--with-input=PACKAGE=REPLACEMENT’
     Replace dependency on PACKAGE by a dependency on REPLACEMENT.
     PACKAGE must be a package name, and REPLACEMENT must be a package
     specification such as ‘guile’ or ‘guile@1.8’.

     For instance, the following command builds Guix, but replaces its
     dependency on the current stable version of Guile with a dependency
     on the legacy version of Guile, ‘guile@2.0’:

          guix build --with-input=guile=guile@2.0 guix

     This is a recursive, deep replacement.  So in this example, both
     ‘guix’ and its dependency ‘guile-json’ (which also depends on
     ‘guile’) get rebuilt against ‘guile@2.0’.

     This is implemented using the ‘package-input-rewriting’ Scheme
     procedure (*note ‘package-input-rewriting’: Описание пакетов.).

‘--with-graft=PACKAGE=REPLACEMENT’
     This is similar to ‘--with-input’ but with an important difference:
     instead of rebuilding the whole dependency chain, REPLACEMENT is
     built and then “grafted” onto the binaries that were initially
     referring to PACKAGE.  *Note Обновления безопасности::, for more
     information on grafts.

     For example, the command below grafts version 3.5.4 of GnuTLS onto
     Wget and all its dependencies, replacing references to the version
     of GnuTLS they currently refer to:

          guix build --with-graft=gnutls=gnutls@3.5.4 wget

     This has the advantage of being much faster than rebuilding
     everything.  But there is a caveat: it works if and only if PACKAGE
     and REPLACEMENT are strictly compatible—for example, if they
     provide a library, the application binary interface (ABI) of those
     libraries must be compatible.  If REPLACEMENT is somehow
     incompatible with PACKAGE, then the resulting package may be
     unusable.  Use with care!

‘--with-git-url=PACKAGE=URL’
     Build PACKAGE from the latest commit of the ‘master’ branch of the
     Git repository at URL.  Git sub-modules of the repository are
     fetched, recursively.

     For example, the following command builds the NumPy Python library
     against the latest commit of the master branch of Python itself:

          guix build python-numpy \
            --with-git-url=python=https://github.com/python/cpython

     This option can also be combined with ‘--with-branch’ or
     ‘--with-commit’ (see below).

     Obviously, since it uses the latest commit of the given branch, the
     result of such a command varies over time.  Nevertheless it is a
     convenient way to rebuild entire software stacks against the latest
     commit of one or more packages.  This is particularly useful in the
     context of continuous integration (CI).

     Checkouts are kept in a cache under ‘~/.cache/guix/checkouts’ to
     speed up consecutive accesses to the same repository.  You may want
     to clean it up once in a while to save disk space.

‘--with-branch=PACKAGE=BRANCH’
     Build PACKAGE from the latest commit of BRANCH.  If the ‘source’
     field of PACKAGE is an origin with the ‘git-fetch’ method (*note
     Интерфейс origin::) or a ‘git-checkout’ object, the repository URL
     is taken from that ‘source’.  Otherwise you have to use
     ‘--with-git-url’ to specify the URL of the Git repository.

     For instance, the following command builds ‘guile-sqlite3’ from the
     latest commit of its ‘master’ branch, and then builds ‘guix’ (which
     depends on it) and ‘cuirass’ (which depends on ‘guix’) against this
     specific ‘guile-sqlite3’ build:

          guix build --with-branch=guile-sqlite3=master cuirass

‘--with-commit=PACKAGE=COMMIT’
     This is similar to ‘--with-branch’, except that it builds from
     COMMIT rather than the tip of a branch.  COMMIT must be a valid Git
     commit SHA1 identifier or a tag.


File: guix.ru.info,  Node: Дополнительные параметры сборки,  Next: Отладка ошибок сборки,  Prev: Параметры преобразования пакета,  Up: Запуск guix build

7.1.3 Дополнительные параметры сборки
-------------------------------------

The command-line options presented below are specific to ‘guix build’.

‘--quiet’
‘-q’
     Build quietly, without displaying the build log; this is equivalent
     to ‘--verbosity=0’.  Upon completion, the build log is kept in
     ‘/var’ (or similar) and can always be retrieved using the
     ‘--log-file’ option.

‘--file=FILE’
‘-f FILE’
     Build the package, derivation, or other file-like object that the
     code within FILE evaluates to (*note file-like objects:
     G-Expressions.).

     As an example, FILE might contain a package definition like this
     (*note Описание пакетов::):

          (use-modules (guix)
                       (guix build-system gnu)
                       (guix licenses))

          (package
            (name "hello")
            (version "2.10")
            (source (origin
                      (method url-fetch)
                      (uri (string-append "mirror://gnu/hello/hello-" version
                                          ".tar.gz"))
                      (sha256
                       (base32
                        "0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i"))))
            (build-system gnu-build-system)
            (synopsis "Hello, GNU world: An example GNU package")
            (description "Guess what GNU Hello prints!")
            (home-page "http://www.gnu.org/software/hello/")
            (license gpl3+))

     The FILE may also contain a JSON representation of one or more
     package definitions.  Running ‘guix build -f’ on ‘hello.json’ with
     the following contents would result in building the packages
     ‘myhello’ and ‘greeter’:

          [
            {
              "name": "myhello",
              "version": "2.10",
              "source": "mirror://gnu/hello/hello-2.10.tar.gz",
              "build-system": "gnu",
              "arguments": {
                "tests?": false
              }
              "home-page": "https://www.gnu.org/software/hello/",
              "synopsis": "Hello, GNU world: An example GNU package",
              "description": "GNU Hello prints a greeting.",
              "license": "GPL-3.0+",
              "native-inputs": ["gettext"]
            },
            {
              "name": "greeter",
              "version": "1.0",
              "source": "https://example.com/greeter-1.0.tar.gz",
              "build-system": "gnu",
              "arguments": {
                "test-target": "foo",
                "parallel-build?": false,
              },
              "home-page": "https://example.com/",
              "synopsis": "Greeter using GNU Hello",
              "description": "This is a wrapper around GNU Hello.",
              "license": "GPL-3.0+",
              "inputs": ["myhello", "hello"]
            }
          ]

‘--manifest=MANIFEST’
‘-m MANIFEST’
     Build all packages listed in the given MANIFEST (*note
     ‘--manifest’: profile-manifest.).

‘--expression=EXPR’
‘-e EXPR’
     Build the package or derivation EXPR evaluates to.

     For example, EXPR may be ‘(@ (gnu packages guile) guile-1.8)’,
     which unambiguously designates this specific variant of version 1.8
     of Guile.

     Alternatively, EXPR may be a G-expression, in which case it is used
     as a build program passed to ‘gexp->derivation’ (*note
     G-Expressions::).

     Lastly, EXPR may refer to a zero-argument monadic procedure (*note
     Устройство склада::).  The procedure must return a derivation as a
     monadic value, which is then passed through ‘run-with-store’.

‘--source’
‘-S’
     Build the source derivations of the packages, rather than the
     packages themselves.

     For instance, ‘guix build -S gcc’ returns something like
     ‘/gnu/store/...-gcc-4.7.2.tar.bz2’, which is the GCC source
     tarball.

     The returned source tarball is the result of applying any patches
     and code snippets specified in the package ‘origin’ (*note Описание
     пакетов::).

     Note that ‘guix build -S’ compiles the sources only of the
     specified packages.  They do not include the sources of statically
     linked dependencies and by themselves are insufficient for
     reproducing the packages.

‘--sources’
     Fetch and return the source of PACKAGE-OR-DERIVATION and all their
     dependencies, recursively.  This is a handy way to obtain a local
     copy of all the source code needed to build PACKAGES, allowing you
     to eventually build them even without network access.  It is an
     extension of the ‘--source’ option and can accept one of the
     following optional argument values:

     ‘package’
          This value causes the ‘--sources’ option to behave in the same
          way as the ‘--source’ option.

     ‘all’
          Build the source derivations of all packages, including any
          source that might be listed as ‘inputs’.  This is the default
          value.

               $ guix build --sources tzdata
               The following derivations will be built:
                  /gnu/store/...-tzdata2015b.tar.gz.drv
                  /gnu/store/...-tzcode2015b.tar.gz.drv

     ‘transitive’
          Build the source derivations of all packages, as well of all
          transitive inputs to the packages.  This can be used e.g. to
          prefetch package source for later offline building.

               $ guix build --sources=transitive tzdata
               The following derivations will be built:
                  /gnu/store/...-tzcode2015b.tar.gz.drv
                  /gnu/store/...-findutils-4.4.2.tar.xz.drv
                  /gnu/store/...-grep-2.21.tar.xz.drv
                  /gnu/store/...-coreutils-8.23.tar.xz.drv
                  /gnu/store/...-make-4.1.tar.xz.drv
                  /gnu/store/...-bash-4.3.tar.xz.drv
               ...

‘--system=SYSTEM’
‘-s SYSTEM’
     Attempt to build for SYSTEM—e.g., ‘i686-linux’—instead of the
     system type of the build host.  The ‘guix build’ command allows you
     to repeat this option several times, in which case it builds for
     all the specified systems; other commands ignore extraneous ‘-s’
     options.

          Примечание: The ‘--system’ flag is for _native_ compilation
          and must not be confused with cross-compilation.  See
          ‘--target’ below for information on cross-compilation.

     An example use of this is on Linux-based systems, which can emulate
     different personalities.  For instance, passing
     ‘--system=i686-linux’ on an ‘x86_64-linux’ system or
     ‘--system=armhf-linux’ on an ‘aarch64-linux’ system allows you to
     build packages in a complete 32-bit environment.

          Примечание: Building for an ‘armhf-linux’ system is
          unconditionally enabled on ‘aarch64-linux’ machines, although
          certain aarch64 chipsets do not allow for this functionality,
          notably the ThunderX.

     Similarly, when transparent emulation with QEMU and ‘binfmt_misc’
     is enabled (*note ‘qemu-binfmt-service-type’: Сервисы
     виртуализации.), you can build for any system for which a QEMU
     ‘binfmt_misc’ handler is installed.

     Builds for a system other than that of the machine you are using
     can also be offloaded to a remote machine of the right
     architecture.  *Note Установка демона разгрузки::, for more
     information on offloading.

‘--target=TRIPLET’
     Cross-build for TRIPLET, which must be a valid GNU triplet, such as
     ‘"aarch64-linux-gnu"’ (*note GNU configuration triplets:
     (autoconf)Specifying Target Triplets.).

‘--check’
     Rebuild PACKAGE-OR-DERIVATION, which are already available in the
     store, and raise an error if the build results are not bit-for-bit
     identical.

     This mechanism allows you to check whether previously installed
     substitutes are genuine (*note Подстановки::), or whether the build
     result of a package is deterministic.  *Note Запуск guix
     challenge::, for more background information and tools.

     При использовании вместе с ‘--keep-failed’ различные результаты
     сохраняются на складе под ‘/gnu/store/...-check’.  Это делает
     возможным просмотр различий между двумя результатами.

‘--repair’
     Attempt to repair the specified store items, if they are corrupt,
     by re-downloading or rebuilding them.

     This operation is not atomic and thus restricted to ‘root’.

‘--derivations’
‘-d’
     Return the derivation paths, not the output paths, of the given
     packages.

‘--root=FILE’
‘-r FILE’
     Make FILE a symlink to the result, and register it as a garbage
     collector root.

     Consequently, the results of this ‘guix build’ invocation are
     protected from garbage collection until FILE is removed.  When that
     option is omitted, build results are eligible for garbage
     collection as soon as the build completes.  *Note Вызов guix gc::,
     for more on GC roots.

‘--log-file’
     Return the build log file names or URLs for the given
     PACKAGE-OR-DERIVATION, or raise an error if build logs are missing.

     This works regardless of how packages or derivations are specified.
     For instance, the following invocations are equivalent:

          guix build --log-file `guix build -d guile`
          guix build --log-file `guix build guile`
          guix build --log-file guile
          guix build --log-file -e '(@ (gnu packages guile) guile-2.0)'

     If a log is unavailable locally, and unless ‘--no-substitutes’ is
     passed, the command looks for a corresponding log on one of the
     substitute servers (as specified with ‘--substitute-urls’).

     So for instance, imagine you want to see the build log of GDB on
     MIPS, but you are actually on an ‘x86_64’ machine:

          $ guix build --log-file gdb -s aarch64-linux
          https://ci.guix.gnu.org/log/...-gdb-7.10

     You can freely access a huge library of build logs!


File: guix.ru.info,  Node: Отладка ошибок сборки,  Prev: Дополнительные параметры сборки,  Up: Запуск guix build

7.1.4 Отладка ошибок сборки
---------------------------

When defining a new package (*note Описание пакетов::), you will
probably find yourself spending some time debugging and tweaking the
build until it succeeds.  To do that, you need to operate the build
commands yourself in an environment as close as possible to the one the
build daemon uses.

   To that end, the first thing to do is to use the ‘--keep-failed’ or
‘-K’ option of ‘guix build’, which will keep the failed build tree in
‘/tmp’ or whatever directory you specified as ‘TMPDIR’ (*note
‘--keep-failed’: Запуск guix build.).

   From there on, you can ‘cd’ to the failed build tree and source the
‘environment-variables’ file, which contains all the environment
variable definitions that were in place when the build failed.  So let’s
say you’re debugging a build failure in package ‘foo’; a typical session
would look like this:

     $ guix build foo -K
     ... build fails
     $ cd /tmp/guix-build-foo.drv-0
     $ source ./environment-variables
     $ cd foo-1.2

   Now, you can invoke commands as if you were the daemon (almost) and
troubleshoot your build process.

   Sometimes it happens that, for example, a package’s tests pass when
you run them manually but they fail when the daemon runs them.  This can
happen because the daemon runs builds in containers where, unlike in our
environment above, network access is missing, ‘/bin/sh’ does not exist,
etc.  (*note Установка окружения сборки::).

   In such cases, you may need to run inspect the build process from
within a container similar to the one the build daemon creates:

     $ guix build -K foo
     ...
     $ cd /tmp/guix-build-foo.drv-0
     $ guix environment --no-grafts -C foo --ad-hoc strace gdb
     [env]# source ./environment-variables
     [env]# cd foo-1.2

   Here, ‘guix environment -C’ creates a container and spawns a new
shell in it (*note Запуск guix environment::).  The ‘--ad-hoc strace
gdb’ part adds the ‘strace’ and ‘gdb’ commands to the container, which
you may find handy while debugging.  The ‘--no-grafts’ option makes sure
we get the exact same environment, with ungrafted packages (*note
Обновления безопасности::, for more info on grafts).

   To get closer to a container like that used by the build daemon, we
can remove ‘/bin/sh’:

     [env]# rm /bin/sh

   (Don’t worry, this is harmless: this is all happening in the
throw-away container created by ‘guix environment’.)

   The ‘strace’ command is probably not in the search path, but we can
run:

     [env]# $GUIX_ENVIRONMENT/bin/strace -f -o log make check

   In this way, not only you will have reproduced the environment
variables the daemon uses, you will also be running the build process in
a container similar to the one the daemon uses.


File: guix.ru.info,  Node: Запуск guix edit,  Next: Запуск guix download,  Prev: Запуск guix build,  Up: Утилиты

7.2 Invoking ‘guix edit’
========================

So many packages, so many source files!  The ‘guix edit’ command
facilitates the life of users and packagers by pointing their editor at
the source file containing the definition of the specified packages.
For instance:

     guix edit gcc@4.9 vim

launches the program specified in the ‘VISUAL’ or in the ‘EDITOR’
environment variable to view the recipe of GCC 4.9.3 and that of Vim.

   If you are using a Guix Git checkout (*note Сборка из Git::), or have
created your own packages on ‘GUIX_PACKAGE_PATH’ (*note Пакетные
модули::), you will be able to edit the package recipes.  In other
cases, you will be able to examine the read-only recipes for packages
currently in the store.

   Instead of ‘GUIX_PACKAGE_PATH’, the command-line option
‘--load-path=DIRECTORY’ (or in short ‘-L DIRECTORY’) allows you to add
DIRECTORY to the front of the package module search path and so make
your own packages visible.


File: guix.ru.info,  Node: Запуск guix download,  Next: Запуск guix hash,  Prev: Запуск guix edit,  Up: Утилиты

7.3 Invoking ‘guix download’
============================

When writing a package definition, developers typically need to download
a source tarball, compute its SHA256 hash, and write that hash in the
package definition (*note Описание пакетов::).  The ‘guix download’ tool
helps with this task: it downloads a file from the given URI, adds it to
the store, and prints both its file name in the store and its SHA256
hash.

   The fact that the downloaded file is added to the store saves
bandwidth: when the developer eventually tries to build the newly
defined package with ‘guix build’, the source tarball will not have to
be downloaded again because it is already in the store.  It is also a
convenient way to temporarily stash files, which may be deleted
eventually (*note Вызов guix gc::).

   The ‘guix download’ command supports the same URIs as used in package
definitions.  In particular, it supports ‘mirror://’ URIs.  ‘https’ URIs
(HTTP over TLS) are supported _provided_ the Guile bindings for GnuTLS
are available in the user’s environment; when they are not available, an
error is raised.  *Note how to install the GnuTLS bindings for Guile:
(gnutls-guile)Guile Preparations, for more information.

   ‘guix download’ verifies HTTPS server certificates by loading the
certificates of X.509 authorities from the directory pointed to by the
‘SSL_CERT_DIR’ environment variable (*note Сертификаты X.509::), unless
‘--no-check-certificate’ is used.

   The following options are available:

‘--hash=ALGORITHM’
‘-H ALGORITHM’
     Compute a hash using the specified ALGORITHM.  *Note Запуск guix
     hash::, for more information.

‘--format=FMT’
‘-f FMT’
     Write the hash in the format specified by FMT.  For more
     information on the valid values for FMT, *note Запуск guix hash::.

‘--no-check-certificate’
     Do not validate the X.509 certificates of HTTPS servers.

     When using this option, you have _absolutely no guarantee_ that you
     are communicating with the authentic server responsible for the
     given URL, which makes you vulnerable to “man-in-the-middle”
     attacks.

‘--output=FILE’
‘-o FILE’
     Save the downloaded file to FILE instead of adding it to the store.


File: guix.ru.info,  Node: Запуск guix hash,  Next: Запуск guix import,  Prev: Запуск guix download,  Up: Утилиты

7.4 Invoking ‘guix hash’
========================

The ‘guix hash’ command computes the SHA256 hash of a file.  It is
primarily a convenience tool for anyone contributing to the
distribution: it computes the cryptographic hash of a file, which can be
used in the definition of a package (*note Описание пакетов::).

   Основной синтаксис:

     guix hash OPTION FILE

   When FILE is ‘-’ (a hyphen), ‘guix hash’ computes the hash of data
read from standard input.  ‘guix hash’ has the following options:

‘--hash=ALGORITHM’
‘-H ALGORITHM’
     Compute a hash using the specified ALGORITHM, ‘sha256’ by default.

     ALGORITHM must the name of a cryptographic hash algorithm supported
     by Libgcrypt via Guile-Gcrypt—e.g., ‘sha512’ or ‘sha3-256’ (*note
     (guile-gcrypt)Hash Functions::).

‘--format=FMT’
‘-f FMT’
     Write the hash in the format specified by FMT.

     Supported formats: ‘base64’, ‘nix-base32’, ‘base32’, ‘base16’
     (‘hex’ and ‘hexadecimal’ can be used as well).

     If the ‘--format’ option is not specified, ‘guix hash’ will output
     the hash in ‘nix-base32’.  This representation is used in the
     definitions of packages.

‘--recursive’
‘-r’
     Compute the hash on FILE recursively.

     In this case, the hash is computed on an archive containing FILE,
     including its children if it is a directory.  Some of the metadata
     of FILE is part of the archive; for instance, when FILE is a
     regular file, the hash is different depending on whether FILE is
     executable or not.  Metadata such as time stamps has no impact on
     the hash (*note Вызов guix archive::).

‘--exclude-vcs’
‘-x’
     When combined with ‘--recursive’, exclude version control system
     directories (‘.bzr’, ‘.git’, ‘.hg’, etc.).

     As an example, here is how you would compute the hash of a Git
     checkout, which is useful when using the ‘git-fetch’ method (*note
     Интерфейс origin::):

          $ git clone http://example.org/foo.git
          $ cd foo
          $ guix hash -rx .


File: guix.ru.info,  Node: Запуск guix import,  Next: Запуск guix refresh,  Prev: Запуск guix hash,  Up: Утилиты

7.5 Invoking ‘guix import’
==========================

The ‘guix import’ command is useful for people who would like to add a
package to the distribution with as little work as possible—a legitimate
demand.  The command knows of a few repositories from which it can
“import” package metadata.  The result is a package definition, or a
template thereof, in the format we know (*note Описание пакетов::).

   Основной синтаксис:

     guix import IMPORTER OPTIONS...

   IMPORTER specifies the source from which to import package metadata,
and OPTIONS specifies a package identifier and other options specific to
IMPORTER.

   Some of the importers rely on the ability to run the ‘gpgv’ command.
For these, GnuPG must be installed and in ‘$PATH’; run ‘guix install
gnupg’ if needed.

   Currently, the available “importers” are:

‘gnu’
     Import metadata for the given GNU package.  This provides a
     template for the latest version of that GNU package, including the
     hash of its source tarball, and its canonical synopsis and
     description.

     Additional information such as the package dependencies and its
     license needs to be figured out manually.

     For example, the following command returns a package definition for
     GNU Hello:

          guix import gnu hello

     Specific command-line options are:

     ‘--key-download=POLICY’
          As for ‘guix refresh’, specify the policy to handle missing
          OpenPGP keys when verifying the package signature.  *Note
          ‘--key-download’: Запуск guix refresh.

‘pypi’
     Import metadata from the Python Package Index
     (https://pypi.python.org/).  Information is taken from the
     JSON-formatted description available at ‘pypi.python.org’ and
     usually includes all the relevant information, including package
     dependencies.  For maximum efficiency, it is recommended to install
     the ‘unzip’ utility, so that the importer can unzip Python wheels
     and gather data from them.

     The command below imports metadata for the ‘itsdangerous’ Python
     package:

          guix import pypi itsdangerous

     ‘--recursive’
     ‘-r’
          Traverse the dependency graph of the given upstream package
          recursively and generate package expressions for all those
          packages that are not yet in Guix.

‘gem’
     Import metadata from RubyGems (https://rubygems.org/).  Information
     is taken from the JSON-formatted description available at
     ‘rubygems.org’ and includes most relevant information, including
     runtime dependencies.  There are some caveats, however.  The
     metadata doesn’t distinguish between synopses and descriptions, so
     the same string is used for both fields.  Additionally, the details
     of non-Ruby dependencies required to build native extensions is
     unavailable and left as an exercise to the packager.

     The command below imports metadata for the ‘rails’ Ruby package:

          guix import gem rails

     ‘--recursive’
     ‘-r’
          Traverse the dependency graph of the given upstream package
          recursively and generate package expressions for all those
          packages that are not yet in Guix.

‘cpan’
     Import metadata from MetaCPAN (https://www.metacpan.org/).
     Information is taken from the JSON-formatted metadata provided
     through MetaCPAN’s API (https://fastapi.metacpan.org/) and includes
     most relevant information, such as module dependencies.  License
     information should be checked closely.  If Perl is available in the
     store, then the ‘corelist’ utility will be used to filter core
     modules out of the list of dependencies.

     The command command below imports metadata for the Acme::Boolean
     Perl module:

          guix import cpan Acme::Boolean

‘cran’
     Import metadata from CRAN (https://cran.r-project.org/), the
     central repository for the GNU R statistical and graphical
     environment (https://r-project.org).

     Information is extracted from the ‘DESCRIPTION’ file of the
     package.

     The command command below imports metadata for the Cairo R package:

          guix import cran Cairo

     When ‘--recursive’ is added, the importer will traverse the
     dependency graph of the given upstream package recursively and
     generate package expressions for all those packages that are not
     yet in Guix.

     When ‘--archive=bioconductor’ is added, metadata is imported from
     Bioconductor (https://www.bioconductor.org/), a repository of R
     packages for for the analysis and comprehension of high-throughput
     genomic data in bioinformatics.

     Information is extracted from the ‘DESCRIPTION’ file contained in
     the package archive.

     The command below imports metadata for the GenomicRanges R package:

          guix import cran --archive=bioconductor GenomicRanges

     Finally, you can also import R packages that have not yet been
     published on CRAN or Bioconductor as long as they are in a git
     repository.  Use ‘--archive=git’ followed by the URL of the git
     repository:

          guix import cran --archive=git https://github.com/immunogenomics/harmony

‘texlive’
     Import metadata from CTAN (https://www.ctan.org/), the
     comprehensive TeX archive network for TeX packages that are part of
     the TeX Live distribution (https://www.tug.org/texlive/).

     Information about the package is obtained through the XML API
     provided by CTAN, while the source code is downloaded from the SVN
     repository of the Tex Live project.  This is done because the CTAN
     does not keep versioned archives.

     The command command below imports metadata for the ‘fontspec’ TeX
     package:

          guix import texlive fontspec

     When ‘--archive=DIRECTORY’ is added, the source code is downloaded
     not from the ‘latex’ sub-directory of the ‘texmf-dist/source’ tree
     in the TeX Live SVN repository, but from the specified sibling
     DIRECTORY under the same root.

     The command below imports metadata for the ‘ifxetex’ package from
     CTAN while fetching the sources from the directory
     ‘texmf/source/generic’:

          guix import texlive --archive=generic ifxetex

‘json’
     Import package metadata from a local JSON file.  Consider the
     following example package definition in JSON format:

          {
            "name": "hello",
            "version": "2.10",
            "source": "mirror://gnu/hello/hello-2.10.tar.gz",
            "build-system": "gnu",
            "home-page": "https://www.gnu.org/software/hello/",
            "synopsis": "Hello, GNU world: An example GNU package",
            "description": "GNU Hello prints a greeting.",
            "license": "GPL-3.0+",
            "native-inputs": ["gettext"]
          }

     The field names are the same as for the ‘<package>’ record (*Note
     Описание пакетов::).  References to other packages are provided as
     JSON lists of quoted package specification strings such as ‘guile’
     or ‘guile@2.0’.

     The importer also supports a more explicit source definition using
     the common fields for ‘<origin>’ records:

          {
            ...
            "source": {
              "method": "url-fetch",
              "uri": "mirror://gnu/hello/hello-2.10.tar.gz",
              "sha256": {
                "base32": "0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i"
              }
            }
            ...
          }

     The command below reads metadata from the JSON file ‘hello.json’
     and outputs a package expression:

          guix import json hello.json

‘nix’
     Import metadata from a local copy of the source of the Nixpkgs
     distribution (https://nixos.org/nixpkgs/)(1).  Package definitions
     in Nixpkgs are typically written in a mixture of Nix-language and
     Bash code.  This command only imports the high-level package
     structure that is written in the Nix language.  It normally
     includes all the basic fields of a package definition.

     When importing a GNU package, the synopsis and descriptions are
     replaced by their canonical upstream variant.

     Usually, you will first need to do:

          export NIX_REMOTE=daemon

     so that ‘nix-instantiate’ does not try to open the Nix database.

     As an example, the command below imports the package definition of
     LibreOffice (more precisely, it imports the definition of the
     package bound to the ‘libreoffice’ top-level attribute):

          guix import nix ~/path/to/nixpkgs libreoffice

‘hackage’
     Import metadata from the Haskell community’s central package
     archive Hackage (https://hackage.haskell.org/).  Information is
     taken from Cabal files and includes all the relevant information,
     including package dependencies.

     Specific command-line options are:

     ‘--stdin’
     ‘-s’
          Read a Cabal file from standard input.
     ‘--no-test-dependencies’
     ‘-t’
          Do not include dependencies required only by the test suites.
     ‘--cabal-environment=ALIST’
     ‘-e ALIST’
          ALIST is a Scheme alist defining the environment in which the
          Cabal conditionals are evaluated.  The accepted keys are:
          ‘os’, ‘arch’, ‘impl’ and a string representing the name of a
          flag.  The value associated with a flag has to be either the
          symbol ‘true’ or ‘false’.  The value associated with other
          keys has to conform to the Cabal file format definition.  The
          default value associated with the keys ‘os’, ‘arch’ and ‘impl’
          is ‘linux’, ‘x86_64’ and ‘ghc’, respectively.
     ‘--recursive’
     ‘-r’
          Traverse the dependency graph of the given upstream package
          recursively and generate package expressions for all those
          packages that are not yet in Guix.

     The command below imports metadata for the latest version of the
     HTTP Haskell package without including test dependencies and
     specifying the value of the flag ‘network-uri’ as ‘false’:

          guix import hackage -t -e "'((\"network-uri\" . false))" HTTP

     A specific package version may optionally be specified by following
     the package name by an at-sign and a version number as in the
     following example:

          guix import hackage mtl@2.1.3.1

‘stackage’
     The ‘stackage’ importer is a wrapper around the ‘hackage’ one.  It
     takes a package name, looks up the package version included in a
     long-term support (LTS) Stackage (https://www.stackage.org) release
     and uses the ‘hackage’ importer to retrieve its metadata.  Note
     that it is up to you to select an LTS release compatible with the
     GHC compiler used by Guix.

     Specific command-line options are:

     ‘--no-test-dependencies’
     ‘-t’
          Do not include dependencies required only by the test suites.
     ‘--lts-version=VERSION’
     ‘-l VERSION’
          VERSION is the desired LTS release version.  If omitted the
          latest release is used.
     ‘--recursive’
     ‘-r’
          Traverse the dependency graph of the given upstream package
          recursively and generate package expressions for all those
          packages that are not yet in Guix.

     The command below imports metadata for the HTTP Haskell package
     included in the LTS Stackage release version 7.18:

          guix import stackage --lts-version=7.18 HTTP

‘elpa’
     Import metadata from an Emacs Lisp Package Archive (ELPA) package
     repository (*note (emacs)Packages::).

     Specific command-line options are:

     ‘--archive=REPO’
     ‘-a REPO’
          REPO identifies the archive repository from which to retrieve
          the information.  Currently the supported repositories and
          their identifiers are:
             - GNU (https://elpa.gnu.org/packages), selected by the
               ‘gnu’ identifier.  This is the default.

               Packages from ‘elpa.gnu.org’ are signed with one of the
               keys contained in the GnuPG keyring at
               ‘share/emacs/25.1/etc/package-keyring.gpg’ (or similar)
               in the ‘emacs’ package (*note ELPA package signatures:
               (emacs)Package Installation.).

             - MELPA-Stable (https://stable.melpa.org/packages),
               selected by the ‘melpa-stable’ identifier.

             - MELPA (https://melpa.org/packages), selected by the
               ‘melpa’ identifier.

     ‘--recursive’
     ‘-r’
          Traverse the dependency graph of the given upstream package
          recursively and generate package expressions for all those
          packages that are not yet in Guix.

‘crate’
     Import metadata from the crates.io Rust package repository
     crates.io (https://crates.io), as in this example:

          guix import crate blake2-rfc

     The crate importer also allows you to specify a version string:

          guix import crate constant-time-eq@0.1.0

     Additional options include:

     ‘--recursive’
     ‘-r’
          Traverse the dependency graph of the given upstream package
          recursively and generate package expressions for all those
          packages that are not yet in Guix.

‘opam’
     Import metadata from the OPAM (https://opam.ocaml.org/) package
     repository used by the OCaml community.

   The structure of the ‘guix import’ code is modular.  It would be
useful to have more importers for other package formats, and your help
is welcome here (*note Содействие::).

   ---------- Footnotes ----------

   (1) This relies on the ‘nix-instantiate’ command of Nix
(https://nixos.org/nix/).


File: guix.ru.info,  Node: Запуск guix refresh,  Next: Запуск guix lint,  Prev: Запуск guix import,  Up: Утилиты

7.6 Invoking ‘guix refresh’
===========================

The primary audience of the ‘guix refresh’ command is developers of the
GNU software distribution.  By default, it reports any packages provided
by the distribution that are outdated compared to the latest upstream
version, like this:

     $ guix refresh
     gnu/packages/gettext.scm:29:13: gettext would be upgraded from 0.18.1.1 to 0.18.2.1
     gnu/packages/glib.scm:77:12: glib would be upgraded from 2.34.3 to 2.37.0

   Alternatively, one can specify packages to consider, in which case a
warning is emitted for packages that lack an updater:

     $ guix refresh coreutils guile guile-ssh
     gnu/packages/ssh.scm:205:2: warning: no updater for guile-ssh
     gnu/packages/guile.scm:136:12: guile would be upgraded from 2.0.12 to 2.0.13

   ‘guix refresh’ browses the upstream repository of each package and
determines the highest version number of the releases therein.  The
command knows how to update specific types of packages: GNU packages,
ELPA packages, etc.—see the documentation for ‘--type’ below.  There are
many packages, though, for which it lacks a method to determine whether
a new upstream release is available.  However, the mechanism is
extensible, so feel free to get in touch with us to add a new method!

‘--recursive’
     Consider the packages specified, and all the packages upon which
     they depend.

          $ guix refresh --recursive coreutils
          gnu/packages/acl.scm:35:2: warning: no updater for acl
          gnu/packages/m4.scm:30:12: info: 1.4.18 is already the latest version of m4
          gnu/packages/xml.scm:68:2: warning: no updater for expat
          gnu/packages/multiprecision.scm:40:12: info: 6.1.2 is already the latest version of gmp
          ...

   Sometimes the upstream name differs from the package name used in
Guix, and ‘guix refresh’ needs a little help.  Most updaters honor the
‘upstream-name’ property in package definitions, which can be used to
that effect:

     (define-public network-manager
       (package
         (name "network-manager")
         ;; ...
         (properties '((upstream-name . "NetworkManager")))))

   When passed ‘--update’, it modifies distribution source files to
update the version numbers and source tarball hashes of those package
recipes (*note Описание пакетов::).  This is achieved by downloading
each package’s latest source tarball and its associated OpenPGP
signature, authenticating the downloaded tarball against its signature
using ‘gpgv’, and finally computing its hash—note that GnuPG must be
installed and in ‘$PATH’; run ‘guix install gnupg’ if needed.

   When the public key used to sign the tarball is missing from the
user’s keyring, an attempt is made to automatically retrieve it from a
public key server; when this is successful, the key is added to the
user’s keyring; otherwise, ‘guix refresh’ reports an error.

   The following options are supported:

‘--expression=EXPR’
‘-e EXPR’
     Consider the package EXPR evaluates to.

     This is useful to precisely refer to a package, as in this example:

          guix refresh -l -e '(@@ (gnu packages commencement) glibc-final)'

     This command lists the dependents of the “final” libc (essentially
     all the packages).

‘--update’
‘-u’
     Update distribution source files (package recipes) in place.  This
     is usually run from a checkout of the Guix source tree (*note
     Запуск Guix перед его устанвокой::):

          $ ./pre-inst-env guix refresh -s non-core -u

     *Note Описание пакетов::, for more information on package
     definitions.

‘--select=[SUBSET]’
‘-s SUBSET’
     Select all the packages in SUBSET, one of ‘core’ or ‘non-core’.

     The ‘core’ subset refers to all the packages at the core of the
     distribution—i.e., packages that are used to build “everything
     else”.  This includes GCC, libc, Binutils, Bash, etc.  Usually,
     changing one of these packages in the distribution entails a
     rebuild of all the others.  Thus, such updates are an inconvenience
     to users in terms of build time or bandwidth used to achieve the
     upgrade.

     The ‘non-core’ subset refers to the remaining packages.  It is
     typically useful in cases where an update of the core packages
     would be inconvenient.

‘--manifest=FILE’
‘-m FILE’
     Select all the packages from the manifest in FILE.  This is useful
     to check if any packages of the user manifest can be updated.

‘--type=UPDATER’
‘-t UPDATER’
     Select only packages handled by UPDATER (may be a comma-separated
     list of updaters).  Currently, UPDATER may be one of:

     ‘gnu’
          the updater for GNU packages;
     ‘gnome’
          the updater for GNOME packages;
     ‘kde’
          the updater for KDE packages;
     ‘xorg’
          the updater for X.org packages;
     ‘kernel.org’
          the updater for packages hosted on kernel.org;
     ‘elpa’
          the updater for ELPA (https://elpa.gnu.org/) packages;
     ‘cran’
          the updater for CRAN (https://cran.r-project.org/) packages;
     ‘bioconductor’
          the updater for Bioconductor (https://www.bioconductor.org/) R
          packages;
     ‘cpan’
          the updater for CPAN (https://www.cpan.org/) packages;
     ‘pypi’
          the updater for PyPI (https://pypi.python.org) packages.
     ‘gem’
          the updater for RubyGems (https://rubygems.org) packages.
     ‘github’
          the updater for GitHub (https://github.com) packages.
     ‘hackage’
          the updater for Hackage (https://hackage.haskell.org)
          packages.
     ‘stackage’
          the updater for Stackage (https://www.stackage.org) packages.
     ‘crate’
          the updater for Crates (https://crates.io) packages.
     ‘launchpad’
          the updater for Launchpad (https://launchpad.net) packages.

     For instance, the following command only checks for updates of
     Emacs packages hosted at ‘elpa.gnu.org’ and for updates of CRAN
     packages:

          $ guix refresh --type=elpa,cran
          gnu/packages/statistics.scm:819:13: r-testthat would be upgraded from 0.10.0 to 0.11.0
          gnu/packages/emacs.scm:856:13: emacs-auctex would be upgraded from 11.88.6 to 11.88.9

   In addition, ‘guix refresh’ can be passed one or more package names,
as in this example:

     $ ./pre-inst-env guix refresh -u emacs idutils gcc@4.8

The command above specifically updates the ‘emacs’ and ‘idutils’
packages.  The ‘--select’ option would have no effect in this case.

   When considering whether to upgrade a package, it is sometimes
convenient to know which packages would be affected by the upgrade and
should be checked for compatibility.  For this the following option may
be used when passing ‘guix refresh’ one or more package names:

‘--list-updaters’
‘-L’
     List available updaters and exit (see ‘--type’ above).

     For each updater, display the fraction of packages it covers; at
     the end, display the fraction of packages covered by all these
     updaters.

‘--list-dependent’
‘-l’
     List top-level dependent packages that would need to be rebuilt as
     a result of upgrading one or more packages.

     *Note the ‘reverse-package’ type of ‘guix graph’: Запуск guix
     graph, for information on how to visualize the list of dependents
     of a package.

   Be aware that the ‘--list-dependent’ option only _approximates_ the
rebuilds that would be required as a result of an upgrade.  More
rebuilds might be required under some circumstances.

     $ guix refresh --list-dependent flex
     Building the following 120 packages would ensure 213 dependent packages are rebuilt:
     hop@2.4.0 geiser@0.4 notmuch@0.18 mu@0.9.9.5 cflow@1.4 idutils@4.6 ...

   The command above lists a set of packages that could be built to
check for compatibility with an upgraded ‘flex’ package.

‘--list-transitive’
     List all the packages which one or more packages depend upon.

          $ guix refresh --list-transitive flex
          flex@2.6.4 depends on the following 25 packages: perl@5.28.0 help2man@1.47.6
          bison@3.0.5 indent@2.2.10 tar@1.30 gzip@1.9 bzip2@1.0.6 xz@5.2.4 file@5.33 ...

   The command above lists a set of packages which, when changed, would
cause ‘flex’ to be rebuilt.

   The following options can be used to customize GnuPG operation:

‘--gpg=COMMAND’
     Use COMMAND as the GnuPG 2.x command.  COMMAND is searched for in
     ‘$PATH’.

‘--keyring=FILE’
     Use FILE as the keyring for upstream keys.  FILE must be in the
     “keybox format”.  Keybox files usually have a name ending in ‘.kbx’
     and the GNU Privacy Guard (GPG) can manipulate these files (*note
     ‘kbxutil’: (gnupg)kbxutil, for information on a tool to manipulate
     keybox files).

     When this option is omitted, ‘guix refresh’ uses
     ‘~/.config/guix/upstream/trustedkeys.kbx’ as the keyring for
     upstream signing keys.  OpenPGP signatures are checked against keys
     from this keyring; missing keys are downloaded to this keyring as
     well (see ‘--key-download’ below).

     You can export keys from your default GPG keyring into a keybox
     file using commands like this one:

          gpg --export rms@gnu.org | kbxutil --import-openpgp >> mykeyring.kbx

     Likewise, you can fetch keys to a specific keybox file like this:

          gpg --no-default-keyring --keyring mykeyring.kbx \
            --recv-keys 3CE464558A84FDC69DB40CFB090B11993D9AEBB5

     *note ‘--keyring’: (gnupg)GPG Configuration Options, for more
     information on GPG’s ‘--keyring’ option.

‘--key-download=POLICY’
     Handle missing OpenPGP keys according to POLICY, which may be one
     of:

     ‘always’
          Always download missing OpenPGP keys from the key server, and
          add them to the user’s GnuPG keyring.

     ‘never’
          Never try to download missing OpenPGP keys.  Instead just bail
          out.

     ‘interactive’
          When a package signed with an unknown OpenPGP key is
          encountered, ask the user whether to download it or not.  This
          is the default behavior.

‘--key-server=HOST’
     Use HOST as the OpenPGP key server when importing a public key.

‘--load-path=DIRECTORY’
     Add DIRECTORY to the front of the package module search path (*note
     Пакетные модули::).

     This allows users to define their own packages and make them
     visible to the command-line tools.

   The ‘github’ updater uses the GitHub API
(https://developer.github.com/v3/) to query for new releases.  When used
repeatedly e.g. when refreshing all packages, GitHub will eventually
refuse to answer any further API requests.  By default 60 API requests
per hour are allowed, and a full refresh on all GitHub packages in Guix
requires more than this.  Authentication with GitHub through the use of
an API token alleviates these limits.  To use an API token, set the
environment variable ‘GUIX_GITHUB_TOKEN’ to a token procured from
<https://github.com/settings/tokens> or otherwise.


File: guix.ru.info,  Node: Запуск guix lint,  Next: Запуск guix size,  Prev: Запуск guix refresh,  Up: Утилиты

7.7 Invoking ‘guix lint’
========================

The ‘guix lint’ command is meant to help package developers avoid common
errors and use a consistent style.  It runs a number of checks on a
given set of packages in order to find common mistakes in their
definitions.  Available “checkers” include (see ‘--list-checkers’ for a
complete list):

‘synopsis’
‘description’
     Validate certain typographical and stylistic rules about package
     descriptions and synopses.

‘inputs-should-be-native’
     Identify inputs that should most likely be native inputs.

‘source’
‘home-page’
‘mirror-url’
‘github-url’
‘source-file-name’
     Probe ‘home-page’ and ‘source’ URLs and report those that are
     invalid.  Suggest a ‘mirror://’ URL when applicable.  If the
     ‘source’ URL redirects to a GitHub URL, recommend usage of the
     GitHub URL. Check that the source file name is meaningful, e.g. is
     not just a version number or “git-checkout”, without a declared
     ‘file-name’ (*note Интерфейс origin::).

‘source-unstable-tarball’
     Parse the ‘source’ URL to determine if a tarball from GitHub is
     autogenerated or if it is a release tarball.  Unfortunately
     GitHub’s autogenerated tarballs are sometimes regenerated.

‘archival’
     Checks whether the package’s source code is archived at Software
     Heritage (https://www.softwareheritage.org).

     When the source code that is not archived comes from a
     version-control system (VCS)—e.g., it’s obtained with ‘git-fetch’,
     send Software Heritage a “save” request so that it eventually
     archives it.  This ensures that the source will remain available in
     the long term, and that Guix can fall back to Software Heritage
     should the source code disappear from its original host.  The
     status of recent “save” requests can be viewed on-line
     (https://archive.softwareheritage.org/save/#requests).

     When source code is a tarball obtained with ‘url-fetch’, simply
     print a message when it is not archived.  As of this writing,
     Software Heritage does not allow requests to save arbitrary
     tarballs; we are working on ways to ensure that non-VCS source code
     is also archived.

     Software Heritage limits the request rate per IP address
     (https://archive.softwareheritage.org/api/#rate-limiting).  When
     the limit is reached, ‘guix lint’ prints a message and the
     ‘archival’ checker stops doing anything until that limit has been
     reset.

‘cve’
     Report known vulnerabilities found in the Common Vulnerabilities
     and Exposures (CVE) databases of the current and past year
     published by the US NIST (https://nvd.nist.gov/vuln/data-feeds).

     To view information about a particular vulnerability, visit pages
     such as:

        • 
          ‘https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-YYYY-ABCD’
        • ‘https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-YYYY-ABCD’

     where ‘CVE-YYYY-ABCD’ is the CVE identifier—e.g., ‘CVE-2015-7554’.

     Package developers can specify in package recipes the Common
     Platform Enumeration (CPE) (https://nvd.nist.gov/products/cpe) name
     and version of the package when they differ from the name or
     version that Guix uses, as in this example:

          (package
            (name "grub")
            ;; ...
            ;; CPE calls this package "grub2".
            (properties '((cpe-name . "grub2")
                          (cpe-version . "2.3"))))

     Some entries in the CVE database do not specify which version of a
     package they apply to, and would thus “stick around” forever.
     Package developers who found CVE alerts and verified they can be
     ignored can declare them as in this example:

          (package
            (name "t1lib")
            ;; ...
            ;; These CVEs no longer apply and can be safely ignored.
            (properties `((lint-hidden-cve . ("CVE-2011-0433"
                                              "CVE-2011-1553"
                                              "CVE-2011-1554"
                                              "CVE-2011-5244")))))

‘formatting’
     Warn about obvious source code formatting issues: trailing white
     space, use of tabulations, etc.

   Основной синтаксис:

     guix lint OPTIONS PACKAGE...

   If no package is given on the command line, then all packages are
checked.  The OPTIONS may be zero or more of the following:

‘--list-checkers’
‘-l’
     List and describe all the available checkers that will be run on
     packages and exit.

‘--checkers’
‘-c’
     Only enable the checkers specified in a comma-separated list using
     the names returned by ‘--list-checkers’.

‘--load-path=DIRECTORY’
‘-L DIRECTORY’
     Add DIRECTORY to the front of the package module search path (*note
     Пакетные модули::).

     This allows users to define their own packages and make them
     visible to the command-line tools.


File: guix.ru.info,  Node: Запуск guix size,  Next: Запуск guix graph,  Prev: Запуск guix lint,  Up: Утилиты

7.8 Invoking ‘guix size’
========================

The ‘guix size’ command helps package developers profile the disk usage
of packages.  It is easy to overlook the impact of an additional
dependency added to a package, or the impact of using a single output
for a package that could easily be split (*note Пакеты со множественным
выходом::).  Such are the typical issues that ‘guix size’ can highlight.

   The command can be passed one or more package specifications such as
‘gcc@4.8’ or ‘guile:debug’, or a file name in the store.  Consider this
example:

     $ guix size coreutils
     store item                               total    self
     /gnu/store/...-gcc-5.5.0-lib           60.4    30.1  38.1%
     /gnu/store/...-glibc-2.27              30.3    28.8  36.6%
     /gnu/store/...-coreutils-8.28          78.9    15.0  19.0%
     /gnu/store/...-gmp-6.1.2               63.1     2.7   3.4%
     /gnu/store/...-bash-static-4.4.12       1.5     1.5   1.9%
     /gnu/store/...-acl-2.2.52              61.1     0.4   0.5%
     /gnu/store/...-attr-2.4.47             60.6     0.2   0.3%
     /gnu/store/...-libcap-2.25             60.5     0.2   0.2%
     total: 78.9 MiB

   The store items listed here constitute the “transitive closure” of
Coreutils—i.e., Coreutils and all its dependencies, recursively—as would
be returned by:

     $ guix gc -R /gnu/store/...-coreutils-8.23

   Here the output shows three columns next to store items.  The first
column, labeled “total”, shows the size in mebibytes (MiB) of the
closure of the store item—that is, its own size plus the size of all its
dependencies.  The next column, labeled “self”, shows the size of the
item itself.  The last column shows the ratio of the size of the item
itself to the space occupied by all the items listed here.

   In this example, we see that the closure of Coreutils weighs in at
79 MiB, most of which is taken by libc and GCC’s run-time support
libraries.  (That libc and GCC’s libraries represent a large fraction of
the closure is not a problem per se because they are always available on
the system anyway.)

   When the package(s) passed to ‘guix size’ are available in the
store(1), ‘guix size’ queries the daemon to determine its dependencies,
and measures its size in the store, similar to ‘du -ms --apparent-size’
(*note (coreutils)du invocation::).

   When the given packages are _not_ in the store, ‘guix size’ reports
information based on the available substitutes (*note Подстановки::).
This makes it possible it to profile disk usage of store items that are
not even on disk, only available remotely.

   You can also specify several package names:

     $ guix size coreutils grep sed bash
     store item                               total    self
     /gnu/store/...-coreutils-8.24          77.8    13.8  13.4%
     /gnu/store/...-grep-2.22               73.1     0.8   0.8%
     /gnu/store/...-bash-4.3.42             72.3     4.7   4.6%
     /gnu/store/...-readline-6.3            67.6     1.2   1.2%
     ...
     total: 102.3 MiB

In this example we see that the combination of the four packages takes
102.3 MiB in total, which is much less than the sum of each closure
since they have a lot of dependencies in common.

   When looking at the profile returned by ‘guix size’, you may find
yourself wondering why a given package shows up in the profile at all.
To understand it, you can use ‘guix graph --path -t references’ to
display the shortest path between the two packages (*note Запуск guix
graph::).

   The available options are:

‘--substitute-urls=URLS’
     Use substitute information from URLS.  *Note the same option for
     ‘guix build’: client-substitute-urls.

‘--sort=KEY’
     Sort lines according to KEY, one of the following options:

     ‘self’
          the size of each item (the default);
     ‘конвейер’
          the total size of the item’s closure.

‘--map-file=FILE’
     Write a graphical map of disk usage in PNG format to FILE.

     For the example above, the map looks like this:

 [image src="images/coreutils-size-map.png" alt="map of Coreutils disk usage produced
by guix size" ]

     This option requires that Guile-Charting
     (https://wingolog.org/software/guile-charting/) be installed and
     visible in Guile’s module search path.  When that is not the case,
     ‘guix size’ fails as it tries to load it.

‘--system=SYSTEM’
‘-s SYSTEM’
     Consider packages for SYSTEM—e.g., ‘x86_64-linux’.

‘--load-path=DIRECTORY’
‘-L DIRECTORY’
     Add DIRECTORY to the front of the package module search path (*note
     Пакетные модули::).

     This allows users to define their own packages and make them
     visible to the command-line tools.

   ---------- Footnotes ----------

   (1) More precisely, ‘guix size’ looks for the _ungrafted_ variant of
the given package(s), as returned by ‘guix build PACKAGE --no-grafts’.
*Note Обновления безопасности::, for information on grafts.


File: guix.ru.info,  Node: Запуск guix graph,  Next: Запуск guix publish,  Prev: Запуск guix size,  Up: Утилиты

7.9 Invoking ‘guix graph’
=========================

Packages and their dependencies form a “graph”, specifically a directed
acyclic graph (DAG). It can quickly become difficult to have a mental
model of the package DAG, so the ‘guix graph’ command provides a visual
representation of the DAG. By default, ‘guix graph’ emits a DAG
representation in the input format of Graphviz
(https://www.graphviz.org/), so its output can be passed directly to the
‘dot’ command of Graphviz.  It can also emit an HTML page with embedded
JavaScript code to display a “chord diagram” in a Web browser, using the
d3.js (https://d3js.org/) library, or emit Cypher queries to construct a
graph in a graph database supporting the openCypher
(https://www.opencypher.org/) query language.  With ‘--path’, it simply
displays the shortest path between two packages.  The general syntax is:

     guix graph OPTIONS PACKAGE...

   For example, the following command generates a PDF file representing
the package DAG for the GNU Core Utilities, showing its build-time
dependencies:

     guix graph coreutils | dot -Tpdf > dag.pdf

   The output looks like this:

[Dependency graph of the GNU Coreutils]
   Nice little graph, no?

   You may find it more pleasant to navigate the graph interactively
with ‘xdot’ (from the ‘xdot’ package):

     guix graph coreutils | xdot -

   But there is more than one graph!  The one above is concise: it is
the graph of package objects, omitting implicit inputs such as GCC,
libc, grep, etc.  It is often useful to have such a concise graph, but
sometimes one may want to see more details.  ‘guix graph’ supports
several types of graphs, allowing you to choose the level of detail:

‘package’
     This is the default type used in the example above.  It shows the
     DAG of package objects, excluding implicit dependencies.  It is
     concise, but filters out many details.

‘reverse-package’
     This shows the _reverse_ DAG of packages.  For example:

          guix graph --type=reverse-package ocaml

     ... yields the graph of packages that _explicitly_ depend on OCaml
     (if you are also interested in cases where OCaml is an implicit
     dependency, see ‘reverse-bag’ below).

     Note that for core packages this can yield huge graphs.  If all you
     want is to know the number of packages that depend on a given
     package, use ‘guix refresh --list-dependent’ (*note
     ‘--list-dependent’: Запуск guix refresh.).

‘bag-emerged’
     This is the package DAG, _including_ implicit inputs.

     For instance, the following command:

          guix graph --type=bag-emerged coreutils

     ... yields this bigger graph:

[Detailed dependency graph of the GNU
Coreutils]
     At the bottom of the graph, we see all the implicit inputs of
     GNU-BUILD-SYSTEM (*note ‘gnu-build-system’: Системы сборки.).

     Now, note that the dependencies of these implicit inputs—that is,
     the “bootstrap dependencies” (*note Начальная загрузка::)—are not
     shown here, for conciseness.

‘bag’
     Similar to ‘bag-emerged’, but this time including all the bootstrap
     dependencies.

‘bag-with-origins’
     Similar to ‘bag’, but also showing origins and their dependencies.

‘reverse-bag’
     This shows the _reverse_ DAG of packages.  Unlike
     ‘reverse-package’, it also takes implicit dependencies into
     account.  For example:

          guix graph -t reverse-bag dune

     ... yields the graph of all packages that depend on Dune, directly
     or indirectly.  Since Dune is an _implicit_ dependency of many
     packages via ‘dune-build-system’, this shows a large number of
     packages, whereas ‘reverse-package’ would show very few if any.

‘деривация’
     This is the most detailed representation: It shows the DAG of
     derivations (*note Деривации::) and plain store items.  Compared to
     the above representation, many additional nodes are visible,
     including build scripts, patches, Guile modules, etc.

     For this type of graph, it is also possible to pass a ‘.drv’ file
     name instead of a package name, as in:

          guix graph -t derivation `guix system build -d my-config.scm`

‘module’
     This is the graph of “package modules” (*note Пакетные модули::).
     For example, the following command shows the graph for the package
     module that defines the ‘guile’ package:

          guix graph -t module guile | xdot -

   All the types above correspond to _build-time dependencies_.  The
following graph type represents the _run-time dependencies_:

‘references’
     This is the graph of “references” of a package output, as returned
     by ‘guix gc --references’ (*note Вызов guix gc::).

     If the given package output is not available in the store, ‘guix
     graph’ attempts to obtain dependency information from substitutes.

     Here you can also pass a store file name instead of a package name.
     For example, the command below produces the reference graph of your
     profile (which can be big!):

          guix graph -t references `readlink -f ~/.guix-profile`

‘referrers’
     This is the graph of the “referrers” of a store item, as returned
     by ‘guix gc --referrers’ (*note Вызов guix gc::).

     This relies exclusively on local information from your store.  For
     instance, let us suppose that the current Inkscape is available in
     10 profiles on your machine; ‘guix graph -t referrers inkscape’
     will show a graph rooted at Inkscape and with those 10 profiles
     linked to it.

     It can help determine what is preventing a store item from being
     garbage collected.

   Often, the graph of the package you are interested in does not fit on
your screen, and anyway all you want to know is _why_ that package
actually depends on some seemingly unrelated package.  The ‘--path’
option instructs ‘guix graph’ to display the shortest path between two
packages (or derivations, or store items, etc.):

     $ guix graph --path emacs libunistring
     emacs@26.3
     mailutils@3.9
     libunistring@0.9.10
     $ guix graph --path -t derivation emacs libunistring
     /gnu/store/...-emacs-26.3.drv
     /gnu/store/...-mailutils-3.9.drv
     /gnu/store/...-libunistring-0.9.10.drv
     $ guix graph --path -t references emacs libunistring
     /gnu/store/...-emacs-26.3
     /gnu/store/...-libidn2-2.2.0
     /gnu/store/...-libunistring-0.9.10

   The available options are the following:

‘--type=TYPE’
‘-t TYPE’
     Produce a graph output of TYPE, where TYPE must be one of the
     values listed above.

‘--list-types’
     List the supported graph types.

‘--backend=BACKEND’
‘-b BACKEND’
     Produce a graph using the selected BACKEND.

‘--list-backends’
     List the supported graph backends.

     Currently, the available backends are Graphviz and d3.js.

‘--path’
     Display the shortest path between two nodes of the type specified
     by ‘--type’.  The example below shows the shortest path between
     ‘libreoffice’ and ‘llvm’ according to the references of
     ‘libreoffice’:

          $ guix graph --path -t references libreoffice llvm
          /gnu/store/...-libreoffice-6.4.2.2
          /gnu/store/...-libepoxy-1.5.4
          /gnu/store/...-mesa-19.3.4
          /gnu/store/...-llvm-9.0.1

‘--expression=EXPR’
‘-e EXPR’
     Consider the package EXPR evaluates to.

     This is useful to precisely refer to a package, as in this example:

          guix graph -e '(@@ (gnu packages commencement) gnu-make-final)'

‘--system=SYSTEM’
‘-s SYSTEM’
     Display the graph for SYSTEM—e.g., ‘i686-linux’.

     The package dependency graph is largely architecture-independent,
     but there are some architecture-dependent bits that this option
     allows you to visualize.

‘--load-path=DIRECTORY’
‘-L DIRECTORY’
     Add DIRECTORY to the front of the package module search path (*note
     Пакетные модули::).

     This allows users to define their own packages and make them
     visible to the command-line tools.

   On top of that, ‘guix graph’ supports all the usual package
transformation options (*note Параметры преобразования пакета::).  This
makes it easy to view the effect of a graph-rewriting transformation
such as ‘--with-input’.  For example, the command below outputs the
graph of ‘git’ once ‘openssl’ has been replaced by ‘libressl’ everywhere
in the graph:

     guix graph git --with-input=openssl=libressl

   So many possibilities, so much fun!


File: guix.ru.info,  Node: Запуск guix publish,  Next: Запуск guix challenge,  Prev: Запуск guix graph,  Up: Утилиты

7.10 Invoking ‘guix publish’
============================

The purpose of ‘guix publish’ is to enable users to easily share their
store with others, who can then use it as a substitute server (*note
Подстановки::).

   When ‘guix publish’ runs, it spawns an HTTP server which allows
anyone with network access to obtain substitutes from it.  This means
that any machine running Guix can also act as if it were a build farm,
since the HTTP interface is compatible with Cuirass, the software behind
the ‘ci.guix.gnu.org’ build farm.

   For security, each substitute is signed, allowing recipients to check
their authenticity and integrity (*note Подстановки::).  Because ‘guix
publish’ uses the signing key of the system, which is only readable by
the system administrator, it must be started as root; the ‘--user’
option makes it drop root privileges early on.

   The signing key pair must be generated before ‘guix publish’ is
launched, using ‘guix archive --generate-key’ (*note Вызов guix
archive::).

   Основной синтаксис:

     guix publish OPTIONS...

   Running ‘guix publish’ without any additional arguments will spawn an
HTTP server on port 8080:

     guix publish

   Once a publishing server has been authorized (*note Вызов guix
archive::), the daemon may download substitutes from it:

     guix-daemon --substitute-urls=http://example.org:8080

   By default, ‘guix publish’ compresses archives on the fly as it
serves them.  This “on-the-fly” mode is convenient in that it requires
no setup and is immediately available.  However, when serving lots of
clients, we recommend using the ‘--cache’ option, which enables caching
of the archives before they are sent to clients—see below for details.
The ‘guix weather’ command provides a handy way to check what a server
provides (*note Запуск guix weather::).

   As a bonus, ‘guix publish’ also serves as a content-addressed mirror
for source files referenced in ‘origin’ records (*note Интерфейс
origin::).  For instance, assuming ‘guix publish’ is running on
‘example.org’, the following URL returns the raw ‘hello-2.10.tar.gz’
file with the given SHA256 hash (represented in ‘nix-base32’ format,
*note Запуск guix hash::):

     http://example.org/file/hello-2.10.tar.gz/sha256/0ssi1...ndq1i

   Obviously, these URLs only work for files that are in the store; in
other cases, they return 404 (“Not Found”).

   Build logs are available from ‘/log’ URLs like:

     http://example.org/log/gwspk...-guile-2.2.3

When ‘guix-daemon’ is configured to save compressed build logs, as is
the case by default (*note Вызов guix-daemon::), ‘/log’ URLs return the
compressed log as-is, with an appropriate ‘Content-Type’ and/or
‘Content-Encoding’ header.  We recommend running ‘guix-daemon’ with
‘--log-compression=gzip’ since Web browsers can automatically decompress
it, which is not the case with Bzip2 compression.

   The following options are available:

‘--port=PORT’
‘-p PORT’
     Listen for HTTP requests on PORT.

‘--listen=HOST’
     Listen on the network interface for HOST.  The default is to accept
     connections from any interface.

‘--user=USER’
‘-u USER’
     Change privileges to USER as soon as possible—i.e., once the server
     socket is open and the signing key has been read.

‘--compression[=METHOD[:LEVEL]]’
‘-C [METHOD[:LEVEL]]’
     Compress data using the given METHOD and LEVEL.  METHOD is one of
     ‘lzip’ and ‘gzip’; when METHOD is omitted, ‘gzip’ is used.

     When LEVEL is zero, disable compression.  The range 1 to 9
     corresponds to different compression levels: 1 is the fastest, and
     9 is the best (CPU-intensive).  The default is 3.

     Usually, ‘lzip’ compresses noticeably better than ‘gzip’ for a
     small increase in CPU usage; see benchmarks on the lzip Web page
     (https://nongnu.org/lzip/lzip_benchmark.html).

     Unless ‘--cache’ is used, compression occurs on the fly and the
     compressed streams are not cached.  Thus, to reduce load on the
     machine that runs ‘guix publish’, it may be a good idea to choose a
     low compression level, to run ‘guix publish’ behind a caching
     proxy, or to use ‘--cache’.  Using ‘--cache’ has the advantage that
     it allows ‘guix publish’ to add ‘Content-Length’ HTTP header to its
     responses.

     This option can be repeated, in which case every substitute gets
     compressed using all the selected methods, and all of them are
     advertised.  This is useful when users may not support all the
     compression methods: they can select the one they support.

‘--cache=DIRECTORY’
‘-c DIRECTORY’
     Cache archives and meta-data (‘.narinfo’ URLs) to DIRECTORY and
     only serve archives that are in cache.

     When this option is omitted, archives and meta-data are created
     on-the-fly.  This can reduce the available bandwidth, especially
     when compression is enabled, since this may become CPU-bound.
     Another drawback of the default mode is that the length of archives
     is not known in advance, so ‘guix publish’ does not add a
     ‘Content-Length’ HTTP header to its responses, which in turn
     prevents clients from knowing the amount of data being downloaded.

     Conversely, when ‘--cache’ is used, the first request for a store
     item (via a ‘.narinfo’ URL) returns 404 and triggers a background
     process to “bake” the archive—computing its ‘.narinfo’ and
     compressing the archive, if needed.  Once the archive is cached in
     DIRECTORY, subsequent requests succeed and are served directly from
     the cache, which guarantees that clients get the best possible
     bandwidth.

     The “baking” process is performed by worker threads.  By default,
     one thread per CPU core is created, but this can be customized.
     See ‘--workers’ below.

     When ‘--ttl’ is used, cached entries are automatically deleted when
     they have expired.

‘--workers=N’
     When ‘--cache’ is used, request the allocation of N worker threads
     to “bake” archives.

‘--ttl=TTL’
     Produce ‘Cache-Control’ HTTP headers that advertise a time-to-live
     (TTL) of TTL.  TTL must denote a duration: ‘5d’ means 5 days, ‘1m’
     means 1 month, and so on.

     This allows the user’s Guix to keep substitute information in cache
     for TTL.  However, note that ‘guix publish’ does not itself
     guarantee that the store items it provides will indeed remain
     available for as long as TTL.

     Additionally, when ‘--cache’ is used, cached entries that have not
     been accessed for TTL and that no longer have a corresponding item
     in the store, may be deleted.

‘--nar-path=PATH’
     Use PATH as the prefix for the URLs of “nar” files (*note
     normalized archives: Вызов guix archive.).

     By default, nars are served at a URL such as
     ‘/nar/gzip/...-coreutils-8.25’.  This option allows you to change
     the ‘/nar’ part to PATH.

‘--public-key=FILE’
‘--private-key=FILE’
     Use the specific FILEs as the public/private key pair used to sign
     the store items being published.

     The files must correspond to the same key pair (the private key is
     used for signing and the public key is merely advertised in the
     signature metadata).  They must contain keys in the canonical
     s-expression format as produced by ‘guix archive --generate-key’
     (*note Вызов guix archive::).  By default,
     ‘/etc/guix/signing-key.pub’ and ‘/etc/guix/signing-key.sec’ are
     used.

‘--repl[=PORT]’
‘-r [PORT]’
     Spawn a Guile REPL server (*note (guile)REPL Servers::) on PORT
     (37146 by default).  This is used primarily for debugging a running
     ‘guix publish’ server.

   Enabling ‘guix publish’ on Guix System is a one-liner: just
instantiate a ‘guix-publish-service-type’ service in the ‘services’
field of the ‘operating-system’ declaration (*note
‘guix-publish-service-type’: guix-publish-service-type.).

   If you are instead running Guix on a “foreign distro”, follow these
instructions:

   • If your host distro uses the systemd init system:

          # ln -s ~root/.guix-profile/lib/systemd/system/guix-publish.service \
                  /etc/systemd/system/
          # systemctl start guix-publish && systemctl enable guix-publish

   • Если ваш дистрибутив использует систему инициализации Upstart:

          # ln -s ~root/.guix-profile/lib/upstart/system/guix-publish.conf /etc/init/
          # start guix-publish

   • Otherwise, proceed similarly with your distro’s init system.


File: guix.ru.info,  Node: Запуск guix challenge,  Next: Запуск guix copy,  Prev: Запуск guix publish,  Up: Утилиты

7.11 Invoking ‘guix challenge’
==============================

Do the binaries provided by this server really correspond to the source
code it claims to build?  Is a package build process deterministic?
These are the questions the ‘guix challenge’ command attempts to answer.

   The former is obviously an important question: Before using a
substitute server (*note Подстановки::), one had better _verify_ that it
provides the right binaries, and thus _challenge_ it.  The latter is
what enables the former: If package builds are deterministic, then
independent builds of the package should yield the exact same result,
bit for bit; if a server provides a binary different from the one
obtained locally, it may be either corrupt or malicious.

   We know that the hash that shows up in ‘/gnu/store’ file names is the
hash of all the inputs of the process that built the file or
directory—compilers, libraries, build scripts, etc.  (*note Введение::).
Assuming deterministic build processes, one store file name should map
to exactly one build output.  ‘guix challenge’ checks whether there is,
indeed, a single mapping by comparing the build outputs of several
independent builds of any given store item.

   The command output looks like this:

     $ guix challenge --substitute-urls="https://ci.guix.gnu.org https://guix.example.org"
     updating list of substitutes from 'https://ci.guix.gnu.org'... 100.0%
     updating list of substitutes from 'https://guix.example.org'... 100.0%
     /gnu/store/...-openssl-1.0.2d contents differ:
       local hash: 0725l22r5jnzazaacncwsvp9kgf42266ayyp814v7djxs7nk963q
       https://ci.guix.gnu.org/nar/...-openssl-1.0.2d: 0725l22r5jnzazaacncwsvp9kgf42266ayyp814v7djxs7nk963q
       https://guix.example.org/nar/...-openssl-1.0.2d: 1zy4fmaaqcnjrzzajkdn3f5gmjk754b43qkq47llbyak9z0qjyim
       differing files:
         /lib/libcrypto.so.1.1
         /lib/libssl.so.1.1

     /gnu/store/...-git-2.5.0 contents differ:
       local hash: 00p3bmryhjxrhpn2gxs2fy0a15lnip05l97205pgbk5ra395hyha
       https://ci.guix.gnu.org/nar/...-git-2.5.0: 069nb85bv4d4a6slrwjdy8v1cn4cwspm3kdbmyb81d6zckj3nq9f
       https://guix.example.org/nar/...-git-2.5.0: 0mdqa9w1p6cmli6976v4wi0sw9r4p5prkj7lzfd1877wk11c9c73
       differing file:
         /libexec/git-core/git-fsck

     /gnu/store/...-pius-2.1.1 contents differ:
       local hash: 0k4v3m9z1zp8xzzizb7d8kjj72f9172xv078sq4wl73vnq9ig3ax
       https://ci.guix.gnu.org/nar/...-pius-2.1.1: 0k4v3m9z1zp8xzzizb7d8kjj72f9172xv078sq4wl73vnq9ig3ax
       https://guix.example.org/nar/...-pius-2.1.1: 1cy25x1a4fzq5rk0pmvc8xhwyffnqz95h2bpvqsz2mpvlbccy0gs
       differing file:
         /share/man/man1/pius.1.gz

     ...

     6,406 store items were analyzed:
       - 4,749 (74.1%) were identical
       - 525 (8.2%) differed
       - 1,132 (17.7%) were inconclusive

In this example, ‘guix challenge’ first scans the store to determine the
set of locally-built derivations—as opposed to store items that were
downloaded from a substitute server—and then queries all the substitute
servers.  It then reports those store items for which the servers
obtained a result different from the local build.

   As an example, ‘guix.example.org’ always gets a different answer.
Conversely, ‘ci.guix.gnu.org’ agrees with local builds, except in the
case of Git.  This might indicate that the build process of Git is
non-deterministic, meaning that its output varies as a function of
various things that Guix does not fully control, in spite of building
packages in isolated environments (*note Особенности::).  Most common
sources of non-determinism include the addition of timestamps in build
results, the inclusion of random numbers, and directory listings sorted
by inode number.  See <https://reproducible-builds.org/docs/>, for more
information.

   To find out what is wrong with this Git binary, the easiest approach
is to run:

     guix challenge git \
       --diff=diffoscope \
       --substitute-urls="https://ci.guix.gnu.org https://guix.example.org"

   This automatically invokes ‘diffoscope’, which displays detailed
information about files that differ.

   Alternatively, we can do something along these lines (*note Вызов
guix archive::):

     $ wget -q -O - https://ci.guix.gnu.org/nar/lzip/...-git-2.5.0 \
        | lzip -d | guix archive -x /tmp/git
     $ diff -ur --no-dereference /gnu/store/...-git.2.5.0 /tmp/git

   This command shows the difference between the files resulting from
the local build, and the files resulting from the build on
‘ci.guix.gnu.org’ (*note Comparing and Merging Files:
(diffutils)Overview.).  The ‘diff’ command works great for text files.
When binary files differ, a better option is Diffoscope
(https://diffoscope.org/), a tool that helps visualize differences for
all kinds of files.

   Once you have done that work, you can tell whether the differences
are due to a non-deterministic build process or to a malicious server.
We try hard to remove sources of non-determinism in packages to make it
easier to verify substitutes, but of course, this is a process that
involves not just Guix, but a large part of the free software community.
In the meantime, ‘guix challenge’ is one tool to help address the
problem.

   If you are writing packages for Guix, you are encouraged to check
whether ‘ci.guix.gnu.org’ and other substitute servers obtain the same
build result as you did with:

     $ guix challenge PACKAGE

where PACKAGE is a package specification such as ‘guile@2.0’ or
‘glibc:debug’.

   Основной синтаксис:

     guix challenge OPTIONS [PACKAGES...]

   When a difference is found between the hash of a locally-built item
and that of a server-provided substitute, or among substitutes provided
by different servers, the command displays it as in the example above
and its exit code is 2 (other non-zero exit codes denote other kinds of
errors).

   The one option that matters is:

‘--substitute-urls=URLS’
     Consider URLS the whitespace-separated list of substitute source
     URLs to compare to.

‘--diff=MODE’
     Upon mismatches, show differences according to MODE, one of:

     ‘simple’ (the default)
          Show the list of files that differ.

     ‘diffoscope’
     COMMAND
          Invoke Diffoscope (https://diffoscope.org/), passing it two
          directories whose contents do not match.

          When COMMAND is an absolute file name, run COMMAND instead of
          Diffoscope.

     ‘none’
          Do not show further details about the differences.

     Thus, unless ‘--diff=none’ is passed, ‘guix challenge’ downloads
     the store items from the given substitute servers so that it can
     compare them.

‘--verbose’
‘-v’
     Show details about matches (identical contents) in addition to
     information about mismatches.


File: guix.ru.info,  Node: Запуск guix copy,  Next: Запуск guix container,  Prev: Запуск guix challenge,  Up: Утилиты

7.12 Invoking ‘guix copy’
=========================

The ‘guix copy’ command copies items from the store of one machine to
that of another machine over a secure shell (SSH) connection(1).  For
example, the following command copies the ‘coreutils’ package, the
user’s profile, and all their dependencies over to HOST, logged in as
USER:

     guix copy --to=USER@HOST \
               coreutils `readlink -f ~/.guix-profile`

   If some of the items to be copied are already present on HOST, they
are not actually sent.

   The command below retrieves ‘libreoffice’ and ‘gimp’ from HOST,
assuming they are available there:

     guix copy --from=HOST libreoffice gimp

   The SSH connection is established using the Guile-SSH client, which
is compatible with OpenSSH: it honors ‘~/.ssh/known_hosts’ and
‘~/.ssh/config’, and uses the SSH agent for authentication.

   The key used to sign items that are sent must be accepted by the
remote machine.  Likewise, the key used by the remote machine to sign
items you are retrieving must be in ‘/etc/guix/acl’ so it is accepted by
your own daemon.  *Note Вызов guix archive::, for more information about
store item authentication.

   Основной синтаксис:

     guix copy [--to=SPEC|--from=SPEC] ITEMS...

   You must always specify one of the following options:

‘--to=SPEC’
‘--from=SPEC’
     Specify the host to send to or receive from.  SPEC must be an SSH
     spec such as ‘example.org’, ‘charlie@example.org’, or
     ‘charlie@example.org:2222’.

   The ITEMS can be either package names, such as ‘gimp’, or store
items, such as ‘/gnu/store/...-idutils-4.6’.

   When specifying the name of a package to send, it is first built if
needed, unless ‘--dry-run’ was specified.  Common build options are
supported (*note Стандартные параметры сборки::).

   ---------- Footnotes ----------

   (1) This command is available only when Guile-SSH was found.  *Note
Требования::, for details.


File: guix.ru.info,  Node: Запуск guix container,  Next: Запуск guix weather,  Prev: Запуск guix copy,  Up: Утилиты

7.13 Invoking ‘guix container’
==============================

     Примечание: As of version 1.0.1.17089-7e269, this tool is
     experimental.  The interface is subject to radical change in the
     future.

   The purpose of ‘guix container’ is to manipulate processes running
within an isolated environment, commonly known as a “container”,
typically created by the ‘guix environment’ (*note Запуск guix
environment::) and ‘guix system container’ (*note Вызов guix system::)
commands.

   Основной синтаксис:

     guix container ACTION OPTIONS...

   ACTION specifies the operation to perform with a container, and
OPTIONS specifies the context-specific arguments for the action.

   The following actions are available:

‘exec’
     Execute a command within the context of a running container.

     The syntax is:

          guix container exec PID PROGRAM ARGUMENTS...

     PID specifies the process ID of the running container.  PROGRAM
     specifies an executable file name within the root file system of
     the container.  ARGUMENTS are the additional options that will be
     passed to PROGRAM.

     The following command launches an interactive login shell inside a
     Guix system container, started by ‘guix system container’, and
     whose process ID is 9001:

          guix container exec 9001 /run/current-system/profile/bin/bash --login

     Note that the PID cannot be the parent process of a container.  It
     must be PID 1 of the container or one of its child processes.


File: guix.ru.info,  Node: Запуск guix weather,  Next: Запуск guix processes,  Prev: Запуск guix container,  Up: Утилиты

7.14 Invoking ‘guix weather’
============================

Occasionally you’re grumpy because substitutes are lacking and you end
up building packages by yourself (*note Подстановки::).  The ‘guix
weather’ command reports on substitute availability on the specified
servers so you can have an idea of whether you’ll be grumpy today.  It
can sometimes be useful info as a user, but it is primarily useful to
people running ‘guix publish’ (*note Запуск guix publish::).

   Here’s a sample run:

     $ guix weather --substitute-urls=https://guix.example.org
     computing 5,872 package derivations for x86_64-linux...
     looking for 6,128 store items on https://guix.example.org..
     updating list of substitutes from 'https://guix.example.org'... 100.0%
     https://guix.example.org
       43.4% substitutes available (2,658 out of 6,128)
       7,032.5 MiB of nars (compressed)
       19,824.2 MiB on disk (uncompressed)
       0.030 seconds per request (182.9 seconds in total)
       33.5 requests per second

       9.8% (342 out of 3,470) of the missing items are queued
       867 queued builds
           x86_64-linux: 518 (59.7%)
           i686-linux: 221 (25.5%)
           aarch64-linux: 128 (14.8%)
       build rate: 23.41 builds per hour
           x86_64-linux: 11.16 builds per hour
           i686-linux: 6.03 builds per hour
           aarch64-linux: 6.41 builds per hour

   As you can see, it reports the fraction of all the packages for which
substitutes are available on the server—regardless of whether
substitutes are enabled, and regardless of whether this server’s signing
key is authorized.  It also reports the size of the compressed archives
(“nars”) provided by the server, the size the corresponding store items
occupy in the store (assuming deduplication is turned off), and the
server’s throughput.  The second part gives continuous integration (CI)
statistics, if the server supports it.  In addition, using the
‘--coverage’ option, ‘guix weather’ can list “important” package
substitutes missing on the server (see below).

   To achieve that, ‘guix weather’ queries over HTTP(S) meta-data
(“narinfos”) for all the relevant store items.  Like ‘guix challenge’,
it ignores signatures on those substitutes, which is innocuous since the
command only gathers statistics and cannot install those substitutes.

   Основной синтаксис:

     guix weather OPTIONS... [PACKAGES...]

   When PACKAGES is omitted, ‘guix weather’ checks the availability of
substitutes for _all_ the packages, or for those specified with
‘--manifest’; otherwise it only considers the specified packages.  It is
also possible to query specific system types with ‘--system’.  ‘guix
weather’ exits with a non-zero code when the fraction of available
substitutes is below 100%.

   The available options are listed below.

‘--substitute-urls=URLS’
     URLS is the space-separated list of substitute server URLs to
     query.  When this option is omitted, the default set of substitute
     servers is queried.

‘--system=SYSTEM’
‘-s SYSTEM’
     Query substitutes for SYSTEM—e.g., ‘aarch64-linux’.  This option
     can be repeated, in which case ‘guix weather’ will query
     substitutes for several system types.

‘--manifest=FILE’
     Instead of querying substitutes for all the packages, only ask for
     those specified in FILE.  FILE must contain a “manifest”, as with
     the ‘-m’ option of ‘guix package’ (*note Вызов guix package::).

     This option can be repeated several times, in which case the
     manifests are concatenated.

‘--coverage[=COUNT]’
‘-c [COUNT]’
     Report on substitute coverage for packages: list packages with at
     least COUNT dependents (zero by default) for which substitutes are
     unavailable.  Dependent packages themselves are not listed: if B
     depends on A and A has no substitutes, only A is listed, even
     though B usually lacks substitutes as well.  The result looks like
     this:

          $ guix weather --substitute-urls=https://ci.guix.gnu.org -c 10
          computing 8,983 package derivations for x86_64-linux...
          looking for 9,343 store items on https://ci.guix.gnu.org...
          updating substitutes from 'https://ci.guix.gnu.org'... 100.0%
          https://ci.guix.gnu.org
            64.7% substitutes available (6,047 out of 9,343)
          ...
          2502 packages are missing from 'https://ci.guix.gnu.org' for 'x86_64-linux', among which:
              58  kcoreaddons@5.49.0      /gnu/store/...-kcoreaddons-5.49.0
              46  qgpgme@1.11.1           /gnu/store/...-qgpgme-1.11.1
              37  perl-http-cookiejar@0.008  /gnu/store/...-perl-http-cookiejar-0.008
              ...

     What this example shows is that ‘kcoreaddons’ and presumably the 58
     packages that depend on it have no substitutes at
     ‘ci.guix.ru.info’; likewise for ‘qgpgme’ and the 46 packages that
     depend on it.

     If you are a Guix developer, or if you are taking care of this
     build farm, you’ll probably want to have a closer look at these
     packages: they may simply fail to build.

‘--display-missing’
     Display the list of store items for which substitutes are missing.


File: guix.ru.info,  Node: Запуск guix processes,  Prev: Запуск guix weather,  Up: Утилиты

7.15 Invoking ‘guix processes’
==============================

The ‘guix processes’ command can be useful to developers and system
administrators, especially on multi-user machines and on build farms: it
lists the current sessions (connections to the daemon), as well as
information about the processes involved(1).  Here’s an example of the
information it returns:

     $ sudo guix processes
     SessionPID: 19002
     ClientPID: 19090
     ClientCommand: guix environment --ad-hoc python

     SessionPID: 19402
     ClientPID: 19367
     ClientCommand: guix publish -u guix-publish -p 3000 -C 9 ...

     SessionPID: 19444
     ClientPID: 19419
     ClientCommand: cuirass --cache-directory /var/cache/cuirass ...
     LockHeld: /gnu/store/...-perl-ipc-cmd-0.96.lock
     LockHeld: /gnu/store/...-python-six-bootstrap-1.11.0.lock
     LockHeld: /gnu/store/...-libjpeg-turbo-2.0.0.lock
     ChildProcess: 20495: guix offload x86_64-linux 7200 1 28800
     ChildProcess: 27733: guix offload x86_64-linux 7200 1 28800
     ChildProcess: 27793: guix offload x86_64-linux 7200 1 28800

   In this example we see that ‘guix-daemon’ has three clients: ‘guix
environment’, ‘guix publish’, and the Cuirass continuous integration
tool; their process identifier (PID) is given by the ‘ClientPID’ field.
The ‘SessionPID’ field gives the PID of the ‘guix-daemon’ sub-process of
this particular session.

   The ‘LockHeld’ fields show which store items are currently locked by
this session, which corresponds to store items being built or
substituted (the ‘LockHeld’ field is not displayed when ‘guix processes’
is not running as root).  Last, by looking at the ‘ChildProcess’ field,
we understand that these three builds are being offloaded (*note
Установка демона разгрузки::).

   The output is in Recutils format so we can use the handy ‘recsel’
command to select sessions of interest (*note (recutils)Selection
Expressions::).  As an example, the command shows the command line and
PID of the client that triggered the build of a Perl package:

     $ sudo guix processes | \
         recsel -p ClientPID,ClientCommand -e 'LockHeld ~ "perl"'
     ClientPID: 19419
     ClientCommand: cuirass --cache-directory /var/cache/cuirass ...

   ---------- Footnotes ----------

   (1) Remote sessions, when ‘guix-daemon’ is started with ‘--listen’
specifying a TCP endpoint, are _not_ listed.


File: guix.ru.info,  Node: Конфигурирование системы,  Next: Документация,  Prev: Утилиты,  Up: Top

8 Конфигурирование системы
**************************

Guix System supports a consistent whole-system configuration mechanism.
By that we mean that all aspects of the global system configuration—such
as the available system services, timezone and locale settings, user
accounts—are declared in a single place.  Such a “system configuration”
can be “instantiated”—i.e., effected.

   One of the advantages of putting all the system configuration under
the control of Guix is that it supports transactional system upgrades,
and makes it possible to roll back to a previous system instantiation,
should something go wrong with the new one (*note Особенности::).
Another advantage is that it makes it easy to replicate the exact same
configuration across different machines, or at different points in time,
without having to resort to additional administration tools layered on
top of the own tools of the system.

   This section describes this mechanism.  First we focus on the system
administrator’s viewpoint—explaining how the system is configured and
instantiated.  Then we show how this mechanism can be extended, for
instance to support new system services.

* Menu:

* Использование системы конфигурации::  Настройка
                                                                          вашей
                                                                          системы
                                                                          GNU.
* Интерфейс operating-system::  Подробные сведения
                                           об объявлениях
                                           opertaing-system
* Файловые системы::  Настройка точек
                                       подключения файловой
                                       системы
* Размеченные устройства::  Дополнительные
                                                   проверки
                                                   блочных
                                                   устройств.
* Учётные записи пользователей::  Задание
                                                              пользовательских
                                                              учётных
                                                              записей.
* Раскладка клавиатуры::  Интерпретация
                                               нажатия клавиш
                                               системой.
* Региональные настройки::  Настройка
                                                   языка и
                                                   культурных
                                                   особенностей.
* Службы::             Настройка системных
                               служб.
* Программы setuid::  Программы, выполняемые с
                                 правами root.
* Сертификаты X.509::  Аутентификация
                                    серверов HTTPS.
* Служба выбора имён::  Настройка службы
                                          имён libc.
* Начальный RAM-диск::  Начальная загрузка
                                       Linux-Libre.
* Настройка загрузчика::  Конфигурирование
                                               загрузчика
                                               диска.
* Вызов guix system::   Проверка конфигурации
                               операционной системы.
* Запуск guix deploy::  Развёртывание
                                конфигурации системы на
                                удалённой машине.
* Запуск Guix на виртуальной машине::  Как
                                                                  запускать
                                                                  систему
                                                                  Guix на
                                                                  виртуальной
                                                                  машине.
* Создание служб::  Добавление новых
                                   определений служб.


File: guix.ru.info,  Node: Использование системы конфигурации,  Next: Интерфейс operating-system,  Up: Конфигурирование системы

8.1 Использование системы конфигурации
======================================

The operating system is configured by providing an ‘operating-system’
declaration in a file that can then be passed to the ‘guix system’
command (*note Вызов guix system::).  A simple setup, with the default
system services, the default Linux-Libre kernel, initial RAM disk, and
boot loader looks like this:

     ;; This is an operating system configuration template
     ;; for a "bare bones" setup, with no X11 display server.

     (use-modules (gnu))
     (use-service-modules networking ssh)
     (use-package-modules screen)

     (operating-system
       (host-name "komputilo")
       (timezone "Europe/Berlin")
       (locale "en_US.utf8")

       ;; Boot in "legacy" BIOS mode, assuming /dev/sdX is the
       ;; target hard disk, and "my-root" is the label of the target
       ;; root file system.
       (bootloader (bootloader-configuration
                     (bootloader grub-bootloader)
                     (target "/dev/sdX")))
       (file-systems (cons (file-system
                             (device (file-system-label "my-root"))
                             (mount-point "/")
                             (type "ext4"))
                           %base-file-systems))

       ;; This is where user accounts are specified.  The "root"
       ;; account is implicit, and is initially created with the
       ;; empty password.
       (users (cons (user-account
                     (name "alice")
                     (comment "Bob's sister")
                     (group "users")

                     ;; Adding the account to the "wheel" group
                     ;; makes it a sudoer.  Adding it to "audio"
                     ;; and "video" allows the user to play sound
                     ;; and access the webcam.
                     (supplementary-groups '("wheel"
                                             "audio" "video")))
                    %base-user-accounts))

       ;; Globally-installed packages.
       (packages (cons screen %base-packages))

       ;; Add services to the baseline: a DHCP client and
       ;; an SSH server.
       (services (append (list (service dhcp-client-service-type)
                               (service openssh-service-type
                                        (openssh-configuration
                                         (port-number 2222))))
                         %base-services)))

   This example should be self-describing.  Some of the fields defined
above, such as ‘host-name’ and ‘bootloader’, are mandatory.  Others,
such as ‘packages’ and ‘services’, can be omitted, in which case they
get a default value.

   Below we discuss the effect of some of the most important fields
(*note Интерфейс operating-system::, for details about all the available
fields), and how to “instantiate” the operating system using ‘guix
system’.

Bootloader
----------

The ‘bootloader’ field describes the method that will be used to boot
your system.  Machines based on Intel processors can boot in “legacy”
BIOS mode, as in the example above.  However, more recent machines rely
instead on the “Unified Extensible Firmware Interface” (UEFI) to boot.
In that case, the ‘bootloader’ field should contain something along
these lines:

     (bootloader-configuration
       (bootloader grub-efi-bootloader)
       (target "/boot/efi"))

   *Note Настройка загрузчика::, for more information on the available
configuration options.

Globally-Visible Packages
-------------------------

The ‘packages’ field lists packages that will be globally visible on the
system, for all user accounts—i.e., in every user’s ‘PATH’ environment
variable—in addition to the per-user profiles (*note Вызов guix
package::).  The ‘%base-packages’ variable provides all the tools one
would expect for basic user and administrator tasks—including the GNU
Core Utilities, the GNU Networking Utilities, the GNU Zile lightweight
text editor, ‘find’, ‘grep’, etc.  The example above adds GNU Screen to
those, taken from the ‘(gnu packages screen)’ module (*note Пакетные
модули::).  The ‘(list package output)’ syntax can be used to add a
specific output of a package:

     (use-modules (gnu packages))
     (use-modules (gnu packages dns))

     (operating-system
       ;; ...
       (packages (cons (list bind "utils")
                       %base-packages)))

   Referring to packages by variable name, like ‘bind’ above, has the
advantage of being unambiguous; it also allows typos and such to be
diagnosed right away as “unbound variables”.  The downside is that one
needs to know which module defines which package, and to augment the
‘use-package-modules’ line accordingly.  To avoid that, one can use the
‘specification->package’ procedure of the ‘(gnu packages)’ module, which
returns the best package for a given name or name and version:

     (use-modules (gnu packages))

     (operating-system
       ;; ...
       (packages (append (map specification->package
                              '("tcpdump" "htop" "gnupg@2.0"))
                         %base-packages)))

System Services
---------------

The ‘services’ field lists “system services” to be made available when
the system starts (*note Службы::).  The ‘operating-system’ declaration
above specifies that, in addition to the basic services, we want the
OpenSSH secure shell daemon listening on port 2222 (*note
‘openssh-service-type’: Сервисы сети.).  Under the hood,
‘openssh-service-type’ arranges so that ‘sshd’ is started with the right
command-line options, possibly with supporting configuration files
generated as needed (*note Создание служб::).

   Occasionally, instead of using the base services as is, you will want
to customize them.  To do this, use ‘modify-services’ (*note
‘modify-services’: Интерфейс сервиса.) to modify the list.

   For example, suppose you want to modify ‘guix-daemon’ and Mingetty
(the console log-in) in the ‘%base-services’ list (*note
‘%base-services’: Базовые службы.).  To do that, you can write the
following in your operating system declaration:

     (define %my-services
       ;; My very own list of services.
       (modify-services %base-services
         (guix-service-type config =>
                            (guix-configuration
                             (inherit config)
                             (use-substitutes? #f)
                             (extra-options '("--gc-keep-derivations"))))
         (mingetty-service-type config =>
                                (mingetty-configuration
                                 (inherit config)))))

     (operating-system
       ;; ...
       (services %my-services))

   This changes the configuration—i.e., the service parameters—of the
‘guix-service-type’ instance, and that of all the
‘mingetty-service-type’ instances in the ‘%base-services’ list.  Observe
how this is accomplished: first, we arrange for the original
configuration to be bound to the identifier ‘config’ in the BODY, and
then we write the BODY so that it evaluates to the desired
configuration.  In particular, notice how we use ‘inherit’ to create a
new configuration which has the same values as the old configuration,
but with a few modifications.

   The configuration for a typical “desktop” usage, with an encrypted
root partition, the X11 display server, GNOME and Xfce (users can choose
which of these desktop environments to use at the log-in screen by
pressing ‘F1’), network management, power management, and more, would
look like this:

     ;; This is an operating system configuration template
     ;; for a "desktop" setup with GNOME and Xfce where the
     ;; root partition is encrypted with LUKS.

     (use-modules (gnu) (gnu system nss))
     (use-service-modules desktop xorg)
     (use-package-modules certs gnome)

     (operating-system
       (host-name "antelope")
       (timezone "Europe/Paris")
       (locale "en_US.utf8")

       ;; Choose US English keyboard layout.  The "altgr-intl"
       ;; variant provides dead keys for accented characters.
       (keyboard-layout (keyboard-layout "us" "altgr-intl"))

       ;; Use the UEFI variant of GRUB with the EFI System
       ;; Partition mounted on /boot/efi.
       (bootloader (bootloader-configuration
                     (bootloader grub-efi-bootloader)
                     (target "/boot/efi")
                     (keyboard-layout keyboard-layout)))

       ;; Specify a mapped device for the encrypted root partition.
       ;; The UUID is that returned by 'cryptsetup luksUUID'.
       (mapped-devices
        (list (mapped-device
               (source (uuid "12345678-1234-1234-1234-123456789abc"))
               (target "my-root")
               (type luks-device-mapping))))

       (file-systems (append
                      (list (file-system
                              (device (file-system-label "my-root"))
                              (mount-point "/")
                              (type "ext4")
                              (dependencies mapped-devices))
                            (file-system
                              (device (uuid "1234-ABCD" 'fat))
                              (mount-point "/boot/efi")
                              (type "vfat")))
                      %base-file-systems))

       (users (cons (user-account
                     (name "bob")
                     (comment "Alice's brother")
                     (group "users")
                     (supplementary-groups '("wheel" "netdev"
                                             "audio" "video")))
                    %base-user-accounts))

       ;; This is where we specify system-wide packages.
       (packages (append (list
                          ;; for HTTPS access
                          nss-certs
                          ;; for user mounts
                          gvfs)
                         %base-packages))

       ;; Add GNOME and Xfce---we can choose at the log-in screen
       ;; by clicking the gear.  Use the "desktop" services, which
       ;; include the X11 log-in service, networking with
       ;; NetworkManager, and more.
       (services (append (list (service gnome-desktop-service-type)
                               (service xfce-desktop-service-type)
                               (set-xorg-configuration
                                (xorg-configuration
                                 (keyboard-layout keyboard-layout))))
                         %desktop-services))

       ;; Allow resolution of '.local' host names with mDNS.
       (name-service-switch %mdns-host-lookup-nss))

   A graphical system with a choice of lightweight window managers
instead of full-blown desktop environments would look like this:

     ;; This is an operating system configuration template
     ;; for a "desktop" setup without full-blown desktop
     ;; environments.

     (use-modules (gnu) (gnu system nss))
     (use-service-modules desktop)
     (use-package-modules bootloaders certs ratpoison suckless wm)
     (use-package-modules bootloaders certs ratpoison suckless wm xorg)

     (operating-system
       (host-name "antelope")
       (timezone "Europe/Paris")
       (locale "en_US.utf8")

       ;; Use the UEFI variant of GRUB with the EFI System
       ;; Partition mounted on /boot/efi.
       (bootloader (bootloader-configuration
                     (bootloader grub-efi-bootloader)
                     (target "/boot/efi")))

       ;; Assume the target root file system is labelled "my-root",
       ;; and the EFI System Partition has UUID 1234-ABCD.
       (file-systems (append
                      (list (file-system
                              (device (file-system-label "my-root"))
                              (mount-point "/")
                              (type "ext4"))
                            (file-system
                              (device (uuid "1234-ABCD" 'fat))
                              (mount-point "/boot/efi")
                              (type "vfat")))
                      %base-file-systems))

       (users (cons (user-account
                     (name "alice")
                     (comment "Bob's sister")
                     (group "users")
                     (supplementary-groups '("wheel" "netdev"
                                             "audio" "video")))
                    %base-user-accounts))

       ;; Add a bunch of window managers; we can choose one at
       ;; the log-in screen with F1.
       (packages (append (list
                          ;; window managers
                          ratpoison i3-wm i3status dmenu
                          ;; terminal emulator
                          xterm
                          ;; for HTTPS access
                          nss-certs)
                         %base-packages))

       ;; Use the "desktop" services, which include the X11
       ;; log-in service, networking with NetworkManager, and more.
       (services %desktop-services)

       ;; Allow resolution of '.local' host names with mDNS.
       (name-service-switch %mdns-host-lookup-nss))

   This example refers to the ‘/boot/efi’ file system by its UUID,
‘1234-ABCD’.  Replace this UUID with the right UUID on your system, as
returned by the ‘blkid’ command.

   *Note Сервисы рабочего стола::, for the exact list of services
provided by ‘%desktop-services’.  *Note Сертификаты X.509::, for
background information about the ‘nss-certs’ package that is used here.

   Again, ‘%desktop-services’ is just a list of service objects.  If you
want to remove services from there, you can do so using the procedures
for list filtering (*note (guile)SRFI-1 Filtering and Partitioning::).
For instance, the following expression returns a list that contains all
the services in ‘%desktop-services’ minus the Avahi service:

     (remove (lambda (service)
               (eq? (service-kind service) avahi-service-type))
             %desktop-services)

Instantiating the System
------------------------

Assuming the ‘operating-system’ declaration is stored in the
‘my-system-config.scm’ file, the ‘guix system reconfigure
my-system-config.scm’ command instantiates that configuration, and makes
it the default GRUB boot entry (*note Вызов guix system::).

   The normal way to change the system configuration is by updating this
file and re-running ‘guix system reconfigure’.  One should never have to
touch files in ‘/etc’ or to run commands that modify the system state
such as ‘useradd’ or ‘grub-install’.  In fact, you must avoid that since
that would not only void your warranty but also prevent you from rolling
back to previous versions of your system, should you ever need to.

   Speaking of roll-back, each time you run ‘guix system reconfigure’, a
new “generation” of the system is created—without modifying or deleting
previous generations.  Old system generations get an entry in the
bootloader boot menu, allowing you to boot them in case something went
wrong with the latest generation.  Reassuring, no?  The ‘guix system
list-generations’ command lists the system generations available on
disk.  It is also possible to roll back the system via the commands
‘guix system roll-back’ and ‘guix system switch-generation’.

   Although the ‘guix system reconfigure’ command will not modify
previous generations, you must take care when the current generation is
not the latest (e.g., after invoking ‘guix system roll-back’), since the
operation might overwrite a later generation (*note Вызов guix
system::).

The Programming Interface
-------------------------

At the Scheme level, the bulk of an ‘operating-system’ declaration is
instantiated with the following monadic procedure (*note Устройство
склада::):

 -- Monadic Procedure: operating-system-derivation os
     Return a derivation that builds OS, an ‘operating-system’ object
     (*note Деривации::).

     The output of the derivation is a single directory that refers to
     all the packages, configuration files, and other supporting files
     needed to instantiate OS.

   This procedure is provided by the ‘(gnu system)’ module.  Along with
‘(gnu services)’ (*note Службы::), this module contains the guts of Guix
System.  Make sure to visit it!


File: guix.ru.info,  Node: Интерфейс operating-system,  Next: Файловые системы,  Prev: Использование системы конфигурации,  Up: Конфигурирование системы

8.2 ‘operating-system’ Reference
================================

This section summarizes all the options available in ‘operating-system’
declarations (*note Использование системы конфигурации::).

 -- Data Type: operating-system
     This is the data type representing an operating system
     configuration.  By that, we mean all the global system
     configuration, not per-user configuration (*note Использование
     системы конфигурации::).

     ‘kernel’ (default: ‘linux-libre’)
          The package object of the operating system kernel to use(1).

     ‘hurd’ (default: ‘#f’)
          The hurd to be started by the kernel.  This is required to
          build an experimental vm-image for the Hurd and requires using
          ‘kernel’ GNU mach as well as other specific operating system
          overrides.

     ‘kernel-loadable-modules’ (default: ’())
          A list of objects (usually packages) to collect loadable
          kernel modules from–e.g.  ‘(list ddcci-driver-linux)’.

     ‘kernel-arguments’ (default: ‘%default-kernel-arguments’)
          List of strings or gexps representing additional arguments to
          pass on the command-line of the kernel—e.g.,
          ‘("console=ttyS0")’.

     ‘bootloader’
          The system bootloader configuration object.  *Note Настройка
          загрузчика::.

     ‘label’
          This is the label (a string) as it appears in the bootloader’s
          menu entry.  The default label includes the kernel name and
          version.

     ‘keyboard-layout’ (default: ‘#f’)
          This field specifies the keyboard layout to use in the
          console.  It can be either ‘#f’, in which case the default
          keyboard layout is used (usually US English), or a
          ‘<keyboard-layout>’ record.

          This keyboard layout is in effect as soon as the kernel has
          booted.  For instance, it is the keyboard layout in effect
          when you type a passphrase if your root file system is on a
          ‘luks-device-mapping’ mapped device (*note Размеченные
          устройства::).

               Примечание: This does _not_ specify the keyboard layout
               used by the bootloader, nor that used by the graphical
               display server.  *Note Настройка загрузчика::, for
               information on how to specify the bootloader’s keyboard
               layout.  *Note Оконная система X::, for information on
               how to specify the keyboard layout used by the X Window
               System.

     ‘initrd-modules’ (default: ‘%base-initrd-modules’)
          The list of Linux kernel modules that need to be available in
          the initial RAM disk.  *Note Начальный RAM-диск::.

     ‘initrd’ (default: ‘base-initrd’)
          A procedure that returns an initial RAM disk for the Linux
          kernel.  This field is provided to support low-level
          customization and should rarely be needed for casual use.
          *Note Начальный RAM-диск::.

     ‘firmware’ (default: ‘%base-firmware’)
          List of firmware packages loadable by the operating system
          kernel.

          The default includes firmware needed for Atheros- and
          Broadcom-based WiFi devices (Linux-libre modules ‘ath9k’ and
          ‘b43-open’, respectively).  *Note По поводу железа::, for more
          info on supported hardware.

     ‘host-name’
          The host name.

     ‘hosts-file’
          A file-like object (*note file-like objects: G-Expressions.)
          for use as ‘/etc/hosts’ (*note (libc)Host Names::).  The
          default is a file with entries for ‘localhost’ and HOST-NAME.

     ‘mapped-devices’ (default: ‘'()’)
          A list of mapped devices.  *Note Размеченные устройства::.

     ‘file-systems’
          A list of file systems.  *Note Файловые системы::.

     ‘swap-devices’ (default: ‘'()’)
          A list of strings identifying devices or files to be used for
          “swap space” (*note (libc)Memory Concepts::).  For example,
          ‘'("/dev/sda3")’ or ‘'("/swapfile")’.  It is possible to
          specify a swap file in a file system on a mapped device,
          provided that the necessary device mapping and file system are
          also specified.  *Note Размеченные устройства:: and *note
          Файловые системы::.

     ‘users’ (default: ‘%base-user-accounts’)
     ‘groups’ (default: ‘%base-groups’)
          List of user accounts and groups.  *Note Учётные записи
          пользователей::.

          If the ‘users’ list lacks a user account with UID 0, a “root”
          account with UID 0 is automatically added.

     ‘skeletons’ (default: ‘(default-skeletons)’)
          A list target file name/file-like object tuples (*note
          file-like objects: G-Expressions.).  These are the skeleton
          files that will be added to the home directory of
          newly-created user accounts.

          For instance, a valid value may look like this:

               `((".bashrc" ,(plain-file "bashrc" "echo Hello\n"))
                 (".guile" ,(plain-file "guile"
                                        "(use-modules (ice-9 readline))
                                         (activate-readline)")))

     ‘issue’ (default: ‘%default-issue’)
          A string denoting the contents of the ‘/etc/issue’ file, which
          is displayed when users log in on a text console.

     ‘packages’ (default: ‘%base-packages’)
          The set of packages installed in the global profile, which is
          accessible at ‘/run/current-system/profile’.

          The default set includes core utilities and it is good
          practice to install non-core utilities in user profiles (*note
          Вызов guix package::).

     ‘timezone’
          A timezone identifying string—e.g., ‘"Europe/Paris"’.

          You can run the ‘tzselect’ command to find out which timezone
          string corresponds to your region.  Choosing an invalid
          timezone name causes ‘guix system’ to fail.

     ‘locale’ (default: ‘"en_US.utf8"’)
          The name of the default locale (*note (libc)Locale Names::).
          *Note Региональные настройки::, for more information.

     ‘locale-definitions’ (default: ‘%default-locale-definitions’)
          The list of locale definitions to be compiled and that may be
          used at run time.  *Note Региональные настройки::.

     ‘locale-libcs’ (default: ‘(list GLIBC)’)
          The list of GNU libc packages whose locale data and tools are
          used to build the locale definitions.  *Note Региональные
          настройки::, for compatibility considerations that justify
          this option.

     ‘name-service-switch’ (default: ‘%default-nss’)
          Configuration of the libc name service switch (NSS)—a
          ‘<name-service-switch>’ object.  *Note Служба выбора имён::,
          for details.

     ‘services’ (default: ‘%base-services’)
          A list of service objects denoting system services.  *Note
          Службы::.

     ‘essential-services’ (default: ...)
          The list of “essential services”—i.e., things like instances
          of ‘system-service-type’ and ‘host-name-service-type’ (*note
          Интерфейс сервиса::), which are derived from the operating
          system definition itself.  As a user you should _never_ need
          to touch this field.

     ‘pam-services’ (default: ‘(base-pam-services)’)
          Linux “pluggable authentication module” (PAM) services.

     ‘setuid-programs’ (default: ‘%setuid-programs’)
          List of string-valued G-expressions denoting setuid programs.
          *Note Программы setuid::.

     ‘sudoers-file’ (default: ‘%sudoers-specification’)
          The contents of the ‘/etc/sudoers’ file as a file-like object
          (*note ‘local-file’ and ‘plain-file’: G-Expressions.).

          This file specifies which users can use the ‘sudo’ command,
          what they are allowed to do, and what privileges they may
          gain.  The default is that only ‘root’ and members of the
          ‘wheel’ group may use ‘sudo’.

      -- Scheme Syntax: this-operating-system
          When used in the _lexical scope_ of an operating system field
          definition, this identifier resolves to the operating system
          being defined.

          The example below shows how to refer to the operating system
          being defined in the definition of the ‘label’ field:

               (use-modules (gnu) (guix))

               (operating-system
                 ;; ...
                 (label (package-full-name
                         (operating-system-kernel this-operating-system))))

          It is an error to refer to ‘this-operating-system’ outside an
          operating system definition.

   ---------- Footnotes ----------

   (1) Currently only the Linux-libre kernel is fully supported.  Using
GNU mach in combination with a ‘hurd’ is experimental and only available
when building a vm-image.


File: guix.ru.info,  Node: Файловые системы,  Next: Размеченные устройства,  Prev: Интерфейс operating-system,  Up: Конфигурирование системы

8.3 Файловые системы
====================

The list of file systems to be mounted is specified in the
‘file-systems’ field of the operating system declaration (*note
Использование системы конфигурации::).  Each file system is declared
using the ‘file-system’ form, like this:

     (file-system
       (mount-point "/home")
       (device "/dev/sda3")
       (type "ext4"))

   As usual, some of the fields are mandatory—those shown in the example
above—while others can be omitted.  These are described below.

 -- Data Type: file-system
     Objects of this type represent file systems to be mounted.  They
     contain the following members:

     ‘type’
          This is a string specifying the type of the file system—e.g.,
          ‘"ext4"’.

     ‘mount-point’
          This designates the place where the file system is to be
          mounted.

     ‘device’
          This names the “source” of the file system.  It can be one of
          three things: a file system label, a file system UUID, or the
          name of a ‘/dev’ node.  Labels and UUIDs offer a way to refer
          to file systems without having to hard-code their actual
          device name(1).

          File system labels are created using the ‘file-system-label’
          procedure, UUIDs are created using ‘uuid’, and ‘/dev’ node are
          plain strings.  Here’s an example of a file system referred to
          by its label, as shown by the ‘e2label’ command:

               (file-system
                 (mount-point "/home")
                 (type "ext4")
                 (device (file-system-label "my-home")))

          UUIDs are converted from their string representation (as shown
          by the ‘tune2fs -l’ command) using the ‘uuid’ form(2), like
          this:

               (file-system
                 (mount-point "/home")
                 (type "ext4")
                 (device (uuid "4dab5feb-d176-45de-b287-9b0a6e4c01cb")))

          When the source of a file system is a mapped device (*note
          Размеченные устройства::), its ‘device’ field _must_ refer to
          the mapped device name—e.g., ‘"/dev/mapper/root-partition"’.
          This is required so that the system knows that mounting the
          file system depends on having the corresponding device mapping
          established.

     ‘flags’ (default: ‘'()’)
          This is a list of symbols denoting mount flags.  Recognized
          flags include ‘read-only’, ‘bind-mount’, ‘no-dev’ (disallow
          access to special files), ‘no-suid’ (ignore setuid and setgid
          bits), ‘no-atime’ (do not update file access times),
          ‘strict-atime’ (update file access time), ‘lazy-time’ (only
          update time on the in-memory version of the file inode), and
          ‘no-exec’ (disallow program execution).  *Note
          (libc)Mount-Unmount-Remount::, for more information on these
          flags.

     ‘options’ (default: ‘#f’)
          This is either ‘#f’, or a string denoting mount options passed
          to the file system driver.  *Note
          (libc)Mount-Unmount-Remount::, for details and run ‘man 8
          mount’ for options for various file systems.  Note that the
          ‘file-system-options->alist’ and ‘alist->file-system-options’
          procedures from ‘(gnu system file-systems)’ can be used to
          convert file system options given as an association list to
          the string representation, and vice-versa.

     ‘mount?’ (default: ‘#t’)
          This value indicates whether to automatically mount the file
          system when the system is brought up.  When set to ‘#f’, the
          file system gets an entry in ‘/etc/fstab’ (read by the ‘mount’
          command) but is not automatically mounted.

     ‘needed-for-boot?’ (default: ‘#f’)
          This Boolean value indicates whether the file system is needed
          when booting.  If that is true, then the file system is
          mounted when the initial RAM disk (initrd) is loaded.  This is
          always the case, for instance, for the root file system.

     ‘check?’ (default: ‘#t’)
          This Boolean indicates whether the file system needs to be
          checked for errors before being mounted.

     ‘create-mount-point?’ (default: ‘#f’)
          When true, the mount point is created if it does not exist
          yet.

     ‘dependencies’ (default: ‘'()’)
          This is a list of ‘<file-system>’ or ‘<mapped-device>’ objects
          representing file systems that must be mounted or mapped
          devices that must be opened before (and unmounted or closed
          after) this one.

          As an example, consider a hierarchy of mounts:
          ‘/sys/fs/cgroup’ is a dependency of ‘/sys/fs/cgroup/cpu’ and
          ‘/sys/fs/cgroup/memory’.

          Another example is a file system that depends on a mapped
          device, for example for an encrypted partition (*note
          Размеченные устройства::).

   The ‘(gnu system file-systems)’ exports the following useful
variables.

 -- Scheme Variable: %base-file-systems
     These are essential file systems that are required on normal
     systems, such as ‘%pseudo-terminal-file-system’ and
     ‘%immutable-store’ (see below).  Operating system declarations
     should always contain at least these.

 -- Scheme Variable: %pseudo-terminal-file-system
     This is the file system to be mounted as ‘/dev/pts’.  It supports
     “pseudo-terminals” created via ‘openpty’ and similar functions
     (*note (libc)Pseudo-Terminals::).  Pseudo-terminals are used by
     terminal emulators such as ‘xterm’.

 -- Scheme Variable: %shared-memory-file-system
     This file system is mounted as ‘/dev/shm’ and is used to support
     memory sharing across processes (*note ‘shm_open’:
     (libc)Memory-mapped I/O.).

 -- Scheme Variable: %immutable-store
     This file system performs a read-only “bind mount” of ‘/gnu/store’,
     making it read-only for all the users including ‘root’.  This
     prevents against accidental modification by software running as
     ‘root’ or by system administrators.

     The daemon itself is still able to write to the store: it remounts
     it read-write in its own “name space.”

 -- Scheme Variable: %binary-format-file-system
     The ‘binfmt_misc’ file system, which allows handling of arbitrary
     executable file types to be delegated to user space.  This requires
     the ‘binfmt.ko’ kernel module to be loaded.

 -- Scheme Variable: %fuse-control-file-system
     The ‘fusectl’ file system, which allows unprivileged users to mount
     and unmount user-space FUSE file systems.  This requires the
     ‘fuse.ko’ kernel module to be loaded.

* Menu:

* Btrfs file system::

   ---------- Footnotes ----------

   (1) Note that, while it is tempting to use ‘/dev/disk/by-uuid’ and
similar device names to achieve the same result, this is not
recommended: These special device nodes are created by the udev daemon
and may be unavailable at the time the device is mounted.

   (2) The ‘uuid’ form expects 16-byte UUIDs as defined in RFC 4122
(https://tools.ietf.org/html/rfc4122).  This is the form of UUID used by
the ext2 family of file systems and others, but it is different from
“UUIDs” found in FAT file systems, for instance.


File: guix.ru.info,  Node: Btrfs file system,  Up: Файловые системы

8.3.1 Btrfs file system
-----------------------

The Btrfs has special features, such as subvolumes, that merit being
explained in more details.  The following section attempts to cover
basic as well as complex uses of a Btrfs file system with the Guix
System.

   In its simplest usage, a Btrfs file system can be described, for
example, by:

     (file-system
       (mount-point "/home")
       (type "btrfs")
       (device (file-system-label "my-home")))

   The example below is more complex, as it makes use of a Btrfs
subvolume, named ‘rootfs’.  The parent Btrfs file system is labeled
‘my-btrfs-pool’, and is located on an encrypted device (hence the
dependency on ‘mapped-devices’):

     (file-system
       (device (file-system-label "my-btrfs-pool"))
       (mount-point "/")
       (type "btrfs")
       (options "subvol=rootfs")
       (dependencies mapped-devices))

   Some bootloaders, for example GRUB, only mount a Btrfs partition at
its top level during the early boot, and rely on their configuration to
refer to the correct subvolume path within that top level.  The
bootloaders operating in this way typically produce their configuration
on a running system where the Btrfs partitions are already mounted and
where the subvolume information is readily available.  As an example,
‘grub-mkconfig’, the configuration generator command shipped with GRUB,
reads ‘/proc/self/mountinfo’ to determine the top-level path of a
subvolume.

   The Guix System produces a bootloader configuration using the
operating system configuration as its sole input; it is therefore
necessary to extract the subvolume name on which ‘/gnu/store’ lives (if
any) from that operating system configuration.  To better illustrate,
consider a subvolume named ’rootfs’ which contains the root file system
data.  In such situation, the GRUB bootloader would only see the top
level of the root Btrfs partition, e.g.:

     /                   (top level)
     ├── rootfs          (subvolume directory)
         ├── gnu         (normal directory)
             ├── store   (normal directory)
     [...]

   Thus, the subvolume name must be prepended to the ‘/gnu/store’ path
of the kernel, initrd binaries and any other files referred to in the
GRUB configuration that must be found during the early boot.

   The next example shows a nested hierarchy of subvolumes and
directories:

     /                   (top level)
     ├── rootfs          (subvolume)
         ├── gnu         (normal directory)
             ├── store   (subvolume)
     [...]

   This scenario would work without mounting the ’store’ subvolume.
Mounting ’rootfs’ is sufficient, since the subvolume name matches its
intended mount point in the file system hierarchy.  Alternatively, the
’store’ subvolume could be referred to by setting the ‘subvol’ option to
either ‘/rootfs/gnu/store’ or ‘rootfs/gnu/store’.

   Finally, a more contrived example of nested subvolumes:

     /                           (top level)
     ├── root-snapshots          (subvolume)
         ├── root-current        (subvolume)
             ├── guix-store      (subvolume)
     [...]

   Here, the ’guix-store’ subvolume doesn’t match its intended mount
point, so it is necessary to mount it.  The subvolume must be fully
specified, by passing its file name to the ‘subvol’ option.  To
illustrate, the ’guix-store’ subvolume could be mounted on ‘/gnu/store’
by using a file system declaration such as:

     (file-system
       (device (file-system-label "btrfs-pool-1"))
       (mount-point "/gnu/store")
       (type "btrfs")
       (options "subvol=root-snapshots/root-current/guix-store,\
     compress-force=zstd,space_cache=v2"))


File: guix.ru.info,  Node: Размеченные устройства,  Next: Учётные записи пользователей,  Prev: Файловые системы,  Up: Конфигурирование системы

8.4 Размеченные устройства
==========================

The Linux kernel has a notion of “device mapping”: a block device, such
as a hard disk partition, can be “mapped” into another device, usually
in ‘/dev/mapper/’, with additional processing over the data that flows
through it(1).  A typical example is encryption device mapping: all
writes to the mapped device are encrypted, and all reads are deciphered,
transparently.  Guix extends this notion by considering any device or
set of devices that are “transformed” in some way to create a new
device; for instance, RAID devices are obtained by “assembling” several
other devices, such as hard disks or partitions, into a new one that
behaves as one partition.  Other examples, not yet implemented, are LVM
logical volumes.

   Mapped devices are declared using the ‘mapped-device’ form, defined
as follows; for examples, see below.

 -- Data Type: mapped-device
     Objects of this type represent device mappings that will be made
     when the system boots up.

     ‘source’
          This is either a string specifying the name of the block
          device to be mapped, such as ‘"/dev/sda3"’, or a list of such
          strings when several devices need to be assembled for creating
          a new one.

     ‘target’
          This string specifies the name of the resulting mapped device.
          For kernel mappers such as encrypted devices of type
          ‘luks-device-mapping’, specifying ‘"my-partition"’ leads to
          the creation of the ‘"/dev/mapper/my-partition"’ device.  For
          RAID devices of type ‘raid-device-mapping’, the full device
          name such as ‘"/dev/md0"’ needs to be given.

     ‘type’
          This must be a ‘mapped-device-kind’ object, which specifies
          how SOURCE is mapped to TARGET.

 -- Scheme Variable: luks-device-mapping
     This defines LUKS block device encryption using the ‘cryptsetup’
     command from the package with the same name.  It relies on the
     ‘dm-crypt’ Linux kernel module.

 -- Scheme Variable: raid-device-mapping
     This defines a RAID device, which is assembled using the ‘mdadm’
     command from the package with the same name.  It requires a Linux
     kernel module for the appropriate RAID level to be loaded, such as
     ‘raid456’ for RAID-4, RAID-5 or RAID-6, or ‘raid10’ for RAID-10.

   The following example specifies a mapping from ‘/dev/sda3’ to
‘/dev/mapper/home’ using LUKS—the Linux Unified Key Setup
(https://gitlab.com/cryptsetup/cryptsetup), a standard mechanism for
disk encryption.  The ‘/dev/mapper/home’ device can then be used as the
‘device’ of a ‘file-system’ declaration (*note Файловые системы::).

     (mapped-device
       (source "/dev/sda3")
       (target "home")
       (type luks-device-mapping))

   Alternatively, to become independent of device numbering, one may
obtain the LUKS UUID (“unique identifier”) of the source device by a
command like:

     cryptsetup luksUUID /dev/sda3

   and use it as follows:

     (mapped-device
       (source (uuid "cb67fc72-0d54-4c88-9d4b-b225f30b0f44"))
       (target "home")
       (type luks-device-mapping))

   It is also desirable to encrypt swap space, since swap space may
contain sensitive data.  One way to accomplish that is to use a swap
file in a file system on a device mapped via LUKS encryption.  In this
way, the swap file is encrypted because the entire device is encrypted.
*Note Disk Partitioning: Подготовка к установке, for an example.

   A RAID device formed of the partitions ‘/dev/sda1’ and ‘/dev/sdb1’
may be declared as follows:

     (mapped-device
       (source (list "/dev/sda1" "/dev/sdb1"))
       (target "/dev/md0")
       (type raid-device-mapping))

   The ‘/dev/md0’ device can then be used as the ‘device’ of a
‘file-system’ declaration (*note Файловые системы::).  Note that the
RAID level need not be given; it is chosen during the initial creation
and formatting of the RAID device and is determined automatically later.

   ---------- Footnotes ----------

   (1) Note that the GNU Hurd makes no difference between the concept of
a “mapped device” and that of a file system: both boil down to
_translating_ input/output operations made on a file to operations on
its backing store.  Thus, the Hurd implements mapped devices, like file
systems, using the generic “translator” mechanism (*note
(hurd)Translators::).


File: guix.ru.info,  Node: Учётные записи пользователей,  Next: Раскладка клавиатуры,  Prev: Размеченные устройства,  Up: Конфигурирование системы

8.5 Учётные записи пользователей
================================

User accounts and groups are entirely managed through the
‘operating-system’ declaration.  They are specified with the
‘user-account’ and ‘user-group’ forms:

     (user-account
       (name "alice")
       (group "users")
       (supplementary-groups '("wheel"   ;allow use of sudo, etc.
                               "audio"   ;sound card
                               "video"   ;video devices such as webcams
                               "cdrom")) ;the good ol' CD-ROM
       (comment "Bob's sister")
       (home-directory "/home/alice"))

   When booting or upon completion of ‘guix system reconfigure’, the
system ensures that only the user accounts and groups specified in the
‘operating-system’ declaration exist, and with the specified properties.
Thus, account or group creations or modifications made by directly
invoking commands such as ‘useradd’ are lost upon reconfiguration or
reboot.  This ensures that the system remains exactly as declared.

 -- Data Type: user-account
     Objects of this type represent user accounts.  The following
     members may be specified:

     ‘name’
          The name of the user account.

     ‘group’
          This is the name (a string) or identifier (a number) of the
          user group this account belongs to.

     ‘supplementary-groups’ (default: ‘'()’)
          Optionally, this can be defined as a list of group names that
          this account belongs to.

     ‘uid’ (default: ‘#f’)
          This is the user ID for this account (a number), or ‘#f’.  In
          the latter case, a number is automatically chosen by the
          system when the account is created.

     ‘comment’ (default: ‘""’)
          A comment about the account, such as the account owner’s full
          name.

     ‘home-directory’
          This is the name of the home directory for the account.

     ‘create-home-directory?’ (default: ‘#t’)
          Indicates whether the home directory of this account should be
          created if it does not exist yet.

     ‘shell’ (default: Bash)
          This is a G-expression denoting the file name of a program to
          be used as the shell (*note G-Expressions::).

     ‘system?’ (default: ‘#f’)
          This Boolean value indicates whether the account is a “system”
          account.  System accounts are sometimes treated specially; for
          instance, graphical login managers do not list them.

     ‘password’ (default: ‘#f’)
          You would normally leave this field to ‘#f’, initialize user
          passwords as ‘root’ with the ‘passwd’ command, and then let
          users change it with ‘passwd’.  Passwords set with ‘passwd’
          are of course preserved across reboot and reconfiguration.

          If you _do_ want to set an initial password for an account,
          then this field must contain the encrypted password, as a
          string.  You can use the ‘crypt’ procedure for this purpose:

               (user-account
                 (name "charlie")
                 (group "users")

                 ;; Specify a SHA-512-hashed initial password.
                 (password (crypt "InitialPassword!" "$6$abc")))

               Примечание: The hash of this initial password will be
               available in a file in ‘/gnu/store’, readable by all the
               users, so this method must be used with care.

          *Note (libc)Passphrase Storage::, for more information on
          password encryption, and *note (guile)Encryption::, for
          information on Guile’s ‘crypt’ procedure.

   User group declarations are even simpler:

     (user-group (name "students"))

 -- Data Type: user-group
     This type is for, well, user groups.  There are just a few fields:

     ‘name’
          The name of the group.

     ‘id’ (default: ‘#f’)
          The group identifier (a number).  If ‘#f’, a new number is
          automatically allocated when the group is created.

     ‘system?’ (default: ‘#f’)
          This Boolean value indicates whether the group is a “system”
          group.  System groups have low numerical IDs.

     ‘password’ (default: ‘#f’)
          What, user groups can have a password?  Well, apparently yes.
          Unless ‘#f’, this field specifies the password of the group.

   For convenience, a variable lists all the basic user groups one may
expect:

 -- Scheme Variable: %base-groups
     This is the list of basic user groups that users and/or packages
     expect to be present on the system.  This includes groups such as
     “root”, “wheel”, and “users”, as well as groups used to control
     access to specific devices such as “audio”, “disk”, and “cdrom”.

 -- Scheme Variable: %base-user-accounts
     This is the list of basic system accounts that programs may expect
     to find on a GNU/Linux system, such as the “nobody” account.

     Note that the “root” account is not included here.  It is a
     special-case and is automatically added whether or not it is
     specified.


File: guix.ru.info,  Node: Раскладка клавиатуры,  Next: Региональные настройки,  Prev: Учётные записи пользователей,  Up: Конфигурирование системы

8.6 Раскладка клавиатуры
========================

To specify what each key of your keyboard does, you need to tell the
operating system what “keyboard layout” you want to use.  The default,
when nothing is specified, is the US English QWERTY layout for 105-key
PC keyboards.  However, German speakers will usually prefer the German
QWERTZ layout, French speakers will want the AZERTY layout, and so on;
hackers might prefer Dvorak or bépo, and they might even want to further
customize the effect of some of the keys.  This section explains how to
get that done.

   There are three components that will want to know about your keyboard
layout:

   • The _bootloader_ may want to know what keyboard layout you want to
     use (*note ‘keyboard-layout’: Настройка загрузчика.).  This is
     useful if you want, for instance, to make sure that you can type
     the passphrase of your encrypted root partition using the right
     layout.

   • The _operating system kernel_, Linux, will need that so that the
     console is properly configured (*note ‘keyboard-layout’: Интерфейс
     operating-system.).

   • The _graphical display server_, usually Xorg, also has its own idea
     of the keyboard layout (*note ‘keyboard-layout’: Оконная система
     X.).

   Guix allows you to configure all three separately but, fortunately,
it allows you to share the same keyboard layout for all three
components.

   Keyboard layouts are represented by records created by the
‘keyboard-layout’ procedure of ‘(gnu system keyboard)’.  Following the X
Keyboard extension (XKB), each layout has four attributes: a name (often
a language code such as “fi” for Finnish or “jp” for Japanese), an
optional variant name, an optional keyboard model name, and a possibly
empty list of additional options.  In most cases the layout name is all
you care about.  Here are a few example:

     ;; The German QWERTZ layout.  Here we assume a standard
     ;; "pc105" keyboard model.
     (keyboard-layout "de")

     ;; The bépo variant of the French layout.
     (keyboard-layout "fr" "bepo")

     ;; The Catalan layout.
     (keyboard-layout "es" "cat")

     ;; Arabic layout with "Alt-Shift" to switch to US layout.
     (keyboard-layout "ar,us" #:options '("grp:alt_shift_toggle"))

     ;; The Latin American Spanish layout.  In addition, the
     ;; "Caps Lock" key is used as an additional "Ctrl" key,
     ;; and the "Menu" key is used as a "Compose" key to enter
     ;; accented letters.
     (keyboard-layout "latam"
                      #:options '("ctrl:nocaps" "compose:menu"))

     ;; The Russian layout for a ThinkPad keyboard.
     (keyboard-layout "ru" #:model "thinkpad")

     ;; The "US international" layout, which is the US layout plus
     ;; dead keys to enter accented characters.  This is for an
     ;; Apple MacBook keyboard.
     (keyboard-layout "us" "intl" #:model "macbook78")

   See the ‘share/X11/xkb’ directory of the ‘xkeyboard-config’ package
for a complete list of supported layouts, variants, and models.

   Let’s say you want your system to use the Turkish keyboard layout
throughout your system—bootloader, console, and Xorg.  Here’s what your
system configuration would look like:

     ;; Using the Turkish layout for the bootloader, the console,
     ;; and for Xorg.

     (operating-system
       ;; ...
       (keyboard-layout (keyboard-layout "tr"))  ;for the console
       (bootloader (bootloader-configuration
                     (bootloader grub-efi-bootloader)
                     (target "/boot/efi")
                     (keyboard-layout keyboard-layout))) ;for GRUB
       (services (cons (set-xorg-configuration
                         (xorg-configuration             ;for Xorg
                           (keyboard-layout keyboard-layout)))
                       %desktop-services)))

   In the example above, for GRUB and for Xorg, we just refer to the
‘keyboard-layout’ field defined above, but we could just as well refer
to a different layout.  The ‘set-xorg-configuration’ procedure
communicates the desired Xorg configuration to the graphical log-in
manager, by default GDM.

   We’ve discussed how to specify the _default_ keyboard layout of your
system when it starts, but you can also adjust it at run time:

   • If you’re using GNOME, its settings panel has a “Region & Language”
     entry where you can select one or more keyboard layouts.

   • Under Xorg, the ‘setxkbmap’ command (from the same-named package)
     allows you to change the current layout.  For example, this is how
     you would change the layout to US Dvorak:

          setxkbmap us dvorak

   • The ‘loadkeys’ command changes the keyboard layout in effect in the
     Linux console.  However, note that ‘loadkeys’ does _not_ use the
     XKB keyboard layout categorization described above.  The command
     below loads the French bépo layout:

          loadkeys fr-bepo

